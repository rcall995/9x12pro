/**
 * 9x12 Pro - Main Application Script
 * ===================================
 *
 * TABLE OF CONTENTS (approximate line numbers):
 *
 * 1. CONFIG & INITIALIZATION ............ Lines 1-500
 *    - Supabase setup, auth, version checking
 *
 * 2. CRM & CLIENT MANAGEMENT ............ Lines 500-2000
 *    - Client state, rendering, modals
 *    - Bulk SMS/Email for clients
 *
 * 3. QUICK ACTION POPUP ................. Lines 2250-2500
 *    - Prospect quick actions modal
 *    - Contact tracking, response tracking
 *
 * 4. PROSPECT POOL ...................... Lines 2500-6000
 *    - Search, enrichment, import/export
 *    - Business data management
 *
 * 5. AI PITCH GENERATOR ................. Lines 6000-6300
 *    - Inline AI pitch generation
 *
 * 6. SPARK COMMENT SYSTEM ............... Lines 6300-7000
 *    - Comment engagement AI
 *
 * 7. CLOSE DEALS & PIPELINE ............. Lines 7000-8000
 *    - Pipeline outreach panel
 *
 * 8. KANBAN BOARD ....................... Lines 14000-17000
 *    - Column rendering, drag-drop
 *    - Selection, filtering, actions
 *
 * 9. FOLLOW-UP DASHBOARD ................ Lines 17200-17400
 *    - Overdue, due today tracking
 *    - Sequence actions due
 *
 * 10. CONTACT STATUS DASHBOARD .......... Lines 17400-17700
 *     - Texted, emailed, FB, IG tracking
 *
 * 11. SEQUENCE AUTO-SCHEDULING .......... Lines 17700-17900
 *     - Alert banner, batch processing
 *
 * 12. OUTREACH SEQUENCES ................ Lines 17900-18200
 *     - Assign, advance, pause, cancel
 *
 * 13. TEMPLATES & QUICK SEND ............ Lines 18200-20000
 *     - Template management
 *     - Bulk send operations
 *
 * 14. GETTING STARTED & STATS ........... Lines 21400-21700
 *     - Checklist, dashboard stats
 *
 * 15. CLOUD SYNC ....................... Lines 23000-24000
 *     - Supabase sync functions
 *
 * 16. ONBOARDING ........................ Lines 24600-24700
 *     - New user wizard
 *
 * See /modules/README.md for future modularization roadmap.
 */

console.log('üöÄ Main app.html script starting...');

// ============================================================
// ENRICHMENT TOGGLE - Disable broken Google/Serper social media searches
// Set to false to use only HERE API data (reliable)
// Set to true to enable Facebook/Instagram searches (currently broken)
// ============================================================
const ENABLE_SOCIAL_MEDIA_SEARCH = false;

// Global error handler to catch uncaught exceptions
window.onerror = function(message, source, lineno, colno, error) {
  console.error('‚ùå GLOBAL ERROR:', message, 'at', source, 'line', lineno);
  // Don't show toast for every error - too noisy
  // Only show for critical sync/data errors
  if (message.includes('campaign') || message.includes('sync') || message.includes('save')) {
    if (typeof toast === 'function') {
      toast('An error occurred. Your data is safe in local storage.', false);
    }
  }
  return false; // Let error propagate to console
};

// Handle unhandled promise rejections
window.onunhandledrejection = function(event) {
  console.error('‚ùå Unhandled Promise Rejection:', event.reason);
  // Prevent the default handling (which would log it again)
  event.preventDefault();
};

// Hide loading overlay - called when app is ready
function hideLoadingOverlay() {
  const overlay = document.getElementById('app-loading-overlay');
  if (overlay) {
    overlay.remove(); // Completely remove from DOM
    console.log('‚úÖ Loading overlay removed');
  }
}

/* ========= SECURITY: XSS Prevention ========= */
/**
 * Escape HTML special characters to prevent XSS attacks
 * Use this when inserting ANY external/user data into innerHTML
 * @param {string} str - String to escape
 * @returns {string} - Escaped string safe for HTML
 */
function escapeHtml(str) {
  if (str === null || str === undefined) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

// Expose globally for use in templates
window.escapeHtml = escapeHtml;

/* ========= SUBSCRIPTION TIER & USAGE LIMITS ========= */
/**
 * Free Tier Limits:
 * - 1 postcard campaign
 * - 25 enrichments per day
 * - 1 zip code search per day (Prospect Radar)
 * - 5 category searches per day (Prospect Radar)
 */
const FREE_TIER_LIMITS = {
  campaigns: 1,
  enrichmentsPerDay: 25,
  zipSearchesPerDay: 1,
  categorySearchesPerDay: 5
};

// User's subscription info (loaded from Supabase)
let userSubscription = {
  tier: 'free', // 'free', 'starter', 'pro', 'enterprise'
  loaded: false
};

// Today's usage (loaded from Supabase)
let dailyUsage = {
  enrichments: 0,
  zipSearches: 0,
  categorySearches: 0,
  zipsSearched: [],
  categoriesSearched: [],
  loaded: false
};

/**
 * Load user's subscription tier from Supabase
 */
async function loadUserSubscription() {
  if (!window.currentAuthUser?.id) {
    console.log('‚è≥ Waiting for auth to load subscription...');
    return;
  }

  try {
    const { data, error } = await supabaseClient
      .from('user_approvals')
      .select('subscription_tier')
      .eq('user_id', window.currentAuthUser.id)
      .single();

    if (error) {
      console.error('Error loading subscription:', error);
      return;
    }

    userSubscription.tier = data?.subscription_tier || 'free';
    userSubscription.loaded = true;
    console.log('üìã Subscription tier:', userSubscription.tier);

    // Apply UI restrictions based on tier
    if (typeof applyFreeTierSearchRestrictions === 'function') {
      applyFreeTierSearchRestrictions();
    }
  } catch (err) {
    console.error('Failed to load subscription:', err);
  }
}

/**
 * Load today's usage from Supabase
 */
async function loadDailyUsage() {
  if (!window.currentAuthUser?.id) return;

  try {
    const today = new Date().toISOString().split('T')[0];
    const { data, error } = await supabaseClient
      .from('daily_usage')
      .select('*')
      .eq('user_id', window.currentAuthUser.id)
      .eq('usage_date', today)
      .single();

    if (error && error.code !== 'PGRST116') { // PGRST116 = no rows
      console.error('Error loading daily usage:', error);
      return;
    }

    if (data) {
      dailyUsage.enrichments = data.enrichments_used || 0;
      dailyUsage.zipSearches = data.zip_searches_used || 0;
      dailyUsage.categorySearches = data.category_searches_used || 0;
      dailyUsage.zipsSearched = data.zips_searched || [];
      dailyUsage.categoriesSearched = data.categories_searched || [];
    }
    dailyUsage.loaded = true;
    console.log('üìä Daily usage loaded:', dailyUsage);
  } catch (err) {
    console.error('Failed to load daily usage:', err);
  }
}

/**
 * Check if user is on free tier
 */
function isFreeTier() {
  return userSubscription.tier === 'free';
}

/**
 * Check if user can create more campaigns
 */
function canCreateCampaign() {
  if (!isFreeTier()) return { allowed: true };

  // Count existing campaigns
  const campaigns = Object.keys(state.mailers || {}).length;
  if (campaigns >= FREE_TIER_LIMITS.campaigns) {
    return {
      allowed: false,
      message: `Free tier is limited to ${FREE_TIER_LIMITS.campaigns} Postcard Campaign. Upgrade to create more.`,
      upgradeUrl: '/pricing.html'
    };
  }
  return { allowed: true };
}

/**
 * Check if user can perform an enrichment
 */
function canEnrich() {
  if (!isFreeTier()) return { allowed: true };

  if (dailyUsage.enrichments >= FREE_TIER_LIMITS.enrichmentsPerDay) {
    return {
      allowed: false,
      message: `Daily enrichment limit reached (${FREE_TIER_LIMITS.enrichmentsPerDay}/day). Upgrade for unlimited enrichments.`,
      upgradeUrl: '/pricing.html'
    };
  }
  return { allowed: true, remaining: FREE_TIER_LIMITS.enrichmentsPerDay - dailyUsage.enrichments };
}

/**
 * Check if user can search a zip code
 */
function canSearchZip(zipCode) {
  if (!isFreeTier()) return { allowed: true };

  // Already searched this zip today - allow it
  if (dailyUsage.zipsSearched.includes(zipCode)) {
    return { allowed: true, alreadySearched: true };
  }

  if (dailyUsage.zipSearches >= FREE_TIER_LIMITS.zipSearchesPerDay) {
    return {
      allowed: false,
      message: `Free tier is limited to ${FREE_TIER_LIMITS.zipSearchesPerDay} zip code per day. Upgrade for unlimited searches.`,
      upgradeUrl: '/pricing.html'
    };
  }
  return { allowed: true };
}

/**
 * Check if user can search a category
 */
function canSearchCategory(category) {
  if (!isFreeTier()) return { allowed: true };

  // Already searched this category today - allow it
  if (dailyUsage.categoriesSearched.includes(category)) {
    return { allowed: true, alreadySearched: true };
  }

  if (dailyUsage.categorySearches >= FREE_TIER_LIMITS.categorySearchesPerDay) {
    return {
      allowed: false,
      message: `Free tier is limited to ${FREE_TIER_LIMITS.categorySearchesPerDay} categories per day. Upgrade for unlimited searches.`,
      upgradeUrl: '/pricing.html'
    };
  }
  return { allowed: true };
}

/**
 * Record an enrichment usage
 */
async function recordEnrichmentUsage() {
  if (!isFreeTier() || !window.currentAuthUser?.id) return;

  dailyUsage.enrichments++;

  try {
    await supabaseClient.rpc('increment_enrichment_usage', {
      p_user_id: window.currentAuthUser.id
    });
  } catch (err) {
    console.error('Failed to record enrichment usage:', err);
  }
}

/**
 * Record a zip code search
 */
async function recordZipSearch(zipCode) {
  if (!isFreeTier() || !window.currentAuthUser?.id) return;

  if (!dailyUsage.zipsSearched.includes(zipCode)) {
    dailyUsage.zipSearches++;
    dailyUsage.zipsSearched.push(zipCode);

    try {
      await supabaseClient.rpc('record_zip_search', {
        p_user_id: window.currentAuthUser.id,
        p_zip: zipCode
      });
    } catch (err) {
      console.error('Failed to record zip search:', err);
    }
  }
}

/**
 * Record a category search
 */
async function recordCategorySearch(category) {
  if (!isFreeTier() || !window.currentAuthUser?.id) return;

  if (!dailyUsage.categoriesSearched.includes(category)) {
    dailyUsage.categorySearches++;
    dailyUsage.categoriesSearched.push(category);

    try {
      await supabaseClient.rpc('record_category_search', {
        p_user_id: window.currentAuthUser.id,
        p_category: category
      });
    } catch (err) {
      console.error('Failed to record category search:', err);
    }
  }
}

/**
 * Show upgrade prompt modal
 */
function showUpgradePrompt(message) {
  const modal = document.createElement('div');
  modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50';
  modal.innerHTML = `
    <div class="bg-white rounded-xl shadow-2xl p-6 max-w-md mx-4">
      <div class="text-center">
        <div class="text-4xl mb-4">üöÄ</div>
        <h3 class="text-xl font-bold text-gray-900 mb-2">Upgrade Your Plan</h3>
        <p class="text-gray-600 mb-6">${escapeHtml(message)}</p>
        <div class="flex gap-3 justify-center">
          <button onclick="this.closest('.fixed').remove()" class="px-4 py-2 text-gray-600 hover:text-gray-800">
            Maybe Later
          </button>
          <a href="/pricing.html" class="px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 font-semibold">
            View Plans
          </a>
        </div>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// Expose limit functions globally
window.canCreateCampaign = canCreateCampaign;
window.canEnrich = canEnrich;
window.canSearchZip = canSearchZip;
window.canSearchCategory = canSearchCategory;
window.showUpgradePrompt = showUpgradePrompt;
window.isFreeTier = isFreeTier;

/* ========= CONFIG ========= */
// Supabase client is initialized in HEAD section
var supabaseClient = window.supabaseClient; // Local reference

// Get current user email from auth (replaces ACTIVE_USER constant)
function getCurrentUserEmail() {
  // Check if auth-root.js has set currentAuthUser
  if (window.currentAuthUser && window.currentAuthUser.email) {
    return window.currentAuthUser.email;
  }
  // Fallback: try to get from session
  console.warn('‚ö†Ô∏è currentAuthUser not available, returning null');
  return null;
}

// Initialize ACTIVE_USER - will be updated when auth completes
var ACTIVE_USER = getCurrentUserEmail();

// Poll to update ACTIVE_USER once auth is ready
var authCheckInterval = setInterval(function() {
  if (window.currentAuthUser && window.currentAuthUser.email) {
    ACTIVE_USER = window.currentAuthUser.email;
    clearInterval(authCheckInterval);
    console.log('‚úÖ ACTIVE_USER set to:', ACTIVE_USER);
    // Load subscription tier and daily usage limits
    loadUserSubscription();
    loadDailyUsage();
  }
}, 100);

// Auto-update checker: Periodically check if app version has changed
let updateBannerDismissed = false; // Track if user dismissed the banner this session
const LAST_VERSION_KEY = '9x12_last_version';
const BANNER_SUPPRESS_UNTIL_KEY = '9x12_suppress_banner_until';

// Force refresh by clearing all caches and unregistering service worker
async function forceAppRefresh() {
  console.log('üîÑ Force refreshing app...');

  try {
    // Save the current version so banner doesn't show after refresh
    const currentVersion = window.APP_CONFIG?.app?.version;
    if (currentVersion) {
      localStorage.setItem(LAST_VERSION_KEY, currentVersion);
    }

    // Set "don't show banner until" timestamp (60 seconds from now)
    localStorage.setItem(BANNER_SUPPRESS_UNTIL_KEY, (Date.now() + 60000).toString());
    console.log('‚úÖ Banner suppression set for 60 seconds');

    // Clear all caches
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      await Promise.all(cacheNames.map(name => {
        console.log('Deleting cache:', name);
        return caches.delete(name);
      }));
      console.log('‚úÖ All caches cleared');
    }

    // Unregister service workers
    if ('serviceWorker' in navigator) {
      const registrations = await navigator.serviceWorker.getRegistrations();
      await Promise.all(registrations.map(reg => {
        console.log('Unregistering service worker');
        return reg.unregister();
      }));
      console.log('‚úÖ Service workers unregistered');
    }

    // Force reload by navigating with cache-busting parameter
    // This is more reliable than reload(true) which is deprecated
    const url = new URL(window.location.href);
    url.searchParams.set('_refresh', Date.now().toString());
    window.location.href = url.toString();
  } catch (err) {
    console.error('Error during force refresh:', err);
    localStorage.setItem(BANNER_SUPPRESS_UNTIL_KEY, (Date.now() + 60000).toString());
    // Fallback: navigate with cache buster
    window.location.href = window.location.pathname + '?_refresh=' + Date.now();
  }
}

function checkForAppUpdate() {
  // Don't show again if user already dismissed this session
  if (updateBannerDismissed) {
    console.log('‚è≠Ô∏è Update banner suppressed (user dismissed)');
    return;
  }

  // Don't create duplicate banners
  if (document.getElementById('update-banner')) return;

  // Check if we're in the suppression window (after clicking Refresh Now)
  const suppressUntil = localStorage.getItem(BANNER_SUPPRESS_UNTIL_KEY);
  if (suppressUntil) {
    const suppressTime = parseInt(suppressUntil);
    if (Date.now() < suppressTime) {
      console.log('‚è≠Ô∏è Update banner suppressed (within 60s of refresh)');
      // Also save current version so banner doesn't show after suppression expires
      const currentVersion = window.APP_CONFIG?.app?.version;
      if (currentVersion) {
        localStorage.setItem(LAST_VERSION_KEY, currentVersion);
      }
      localStorage.removeItem(BANNER_SUPPRESS_UNTIL_KEY);
      return;
    }
    // Suppression expired, remove it
    localStorage.removeItem(BANNER_SUPPRESS_UNTIL_KEY);
  }

  // Check if config version differs from last seen version
  const currentVersion = window.APP_CONFIG?.app?.version;
  const lastVersion = localStorage.getItem(LAST_VERSION_KEY);

  // First visit - just save current version, no banner
  if (!lastVersion) {
    if (currentVersion) {
      localStorage.setItem(LAST_VERSION_KEY, currentVersion);
      console.log('üìù First visit, saved version:', currentVersion);
    }
    return;
  }

  if (currentVersion && currentVersion !== lastVersion) {
    console.log('üÜï New version detected:', currentVersion, '(last seen:', lastVersion + ')');

    // Immediately update localStorage so we don't show redundant banners
    // The new code is already loaded, user just needs to know about it
    localStorage.setItem(LAST_VERSION_KEY, currentVersion);

    // Show brief success notification (auto-dismisses since new code is already loaded)
    const updateBanner = document.createElement('div');
    updateBanner.id = 'update-banner';
    updateBanner.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      padding: 12px 20px;
      text-align: center;
      font-weight: bold;
      z-index: 99999;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      animation: slideDown 0.3s ease-out;
    `;
    updateBanner.innerHTML = `
      <div style="max-width: 800px; margin: 0 auto; display: flex; align-items: center; justify-content: center; gap: 16px; flex-wrap: wrap;">
        <span>‚úÖ Updated to ${currentVersion}</span>
        <button onclick="this.parentElement.parentElement.remove()" style="background: transparent; color: white; padding: 4px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.5); cursor: pointer; font-size: 12px;">
          Dismiss
        </button>
      </div>
    `;

    // Auto-dismiss after 4 seconds
    setTimeout(() => {
      const banner = document.getElementById('update-banner');
      if (banner) {
        banner.style.animation = 'slideUp 0.3s ease-out forwards';
        setTimeout(() => banner.remove(), 300);
      }
    }, 4000);

    // Add animation (only once)
    if (!document.getElementById('update-banner-style')) {
      const style = document.createElement('style');
      style.id = 'update-banner-style';
      style.textContent = `
        @keyframes slideDown {
          from { transform: translateY(-100%); }
          to { transform: translateY(0); }
        }
        @keyframes slideUp {
          from { transform: translateY(0); opacity: 1; }
          to { transform: translateY(-100%); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }
    document.body.appendChild(updateBanner);
  } else if (currentVersion) {
    // No update needed - save current version as last seen
    localStorage.setItem(LAST_VERSION_KEY, currentVersion);
  }
}

// Check for updates every 5 minutes
setInterval(checkForAppUpdate, 5 * 60 * 1000);
// Also check once on load (after 10 seconds to let everything initialize)
setTimeout(checkForAppUpdate, 10000);

// Cloud Sync State - Tracks what's syncing and when
// ========= CLOUD SYNC STATE & OFFLINE SUPPORT (extracted to cloud-sync.js) =========
// cloudSyncState, offlineState, initOfflineSupport, handleOnline, handleOffline,
// updateOfflineUI, queueOfflineSave, retryQueuedSyncs
// are now loaded from cloud-sync.js

// ‚ö†Ô∏è SECURITY WARNING: Never commit real API keys to version control!
//
// Google Places API Key - Replace with your actual key
// Get your key at: https://console.cloud.google.com/google/maps-apis/
// IMPORTANT: Restrict this key by HTTP referrer in Google Cloud Console to prevent abuse
const GOOGLE_PLACES_API_KEY = "YOUR_GOOGLE_PLACES_API_KEY_HERE";

// Message Templates - For outreach to prospects
// User Templates State (editable, synced to cloud)
const userTemplatesState = {
  templates: {} // { templateId: { id, name, category, type, subject, body, variables, createdAt, lastUsed } }
};

// Application Configuration Constants
const TOTAL_SPOTS_PER_POSTCARD = 18;
const DEFAULT_DESIGN_COST = 150;
const CLOUD_SYNC_URL_LENGTH_LIMIT = 6000; // Browser URL length limit for GET requests
const CLOUD_SYNC_RETRY_INTERVAL = 60000; // 1 minute in milliseconds
const DEBOUNCE_RENDER_DELAY = 150; // Milliseconds to debounce kanban rendering

// ========= STORAGE FUNCTIONS (extracted to storage.js) =========
// safeSetItem, safeGetItem, safeRemoveItem, initIndexedDB, idbSet, idbGet, idbDelete, migrateLocalStorageToIDB
// are now loaded from storage.js

/* ========= CACHE MANAGEMENT ========= */

// Clear local cache (keeps cloud data intact)
function clearLocalCache() {
  if (!confirm('This will clear cached search results from this browser.\n\nYour data is safely stored in the cloud and will reload automatically.\n\nContinue?')) {
    return;
  }

  try {
    // Clear the places cache (largest item)
    localStorage.removeItem('mailslot-places-cache');

    // Clear other non-critical caches
    localStorage.removeItem('mailslot-api-quota');

    // Update UI
    updateCacheStatus();

    toast('‚úÖ Local cache cleared! Reloading data from cloud...', true);

    // Reload cache from cloud
    setTimeout(() => {
      loadPlacesCache().then(() => {
        updateCacheStatus();
        renderProspectPool();
      });
    }, 500);

  } catch (err) {
    console.error('Error clearing cache:', err);
    toast('‚ùå Error clearing cache', false);
  }
}

// Update the cache status display on dashboard
function updateCacheStatus() {
  const statusEl = document.getElementById('cacheStatusText');
  if (!statusEl) return;

  try {
    // Calculate localStorage usage
    let totalSize = 0;
    let cacheSize = 0;

    for (let key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        const itemSize = (localStorage[key].length * 2) / 1024; // Size in KB (UTF-16)
        totalSize += itemSize;
        if (key === 'mailslot-places-cache') {
          cacheSize = itemSize;
        }
      }
    }

    // Get search count from memory
    const searchCount = Object.keys(placesCache?.searches || {}).length;

    statusEl.innerHTML = `
      <span class="font-semibold">${searchCount} searches</span> in memory ‚Ä¢
      <span class="font-semibold">${Math.round(cacheSize)} KB</span> cached locally ‚Ä¢
      <span class="font-semibold">${Math.round(totalSize)} KB</span> total storage
    `;
  } catch (err) {
    statusEl.textContent = 'Unable to read cache status';
  }
}

// Expose functions globally
window.clearLocalCache = clearLocalCache;
window.updateCacheStatus = updateCacheStatus;

// ========= CLOUD SYNC FUNCTIONS (extracted to cloud-sync.js) =========
// loadFromCloud, saveToCloud, saveToCloudOptimized, auto-retry interval
// are now loaded from cloud-sync.js

const CANONICAL_STATUSES = [
  "Available",
  "Reserved",
  "Invoice Sent",
  "Deposit Paid",
  "Proof In Progress",
  "Ad Approved",
  "Paid in Full"
];

let sortOrder = [...CANONICAL_STATUSES];
let visibleStatuses = [...CANONICAL_STATUSES];
const GRADIENT_HEX = ["#fef3c7", "#fff7ed", "#fed7aa", "#fdba74", "#dbeafe", "#2563eb", "#16a34a"];
const GRADIENT_PILL = ["#fcd34d", "#fb923c", "#f97316", "#ea580c", "#3b82f6", "#1d4ed8", "#15803d"];
let STATUS_HEX = {};
let STATUS_PILL = {};

function updateColorMappings() {
  const visibleSorted = sortOrder.filter(s => visibleStatuses.includes(s));
  const numVisible = visibleSorted.length;
  const usedHex = GRADIENT_HEX.slice(0, numVisible - 1);
  usedHex.push(GRADIENT_HEX[GRADIENT_HEX.length - 1]);
  const usedPill = GRADIENT_PILL.slice(0, numVisible - 1);
  usedPill.push(GRADIENT_PILL[GRADIENT_PILL.length - 1]);
  visibleSorted.forEach((s, i) => {
    STATUS_HEX[s] = usedHex[i];
    STATUS_PILL[s] = usedPill[i];
  });
  const hiddenDefault = STATUS_HEX["Available"] || GRADIENT_HEX[0];
  CANONICAL_STATUSES.filter(s => !visibleStatuses.includes(s)).forEach(s => {
    STATUS_HEX[s] = hiddenDefault;
    STATUS_PILL[s] = GRADIENT_PILL[0];
  });
}

const PAIRS = [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18]];
const keyPair = (a,b)=>[Math.min(a,b),Math.max(a,b)].join("-");
const isValidPair=(a,b)=>PAIRS.some(([x,y])=>x===Math.min(a,b)&&y===Math.max(a,b));
const mateOf = n => { for (const [a,b] of PAIRS) { if (a===n) return b; if (b===n) return a; } return null; };

// VERSION CHECK - reads from config.js (single source of truth)
console.log('üî• APP VERSION:', window.APP_CONFIG?.app?.version || 'unknown');

const state = {
  mailers: [],
  current: null,
  availability: {},
  initial: {},
  merged: new Set(),
  selected: new Set(),
  dirty: false,
  lastSide: "front",
  updatingSelectors: false  // Flag to prevent circular updates when syncing dropdowns
};

const stagedColors = {
  Postcard_BG: "",
  Banner_BG: "#000000"  // Black - ensures white text by default
};

// AUTO-SAVE STATE
const autoSaveState = {
  timer: null,
  lastSaveTime: null,
  saving: false,
  updateInterval: null
};

// PRODUCTION STATE (OLD - for expenses and spot pricing)
const productionState = {
  expenses: {},
  spotPricing: {},
  pricing: {}, // Per-postcard pricing: { mailerId: { singleAd, doubleAd, bannerAd } }
  revenueGoals: {} // Per-postcard revenue goals: { mailerId: { singleCount, singlePrice, doubleCount, doublePrice, bannerCount, bannerPrice, total } }
};

const DEFAULT_SPOT_PRICE = 500;
const DEFAULT_EXPENSES = {
  printing: 0,
  postage: 0,
  design: 0,
  misc: 0
};

// CRM STATE
const crmState = {
  clients: {},
  nextClientId: 1
};
console.log('üîß Checkpoint: line ~1000 - crmState defined');

// CLIENT SELECTION STATE (for bulk send)
const clientSelectionState = {
  selectedIds: new Set()
};

// KANBAN STATE - Getter shim that reads from Campaign Board (single source of truth)
// All read sites automatically get campaign board data through this proxy.
// Write sites must be individually updated to write to campaign board directly.
const kanbanState = {
  get columns() {
    const board = typeof getCurrentCampaignBoard === 'function' ? getCurrentCampaignBoard() : null;
    if (!board || !board.columns) {
      return { 'prospect-list': [], 'to-contact': [], 'in-progress': [], 'committed': [] };
    }
    return {
      'prospect-list': board.columns['queued'] || [],
      'to-contact': board.columns['attempting'] || [],
      'in-progress': board.columns['negotiating'] || [],
      'committed': [...(board.columns['invoice-sent'] || []), ...(board.columns['proof-approved'] || [])]
    };
  },
  zipFilters: {}
};

// CAMPAIGN BOARDS STATE - New unified pipeline system
const campaignBoardsState = {
  boards: {},           // { mailerId: boardObject }
  activeBoardId: null,
  useLegacyKanban: false, // Campaign Board is now the default (legacy kanban removed)
  globalZipFilter: 'target', // 'target' = show target ZIPs only, 'all' = show all, or specific ZIP code
  queuedSelection: new Set(), // Selected item IDs in queued column
  attemptingSelection: new Set(), // Selected item IDs in attempting column
  columnView: 'discovery', // 'discovery' (cols 1-3) or 'sales' (cols 4-6)
  cloudDataLoaded: false // Track whether boards were successfully loaded from cloud
};

// Board structure template (not stored, just documentation):
// {
//   mailerId: "MAILER-001",
//   name: "Spring HVAC Promo",
//   config: {
//     channelPriority: ['sms', 'email', 'facebook', 'call'],
//     templates: { sms: 'tpl_1', email: 'tpl_2', facebook: 'tpl_3', call: 'tpl_4' },
//     daysBetweenAttempts: 3,
//     maxAttempts: 4
//   },
//   columns: {
//     'queued': [],
//     'attempting': [],
//     'negotiating': [],
//     'invoice-sent': [],
//     'proof-approved': [],
//     'paid-in-full': []
//   }
// }

// ========== CAMPAIGN BOARD COMPATIBILITY LAYER ==========
// Maps Campaign Board (6 columns) to legacy kanban view (4 columns)
// This allows Pipeline tab to read from Campaign Board while keeping existing UI

// Legacy mapping functions removed - kanbanState getter shim handles column mapping

// Check if a business is already in any Campaign Board column
function isInCampaignBoard(placeId) {
  if (!placeId) return false;
  for (const board of Object.values(campaignBoardsState.boards)) {
    if (!board || !board.columns) continue;
    for (const column of Object.values(board.columns)) {
      if (!Array.isArray(column)) continue;
      if (column.some(item => item && (item.placeId === placeId || item.id === placeId))) {
        return true;
      }
    }
  }
  return false;
}

// Find a prospect by ID in Campaign Board (returns {item, column} or null)
function findProspectInCampaignBoard(prospectId) {
  const board = getCurrentCampaignBoard();
  if (!board || !board.columns) return null;

  for (const colKey of Object.keys(board.columns)) {
    const items = board.columns[colKey] || [];
    const item = items.find(i => i && typeof i === 'object' && String(i.id) === String(prospectId));
    if (item) {
      return { item, column: colKey };
    }
  }
  return null;
}


// Get all placeIds that are in Campaign Board (for "In System" checks)
function getCampaignBoardPlaceIds() {
  const placeIds = new Set();
  const board = getCurrentCampaignBoard();
  if (!board || !board.columns) return placeIds;

  Object.values(board.columns).forEach(column => {
    if (!Array.isArray(column)) return;
    column.forEach(item => {
      if (item && item.placeId) placeIds.add(item.placeId);
      if (item && item.id) placeIds.add(String(item.id));
    });
  });
  return placeIds;
}

// DAILY OUTREACH GOAL STATE
const dailyGoalState = {
  dailyGoal: 10,               // Default goal: contact 10 businesses per day
  todayCount: 0,               // How many contacted today
  lastResetDate: new Date().toDateString(),  // Track when we last reset
  history: []                  // Array of {date, goal, actual, businesses: []}
};

// CLOUD SYNC SELECTION STATE
const cloudSyncSelection = {
  selectedIds: new Set(),
  showSyncUI: false
};

// TASKS STATE
const tasksState = {
  tasks: []
};

// API QUOTA TRACKING STATE
const apiQuotaState = {
  monthlyLimit: 28000,  // Google Places API free tier
  currentMonth: new Date().toISOString().slice(0, 7), // "2025-11"
  callsThisMonth: 0,
  userQuotas: {},  // Per-user quotas when restrictions activate
  restrictionsActive: false,
  warningThreshold: 0.8,  // 80% = 22,400 calls
  criticalThreshold: 0.95  // 95% = 26,600 calls
};

// FOLLOW-UP DASHBOARD STATE
const followUpDashboardState = {
  overdueFollowUps: [],      // Prospects with followUpDate < today
  dueToday: [],              // Prospects with followUpDate = today
  upcomingWeek: [],          // Next 7 days
  sequenceActionsDue: [],    // Prospects needing next sequence step
  lastRefreshed: null
};

// OUTREACH SEQUENCES STATE
const outreachSequencesState = {
  sequences: {
    'seq_standard_email': {
      id: 'seq_standard_email',
      name: 'Standard Email Sequence',
      description: '4 emails over 2 weeks',
      steps: [
        { day: 1, channel: 'email', templateId: 'email1', description: 'Initial Outreach' },
        { day: 4, channel: 'email', templateId: 'email2', description: 'Follow-up 1' },
        { day: 8, channel: 'email', templateId: 'email3', description: 'Follow-up 2' },
        { day: 14, channel: 'email', templateId: 'email4', description: 'Final email' }
      ]
    },
    'seq_multi_channel': {
      id: 'seq_multi_channel',
      name: 'Multi-Channel Blitz',
      description: 'Email, text, call combo',
      steps: [
        { day: 1, channel: 'email', templateId: 'email1', description: 'Initial email' },
        { day: 3, channel: 'text', templateId: 'sms1', description: 'Follow-up text' },
        { day: 7, channel: 'call', templateId: 'call1', description: 'Phone call' },
        { day: 10, channel: 'email', templateId: 'email4', description: 'Final email' }
      ]
    },
    'seq_social_first': {
      id: 'seq_social_first',
      name: 'Social First',
      description: 'FB, IG, Email, Text over 10 days',
      steps: [
        { day: 1, channel: 'facebook', templateId: 'facebook1', description: 'Facebook message' },
        { day: 4, channel: 'instagram', templateId: 'instagram1', description: 'Instagram DM' },
        { day: 7, channel: 'email', templateId: 'email1', description: 'Email follow-up' },
        { day: 10, channel: 'text', templateId: 'sms1', description: 'Text message' }
      ]
    }
  }
};

// PLACES CACHE STATE (30-day cache + permanent Place IDs)
const placesCache = {
  searches: {}  // Format: { "zipCode-category": { placeIds: [], cachedData: [], cachedUntil: "date" } }
};

// Cache size limits to prevent localStorage quota issues
const CACHE_LIMITS = {
  MAX_ENTRIES: 2000,       // Maximum number of search cache entries (increased for power users)
  MAX_SIZE_KB: 20000,      // Maximum cache size in KB (~20MB - IndexedDB can handle 50MB+)
  MIN_ENTRIES_TO_KEEP: 500 // Always keep at least this many recent entries
};

// NOT INTERESTED LIST STATE (permanent exclusion list)
const notInterestedState = {
  placeIds: new Set(),  // Set of Place IDs marked as "not interested"
  businesses: {}  // Map of Place ID => business info for reference
};

// PROSPECTS RESULTS STATE (temporary storage for search results)
let prospectsResultsState = {
  businesses: [],
  selectedIds: new Set()
};

let lastFocusedElementBeforeModal = null;
let draggedItem = null;
let draggedTask = null;

// ========= UTILITIES (extracted to utilities.js) =========
// $, esc, ensureHttps, show, toast, formatDate, isOverdue
// are now loaded from utilities.js

function updateTaskDate(input) {
  const row = input.closest('.task-row');
  const taskId = row.dataset.taskId;
  const newDate = input.value;
  if (newDate) {
    row.dataset.dueDate = newDate;
    const task = tasksState.tasks.find(t => t.id == taskId);
    if (task) {
      task.dueDate = newDate;
      saveTasks();
    }
    updateTasksDisplay();
    toast('Task date updated');
  }
}

function toggleTaskComplete(checkbox) {
  // Handle case where checkbox might be an event instead of an element
  if (!checkbox || typeof checkbox.closest !== 'function') {
    console.error('toggleTaskComplete called with invalid checkbox:', checkbox);
    return;
  }

  // Support both task-row (Tasks tab) and direct data-task-id (Dashboard widget)
  const row = checkbox.closest('.task-row');
  const taskId = row ? row.dataset.taskId : checkbox.dataset.taskId;

  if (!taskId) {
    console.error('Could not find task ID for checkbox');
    return;
  }

  const task = tasksState.tasks.find(t => t.id == taskId);
  if (task) {
    task.completed = checkbox.checked;
    saveTasks();
    if (row) {
      if (checkbox.checked) {
        row.classList.add('completed');
      } else {
        row.classList.remove('completed');
      }
    }
    updateTasksDisplay();
  }
}

/* ========= FINANCIAL CALCULATIONS ========= */
function calculateFinancials(mailerId, campaign = null) {
  if (!mailerId) return null;

  // If pricing data hasn't loaded yet, return null to avoid showing $500 defaults
  const hasPricingData = Object.keys(productionState.pricing).length > 0 || Object.keys(productionState.spotPricing).length > 0;
  if (!hasPricingData) return null;

  const expenses = productionState.expenses[mailerId] || { ...DEFAULT_EXPENSES };
  // Only sum actual expense fields, excluding addressCount
  const totalExpenses = (parseFloat(expenses.printing) || 0) +
                       (parseFloat(expenses.postage) || 0) +
                       (parseFloat(expenses.design) || 0) +
                       (parseFloat(expenses.misc) || 0);

  let paidRevenue = 0;
  let depositRevenue = 0;
  let projectedRevenue = 0;
  let spotsSold = 0;
  let spotsPaid = 0;

  // Use campaign data if provided, otherwise use state.availability (for current postcard)
  const getSpotData = (i) => {
    if (campaign && campaign[`Spot_${i}`]) {
      const spotValue = campaign[`Spot_${i}`];

      // Handle plain "Available" string (empty spot)
      if (spotValue === "Available") {
        return { name: "", status: "Available" };
      }

      // Handle string format "Status: Business Name"
      if (typeof spotValue === 'string') {
        // Check if it's "Status: Name" format
        if (spotValue.includes(':')) {
          const colonIndex = spotValue.indexOf(':');
          const status = spotValue.substring(0, colonIndex).trim();
          const name = spotValue.substring(colonIndex + 1).trim();
          return { name, status };
        }

        // Try JSON parse as fallback
        try {
          return JSON.parse(spotValue);
        } catch (e) {
          // If not JSON and no colon, treat as Available
          return { name: "", status: "Available" };
        }
      }

      // Handle object
      return spotValue;
    }
    return state.availability[`Spot_${i}`];
  };

  // Get pricing for this postcard (new system)
  const pricing = productionState.pricing[mailerId] || null;

  for (let i = 1; i <= TOTAL_SPOTS_PER_POSTCARD; i++) {
    const spot = getSpotData(i);

    // Check if this spot is the SECOND spot in a merged pair
    const mate = mateOf(i);
    let isMergedSecond = false;
    let isMerged = false;
    if (mate && mate < i) {
      if (campaign) {
        // When using campaign data, check if spot names match (indicates merge)
        const mateSpot = getSpotData(mate);
        const spotName = spot?.name?.trim() || '';
        const mateName = mateSpot?.name?.trim() || '';
        isMergedSecond = spotName && mateName && spotName === mateName;
      } else {
        // When using state.availability, use state.merged
        isMergedSecond = state.merged.has(keyPair(i, mate));
      }
    }

    // Check if this spot is the FIRST in a merged pair
    if (mate && mate > i) {
      if (campaign) {
        const mateSpot = getSpotData(mate);
        const spotName = spot?.name?.trim() || '';
        const mateName = mateSpot?.name?.trim() || '';
        isMerged = spotName && mateName && spotName === mateName;
      } else {
        isMerged = state.merged.has(keyPair(i, mate));
      }
    }

    // Skip if this is the second spot in a merged pair (already counted with first spot)
    if (isMergedSecond) {
      continue;
    }

    // Simple pricing logic:
    // 1. If spot has custom price (manually set) ‚Üí use it
    // 2. Otherwise ‚Üí use Set Pricing defaults (Single/Double/Banner)
    let price;
    const priceKey = normalizePriceKey(mailerId, i);
    const customSpotPrice = productionState.spotPricing[priceKey];

    if (customSpotPrice !== undefined && customSpotPrice !== null && customSpotPrice > 0) {
      price = parseFloat(customSpotPrice);
    } else if (pricing) {
      if (isMerged) {
        if ((i === 13 || i === 14) && mate && (mate === 13 || mate === 14)) {
          price = parseFloat(pricing.bannerAd) || DEFAULT_SPOT_PRICE;
        } else {
          price = parseFloat(pricing.doubleAd) || DEFAULT_SPOT_PRICE;
        }
      } else {
        price = parseFloat(pricing.singleAd) || DEFAULT_SPOT_PRICE;
      }
    } else {
      price = DEFAULT_SPOT_PRICE;
    }

    // Only count revenue if spot has a business name entered
    if (spot && spot.status !== "Available" && spot.name && spot.name.trim() !== "") {
      spotsSold++;
      projectedRevenue += price;

      if (spot.status === "Deposit Paid") {
        depositRevenue += price * 0.5;
      } else {
        paidRevenue += price;
        spotsPaid++;
      }
    }
  }

  const currentRevenue = paidRevenue + depositRevenue;
  const currentProfit = currentRevenue - totalExpenses;
  const projectedProfit = projectedRevenue - totalExpenses;
  const breakeven = currentRevenue >= totalExpenses;

  // Use actual pricing when no spots sold, not the hardcoded default
  const avgSpotPrice = spotsSold > 0 ? projectedRevenue / spotsSold : (pricing?.singleAd || DEFAULT_SPOT_PRICE);
  const remainingToBreakeven = Math.max(0, totalExpenses - currentRevenue);
  const spotsNeeded = Math.ceil(remainingToBreakeven / avgSpotPrice);

  // Calculate effective total spots (18 minus number of merged pairs)
  // Each merged pair reduces total by 1 (4 singles become 2 doubles = -2 spots)
  let mergedPairsCount = 0;
  if (campaign) {
    // Count merged pairs by checking if adjacent spots have matching names
    for (let i = 1; i <= TOTAL_SPOTS_PER_POSTCARD; i++) {
      const mate = mateOf(i);
      if (mate && mate > i) { // Only count each pair once
        const spot = getSpotData(i);
        const mateSpot = getSpotData(mate);
        const spotName = spot?.name?.trim() || '';
        const mateName = mateSpot?.name?.trim() || '';
        if (spotName && mateName && spotName === mateName) {
          mergedPairsCount++;
        }
      }
    }
  } else {
    mergedPairsCount = state.merged.size;
  }
  const effectiveTotalSpots = TOTAL_SPOTS_PER_POSTCARD - mergedPairsCount;

  // Calculate maximum potential revenue by summing actual price for each spot
  // This accounts for custom spot pricing - if a spot has a custom price, use it
  let maxPotentialRevenue = 0;
  for (let i = 1; i <= TOTAL_SPOTS_PER_POSTCARD; i++) {
    const priceKey = normalizePriceKey(mailerId, i);
    const customSpotPrice = productionState.spotPricing[priceKey];

    // Use same 3-step pricing logic
    let spotPrice;
    if (customSpotPrice !== undefined && customSpotPrice !== null && customSpotPrice > 0) {
      spotPrice = parseFloat(customSpotPrice);
    } else if (pricing) {
      spotPrice = parseFloat(pricing.singleAd) || DEFAULT_SPOT_PRICE;
    } else {
      spotPrice = DEFAULT_SPOT_PRICE;
    }

    maxPotentialRevenue += spotPrice;
  }

  // Use revenue goal if set, otherwise use maxPotentialRevenue
  const revenueGoal = productionState.revenueGoals[mailerId];
  const revenueTarget = (revenueGoal && revenueGoal.total > 0) ? revenueGoal.total : maxPotentialRevenue;

  return {
    revenue: {
      paid: paidRevenue,
      deposit: depositRevenue,
      current: currentRevenue,
      projected: projectedRevenue,
      target: revenueTarget
    },
    expenses: {
      ...expenses,
      total: totalExpenses
    },
    profit: {
      current: currentProfit,
      projected: projectedProfit,
      margin: projectedRevenue > 0 ? (projectedProfit / projectedRevenue * 100) : 0
    },
    metrics: {
      spotsSold,
      spotsPaid,
      spotsAvailable: effectiveTotalSpots - spotsSold,
      avgSpotPrice,
      breakeven,
      spotsNeeded,
      progressPercent: effectiveTotalSpots > 0 ? (spotsSold / effectiveTotalSpots * 100) : 0,
      effectiveTotalSpots // Add this for display purposes
    }
  };
}

function formatCurrency(amount) {
  return new Intl.NumberFormat('en-US', { 
    style: 'currency', 
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(amount || 0);
}

function updateFinancialDashboard() {
  if (!state.current) return;

  const financials = calculateFinancials(state.current.Mailer_ID, state.current);
  if (!financials) return;
  
  const profitEl = document.getElementById('profitStatus');
  const revenueEl = document.getElementById('currentRevenue');
  const expensesEl = document.getElementById('oldTotalExpenses');
  const spotsToBreakevenEl = document.getElementById('spotsToBreakeven');
  const progressBarEl = document.getElementById('revenueProgressBar');
  const progressTextEl = document.getElementById('revenueProgressText');
  
  if (profitEl) {
    profitEl.textContent = formatCurrency(financials.profit.current);
    profitEl.className = `metric-value ${financials.metrics.breakeven ? 'text-green-600' : 'text-red-500'}`;
  }
  
  if (revenueEl) revenueEl.textContent = formatCurrency(financials.revenue.current);
  if (expensesEl) expensesEl.textContent = formatCurrency(financials.expenses.total);
  
  if (spotsToBreakevenEl) {
    if (financials.metrics.breakeven) {
      spotsToBreakevenEl.innerHTML = '‚úì <span class="text-green-600 font-bold">Profitable!</span>';
    } else {
      spotsToBreakevenEl.innerHTML = `Need <span class="font-bold text-indigo-600">${financials.metrics.spotsNeeded} more spot${financials.metrics.spotsNeeded === 1 ? '' : 's'}</span> to break even`;
    }
  }
  
  if (progressBarEl) {
    const percent = (financials.revenue.current / financials.revenue.target * 100);
    progressBarEl.style.width = `${Math.min(percent, 100)}%`;
  }
  
  if (progressTextEl) {
    const revenuePercent = Math.round((financials.revenue.current / financials.revenue.target) * 100);
    progressTextEl.textContent = `${formatCurrency(financials.revenue.current)} of ${formatCurrency(financials.revenue.target)} goal (${revenuePercent}%)`;
  }
  
  const slotsSoldEl = document.getElementById('slotsSoldMetric');
  const slotsSoldPercentEl = document.getElementById('slotsSoldPercent');
  if (slotsSoldEl) {
    slotsSoldEl.textContent = `${financials.metrics.spotsSold}/${financials.metrics.effectiveTotalSpots}`;
  }
  if (slotsSoldPercentEl) {
    const percent = Math.round(financials.metrics.progressPercent);
    slotsSoldPercentEl.textContent = `(${percent}%)`;
  }

  const slotsSoldBarEl = document.getElementById('slotsSoldBar');
  if (slotsSoldBarEl) {
    slotsSoldBarEl.style.width = `${financials.metrics.progressPercent}%`;
  }
}

/* ========= EXPENSE MODAL ========= */
function openExpenseModal() {
  if (!state.current) {
    toast("Please select a postcard first", false);
    return;
  }

  const modal = document.getElementById("expenseModal");
  const mailerId = state.current.Mailer_ID;
  const expenses = productionState.expenses[mailerId] || { ...DEFAULT_EXPENSES };

  document.getElementById("expensePrinting").value = expenses.printing || DEFAULT_EXPENSES.printing;
  document.getElementById("expensePostage").value = expenses.postage || DEFAULT_EXPENSES.postage;
  document.getElementById("expenseDesign").value = expenses.design || DEFAULT_EXPENSES.design;
  document.getElementById("expenseMisc").value = expenses.misc || DEFAULT_EXPENSES.misc;
  document.getElementById("expenseAddressCount").value = expenses.addressCount || 0;

  updateExpenseTotal();

  lastFocusedElementBeforeModal = document.activeElement;
  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
  document.getElementById("expensePrinting").focus();
}

function closeExpenseModal() {
  const modal = document.getElementById("expenseModal");
  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
  if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();
}

function updateExpenseTotal() {
  const printing = parseFloat(document.getElementById("expensePrinting").value) || 0;
  const postage = parseFloat(document.getElementById("expensePostage").value) || 0;
  const design = parseFloat(document.getElementById("expenseDesign").value) || 0;
  const misc = parseFloat(document.getElementById("expenseMisc").value) || 0;

  const total = printing + postage + design + misc;
  document.getElementById("expenseTotal").textContent = formatCurrency(total);
}

function calculateEDDMPostage() {
  const addressCount = parseFloat(document.getElementById("expenseAddressCount").value) || 0;
  const postageCost = addressCount * 0.247;

  document.getElementById("expensePostage").value = postageCost.toFixed(2);
  updateExpenseTotal();
}

async function loadExpenses() {
  try {
    // Try loading from cloud first
    const cloudData = await loadFromCloud('expenses');

    if (cloudData) {
      productionState.expenses = cloudData;
    } else {
      // Fallback to localStorage
      const saved = localStorage.getItem('mailslot-expenses');
      if (saved) {
        productionState.expenses = JSON.parse(saved);
        // Sync to cloud
        saveToCloud('expenses', productionState.expenses).catch(e => console.warn('Failed to sync expenses to cloud:', e));
      }
    }
  } catch(e) {
    console.error('Error loading expenses:', e);
  }
}

async function saveExpenses() {
  try {
    // Save to cloud and localStorage
    await saveToCloud('expenses', productionState.expenses);
  } catch(e) {
    console.warn('Expenses saved to localStorage only (cloud sync failed):', e);
  }
}

function saveExpenseModal() {
  if (!state.current) return;

  const mailerId = state.current.Mailer_ID;
  productionState.expenses[mailerId] = {
    printing: parseFloat(document.getElementById("expensePrinting").value) || 0,
    postage: parseFloat(document.getElementById("expensePostage").value) || 0,
    design: parseFloat(document.getElementById("expenseDesign").value) || 0,
    misc: parseFloat(document.getElementById("expenseMisc").value) || 0,
    addressCount: parseFloat(document.getElementById("expenseAddressCount").value) || 0
  };

  saveExpenses();

  updateFinancialDashboard();
  closeExpenseModal();
  state.dirty = true;
  updateToolbar();
  // Save immediately to database
  saveToSheet();
}

/* ========= CRM FUNCTIONS ========= */

function buildClientObject(data) {
  return {
    id: data.id || `CLT-${String(crmState.nextClientId++).padStart(4, '0')}`,
    businessName: data.businessName || "",
    category: data.category || "",
    contact: {
      name: data.contactName || "",
      firstName: data.firstName || "",
      phone: data.phone || "",
      email: data.email || "",
      address: data.address || ""
    },
    monthlyPrice: data.monthlyPrice || 0,
    status: data.status || "active", // active, paused, inactive
    activeMonths: data.activeMonths || [true, true, true, true, true, true, true, true, true, true, true, true], // J F M A M J J A S O N D
    history: data.history || [],
    interactions: data.interactions || [], // Interaction tracking: [{date, type, notes, nextFollowUp}]
    lifetime: {
      totalSpent: 0,
      cardsBought: 0,
      renewalRate: 0,
      avgPrice: 0
    },
    notes: data.notes || "",
    tags: data.tags || [],
    createdDate: data.createdDate || new Date().toISOString(),
    lastContact: data.lastContact || null,
    nextRenewal: data.nextRenewal || null,
    contract: data.contract || {
      enabled: false,
      startDate: null,
      length: 6,
      monthlyRate: 0,
      totalValue: 0,
      endDate: null,
      autoRenew: false
    }
  };
}

async function loadClients() {
  try {
    // Try loading from cloud first
    const cloudData = await loadFromCloud('clients');
    console.log('üìã loadClients - cloudData:', cloudData);

    if (cloudData) {
      crmState.clients = cloudData.clients || {};
      crmState.nextClientId = cloudData.nextClientId || 1;
      console.log('üìã Loaded', Object.keys(crmState.clients).length, 'clients from cloud');

      // Normalize client data to ensure all have required structure
      Object.keys(crmState.clients).forEach(clientId => {
        const client = crmState.clients[clientId];

        // Normalize ZIP codes to 5 digits
        if (client.zipCode && client.zipCode.length > 5) {
          client.zipCode = truncateZipTo5(client.zipCode);
        }
        if (client.zip && client.zip.length > 5) {
          client.zip = truncateZipTo5(client.zip);
        }

        // Always ensure required nested objects exist
        if (!client.lifetime) {
          client.lifetime = { cardsBought: 0, totalSpent: 0, avgPrice: 0 };
        }
        if (!client.contact || typeof client.contact === 'string') {
          const contactName = typeof client.contact === 'string' ? client.contact : '';
          client.contact = {
            name: contactName || client.contactName || client.contact_name || '',
            firstName: client.firstName || '',
            phone: client.phone || '',
            email: client.email || ''
          };
        }
        if (!client.history) {
          client.history = [];
        }

        // If client needs full rebuild, use buildClientObject
        if (!client.businessName && !client.id) {
          crmState.clients[clientId] = buildClientObject({
            id: client.id || clientId,
            businessName: client.businessName || client.business_name || "",
            category: client.category || "",
            contactName: client.contact?.name || client.contactName || client.contact_name || "",
            phone: client.contact?.phone || client.phone || "",
            email: client.contact?.email || client.email || "",
            address: client.address || "",
            notes: client.notes || "",
            history: client.history || [],
            tags: client.tags || [],
            createdDate: client.createdDate || client.created_at || new Date().toISOString(),
            lastContact: client.lastContact || null,
            nextRenewal: client.nextRenewal || null,
            contract: client.contract || undefined
          });
        }
      });
    } else {
      // Fallback to localStorage
      console.log('üìã No cloud data for clients, checking localStorage...');
      const saved = localStorage.getItem('mailslot-clients');
      if (saved) {
        const data = JSON.parse(saved);
        crmState.clients = data.clients || {};
        crmState.nextClientId = data.nextClientId || 1;
        console.log('üìã Loaded', Object.keys(crmState.clients).length, 'clients from localStorage');
        // Sync to cloud
        saveToCloud('clients', { clients: crmState.clients, nextClientId: crmState.nextClientId }).catch(e => console.warn('Failed to sync clients to cloud:', e));
      } else {
        console.log('üìã No clients found in localStorage either');
      }
    }

    // Render client list (inside try-catch to prevent promise rejection)
    console.log('üìã Rendering client list with', Object.keys(crmState.clients).length, 'clients');
    renderClientList();
  } catch(e) {
    console.error('Error loading clients:', e);
    // Still try to render with empty state
    crmState.clients = {};
    crmState.nextClientId = 1;
    renderClientList();
  }
}

async function saveClients() {
  try {
    const data = {
      clients: crmState.clients,
      nextClientId: crmState.nextClientId
    };
    // Save to cloud and localStorage
    await saveToCloud('clients', data);
  } catch(e) {
    console.warn('Clients saved to localStorage only (cloud sync failed):', e);
  }
}

function renderClientList() {
  const container = document.getElementById('clientList');

  // Helper to normalize names for deduplication (matches cleanupDuplicateClients)
  const normalizeForDedup = (name) => {
    if (!name) return '';
    // Truncate at separators: bullets, pipes, colons, dashes
    let n = name.split(/[‚Ä¢¬∑‚óè|:\-‚Äì‚Äî‚ñ∫‚ñ∏‚Ä£‚ÅÉ]/)[0];
    n = n.toLowerCase()
      .replace(/&/g, ' and ')  // Normalize all & to and (with or without spaces)
      .replace(/['''`¬¥",.]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    // Remove common business suffixes repeatedly (including trailing "and", "of")
    const suffixes = /\s+(and|of|inc|llc|corp|svce?|services?|the|repair|towing?|automobile|automotive|auto|shop|shoppe|community|preschool|pre-school|school|daycare|day care|childcare|center|centre|salon|spa|studio|learning|early childhood)\s*$/gi;
    for (let i = 0; i < 5; i++) {
      n = n.replace(suffixes, '');
    }
    return n.trim();
  };

  // Combine crmState.clients with pipeline prospects
  // First, deduplicate crmClients themselves (in case of duplicates in the database)
  const allCrmClients = Object.values(crmState.clients);
  const crmClients = [];
  const seenNormalizedNames = new Set();
  const seenPlaceIds = new Set();

  // Sort by data quality - prefer records with more info (revenue, contact data)
  allCrmClients.sort((a, b) => {
    const scoreA = (a.lifetime?.totalSpent || 0) + (a.monthlyPrice || 0) * 100 + (a.contact?.phone ? 10 : 0) + (a.contact?.email ? 10 : 0);
    const scoreB = (b.lifetime?.totalSpent || 0) + (b.monthlyPrice || 0) * 100 + (b.contact?.phone ? 10 : 0) + (b.contact?.email ? 10 : 0);
    return scoreB - scoreA; // Higher score first
  });

  for (const client of allCrmClients) {
    const normalizedName = normalizeForDedup(client.businessName);
    // Skip if we've already seen this normalized name or placeId
    if (normalizedName && seenNormalizedNames.has(normalizedName)) continue;
    if (client.placeId && seenPlaceIds.has(client.placeId)) continue;

    crmClients.push(client);
    if (normalizedName) seenNormalizedNames.add(normalizedName);
    if (client.placeId) seenPlaceIds.add(client.placeId);
  }

  // Get all prospects from kanban pipeline columns
  const pipelineProspects = [];
  const existingPlaceIds = new Set(crmClients.map(c => c.placeId).filter(Boolean));
  const existingNormalizedNames = new Set(crmClients.map(c => normalizeForDedup(c.businessName)).filter(Boolean));

  if (kanbanState && kanbanState.columns) {
    Object.values(kanbanState.columns).forEach(column => {
      column.forEach(prospect => {
        const prospectName = prospect.businessName || prospect.name || prospect.title || '';
        const normalizedName = normalizeForDedup(prospectName);
        // Skip if already in CRM (by placeId or normalized name)
        if (prospect.placeId && existingPlaceIds.has(prospect.placeId)) return;
        if (normalizedName && existingNormalizedNames.has(normalizedName)) return;

        // Track this name to avoid duplicates within pipeline
        if (normalizedName) {
          existingNormalizedNames.add(normalizedName);
        }
        if (prospect.placeId) {
          existingPlaceIds.add(prospect.placeId);
        }

        // Convert to client-like format
        pipelineProspects.push({
          id: prospect.id || prospect.placeId || `pipeline-${Date.now()}-${Math.random()}`,
          businessName: prospect.businessName || prospect.name || prospect.title || 'Unknown Business',
          category: prospect.category || '',
          status: 'active',
          contact: {
            name: prospect.contactName || prospect.ownerName || '',
            firstName: '',
            phone: prospect.phone || '',
            email: prospect.email || ''
          },
          website: prospect.website || '',
          facebook: prospect.facebook || '',
          instagram: prospect.instagram || '',
          linkedin: prospect.linkedin || '',
          twitter: prospect.twitter || '',
          ownerName: prospect.ownerName || prospect.contactName || '',
          rating: prospect.rating || null,
          reviewCount: prospect.reviewCount || null,
          priceLevel: prospect.priceLevel || null,
          description: prospect.description || '',
          monthlyPrice: null,
          placeId: prospect.placeId || null,
          history: [],
          lifetime: { totalSpent: 0, cardsBought: 0 },
          isPipelineProspect: true // Mark as pipeline prospect
        });
      });
    });
  }

  // Combine CRM clients and pipeline prospects (CRM clients take priority - already deduped above)
  const clients = [...crmClients, ...pipelineProspects];

  if (clients.length === 0) {
    container.innerHTML = '<p class="text-sm text-gray-500 text-center py-8">No businesses yet. Search for prospects or add a business above!</p>';
    updateClientBulkSendSection();
    return;
  }

  clients.sort((a, b) => a.businessName.localeCompare(b.businessName));

  container.innerHTML = `
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3" id="clientListGrid">
      ${clients.map(client => {
        const lastPurchase = (client.history && client.history.length > 0)
          ? client.history[client.history.length - 1]
          : null;

        const hasPhone = client.contact && client.contact.phone;
        const hasEmail = client.contact && client.contact.email;
        const isSelected = clientSelectionState.selectedIds.has(client.id);
        const totalSpent = (client.lifetime?.totalSpent) || 0;
        const monthlyPrice = client.monthlyPrice || 0;
        // A client is someone with revenue, monthly price, or explicitly in crmState.clients (not from pipeline)
        const isActualClient = totalSpent > 0 || monthlyPrice > 0 || (!client.isPipelineProspect && crmState.clients[client.id]);
        const isPipelineProspect = client.isPipelineProspect || false;

        return `
          <div class="client-row bg-white border-2 ${isSelected ? 'border-indigo-400 bg-indigo-50' : 'border-gray-200'} rounded-lg p-3 hover:shadow-lg transition relative flex flex-col min-h-[220px] overflow-hidden"
               data-client-id="${esc(client.id)}"
               data-category="${esc(client.category)}"
               data-business="${esc(client.businessName.toLowerCase())}"
               data-is-client="${isActualClient}"
               data-is-prospect="${!isActualClient}">

            ${isActualClient ? '<div class="absolute top-0 left-0 right-0 h-1.5 bg-gradient-to-r from-green-500 to-emerald-400"></div>' : (isPipelineProspect ? '<div class="absolute top-0 left-0 right-0 h-1.5 bg-gradient-to-r from-blue-500 to-indigo-400"></div>' : '')}

            <!-- Checkbox in top-left corner -->
            <div class="absolute top-2 left-2 z-10">
              <input
                type="checkbox"
                class="client-checkbox h-5 w-5 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer"
                data-client-id="${esc(client.id)}"
                ${isSelected ? 'checked' : ''}
              />
            </div>

            <!-- Revenue/Status Badge in top-right corner -->
            <div class="absolute top-2 right-2 text-right pointer-events-none z-10">
              ${isActualClient ? `
                ${totalSpent > 0 ? `
                  <div class="text-sm font-semibold text-green-600">${formatCurrency(totalSpent)}</div>
                  <div class="text-xs text-gray-500">${(client.lifetime?.cardsBought) || 0} card${(client.lifetime?.cardsBought) === 1 ? '' : 's'}</div>
                ` : `
                  <span class="text-xs px-2 py-1 bg-green-100 text-green-700 rounded-md font-medium">Client</span>
                  ${monthlyPrice > 0 ? `<div class="text-xs text-green-600 mt-1">${formatCurrency(monthlyPrice)}/mo</div>` : ''}
                `}
              ` : (isPipelineProspect ? `
                <span class="text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded-md font-medium">Pipeline</span>
              ` : `
                <span class="text-xs px-2 py-1 bg-gray-100 text-gray-600 rounded-md font-medium">Prospect</span>
              `)}
            </div>

            <!-- Main content (clickable to open modal) -->
            <div class="client-card-body cursor-pointer pt-6 pb-2 flex-1" data-client-id="${esc(client.id)}">
              <!-- Business Name (larger, more prominent) -->
              <h5 class="font-bold text-base text-gray-900 mb-2 pr-16 leading-tight">${esc(client.businessName)}</h5>

              <!-- Category with badge styling -->
              <div class="flex items-center gap-2 mb-2 flex-wrap">
                ${client.category ? `<span class="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded-md font-medium">üè¢ ${esc(client.category)}</span>` : '<span class="text-xs bg-gray-100 text-gray-500 px-2 py-1 rounded-md">Uncategorized</span>'}
                ${client.status === 'paused' ? '<span class="text-xs bg-yellow-100 text-yellow-700 px-2 py-1 rounded-md font-medium">‚è∏Ô∏è Paused</span>' : ''}
                ${client.status === 'inactive' ? '<span class="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded-md font-medium">‚ùå Inactive</span>' : ''}
              </div>

              <!-- Owner name (if available from enrichment) -->
              ${client.ownerName ? `<div class="text-xs text-gray-600 mb-1">üë§ Owner: ${esc(client.ownerName)}</div>` : ''}

              <!-- Rating and Review Count (if available) -->
              ${client.rating || client.reviewCount ? `
                <div class="flex items-center gap-2 mb-2 text-xs text-gray-700">
                  ${client.rating ? `<span class="font-semibold">‚≠ê ${client.rating}</span>` : ''}
                  ${client.reviewCount ? `<span class="text-gray-500">(${client.reviewCount.toLocaleString()} reviews)</span>` : ''}
                  ${client.priceLevel && client.priceLevel > 0 ? `<span class="text-green-600 font-bold">${'$'.repeat(client.priceLevel)}</span>` : ''}
                </div>
              ` : ''}

              <!-- Business Description (if available) -->
              ${client.description ? `<p class="text-xs text-gray-600 italic mb-2">"${esc(client.description.substring(0, 60))}${client.description.length > 60 ? '...' : ''}"</p>` : ''}

              <!-- Contact Info Section -->
              <div class="space-y-1 mb-2">
                ${client.contact.firstName ? `<div class="text-sm text-gray-700 font-medium">üë§ ${esc(client.contact.firstName)}${client.contact.name && client.contact.name !== client.contact.firstName ? ` (${esc(client.contact.name)})` : ''}</div>` : (client.contact.name ? `<div class="text-sm text-gray-600">üë§ ${esc(client.contact.name)}</div>` : '')}
                ${hasPhone ? `<div class="text-xs text-gray-600 flex items-center gap-2">
                  <a href="tel:${esc(client.contact.phone)}" onclick="event.stopPropagation()" class="hover:scale-110 transition-transform" title="Call ${esc(client.contact.phone)}">üìû</a>
                  <button onclick="event.stopPropagation(); textClientViaGoogleVoice('${esc(client.contact.phone)}', '${esc(client.businessName)}')" class="hover:scale-110 transition-transform" title="Text via Google Voice">üí¨</button>
                  <span>${esc(client.contact.phone)}</span>
                </div>` : ''}
                ${hasEmail ? `<div class="text-xs text-gray-600 truncate">‚úâÔ∏è ${esc(client.contact.email)}</div>` : ''}
              </div>

              <!-- Social Media Icons (if available) -->
              ${(() => {
                const socialIcons = [];
                if (client.website) socialIcons.push(`<a href="${esc(ensureHttps(client.website))}" onclick="event.stopPropagation()" target="_blank" class="text-base hover:scale-125 transition-transform" title="üåê ${esc(client.website)}">üåê</a>`);
                if (client.instagram) socialIcons.push(`<a href="${esc(ensureHttps(client.instagram))}" onclick="event.stopPropagation()" target="_blank" class="text-base hover:scale-125 transition-transform" title="üì∑ ${esc(client.instagram)}">üì∑</a>`);
                if (client.facebook) socialIcons.push(`<a href="${esc(ensureHttps(client.facebook))}" onclick="event.stopPropagation()" target="_blank" class="text-base hover:scale-125 transition-transform" title="üìò ${esc(client.facebook)}">üìò</a>`);
                if (client.linkedin) socialIcons.push(`<a href="${esc(ensureHttps(client.linkedin))}" onclick="event.stopPropagation()" target="_blank" class="text-base hover:scale-125 transition-transform" title="üíº ${esc(client.linkedin)}">üíº</a>`);
                if (client.twitter) socialIcons.push(`<a href="${esc(ensureHttps(client.twitter))}" onclick="event.stopPropagation()" target="_blank" class="text-base hover:scale-125 transition-transform" title="üê¶ ${esc(client.twitter)}">üê¶</a>`);
                return socialIcons.length > 0 ? `
                  <div class="flex gap-2 items-center py-1 mb-2 border-t border-gray-200 pt-2">
                    ${socialIcons.join('')}
                  </div>
                ` : '';
              })()}

              <!-- Monthly Price (more prominent if set) -->
              ${client.monthlyPrice ? `<div class="text-sm font-bold text-green-600 bg-green-50 px-2 py-1 rounded-md inline-block mb-2">üí∞ ${formatCurrency(client.monthlyPrice)}/month</div>` : ''}

              <!-- Last purchase info -->
              ${lastPurchase ? `
                <div class="mt-2 pt-2 border-t border-gray-200">
                  <div class="text-xs text-gray-500">Last campaign:</div>
                  <div class="text-xs text-gray-700 font-medium">${esc(lastPurchase.campaign)}</div>
                </div>
              ` : ''}
            </div>

            <!-- Action button - always at bottom -->
            <div class="mt-auto pt-2 border-t">
              <button class="client-move-btn w-full px-3 py-1.5 bg-purple-600 text-white rounded-md hover:bg-purple-700 font-semibold text-xs"
                      data-client-id="${esc(client.id)}">
                üì§ Move to Pipeline
              </button>
            </div>
          </div>
        `;
      }).join('')}
    </div>
  `;

  // Add event delegation after DOM is ready
  setTimeout(() => {
    const gridElement = document.getElementById('clientListGrid');
    if (!gridElement) return;

    // Use a single click handler for everything
    gridElement.onclick = (e) => {
      // Handle checkbox clicks
      if (e.target.classList.contains('client-checkbox')) {
        e.stopPropagation();
        const clientId = e.target.getAttribute('data-client-id');
        if (clientId) {
          toggleClientSelection(clientId);
        }
        return;
      }

      // Handle button clicks
      if (e.target.classList.contains('client-move-btn') || e.target.closest('.client-move-btn')) {
        e.stopPropagation();
        const btn = e.target.classList.contains('client-move-btn') ? e.target : e.target.closest('.client-move-btn');
        const clientId = btn.getAttribute('data-client-id');
        if (clientId) {
          moveClientToKanban(clientId);
        }
        return;
      }

      // Handle card body clicks (open CRM contact card)
      const cardBody = e.target.closest('.client-card-body');
      if (cardBody) {
        const clientId = cardBody.getAttribute('data-client-id');
        if (clientId) {
          openClientCrmCard(clientId);
        }
      }
    };
  }, 10);

  updateClientBulkSendSection();
}

function toggleClientSelection(clientId) {
  if (clientSelectionState.selectedIds.has(clientId)) {
    clientSelectionState.selectedIds.delete(clientId);
  } else {
    clientSelectionState.selectedIds.add(clientId);
  }

  // Update the checkbox visual state and card styling without full re-render
  const checkbox = document.querySelector(`.client-checkbox[data-client-id="${clientId}"]`);
  const card = document.querySelector(`.client-row[data-client-id="${clientId}"]`);

  if (checkbox) {
    checkbox.checked = clientSelectionState.selectedIds.has(clientId);
  }

  if (card) {
    if (clientSelectionState.selectedIds.has(clientId)) {
      card.classList.remove('border-gray-200');
      card.classList.add('border-indigo-400', 'bg-indigo-50');
    } else {
      card.classList.remove('border-indigo-400', 'bg-indigo-50');
      card.classList.add('border-gray-200');
    }
  }

  updateClientBulkSendSection();
}

function selectAllClients() {
  // Look in the grid container, not the parent container
  const visibleClients = Array.from(document.querySelectorAll('#clientListGrid .client-row'))
    .filter(el => el.style.display !== 'none')
    .map(el => el.dataset.clientId);

  visibleClients.forEach(id => {
    clientSelectionState.selectedIds.add(id);

    // Update checkbox and card styling
    const checkbox = document.querySelector(`.client-checkbox[data-client-id="${id}"]`);
    const card = document.querySelector(`.client-row[data-client-id="${id}"]`);

    if (checkbox) {
      checkbox.checked = true;
    }

    if (card) {
      card.classList.remove('border-gray-200');
      card.classList.add('border-indigo-400', 'bg-indigo-50');
    }
  });

  updateClientBulkSendSection();
}

function clearClientSelection() {
  // Update all checkboxes and cards before clearing
  clientSelectionState.selectedIds.forEach(id => {
    const checkbox = document.querySelector(`.client-checkbox[data-client-id="${id}"]`);
    const card = document.querySelector(`.client-row[data-client-id="${id}"]`);

    if (checkbox) {
      checkbox.checked = false;
    }

    if (card) {
      card.classList.remove('border-indigo-400', 'bg-indigo-50');
      card.classList.add('border-gray-200');
    }
  });

  clientSelectionState.selectedIds.clear();
  updateClientBulkSendSection();
}

// Select only Active clients (for renewal reminders)
function selectActiveClientsForRenewal() {
  clearClientSelection();

  const currentMonth = new Date().getMonth(); // 0-11 (Jan = 0, Dec = 11)

  // Get all visible clients
  const visibleClients = Array.from(document.querySelectorAll('#clientListGrid .client-row'))
    .filter(el => el.style.display !== 'none')
    .map(el => el.dataset.clientId);

  let selectedCount = 0;

  visibleClients.forEach(id => {
    const client = crmState.clients[id];
    if (!client) return;

    // Only select Active clients AND check if they're active this month
    const isActiveStatus = client.status === 'active' || !client.status; // Default to active if no status
    const hasContract = client.contract && client.contract.enabled;
    const isActiveThisMonth = client.activeMonths ? client.activeMonths[currentMonth] : true;

    if (isActiveStatus && !hasContract && isActiveThisMonth) {
      clientSelectionState.selectedIds.add(id);

      // Update checkbox and card styling
      const checkbox = document.querySelector(`.client-checkbox[data-client-id="${id}"]`);
      const card = document.querySelector(`.client-row[data-client-id="${id}"]`);

      if (checkbox) checkbox.checked = true;
      if (card) {
        card.classList.remove('border-gray-200');
        card.classList.add('border-indigo-400', 'bg-indigo-50');
      }

      selectedCount++;
    }
  });

  updateClientBulkSendSection();
  toast(`Selected ${selectedCount} active client(s) for renewal reminder`, true);
}

// Select only Paused/Inactive clients (for reactivation)
function selectInactiveClientsForReactivation() {
  clearClientSelection();

  // Get all visible clients
  const visibleClients = Array.from(document.querySelectorAll('#clientListGrid .client-row'))
    .filter(el => el.style.display !== 'none')
    .map(el => el.dataset.clientId);

  let selectedCount = 0;

  visibleClients.forEach(id => {
    const client = crmState.clients[id];
    if (!client) return;

    // Only select Paused or Inactive clients
    if (client.status === 'paused' || client.status === 'inactive') {
      clientSelectionState.selectedIds.add(id);

      // Update checkbox and card styling
      const checkbox = document.querySelector(`.client-checkbox[data-client-id="${id}"]`);
      const card = document.querySelector(`.client-row[data-client-id="${id}"]`);

      if (checkbox) checkbox.checked = true;
      if (card) {
        card.classList.remove('border-gray-200');
        card.classList.add('border-indigo-400', 'bg-indigo-50');
      }

      selectedCount++;
    }
  });

  updateClientBulkSendSection();
  toast(`Selected ${selectedCount} paused/inactive client(s) for reactivation`, true);
}

function updateClientBulkSendSection() {
  const section = document.getElementById('clientBulkSendSection');
  const countSpan = document.getElementById('clientSelectedCount');
  const selectedCount = clientSelectionState.selectedIds.size;

  if (countSpan) {
    countSpan.textContent = selectedCount;
  }

  if (section) {
    if (selectedCount > 0) {
      section.classList.remove('hidden');
      // Populate template selector if not already done
      populateClientBulkSendTemplates();
    } else {
      section.classList.add('hidden');
    }
  }
}

function populateClientBulkSendTemplates() {
  const selector = document.getElementById('clientBulkSendTemplateSelector');
  if (!selector) return;

  const templates = Object.values(userTemplatesState.templates || {});

  // Only populate if empty
  if (selector.options.length <= 1) {
    selector.innerHTML = '<option value="">‚Äî Choose a template ‚Äî</option>' +
      templates.map(t => `<option value="${t.id}">[${t.type.toUpperCase()}] ${t.name}</option>`).join('');
  }

  // Add event listener for template preview
  selector.onchange = function() {
    const previewDiv = document.getElementById('clientBulkSendPreview');
    const previewText = document.getElementById('clientBulkSendPreviewText');

    if (this.value && previewDiv && previewText) {
      const template = userTemplatesState.templates[this.value];
      if (template) {
        previewText.textContent = template.body;
        previewDiv.classList.remove('hidden');
      } else {
        previewDiv.classList.add('hidden');
      }
    } else if (previewDiv) {
      previewDiv.classList.add('hidden');
    }
  };
}

function clientBulkSendSMS() {
  const templateSelector = document.getElementById('clientBulkSendTemplateSelector');
  if (!templateSelector || !templateSelector.value) {
    toast('‚ö†Ô∏è Please select a template first', false);
    return;
  }

  const templateId = templateSelector.value;
  const template = userTemplatesState.templates[templateId];

  if (!template) {
    toast('‚ö†Ô∏è Template not found', false);
    return;
  }

  if (template.type !== 'sms') {
    toast('‚ö†Ô∏è Please select an SMS template', false);
    return;
  }

  const selectedCount = clientSelectionState.selectedIds.size;

  if (confirm(`Send SMS to ${selectedCount} selected client${selectedCount > 1 ? 's' : ''}?\n\nThis will open your SMS app for each contact.`)) {
    let successCount = 0;

    clientSelectionState.selectedIds.forEach(clientId => {
      const client = crmState.clients[clientId];
      if (client && client.contact && client.contact.phone) {
        // Fill template variables
        const data = {
          businessName: client.businessName,
          contactName: client.contact.name || client.businessName,
          firstName: client.contact?.firstName || '',
          phone: client.contact.phone,
          email: client.contact.email || '',
          town: client.address?.city || '',
          zipCode: client.address?.zipCode || '',
          monthlyPrice: client.monthlyPrice ? `$${client.monthlyPrice}` : ''
        };
        const filled = fillTemplateVariables(template, data);
        const message = filled.body;

        // Copy message and open Google Voice
        const cleanPhone = client.contact.phone.replace(/\D/g, '');
        navigator.clipboard.writeText(message).catch(() => {});
        window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
        successCount++;
      }
    });

    // Track template usage
    if (template) {
      template.lastUsed = new Date().toISOString();
      template.usageCount = (template.usageCount || 0) + selectedCount;
      saveUserTemplates();
    }

    toast(`üìã Message copied! Opened Google Voice for ${successCount} client${successCount > 1 ? 's' : ''}`, true);

    // Clear selections
    clearClientSelection();
  }
}

// State for sequential email sending
let clientBulkEmailQueue = [];
let clientBulkEmailCurrentIndex = 0;
let clientBulkEmailTemplate = null;

function clientBulkSendEmail() {
  const templateSelector = document.getElementById('clientBulkSendTemplateSelector');
  if (!templateSelector || !templateSelector.value) {
    toast('‚ö†Ô∏è Please select a template first', false);
    return;
  }

  const templateId = templateSelector.value;
  const template = userTemplatesState.templates[templateId];

  if (!template) {
    toast('‚ö†Ô∏è Template not found', false);
    return;
  }

  if (template.type !== 'email') {
    toast('‚ö†Ô∏è Please select an Email template', false);
    return;
  }

  // Collect all clients with emails
  const clientsWithEmails = [];
  clientSelectionState.selectedIds.forEach(clientId => {
    const client = crmState.clients[clientId];
    if (client && client.contact && client.contact.email) {
      clientsWithEmails.push(client);
    }
  });

  if (clientsWithEmails.length === 0) {
    toast('‚ö†Ô∏è No clients with email addresses selected', false);
    return;
  }

  if (confirm(`Send personalized emails to ${clientsWithEmails.length} client${clientsWithEmails.length > 1 ? 's' : ''}?\n\nYou'll click through each email one at a time.`)) {
    // Initialize queue
    clientBulkEmailQueue = clientsWithEmails;
    clientBulkEmailCurrentIndex = 0;
    clientBulkEmailTemplate = template;

    // Track template usage
    template.lastUsed = new Date().toISOString();
    template.usageCount = (template.usageCount || 0) + clientsWithEmails.length;
    saveUserTemplates();

    // Open first email
    openNextClientEmail();
  }
}

function openNextClientEmail() {
  if (clientBulkEmailCurrentIndex >= clientBulkEmailQueue.length) {
    // Done!
    toast(`‚úÖ Completed ${clientBulkEmailQueue.length} personalized email${clientBulkEmailQueue.length > 1 ? 's' : ''}`, true);
    clientBulkEmailQueue = [];
    clientBulkEmailCurrentIndex = 0;
    clientBulkEmailTemplate = null;
    clearClientSelection();
    return;
  }

  const client = clientBulkEmailQueue[clientBulkEmailCurrentIndex];
  const template = clientBulkEmailTemplate;

  // Fill template variables with this client's data
  const data = {
    businessName: client.businessName,
    contactName: client.contact?.name || client.businessName,
    firstName: client.contact?.firstName || '',
    phone: client.contact?.phone || '',
    email: client.contact?.email || '',
    town: client.address?.city || '',
    zipCode: client.address?.zipCode || '',
    monthlyPrice: client.monthlyPrice ? `$${client.monthlyPrice}` : ''
  };

  const filled = fillTemplateVariables(template, data);
  const subject = filled.subject;
  const body = filled.body;

  // Open mailto link
  window.open(`mailto:${client.contact.email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`, '_blank');

  clientBulkEmailCurrentIndex++;

  // Show progress and next button
  const remaining = clientBulkEmailQueue.length - clientBulkEmailCurrentIndex;
  if (remaining > 0) {
    setTimeout(() => {
      if (confirm(`Email ${clientBulkEmailCurrentIndex} of ${clientBulkEmailQueue.length} opened for ${client.businessName}.\n\n${remaining} more to go. Continue to next email?`)) {
        openNextClientEmail();
      } else {
        toast(`‚ö†Ô∏è Stopped at ${clientBulkEmailCurrentIndex} of ${clientBulkEmailQueue.length}`, false);
        clientBulkEmailQueue = [];
        clientBulkEmailCurrentIndex = 0;
        clientBulkEmailTemplate = null;
      }
    }, 500);
  } else {
    // Last one
    setTimeout(() => {
      toast(`‚úÖ Completed all ${clientBulkEmailQueue.length} personalized email${clientBulkEmailQueue.length > 1 ? 's' : ''}!`, true);
      clientBulkEmailQueue = [];
      clientBulkEmailCurrentIndex = 0;
      clientBulkEmailTemplate = null;
      clearClientSelection();
    }, 500);
  }
}

function clientBulkSendGoogleVoice() {
  const templateSelector = document.getElementById('clientBulkSendTemplateSelector');
  if (!templateSelector || !templateSelector.value) {
    toast('‚ö†Ô∏è Please select a template first', false);
    return;
  }

  const templateId = templateSelector.value;
  const template = userTemplatesState.templates[templateId];

  if (!template) {
    toast('‚ö†Ô∏è Template not found', false);
    return;
  }

  if (template.type !== 'sms') {
    toast('‚ö†Ô∏è Please select an SMS template (Google Voice uses SMS format)', false);
    return;
  }

  const selectedCount = clientSelectionState.selectedIds.size;

  if (confirm(`Send via Google Voice to ${selectedCount} selected client${selectedCount > 1 ? 's' : ''}?\n\nThis will:\n1. Copy the message to your clipboard\n2. Open Google Voice for each contact\n3. You can paste (Ctrl+V) the message and send`)) {
    let successCount = 0;

    clientSelectionState.selectedIds.forEach(clientId => {
      const client = crmState.clients[clientId];
      if (client && client.contact && client.contact.phone) {
        // Fill template variables
        const data = {
          businessName: client.businessName,
          contactName: client.contact.name || client.businessName,
          firstName: client.contact?.firstName || '',
          phone: client.contact.phone,
          email: client.contact.email || '',
          town: client.address?.city || '',
          zipCode: client.address?.zipCode || '',
          monthlyPrice: client.monthlyPrice ? `$${client.monthlyPrice}` : ''
        };
        const filled = fillTemplateVariables(template, data);
        const message = filled.body;

        const cleanPhone = client.contact.phone.replace(/\D/g, '');
        const formattedPhone = cleanPhone.length === 10 ? `+1${cleanPhone}` : `+${cleanPhone}`;
        const googleVoiceUrl = `https://voice.google.com/u/0/messages?itemId=${formattedPhone}`;

        navigator.clipboard.writeText(message).then(() => {
          console.log('Message copied to clipboard');
        }).catch(err => {
          console.warn('Could not copy to clipboard:', err);
        });

        window.open(googleVoiceUrl, '_blank');
        successCount++;
      }
    });

    // Track template usage
    if (template) {
      template.lastUsed = new Date().toISOString();
      template.usageCount = (template.usageCount || 0) + selectedCount;
      saveUserTemplates();
    }

    toast(`‚úÖ Message copied! Opened Google Voice for ${successCount} client${successCount > 1 ? 's' : ''}. Paste with Ctrl+V`, true);

    // Clear selections
    clearClientSelection();
  }
}

// Business type filter state
let businessTypeFilter = 'all'; // 'all', 'prospects', 'clients'

function setBusinessTypeFilter(type) {
  businessTypeFilter = type;

  // Update button states
  document.getElementById('filterAll').className = type === 'all'
    ? 'px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium transition-colors'
    : 'px-4 py-2 bg-gray-100 text-gray-700 rounded-lg text-sm font-medium hover:bg-gray-200 transition-colors';
  document.getElementById('filterProspects').className = type === 'prospects'
    ? 'px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium transition-colors'
    : 'px-4 py-2 bg-gray-100 text-gray-700 rounded-lg text-sm font-medium hover:bg-gray-200 transition-colors';
  document.getElementById('filterClients').className = type === 'clients'
    ? 'px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium transition-colors'
    : 'px-4 py-2 bg-gray-100 text-gray-700 rounded-lg text-sm font-medium hover:bg-gray-200 transition-colors';

  filterClients();
}

function filterClients() {
  const searchTerm = document.getElementById('clientSearch').value.toLowerCase();
  const categoryFilter = document.getElementById('categoryFilter').value;
  const statusFilter = document.getElementById('statusFilter')?.value || '';

  const clientEls = document.querySelectorAll('#clientList .client-row');

  clientEls.forEach(el => {
    const business = el.dataset.business || '';
    const category = el.dataset.category || '';
    const clientId = el.dataset.clientId;
    const client = crmState.clients[clientId];
    const isClient = el.dataset.isClient === 'true';

    let visible = true;

    // Business type filter
    if (businessTypeFilter === 'clients' && !isClient) visible = false;
    if (businessTypeFilter === 'prospects' && isClient) visible = false;

    if (searchTerm && !business.includes(searchTerm) && !category.toLowerCase().includes(searchTerm)) {
      visible = false;
    }

    if (categoryFilter && category !== categoryFilter) {
      visible = false;
    }

    if (statusFilter && client) {
      const hasActivePurchase = client.history.some(h => h.status === 'Paid in Full');
      const hasPendingPurchase = client.history.some(h => h.status !== 'Paid in Full' && h.status !== 'Available');

      if (statusFilter === 'active' && !hasActivePurchase) visible = false;
      if (statusFilter === 'pending' && !hasPendingPurchase) visible = false;
      if (statusFilter === 'inactive' && (hasActivePurchase || hasPendingPurchase)) visible = false;
    }

    el.style.display = visible ? 'block' : 'none';
  });
}

/* ========= CONTRACT MANAGEMENT ========= */
function toggleContractFields() {
  const enabled = document.getElementById('hasContract').checked;
  document.getElementById('contractFields').classList.toggle('hidden', !enabled);
  if (enabled) {
    // Set default start date to today if empty
    if (!document.getElementById('contractStartDate').value) {
      const today = new Date().toISOString().split('T')[0];
      document.getElementById('contractStartDate').value = today;
      calculateContractEnd();
    }
  }
}

function calculateContractEnd() {
  const startDate = document.getElementById('contractStartDate').value;
  const length = parseInt(document.getElementById('contractLength').value);

  if (!startDate) {
    document.getElementById('contractEndDate').textContent = '‚Äî';
    return;
  }

  const start = new Date(startDate);
  const end = new Date(start);
  end.setMonth(end.getMonth() + length);

  // Format as readable date
  const options = { year: 'numeric', month: 'long', day: 'numeric' };
  document.getElementById('contractEndDate').textContent = end.toLocaleDateString('en-US', options);

  calculateContractTotal();
}

function calculateContractTotal() {
  const monthlyRate = parseFloat(document.getElementById('contractMonthlyRate').value) || 0;
  const length = parseInt(document.getElementById('contractLength').value);
  const total = monthlyRate * length;

  document.getElementById('contractTotalValue').textContent = formatCurrency(total);
}

// Quick action popup for pipeline cards - shows Not Interested and Convert to Client at top
function openQuickActionPopup(leadId, columnKey) {
  // Find the prospect in campaign board first
  let prospect = null;
  const result = typeof findProspectInCampaignBoard === 'function' ? findProspectInCampaignBoard(leadId) : null;
  if (result) {
    prospect = result.item;
    columnKey = result.column || columnKey;
  }
  // Fallback: search via getter shim
  if (!prospect) {
    const items = kanbanState.columns[columnKey] || [];
    prospect = items.find(item => typeof item === 'object' && String(item.id) === String(leadId));
  }

  if (!prospect) {
    toast('Prospect not found', false);
    return;
  }

  // Check if this is an existing client
  const existingClient = Object.values(crmState.clients).find(c =>
    c.businessName && prospect.businessName &&
    c.businessName.toLowerCase() === (prospect.businessName || prospect.name || '').toLowerCase()
  );

  if (existingClient) {
    // Open CRM card for existing client
    openClientCrmCard(existingClient.id);
  } else {
    // Open CRM card for prospect - include columnKey for stage display
    const prospectWithStage = { ...prospect, columnKey, stage: columnKey };
    openProspectDetailModal(prospectWithStage, 'prospect');
  }
}


function closeQuickActionPopup() {
  const popup = document.getElementById('quickActionPopup');
  if (popup) popup.remove();
}

// Helper function to open client modal for a prospect (converts prospect data to client format)
function openClientModalForProspect(prospectDataOrId) {
  let prospectData;

  // If passed an ID (string/number), look it up in kanban state or prospect pool
  if (typeof prospectDataOrId === 'string' || typeof prospectDataOrId === 'number') {
    const itemId = String(prospectDataOrId);

    // Search all kanban columns
    for (const column of ['prospect-list', 'to-contact', 'in-progress', 'committed']) {
      const items = kanbanState.columns[column] || [];
      const found = items.find(item => typeof item === 'object' && String(item.id) === itemId);
      if (found) {
        prospectData = found;
        break;
      }
    }

    // Search campaign boards
    if (!prospectData && campaignBoardsState && campaignBoardsState.boards) {
      for (const boardId of Object.keys(campaignBoardsState.boards)) {
        const board = campaignBoardsState.boards[boardId];
        if (board.columns) {
          for (const columnKey of Object.keys(board.columns)) {
            const found = board.columns[columnKey].find(item => String(item.id) === itemId || String(item.placeId) === itemId);
            if (found) {
              prospectData = found;
              break;
            }
          }
        }
        if (prospectData) break;
      }
    }

    // Search prospect pool manual prospects if not found in kanban
    if (!prospectData) {
      prospectData = prospectPoolState.manualProspects.find(p => String(p.id) === itemId);
    }

    // Search rendered prospects lookup (for search results not in manualProspects)
    if (!prospectData && prospectPoolState.renderedProspects) {
      prospectData = prospectPoolState.renderedProspects[itemId];
    }

    // If still not found, show error
    if (!prospectData) {
      console.error('Prospect not found for ID:', itemId);
      toast('Prospect not found', false);
      return;
    }
  } else {
    // Passed the full object
    prospectData = prospectDataOrId;
  }

  // Check if this prospect already exists as a client (by business name)
  const existingClient = Object.values(crmState.clients).find(c =>
    c.businessName && prospectData.businessName &&
    c.businessName.toLowerCase() === prospectData.businessName.toLowerCase()
  );

  if (existingClient) {
    // Open CRM card for existing client
    openClientCrmCard(existingClient.id);
    return;
  }

  // Open CRM card for prospect
  openProspectDetailModal(prospectData, 'prospect');
}

function openClientModal(clientId = null) {
  const modal = document.getElementById('clientModal');
  const title = document.getElementById('clientModalTitle');
  const deleteBtn = document.getElementById('btnDeleteClient');
  const historySection = document.getElementById('clientHistorySection');
  
  lastFocusedElementBeforeModal = document.activeElement;
  
  if (clientId && crmState.clients[clientId]) {
    const client = crmState.clients[clientId];
    title.textContent = 'Edit Client';
    deleteBtn.classList.remove('hidden');
    historySection.classList.remove('hidden');
    
    document.getElementById('clientId').value = client.id;
    document.getElementById('clientBusinessName').value = client.businessName;
    document.getElementById('clientCategory').value = client.category;
    document.getElementById('clientContactName').value = client.contact.name;
    document.getElementById('clientFirstName').value = client.contact.firstName || '';
    document.getElementById('clientPhone').value = client.contact.phone;
    document.getElementById('clientEmail').value = client.contact.email;
    document.getElementById('clientMonthlyPrice').value = client.monthlyPrice || '';
    document.getElementById('clientStatus').value = client.status || 'active';
    document.getElementById('clientNotes').value = client.notes;

    // Load active months
    const activeMonths = client.activeMonths || [true, true, true, true, true, true, true, true, true, true, true, true];
    for (let i = 0; i < 12; i++) {
      document.getElementById(`activeMonth${i}`).checked = activeMonths[i];
    }

    renderClientHistory(client);
    
    document.getElementById('clientLifetimeSpent').textContent = formatCurrency(client.lifetime?.totalSpent || 0);
    document.getElementById('clientCardsBought').textContent = client.lifetime?.cardsBought || 0;
    document.getElementById('clientAvgPrice').textContent = formatCurrency(client.lifetime?.avgPrice || 0);

    // Load contract data
    if (client.contract && client.contract.enabled) {
      document.getElementById('hasContract').checked = true;
      document.getElementById('contractFields').classList.remove('hidden');
      document.getElementById('contractStartDate').value = client.contract.startDate || '';
      document.getElementById('contractLength').value = client.contract.length || 6;
      document.getElementById('contractMonthlyRate').value = client.contract.monthlyRate || '';
      document.getElementById('contractAutoRenew').checked = client.contract.autoRenew || false;
      calculateContractEnd();
    } else {
      document.getElementById('hasContract').checked = false;
      document.getElementById('contractFields').classList.add('hidden');
    }
  } else {
    title.textContent = 'Add New Client';
    deleteBtn.classList.add('hidden');
    historySection.classList.add('hidden');

    document.getElementById('clientId').value = '';
    document.getElementById('clientBusinessName').value = '';
    document.getElementById('clientCategory').value = '';
    document.getElementById('clientContactName').value = '';
    document.getElementById('clientFirstName').value = '';
    document.getElementById('clientPhone').value = '';
    document.getElementById('clientEmail').value = '';
    document.getElementById('clientMonthlyPrice').value = '';
    document.getElementById('clientStatus').value = 'active';
    document.getElementById('clientNotes').value = '';

    // Reset active months (all checked by default)
    for (let i = 0; i < 12; i++) {
      document.getElementById(`activeMonth${i}`).checked = true;
    }

    // Reset contract fields
    document.getElementById('hasContract').checked = false;
    document.getElementById('contractFields').classList.add('hidden');
    document.getElementById('contractStartDate').value = '';
    document.getElementById('contractLength').value = '6';
    document.getElementById('contractMonthlyRate').value = '';
    document.getElementById('contractAutoRenew').checked = false;
    document.getElementById('contractEndDate').textContent = '‚Äî';
    document.getElementById('contractTotalValue').textContent = '$0';
  }
  
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
  document.getElementById('clientBusinessName').focus();
}

function renderClientHistory(client) {
  const container = document.getElementById('clientHistory');
  
  if (client.history.length === 0) {
    container.innerHTML = '<p class="text-sm text-gray-500 text-center py-2">No purchase history yet</p>';
    return;
  }
  
  container.innerHTML = client.history.map(purchase => `
    <div class="flex justify-between items-center p-2 bg-white border rounded">
      <div>
        <div class="font-medium text-sm">${esc(purchase.campaign)}</div>
        <div class="text-xs text-gray-500">Spot ${purchase.spot} ‚Ä¢ ${purchase.status}</div>
      </div>
      <div class="text-right">
        <div class="font-semibold text-green-600">${formatCurrency(purchase.price)}</div>
        <div class="text-xs text-gray-500">${purchase.date || 'N/A'}</div>
      </div>
    </div>
  `).join('');
}

// toggleCustomCategory function removed - categories now come from businessCategories

function closeClientModal() {
  const modal = document.getElementById('clientModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
  if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();
}

function saveClientModal() {
  const businessName = document.getElementById('clientBusinessName').value.trim();

  if (!businessName) {
    toast('Business name is required', false);
    document.getElementById('clientBusinessName').focus();
    return;
  }

  // Get category from dropdown
  const category = document.getElementById('clientCategory').value;

  const clientId = document.getElementById('clientId').value;
  const isNew = !clientId;

  // Collect active months
  const activeMonths = [];
  for (let i = 0; i < 12; i++) {
    activeMonths.push(document.getElementById(`activeMonth${i}`).checked);
  }

  const clientData = {
    id: clientId || undefined,
    businessName,
    category: category,
    contactName: document.getElementById('clientContactName').value,
    firstName: document.getElementById('clientFirstName').value.trim(),
    phone: document.getElementById('clientPhone').value,
    email: document.getElementById('clientEmail').value,
    monthlyPrice: parseFloat(document.getElementById('clientMonthlyPrice').value) || 0,
    status: document.getElementById('clientStatus').value,
    activeMonths: activeMonths,
    notes: document.getElementById('clientNotes').value
  };
  
  let client;
  if (isNew) {
    client = buildClientObject(clientData);
    crmState.clients[client.id] = client;
  } else {
    client = crmState.clients[clientId];
    client.businessName = clientData.businessName;
    client.category = clientData.category;
    client.contact.name = clientData.contactName;
    client.contact.firstName = clientData.firstName;
    client.contact.phone = clientData.phone;
    client.contact.email = clientData.email;
    client.monthlyPrice = clientData.monthlyPrice;
    client.status = clientData.status;
    client.activeMonths = clientData.activeMonths;
    client.notes = clientData.notes;
  }

  // Save contract data
  const hasContract = document.getElementById('hasContract').checked;
  if (hasContract) {
    const startDate = document.getElementById('contractStartDate').value;
    const length = parseInt(document.getElementById('contractLength').value);
    const monthlyRate = parseFloat(document.getElementById('contractMonthlyRate').value) || 0;
    const autoRenew = document.getElementById('contractAutoRenew').checked;

    // Calculate end date
    let endDate = null;
    if (startDate) {
      const start = new Date(startDate);
      const end = new Date(start);
      end.setMonth(end.getMonth() + length);
      endDate = end.toISOString().split('T')[0];
    }

    client.contract = {
      enabled: true,
      startDate: startDate,
      length: length,
      monthlyRate: monthlyRate,
      totalValue: monthlyRate * length,
      endDate: endDate,
      autoRenew: autoRenew
    };
  } else {
    client.contract = {
      enabled: false,
      startDate: null,
      length: 6,
      monthlyRate: 0,
      totalValue: 0,
      endDate: null,
      autoRenew: false
    };
  }

  saveClients();

  // Also update Campaign Board entries with matching business name
  syncClientToCampaignBoard(client);

  renderClientList();
  closeClientModal();
  toast(isNew ? 'Client added' : 'Client updated');
}

// Sync client data to Campaign Board entries with matching business name
async function syncClientToCampaignBoard(client) {
  if (!client || !client.businessName) return;

  const clientNameLower = client.businessName.toLowerCase();
  let updated = false;

  // Search all campaign boards
  for (const [mailerId, board] of Object.entries(campaignBoardsState.boards)) {
    const columnKeys = ['queued', 'attempting', 'negotiating', 'invoice-sent', 'proof-approved', 'paid-in-full'];

    for (const colKey of columnKeys) {
      const items = board.columns[colKey] || [];
      for (const item of items) {
        const itemName = (item.businessName || item.name || '').toLowerCase();
        if (itemName === clientNameLower) {
          // Update the Campaign Board item with client data
          if (client.contact?.phone) item.phone = client.contact.phone;
          if (client.contact?.email) item.email = client.contact.email;
          if (client.category) item.category = client.category;
          if (client.contact?.name) item.contactName = client.contact.name;
          if (client.contact?.firstName) item.firstName = client.contact.firstName;
          updated = true;
          console.log(`‚úÖ Synced client "${client.businessName}" to Campaign Board (${colKey})`);
        }
      }
    }
  }

  if (updated) {
    await saveCampaignBoards();
    // Re-render if viewing Campaign Board
    if (!campaignBoardsState.useLegacyKanban) {
      renderCampaignBoard();
    }
  }
}

function deleteClientModal() {
  const clientId = document.getElementById('clientId').value;
  if (!clientId) return;

  const client = crmState.clients[clientId];
  if (!client) return;

  const historyCount = client.history?.length || 0;
  const confirmMsg = `Are you sure you want to delete "${client.businessName}"?\n\n` +
    `This client has ${historyCount} purchase ${historyCount === 1 ? 'record' : 'records'}.\n\n` +
    `This action cannot be undone.`;

  if (confirm(confirmMsg)) {
    delete crmState.clients[clientId];
    saveClients();
    renderClientList();
    closeClientModal();
    toast('Client deleted');
  }
}

function linkClientToSpot(clientId, spotNum, campaign, price, status) {
  const client = crmState.clients[clientId];
  if (!client) return;
  
  const purchase = {
    campaign: campaign,
    spot: spotNum,
    price: price,
    status: status,
    date: new Date().toISOString().split('T')[0]
  };
  
  client.history.push(purchase);

  // Ensure lifetime object exists
  if (!client.lifetime) {
    client.lifetime = { cardsBought: 0, totalSpent: 0, avgPrice: 0 };
  }
  client.lifetime.cardsBought = client.history.length;
  client.lifetime.totalSpent = client.history.reduce((sum, p) => sum + (p.price || 0), 0);
  client.lifetime.avgPrice = client.lifetime.cardsBought > 0 ? client.lifetime.totalSpent / client.lifetime.cardsBought : 0;
  
  saveClients();
}

function populateClientDropdown() {
  const select = document.getElementById('editClient');
  if (!select) return;

  const clients = Object.values(crmState.clients).sort((a, b) =>
    a.businessName.localeCompare(b.businessName)
  );

  select.innerHTML = '<option value="">‚Äî Select existing client ‚Äî</option>' +
    clients.map(c => `<option value="${c.id}">${esc(c.businessName)} (${esc(c.category)})</option>`).join('');

  // Auto-fill business name when client is selected
  select.onchange = function() {
    const clientId = this.value;
    if (clientId && crmState.clients[clientId]) {
      document.getElementById('editName').value = crmState.clients[clientId].businessName;
    }
  };
}

function quickAddClient() {
  const businessName = document.getElementById('editName').value.trim();
  openClientModal();
  if (businessName) {
    document.getElementById('clientBusinessName').value = businessName;
  }
}

/* ========= EXPORT/IMPORT FUNCTIONS ========= */

function exportClientsCSV() {
  const clients = Object.values(crmState.clients);

  const headers = ['Business Name', 'Category', 'Contact Name', 'First Name', 'Phone', 'Email', 'Monthly Price', 'Lifetime Spent', 'Cards Bought', 'Notes'];

  let rows = [];
  if (clients.length === 0) {
    // Export template with example row
    rows = [['Example Business', 'Restaurant', 'John Smith', 'John', '555-123-4567', 'john@example.com', '150', '0', '0', 'Delete this example row']];
  } else {
    rows = clients.map(c => [
      c.businessName || '',
      c.category || '',
      c.contact?.name || '',
      c.contact?.firstName || '',
      c.contact?.phone || '',
      c.contact?.email || '',
      c.monthlyPrice || 0,
      c.lifetime?.totalSpent || 0,
      c.lifetime?.cardsBought || 0,
      c.notes || ''
    ]);
  }

  let csv = headers.join(',') + '\n';
  rows.forEach(row => {
    csv += row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',') + '\n';
  });

  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `clients-${new Date().toISOString().split('T')[0]}.csv`;
  a.click();
  URL.revokeObjectURL(url);

  toast(clients.length === 0 ? 'Template exported - add your clients and import' : 'Clients exported to CSV');
}

function importClientsCSV(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const csv = e.target.result;
      const lines = csv.split('\n').filter(line => line.trim());

      if (lines.length < 2) {
        toast('CSV file is empty or invalid', false);
        return;
      }

      // Parse CSV
      const parseCsvLine = (line) => {
        const result = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            result.push(current);
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current);
        return result;
      };

      // Parse header
      const headers = parseCsvLine(lines[0]).map(h => h.trim().toLowerCase());

      // Validate headers
      const requiredHeaders = ['business name', 'category', 'contact name', 'phone', 'email'];
      const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
      if (missingHeaders.length > 0) {
        toast(`CSV missing required columns: ${missingHeaders.join(', ')}`, false);
        return;
      }

      // Parse data rows
      const imported = [];
      const errors = [];

      for (let i = 1; i < lines.length; i++) {
        const values = parseCsvLine(lines[i]);
        if (values.length !== headers.length) continue;

        const row = {};
        headers.forEach((header, idx) => {
          row[header] = values[idx];
        });

        // Validate required fields
        if (!row['business name'] || !row['business name'].trim()) {
          errors.push(`Row ${i + 1}: Missing business name`);
          continue;
        }

        // Create or update client object
        const businessName = row['business name'].trim();

        // Check if client already exists (by business name)
        let existingClient = Object.values(crmState.clients).find(
          c => c.businessName.toLowerCase() === businessName.toLowerCase()
        );

        const clientId = existingClient ? existingClient.id : Date.now() + i;

        const client = {
          id: clientId,
          businessName: businessName,
          category: row['category'] || '',
          contact: {
            name: row['contact name'] || '',
            firstName: row['first name'] || '',
            phone: row['phone'] || '',
            email: row['email'] || ''
          },
          monthlyPrice: parseFloat(row['monthly price']) || 0,
          lifetime: {
            totalSpent: parseFloat(row['lifetime spent']) || 0,
            cardsBought: parseInt(row['cards bought']) || 0
          },
          notes: row['notes'] || '',
          contracts: existingClient ? existingClient.contracts : [],
          history: existingClient ? existingClient.history : []
        };

        crmState.clients[clientId] = client;
        imported.push(businessName);
      }

      // Save and re-render
      saveClients();
      renderClientList();

      // Reset file input
      event.target.value = '';

      // Show results
      if (imported.length > 0) {
        toast(`Successfully imported ${imported.length} client${imported.length === 1 ? '' : 's'}`, true);
      }
      if (errors.length > 0) {
        console.warn('Import errors:', errors);
        toast(`Imported with ${errors.length} error${errors.length === 1 ? '' : 's'} (check console)`, false);
      }

    } catch (err) {
      console.error('CSV import error:', err);
      toast('Failed to import CSV. Please check the file format.', false);
    }
  };

  reader.onerror = () => {
    toast('Failed to read CSV file', false);
  };

  reader.readAsText(file);
}

function syncClientsToSheets() {
  // Google Sheets sync deprecated - now using Supabase cloud storage
  toast('Clients are now automatically synced to Supabase', true);
  return;
}


/* ========= EMAIL FUNCTIONS ========= */

const emailTemplates = {
  invoice: {
    subject: 'Invoice Reminder - {businessName}',
    body: 'Hi {contactName},\n\nThis is a friendly reminder that your invoice for {campaign} is still pending.\n\nAmount Due: {amount}\n\nPlease let me know if you have any questions.\n\nBest regards'
  },
  proof: {
    subject: 'Your Ad Proof is Ready - {businessName}',
    body: 'Hi {contactName},\n\nGreat news! Your ad proof for {campaign} is ready for review.\n\nPlease review and let me know if you\'d like any changes.\n\nBest regards'
  },
  renewal: {
    subject: 'Time to Renew - {businessName}',
    body: 'Hi {contactName},\n\nI hope your campaign with us has been successful!\n\nWe\'re preparing our next mailing and would love to have you on board again.\n\nWould you like to renew your spot?\n\nBest regards'
  },
  thankyou: {
    subject: 'Thank You - {businessName}',
    body: 'Hi {contactName},\n\nThank you for advertising with us on {campaign}!\n\nWe appreciate your business and look forward to working with you again.\n\nBest regards'
  }
};

function openEmailModal() {
  const modal = document.getElementById('emailModal');
  lastFocusedElementBeforeModal = document.activeElement;
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
}

function closeEmailModal() {
  const modal = document.getElementById('emailModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
  if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();
}

function loadClientEmailTemplate() {
  const templateKey = document.getElementById('emailTemplate').value;
  if (!templateKey) return;

  const template = emailTemplates[templateKey];
  if (!template) return;
  document.getElementById('emailSubject').value = template.subject;
  document.getElementById('emailBody').value = template.body;
}

function sendEmail() {
  const to = document.getElementById('emailTo').value;
  const subject = document.getElementById('emailSubject').value;
  const body = document.getElementById('emailBody').value;
  
  if (!to || !subject || !body) {
    toast('Please fill in all fields', false);
    return;
  }
  
  // In production, this would call your email API
  const mailtoLink = `mailto:${to}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
  window.location.href = mailtoLink;
  
  toast('Email client opened');
  closeEmailModal();
}

/* ========= REPORTS FUNCTIONS ========= */

function openReportsModal() {
  const modal = document.getElementById('reportsModal');
  lastFocusedElementBeforeModal = document.activeElement;
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
}

function closeReportsModal() {
  const modal = document.getElementById('reportsModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
  if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();
}

function generateProfitLossReport() {
  const output = document.getElementById('reportOutput');
  const content = document.getElementById('reportContent');
  
  let report = '<div class="space-y-4">';
  report += '<h3 class="font-bold text-lg">Profit & Loss Report</h3>';
  
  state.mailers.forEach(campaign => {
    const financials = calculateFinancials(campaign.Mailer_ID, campaign);
    if (!financials) return;

    report += `
      <div class="border-b pb-3">
        <div class="font-semibold">${esc(campaign.Town)} ‚Äî ${esc(campaign.Mail_Date)}</div>
        <div class="grid grid-cols-2 gap-2 mt-2 text-sm">
          <div>Revenue: ${formatCurrency(financials.revenue.current)}</div>
          <div>Expenses: ${formatCurrency(financials.expenses.total)}</div>
          <div class="${financials.profit.current >= 0 ? 'text-green-600' : 'text-red-600'} font-semibold">
            Profit: ${formatCurrency(financials.profit.current)}
          </div>
          <div>Margin: ${financials.profit.margin.toFixed(1)}%</div>
        </div>
      </div>
    `;
  });
  
  report += '</div>';
  content.innerHTML = report;
  output.classList.remove('hidden');
}

function generateClientValueReport() {
  const output = document.getElementById('reportOutput');
  const content = document.getElementById('reportContent');
  
  const clients = Object.values(crmState.clients).sort((a, b) => b.lifetime.totalSpent - a.lifetime.totalSpent);
  
  let report = '<div class="space-y-2">';
  report += '<h3 class="font-bold text-lg mb-3">Client Value Analysis</h3>';
  report += '<div class="grid grid-cols-3 gap-2 font-semibold text-sm border-b pb-2">';
  report += '<div>Client</div><div>Lifetime Value</div><div>Cards Purchased</div>';
  report += '</div>';
  
  clients.forEach(client => {
    report += `
      <div class="grid grid-cols-3 gap-2 text-sm py-1">
        <div>${esc(client.businessName)}</div>
        <div class="text-green-600 font-semibold">${formatCurrency(client.lifetime?.totalSpent || 0)}</div>
        <div>${client.lifetime?.cardsBought || 0}</div>
      </div>
    `;
  });
  
  report += '</div>';
  content.innerHTML = report;
  output.classList.remove('hidden');
}

function generateCampaignReport() {
  toast('Campaign comparison report generated');
  // Implementation similar to P&L
}

function generateSalesFunnelReport() {
  toast('Sales funnel report generated');
  // Implementation with kanban metrics
}

function downloadReport() {
  toast('Report download started');
}

/* ========= API QUOTA & PLACES CACHE FUNCTIONS ========= */

function loadApiQuota() {
  try {
    const saved = safeGetItem('mailslot-api-quota');
    if (saved) {
      const data = JSON.parse(saved);
      const currentMonth = new Date().toISOString().slice(0, 7);

      // Reset if new month
      if (data.currentMonth !== currentMonth) {
        apiQuotaState.currentMonth = currentMonth;
        apiQuotaState.callsThisMonth = 0;
        apiQuotaState.userQuotas = {};
        apiQuotaState.restrictionsActive = false;
        saveApiQuota();
      } else {
        Object.assign(apiQuotaState, data);
      }
    }
  } catch(e) {
    console.error('Error loading API quota:', e);
  }
}

function saveApiQuota() {
  safeSetItem('mailslot-api-quota', JSON.stringify(apiQuotaState));
}

function getApiQuota() {
  return {
    used: apiQuotaState.callsThisMonth,
    total: apiQuotaState.monthlyLimit,
    remaining: apiQuotaState.monthlyLimit - apiQuotaState.callsThisMonth,
    percentUsed: (apiQuotaState.callsThisMonth / apiQuotaState.monthlyLimit) * 100,
    restrictionsActive: apiQuotaState.restrictionsActive
  };
}

async function loadNotInterestedList() {
  try {
    // Try loading from cloud first
    const cloudData = await loadFromCloud('notInterested');

    if (cloudData) {
      notInterestedState.placeIds = new Set(cloudData.placeIds || []);
      notInterestedState.businesses = cloudData.businesses || {};
    } else {
      // Fallback to localStorage
      const saved = localStorage.getItem('mailslot-not-interested');
      if (saved) {
        const data = JSON.parse(saved);
        notInterestedState.placeIds = new Set(data.placeIds || []);
        notInterestedState.businesses = data.businesses || {};
        // Sync to cloud
        const cloudData = {
          placeIds: Array.from(notInterestedState.placeIds),
          businesses: notInterestedState.businesses
        };
        saveToCloud('notInterested', cloudData).catch(e => console.warn('Failed to sync not interested list to cloud:', e));
      }
    }
  } catch(e) {
    console.error('Error loading not interested list:', e);
  }
}

async function saveNotInterestedList() {
  try {
    const data = {
      placeIds: Array.from(notInterestedState.placeIds),
      businesses: notInterestedState.businesses
    };
    await saveToCloud('notInterested', data);
  } catch(e) {
    console.warn('Not interested list saved to localStorage only (cloud sync failed):', e);
  }
}

/* ========= USER TEMPLATES FUNCTIONS ========= */

async function loadUserTemplates() {
  try {
    // Try loading from cloud first
    const cloudData = await loadFromCloud('userTemplates');

    if (cloudData && cloudData.templates) {
      userTemplatesState.templates = cloudData.templates;
      console.log(`‚úÖ Loaded ${Object.keys(cloudData.templates).length} user templates from cloud`);
    } else {
      // Fallback to localStorage
      const saved = safeGetItem('mailslot-user-templates');
      if (saved) {
        const data = JSON.parse(saved);
        userTemplatesState.templates = data.templates || {};
        console.log(`‚úÖ Loaded ${Object.keys(userTemplatesState.templates).length} user templates from localStorage`);
      } else {
        // Initialize with default templates converted from hardcoded ones
        initializeDefaultTemplates();
      }
    }

    // Migrate old templates: remove isDefault flag
    migrateTemplates();

    // Populate bulk send dropdown after templates are loaded
    populateBulkSendTemplates();
  } catch(e) {
    console.error('Error loading user templates:', e);
    // Initialize with defaults on error
    initializeDefaultTemplates();
    // Still try to populate dropdown
    populateBulkSendTemplates();
  }
}

// Migration function to remove isDefault flag from existing templates
function migrateTemplates() {
  let migrated = false;
  Object.keys(userTemplatesState.templates).forEach(templateId => {
    const template = userTemplatesState.templates[templateId];
    if (template.isDefault === true) {
      delete template.isDefault;
      // Ensure usage tracking fields exist
      if (template.usageCount === undefined) template.usageCount = 0;
      if (template.lastUsed === undefined) template.lastUsed = null;
      migrated = true;
    }
  });

  if (migrated) {
    console.log('üîÑ Migrated templates: removed isDefault flags');
    saveUserTemplates();
  }
}

function initializeDefaultTemplates() {
  // Initialize default user templates
  const defaultTemplates = {
    'default_messenger': {
      id: 'default_messenger',
      name: 'Facebook Messenger - First Contact',
      category: 'prospect',
      type: 'messenger',
      subject: '',
      body: `Hi there!

I noticed {businessName} and wanted to reach out about a local advertising opportunity.

We help local businesses like yours reach thousands of households in {town} through our shared mailer program. Your business would be featured alongside other quality local services.

Would you be open to a quick chat about how this could work for you?

Looking forward to hearing from you!

Best regards,
{yourName}
{yourPhone}`,
      variables: ['businessName', 'town', 'yourName', 'yourPhone'],
      createdAt: new Date().toISOString(),
      usageCount: 0,
      lastUsed: null
    },
    'default_email_prospect': {
      id: 'default_email_prospect',
      name: 'Email - First Contact',
      category: 'prospect',
      type: 'email',
      subject: 'Local Advertising Opportunity for {businessName}',
      body: `Hi,

I hope this email finds you well. I'm reaching out regarding a cost-effective advertising opportunity for {businessName} in {town}.

We publish a shared mailer that goes directly to thousands of local households. Your business would be featured alongside other quality local services, giving you exposure to potential customers in your area.

Here's what makes this different:
‚Ä¢ Direct mail to targeted local households
‚Ä¢ Professional design included
‚Ä¢ Shared cost model makes it affordable
‚Ä¢ Proven results for local businesses

Would you be interested in learning more? I'd be happy to send over some details and pricing.

Best regards,
{yourName}
{yourPhone}
{yourEmail}`,
      variables: ['businessName', 'town', 'yourName', 'yourPhone', 'yourEmail'],
      createdAt: new Date().toISOString(),
      usageCount: 0,
      lastUsed: null
    },
    'default_instagram': {
      id: 'default_instagram',
      name: 'Instagram DM - First Contact',
      category: 'prospect',
      type: 'instagram',
      subject: '',
      body: `Hey!

Love what {businessName} is doing! I wanted to reach out about a local advertising opportunity that might interest you.

We help businesses in {town} reach thousands of local households through our shared mailer program.

Would you be open to a quick chat? I think this could be a great fit for you!

{yourName}
{yourPhone}`,
      variables: ['businessName', 'town', 'yourName', 'yourPhone'],
      createdAt: new Date().toISOString(),
      usageCount: 0,
      lastUsed: null
    },
    'default_followup': {
      id: 'default_followup',
      name: 'Follow-up - After Initial Contact',
      category: 'followup',
      type: 'email',
      subject: 'Following up - {businessName}',
      body: `Hi,

I wanted to follow up on my message from {date} about the local advertising opportunity.

I know you're busy, but I wanted to make sure this didn't get lost in your inbox.

We're putting together our next mailer for {town} and I'd love to include {businessName} if you're interested.

Do you have 5 minutes to chat this week?

Thanks!
{yourName}
{yourPhone}`,
      variables: ['businessName', 'town', 'date', 'yourName', 'yourPhone'],
      createdAt: new Date().toISOString(),
      usageCount: 0,
      lastUsed: null
    },
    'default_invoice': {
      id: 'default_invoice',
      name: 'Invoice Reminder',
      category: 'client',
      type: 'email',
      subject: 'Invoice Reminder - {businessName}',
      body: 'Hi {contactName},\n\nThis is a friendly reminder that your invoice for {campaign} is still pending.\n\nAmount Due: {amount}\n\nPlease let me know if you have any questions.\n\nBest regards',
      variables: ['businessName', 'contactName', 'campaign', 'amount'],
      createdAt: new Date().toISOString(),
      usageCount: 0,
      lastUsed: null
    },
    'default_proof': {
      id: 'default_proof',
      name: 'Ad Proof Ready',
      category: 'client',
      type: 'email',
      subject: 'Your Ad Proof is Ready - {businessName}',
      body: 'Hi {contactName},\n\nGreat news! Your ad proof for {campaign} is ready for review.\n\nPlease review and let me know if you\'d like any changes.\n\nBest regards',
      variables: ['businessName', 'contactName', 'campaign'],
      createdAt: new Date().toISOString(),
      usageCount: 0,
      lastUsed: null
    },
    'default_renewal': {
      id: 'default_renewal',
      name: 'Monthly Renewal Reminder',
      category: 'client',
      type: 'email',
      subject: 'Advertise Again Next Month? - {businessName}',
      body: 'Hi {firstName},\n\nWe\'re preparing our next month\'s mailing and wanted to reach out to see if you\'d like to continue advertising with us.\n\nYour current monthly rate: {monthlyPrice}\n\nJust reply "YES" to confirm your spot, or let me know if you have any questions.\n\nThanks!\n{yourName}',
      variables: ['firstName', 'businessName', 'monthlyPrice', 'yourName'],
      createdAt: new Date().toISOString(),
      usageCount: 0,
      lastUsed: null
    },
    'default_reactivation': {
      id: 'default_reactivation',
      name: 'Reactivation Offer',
      category: 'client',
      type: 'email',
      subject: 'We\'d Love to Have You Back! - {businessName}',
      body: 'Hi {firstName},\n\nIt\'s been a while since you last advertised with us, and we wanted to reach out to see if you\'d like to join our next mailing.\n\nWe\'ve helped many businesses like yours reach thousands of local customers.\n\nWould you like to advertise with us again next month?\n\nReply "YES" and I\'ll get you set up!\n\nBest regards,\n{yourName}',
      variables: ['firstName', 'businessName', 'yourName'],
      createdAt: new Date().toISOString(),
      usageCount: 0,
      lastUsed: null
    },
    'default_thankyou': {
      id: 'default_thankyou',
      name: 'Thank You',
      category: 'client',
      type: 'email',
      subject: 'Thank You - {businessName}',
      body: 'Hi {contactName},\n\nThank you for advertising with us on {campaign}!\n\nWe appreciate your business and look forward to working with you again.\n\nBest regards',
      variables: ['businessName', 'contactName', 'campaign'],
      createdAt: new Date().toISOString(),
      usageCount: 0,
      lastUsed: null
    }
  };

  userTemplatesState.templates = defaultTemplates;
  saveUserTemplates(); // Save defaults to cloud
  console.log('‚úÖ Initialized with 8 starter templates');
}

async function saveUserTemplates() {
  try {
    const data = {
      templates: userTemplatesState.templates
    };
    await saveToCloud('userTemplates', data);
    safeSetItem('mailslot-user-templates', JSON.stringify(data));
    console.log(`‚úÖ Saved ${Object.keys(userTemplatesState.templates).length} templates to cloud`);
  } catch(e) {
    console.warn('Templates saved to localStorage only (cloud sync failed):', e);
    safeSetItem('mailslot-user-templates', JSON.stringify({ templates: userTemplatesState.templates }));
  }
}

function createTemplate(name, category, type, subject, body) {
  const id = 'template_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

  // Extract variables from body and subject
  const variablePattern = /\{([^}]+)\}/g;
  const variablesSet = new Set();
  const allText = (subject + ' ' + body);
  let match;
  while ((match = variablePattern.exec(allText)) !== null) {
    variablesSet.add(match[1]);
  }

  const template = {
    id,
    name,
    category,
    type,
    subject,
    body,
    variables: Array.from(variablesSet),
    createdAt: new Date().toISOString(),
    lastUsed: null,
    usageCount: 0,  // New: Track usage
    isDefault: false
  };

  userTemplatesState.templates[id] = template;
  saveUserTemplates();
  return template;
}

function updateTemplate(id, updates) {
  if (!userTemplatesState.templates[id]) {
    console.error('Template not found:', id);
    return null;
  }

  // Don't allow editing default templates
  if (userTemplatesState.templates[id].isDefault) {
    toast('‚ö†Ô∏è Cannot edit default templates. Create a copy instead.', false);
    return null;
  }

  // Update fields
  Object.assign(userTemplatesState.templates[id], updates);

  // Re-extract variables if body or subject changed
  if (updates.body || updates.subject) {
    const variablePattern = /\{([^}]+)\}/g;
    const variablesSet = new Set();
    const allText = (userTemplatesState.templates[id].subject + ' ' + userTemplatesState.templates[id].body);
    let match;
    while ((match = variablePattern.exec(allText)) !== null) {
      variablesSet.add(match[1]);
    }
    userTemplatesState.templates[id].variables = Array.from(variablesSet);
  }

  saveUserTemplates();
  return userTemplatesState.templates[id];
}


function deleteTemplate(id) {
  const template = userTemplatesState.templates[id];
  if (!template) {
    toast('‚ö†Ô∏è Template not found', false);
    return;
  }

  if (confirm(`Are you sure you want to delete "${template.name}"?\n\nThis action cannot be undone.`)) {
    delete userTemplatesState.templates[id];
    saveUserTemplates();
    renderTemplateManager();
    populateBulkSendTemplates();
    toast('‚úÖ Template deleted', true);
  }
}

function duplicateTemplate(id) {
  if (!userTemplatesState.templates[id]) {
    toast('‚ö†Ô∏è Template not found', false);
    return null;
  }

  const original = userTemplatesState.templates[id];
  const newId = 'template_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

  const duplicate = {
    ...original,
    id: newId,
    name: original.name + ' (Copy)',
    createdAt: new Date().toISOString(),
    lastUsed: null,
    usageCount: 0,  // New: Track usage
    isDefault: false
  };

  userTemplatesState.templates[newId] = duplicate;
  saveUserTemplates();
  renderTemplateManager();
  populateBulkSendTemplates();
  toast('‚úÖ Template duplicated', true);
  return duplicate;
}

function getTemplatesByCategory(category) {
  return Object.values(userTemplatesState.templates)
    .filter(t => t.category === category)
    .sort((a, b) => {
      // Sort defaults first, then by name
      if (a.isDefault && !b.isDefault) return -1;
      if (!a.isDefault && b.isDefault) return 1;
      return a.name.localeCompare(b.name);
    });
}

function fillTemplateVariables(template, data) {
  let subject = template.subject || '';
  let body = template.body || '';

  // Replace all variables with data (new {VARIABLE} format)
  if (template.variables && Array.isArray(template.variables)) {
    template.variables.forEach(variable => {
      const regex = new RegExp(`\\{${variable}\\}`, 'g');
      const value = data[variable] || `{${variable}}`;
      subject = subject.replace(regex, value);
      body = body.replace(regex, value);
    });
  }

  // EXPANDED VARIABLE REPLACEMENT - Both [VARIABLE] and {VARIABLE} formats
  const variableMap = {
    // Business info
    'BUSINESS_NAME': data.businessName || data.name || '',
    'COMPANY': data.businessName || data.name || '',
    'BUSINESS': data.businessName || data.name || '',

    // Contact person info
    'FIRST_NAME': data.firstName || data.contactName?.split(' ')[0] || '',
    'LAST_NAME': data.lastName || data.contactName?.split(' ').slice(1).join(' ') || '',
    'CONTACT_NAME': data.contactName || data.firstName || '',
    'FULL_NAME': data.contactName || (data.firstName && data.lastName ? `${data.firstName} ${data.lastName}` : data.firstName || ''),
    'OWNER_NAME': data.ownerName || data.contactName || '',

    // Business details
    'INDUSTRY': data.industry || data.category || '',
    'CATEGORY': data.category || data.industry || '',
    'WEBSITE': data.website || '',
    'PHONE': data.phone || '',
    'EMAIL': data.email || '',

    // Location
    'ADDRESS': data.address || '',
    'STREET': data.address || '',
    'CITY': data.city || data.town || '',
    'TOWN': data.town || data.city || '',
    'STATE': data.state || '',
    'ZIP': data.zipCode || data.zip || '',
    'ZIP_CODE': data.zipCode || data.zip || '',
    'LOCATION': data.city || data.town || data.zipCode || '',

    // Pricing
    'PRICE': data.price || data.amount || '',
    'AMOUNT': data.amount || data.price || '',
    'COST': data.price || data.amount || '',
    'DISCOUNT': data.discount || '',

    // Campaign info
    'CAMPAIGN': data.campaign || '',
    'MAILER': data.campaign || '',

    // User info (sender)
    'YOUR_NAME': data.yourName || '',
    'YOUR_PHONE': data.yourPhone || '',
    'YOUR_EMAIL': data.yourEmail || '',
    'YOUR_COMPANY': data.yourCompany || '',
    'YOUR_WEBSITE': data.yourWebsite || '',

    // Date/time
    'DATE': new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }),
    'SHORT_DATE': new Date().toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' }),
    'MONTH': new Date().toLocaleDateString('en-US', { month: 'long' }),
    'YEAR': new Date().getFullYear().toString(),
    'DAY': new Date().toLocaleDateString('en-US', { weekday: 'long' })
  };

  // Replace both {VARIABLE} and [VARIABLE] formats
  Object.keys(variableMap).forEach(key => {
    const value = variableMap[key];
    // Replace {VARIABLE} format
    const curlyRegex = new RegExp(`\\{${key}\\}`, 'g');
    subject = subject.replace(curlyRegex, value);
    body = body.replace(curlyRegex, value);
    // Replace [VARIABLE] format
    const bracketRegex = new RegExp(`\\[${key}\\]`, 'g');
    subject = subject.replace(bracketRegex, value);
    body = body.replace(bracketRegex, value);
  });

  return { subject, body };
}

// Detect unfilled variables in template text
function detectMissingVariables(text) {
  const missing = [];

  // Match {VARIABLE} format
  const curlyMatches = text.match(/\{([A-Z_]+)\}/g) || [];
  curlyMatches.forEach(match => {
    const varName = match.slice(1, -1); // Remove { and }
    if (!missing.includes(varName)) {
      missing.push(varName);
    }
  });

  // Match [VARIABLE] format
  const bracketMatches = text.match(/\[([A-Z_]+)\]/g) || [];
  bracketMatches.forEach(match => {
    const varName = match.slice(1, -1); // Remove [ and ]
    if (!missing.includes(varName)) {
      missing.push(varName);
    }
  });

  return missing;
}

/**
 * Prune old cache entries to prevent localStorage quota issues
 * Uses LRU (Least Recently Used) eviction based on lastFetched timestamp
 * @param {Object} cacheData - The cache searches object to prune
 * @returns {Object} - Pruned cache data
 */
function pruneOldCacheEntries(cacheData) {
  if (!cacheData || typeof cacheData !== 'object') {
    return {};
  }

  const entries = Object.entries(cacheData);
  const currentSize = JSON.stringify(cacheData).length / 1024; // Size in KB

  // If under limits, no pruning needed
  if (entries.length <= CACHE_LIMITS.MAX_ENTRIES && currentSize <= CACHE_LIMITS.MAX_SIZE_KB) {
    return cacheData;
  }

  // Sort entries by lastFetched (oldest first) - entries without lastFetched go first (oldest)
  const sortedEntries = entries.sort((a, b) => {
    const dateA = a[1].lastFetched ? new Date(a[1].lastFetched).getTime() : 0;
    const dateB = b[1].lastFetched ? new Date(b[1].lastFetched).getTime() : 0;
    return dateA - dateB; // Oldest first
  });

  // Keep removing oldest entries until we're under limits
  let prunedEntries = [...sortedEntries];

  // First pass: Remove entries until under MAX_ENTRIES
  while (prunedEntries.length > CACHE_LIMITS.MAX_ENTRIES &&
         prunedEntries.length > CACHE_LIMITS.MIN_ENTRIES_TO_KEEP) {
    prunedEntries.shift(); // Remove oldest
  }

  // Second pass: Remove entries until under MAX_SIZE_KB
  let prunedData = Object.fromEntries(prunedEntries);
  let newSize = JSON.stringify(prunedData).length / 1024;

  while (newSize > CACHE_LIMITS.MAX_SIZE_KB &&
         prunedEntries.length > CACHE_LIMITS.MIN_ENTRIES_TO_KEEP) {
    prunedEntries.shift(); // Remove oldest
    prunedData = Object.fromEntries(prunedEntries);
    newSize = JSON.stringify(prunedData).length / 1024;
  }

  return prunedData;
}

async function loadPlacesCache() {
  try {
    // Load from cloud first (contains full history)
    const cloudData = await loadFromCloud('placesCache') || {};

    // Load from IndexedDB (may be pruned)
    const localData = await idbGet('mailslot-places-cache') || {};

    // Merge cloud and local data (keep newer entries)
    // Cloud has full history, local may have newer entries not yet synced
    let merged = { ...cloudData };

    Object.keys(localData).forEach(cacheKey => {
      const local = localData[cacheKey];
      const cloud = merged[cacheKey];

      if (!cloud) {
        // Only in local - add it
        merged[cacheKey] = local;
      } else if (local.lastFetched && cloud.lastFetched) {
        // In both - keep the newer one
        const localDate = new Date(local.lastFetched);
        const cloudDate = new Date(cloud.lastFetched);
        if (localDate > cloudDate) {
          merged[cacheKey] = local;
        }
      }
    });

    // Normalize ZIP codes in cached businesses to 5 digits
    let zipsNormalized = 0;
    Object.keys(merged).forEach(cacheKey => {
      const cache = merged[cacheKey];
      if (cache.cachedData && Array.isArray(cache.cachedData)) {
        cache.cachedData = cache.cachedData.map(biz => {
          let updated = biz;
          let needsUpdate = false;

          if (biz.zipCode && biz.zipCode.length > 5) {
            updated = { ...updated, zipCode: truncateZipTo5(biz.zipCode) };
            needsUpdate = true;
          }
          if (biz.actualZip && biz.actualZip.length > 5) {
            updated = { ...updated, actualZip: truncateZipTo5(biz.actualZip) };
            needsUpdate = true;
          }
          if (biz.zip && biz.zip.length > 5) {
            updated = { ...updated, zip: truncateZipTo5(biz.zip) };
            needsUpdate = true;
          }

          if (needsUpdate) zipsNormalized++;
          return updated;
        });
      }
    });

    if (zipsNormalized > 0) {
      console.log(`üìç Normalized ${zipsNormalized} ZIP codes in cache to 5-digit format`);
    }

    // Keep FULL data in memory (for cloud sync and search results)
    placesCache.searches = merged;

    const totalProspects = Object.values(merged).reduce((sum, cache) =>
      sum + (cache.cachedData?.length || 0), 0
    );

    console.log(`üì¶ Loaded prospect cache: ${Object.keys(merged).length} searches, ${totalProspects} total prospects`);

    // DON'T save pruned data back to IndexedDB on load - this was causing data loss!
    // IndexedDB is only updated on explicit saves (new searches, enrichments, etc.)
    // The full data is kept in cloud, IndexedDB is just a backup for offline access

  } catch(e) {
    console.error('Error loading places cache:', e);
    // Fall back to IndexedDB only
    const saved = await idbGet('mailslot-places-cache');
    if (saved) {
      placesCache.searches = saved;
    }
  }
}

// Debounce timer for cache saves - prevents rapid-fire cloud uploads
let savePlacesCacheTimer = null;
let savePlacesCachePending = false;
let lastCloudSaveTime = 0;
const CLOUD_SAVE_MIN_INTERVAL = 60000; // Minimum 60 seconds between cloud saves
const CLOUD_SAVE_DEBOUNCE = 15000; // Wait 15 seconds of inactivity before saving

async function savePlacesCache() {
  // Save to IndexedDB immediately (fast, local, no quota issues)
  try {
    const prunedData = pruneOldCacheEntries(placesCache.searches);
    await idbSet('mailslot-places-cache', prunedData);
  } catch(e) {
    console.error('Error saving places cache to IndexedDB:', e);
  }

  // Debounce cloud save - wait for inactivity before uploading
  if (savePlacesCacheTimer) {
    clearTimeout(savePlacesCacheTimer);
  }

  savePlacesCachePending = true;
  savePlacesCacheTimer = setTimeout(async () => {
    // Check if enough time has passed since last cloud save
    const timeSinceLastSave = Date.now() - lastCloudSaveTime;
    if (timeSinceLastSave >= CLOUD_SAVE_MIN_INTERVAL) {
      await savePlacesCacheToCloud();
    } else {
      // Schedule for later when the interval has passed
      const waitTime = CLOUD_SAVE_MIN_INTERVAL - timeSinceLastSave;
      console.log(`‚è≥ Cloud save queued (${Math.round(waitTime/1000)}s until next allowed save)`);
      setTimeout(() => savePlacesCacheToCloud(), waitTime);
    }
    savePlacesCachePending = false;
  }, CLOUD_SAVE_DEBOUNCE);
}

// Actual cloud save - called after debounce delay
async function savePlacesCacheToCloud() {
  // Double-check minimum interval
  const timeSinceLastSave = Date.now() - lastCloudSaveTime;
  if (timeSinceLastSave < CLOUD_SAVE_MIN_INTERVAL) {
    return; // Skip, too soon
  }

  try {
    // Prune before cloud sync (same as local save) to stay under size limits
    const prunedData = pruneOldCacheEntries(placesCache.searches);
    const dataStr = JSON.stringify(prunedData);

    // Supabase has a reasonable size limit - if under 5MB we're good
    if (dataStr.length <= 5000000) {
      await saveToCloud('placesCache', prunedData);
      lastCloudSaveTime = Date.now();
    } else {
      console.warn('‚ö†Ô∏è Prospect cache too large for cloud sync (>5MB) even after pruning, keeping local only');
    }
  } catch(e) {
    console.error('Error saving places cache to cloud:', e);
  }
}

// Sync all prospects to Supabase as a flattened list for email report
// This extracts just the prospect data (much smaller than full cache structure)
async function syncAllProspectsToCloud() {
  try {
    toast('üîÑ Syncing all prospects to cloud...', true);

    // Collect all prospects from all sources
    const allProspects = [];
    const seenIds = new Set();

    // 1. From placesCache.searches
    Object.keys(placesCache.searches).forEach(cacheKey => {
      const cached = placesCache.searches[cacheKey];
      if (cached?.cachedData) {
        cached.cachedData.forEach(business => {
          const id = business.placeId || business.id;
          if (id && !seenIds.has(id)) {
            seenIds.add(id);
            // Only keep essential fields to reduce size
            allProspects.push({
              placeId: business.placeId,
              id: business.id,
              name: business.name,
              businessName: business.businessName || business.name,
              email: business.email,
              phone: business.phone,
              address: business.address,
              city: business.city,
              state: business.state,
              zipCode: business.zipCode || business.actualZip || business.zip,
              category: business.category,
              website: business.website,
              facebook: business.facebook,
              instagram: business.instagram,
              linkedin: business.linkedin,
              twitter: business.twitter,
              contactName: business.contactName,
              contactTracking: business.contactTracking
            });
          }
        });
      }
    });

    // 2. From manualProspects
    prospectPoolState.manualProspects.forEach(p => {
      const id = p.placeId || p.id || p.businessName;
      if (id && !seenIds.has(id)) {
        seenIds.add(id);
        allProspects.push({
          placeId: p.placeId,
          id: p.id,
          name: p.name,
          businessName: p.businessName || p.name,
          email: p.email,
          phone: p.phone,
          address: p.address,
          city: p.city,
          state: p.state,
          zipCode: p.zipCode || p.actualZip || p.zip,
          category: p.category,
          website: p.website,
          facebook: p.facebook,
          instagram: p.instagram,
          linkedin: p.linkedin,
          twitter: p.twitter,
          contactName: p.contactName,
          contactTracking: p.contactTracking
        });
      }
    });

    // 3. From campaignBoardsState.boards (Campaign Boards - main source of pipeline data)
    if (campaignBoardsState && campaignBoardsState.boards) {
      let campaignBoardsCount = 0;
      let campaignBoardsEmails = 0;
      Object.values(campaignBoardsState.boards).forEach(board => {
        if (board && board.columns) {
          Object.values(board.columns).forEach(column => {
            if (Array.isArray(column)) {
              column.forEach(lead => {
                const id = lead.placeId || lead.id || lead.businessName;
                campaignBoardsCount++;
                if (lead.email) campaignBoardsEmails++;

                if (id && !seenIds.has(id)) {
                  seenIds.add(id);
                  allProspects.push({
                    placeId: lead.placeId,
                    id: lead.id,
                    name: lead.name,
                    businessName: lead.businessName || lead.name,
                    email: lead.email,
                    phone: lead.phone,
                    address: lead.address,
                    city: lead.city,
                    state: lead.state,
                    zipCode: lead.zipCode || lead.actualZip || lead.zip,
                    category: lead.category,
                    website: lead.website,
                    facebook: lead.facebook,
                    instagram: lead.instagram,
                    linkedin: lead.linkedin,
                    twitter: lead.twitter,
                    contactName: lead.contactName,
                    contactTracking: lead.contactTracking,
                    enriched: lead.enriched
                  });
                } else if (id && seenIds.has(id)) {
                  // Update existing entry with data from campaign boards
                  const existingIndex = allProspects.findIndex(p => (p.placeId || p.id) === id);
                  if (existingIndex !== -1) {
                    if (lead.email && !allProspects[existingIndex].email) {
                      allProspects[existingIndex].email = lead.email;
                    }
                    if (lead.phone && !allProspects[existingIndex].phone) {
                      allProspects[existingIndex].phone = lead.phone;
                    }
                    if (lead.facebook && !allProspects[existingIndex].facebook) {
                      allProspects[existingIndex].facebook = lead.facebook;
                    }
                    if (lead.instagram && !allProspects[existingIndex].instagram) {
                      allProspects[existingIndex].instagram = lead.instagram;
                    }
                  }
                }
              });
            }
          });
        }
      });
      console.log(`üìã Campaign Boards: ${campaignBoardsCount} items, ${campaignBoardsEmails} with emails`);
    }

    // 4. From legacy kanbanState.columns (fallback)
    if (kanbanState && kanbanState.columns) {
      Object.values(kanbanState.columns).forEach(column => {
        if (Array.isArray(column)) {
          column.forEach(lead => {
            const id = lead.placeId || lead.id || lead.businessName;
            if (id && !seenIds.has(id)) {
              seenIds.add(id);
              allProspects.push({
                placeId: lead.placeId,
                id: lead.id,
                name: lead.name,
                businessName: lead.businessName || lead.name,
                email: lead.email,
                phone: lead.phone,
                address: lead.address,
                city: lead.city,
                state: lead.state,
                zipCode: lead.zipCode || lead.actualZip || lead.zip,
                category: lead.category,
                website: lead.website,
                facebook: lead.facebook,
                instagram: lead.instagram,
                linkedin: lead.linkedin,
                twitter: lead.twitter,
                contactName: lead.contactName,
                contactTracking: lead.contactTracking,
                enriched: lead.enriched
              });
            } else if (id && seenIds.has(id)) {
              // Update existing entry with enriched data from kanban
              const existingIndex = allProspects.findIndex(p => (p.placeId || p.id) === id);
              if (existingIndex !== -1 && lead.email && !allProspects[existingIndex].email) {
                allProspects[existingIndex].email = lead.email;
              }
              if (existingIndex !== -1 && lead.phone && !allProspects[existingIndex].phone) {
                allProspects[existingIndex].phone = lead.phone;
              }
              if (existingIndex !== -1 && lead.facebook && !allProspects[existingIndex].facebook) {
                allProspects[existingIndex].facebook = lead.facebook;
              }
              if (existingIndex !== -1 && lead.instagram && !allProspects[existingIndex].instagram) {
                allProspects[existingIndex].instagram = lead.instagram;
              }
            }
          });
        }
      });
    }

    // 5. Build lookup of enriched data from placesCache by placeId
    // Then update any prospects that are missing enriched data
    const enrichedLookup = new Map();
    Object.values(placesCache.searches).forEach(cached => {
      if (cached?.cachedData) {
        cached.cachedData.forEach(b => {
          if (b.placeId && b.enriched) {
            enrichedLookup.set(b.placeId, b);
          }
        });
      }
    });

    // Update prospects with enriched data they might be missing
    let enrichedUpdates = 0;
    allProspects.forEach((prospect, index) => {
      const enriched = enrichedLookup.get(prospect.placeId);
      if (enriched) {
        // Always copy the enriched flag
        allProspects[index].enriched = true;

        if (enriched.email && !prospect.email) {
          allProspects[index].email = enriched.email;
          enrichedUpdates++;
        }
        if (enriched.phone && !prospect.phone) {
          allProspects[index].phone = enriched.phone;
        }
        if (enriched.facebook && !prospect.facebook) {
          allProspects[index].facebook = enriched.facebook;
        }
        if (enriched.instagram && !prospect.instagram) {
          allProspects[index].instagram = enriched.instagram;
        }
        if (enriched.linkedin && !prospect.linkedin) {
          allProspects[index].linkedin = enriched.linkedin;
        }
        if (enriched.twitter && !prospect.twitter) {
          allProspects[index].twitter = enriched.twitter;
        }
        if (enriched.contactNames && enriched.contactNames.length > 0 && !prospect.contactName) {
          allProspects[index].contactName = enriched.contactNames[0];
        }
      }
    });

    if (enrichedUpdates > 0) {
      console.log(`üìß Updated ${enrichedUpdates} prospects with enriched email data`);
    }

    // Count how many have emails
    const withEmails = allProspects.filter(p => p.email && p.email.trim()).length;
    console.log(`üìä Total prospects to sync: ${allProspects.length} (${withEmails} with emails)`);

    // Check size and chunk if needed
    const dataStr = JSON.stringify(allProspects);
    const sizeKB = Math.round(dataStr.length / 1024);
    console.log(`üì¶ Data size: ${sizeKB} KB`);

    // Supabase limit is about 5MB, use 4MB to be safe
    const MAX_CHUNK_SIZE = 4 * 1024 * 1024; // 4MB

    if (dataStr.length <= MAX_CHUNK_SIZE) {
      // Single save
      await saveToCloud('allProspectsFlat', allProspects);
      toast(`‚úÖ Synced ${allProspects.length} prospects (${withEmails} with emails) to cloud!`, true);
    } else {
      // Need to chunk
      const chunkSize = Math.ceil(allProspects.length / Math.ceil(dataStr.length / MAX_CHUNK_SIZE));
      const chunks = [];

      for (let i = 0; i < allProspects.length; i += chunkSize) {
        chunks.push(allProspects.slice(i, i + chunkSize));
      }

      console.log(`üì¶ Splitting into ${chunks.length} chunks of ~${chunkSize} prospects each`);

      // Save chunk count first
      await saveToCloud('allProspectsFlat_meta', { chunkCount: chunks.length, totalCount: allProspects.length });

      // Save each chunk
      for (let i = 0; i < chunks.length; i++) {
        await saveToCloud(`allProspectsFlat_chunk_${i}`, chunks[i]);
        console.log(`‚úÖ Saved chunk ${i + 1}/${chunks.length}`);
      }

      toast(`‚úÖ Synced ${allProspects.length} prospects to cloud in ${chunks.length} chunks!`, true);
    }

    return allProspects.length;
  } catch (e) {
    console.error('Error syncing prospects to cloud:', e);
    toast('‚ùå Failed to sync prospects to cloud', false);
    throw e;
  }
}

// Expose globally for console/UI access
window.syncAllProspectsToCloud = syncAllProspectsToCloud;

function trackApiCall(count = 1) {
  apiQuotaState.callsThisMonth += count;

  const percentUsed = apiQuotaState.callsThisMonth / apiQuotaState.monthlyLimit;

  // Activate restrictions at warning threshold
  if (percentUsed >= apiQuotaState.warningThreshold && !apiQuotaState.restrictionsActive) {
    apiQuotaState.restrictionsActive = true;
    // Set per-user quota: remaining calls divided by estimated active users (default 10)
    const remainingCalls = apiQuotaState.monthlyLimit - apiQuotaState.callsThisMonth;
    const perUserQuota = Math.floor(remainingCalls / 10); // Conservative estimate

    toast(`‚ö†Ô∏è API quota at ${Math.round(percentUsed * 100)}% - Per-user limits now active (${perUserQuota} searches/user)`, false);
  }

  // Critical warning
  if (percentUsed >= apiQuotaState.criticalThreshold) {
    toast(`üö® API quota at ${Math.round(percentUsed * 100)}% - Very limited searches remaining`, false);
  }

  saveApiQuota();
}

function canUserSearch(userId = ACTIVE_USER) {
  const percentUsed = apiQuotaState.callsThisMonth / apiQuotaState.monthlyLimit;

  // If under warning threshold, everyone can search
  if (percentUsed < apiQuotaState.warningThreshold) {
    return { allowed: true, reason: null };
  }

  // If restrictions active, check user quota
  if (apiQuotaState.restrictionsActive) {
    const userCalls = apiQuotaState.userQuotas[userId] || 0;
    const remainingCalls = apiQuotaState.monthlyLimit - apiQuotaState.callsThisMonth;
    const perUserLimit = Math.floor(remainingCalls / 10);

    if (userCalls >= perUserLimit) {
      return {
        allowed: false,
        reason: `Monthly search limit reached (${perUserLimit} searches). Resets ${getNextMonthDate()}.`
      };
    }
  }

  // Check absolute limit
  if (apiQuotaState.callsThisMonth >= apiQuotaState.monthlyLimit) {
    return {
      allowed: false,
      reason: `System-wide monthly limit reached. Resets ${getNextMonthDate()}.`
    };
  }

  return { allowed: true, reason: null };
}

function recordUserSearch(userId = ACTIVE_USER) {
  if (!apiQuotaState.userQuotas[userId]) {
    apiQuotaState.userQuotas[userId] = 0;
  }
  apiQuotaState.userQuotas[userId]++;
  saveApiQuota();
}

function getNextMonthDate() {
  const now = new Date();
  const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
  return nextMonth.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

function getApiUsageStats() {
  const percentUsed = (apiQuotaState.callsThisMonth / apiQuotaState.monthlyLimit * 100).toFixed(1);
  const remaining = apiQuotaState.monthlyLimit - apiQuotaState.callsThisMonth;

  return {
    used: apiQuotaState.callsThisMonth,
    limit: apiQuotaState.monthlyLimit,
    remaining: remaining,
    percentUsed: percentUsed,
    restrictionsActive: apiQuotaState.restrictionsActive,
    resetsOn: getNextMonthDate()
  };
}

/* ========= GOOGLE PLACES AUTO-POPULATE FUNCTIONS ========= */

function openAutoPopulateModal() {
  if (!GOOGLE_PLACES_API_KEY) {
    toast('Google Places API key not configured. Please add your API key to the GOOGLE_PLACES_API_KEY constant.', false);
    return;
  }

  const modal = document.getElementById('autoPopulateModal');
  modal.classList.add('show');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');

  // Update API usage display
  updateApiUsageDisplay();

  // Focus first input
  document.getElementById('autoPopZipCode').focus();
}

function closeAutoPopulateModal() {
  const modal = document.getElementById('autoPopulateModal');
  modal.classList.remove('show');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');

  // Reset form
  document.getElementById('autoPopZipCode').value = '';
  document.getElementById('autoPopCategory').value = '';
  document.getElementById('autoPopRadius').value = '3000';
}

function updateApiUsageDisplay() {
  const stats = getApiUsageStats();
  const display = document.getElementById('apiUsageDisplay');

  let bgColor = 'bg-green-50 border-green-300';
  let textColor = 'text-green-900';
  let icon = '‚úÖ';

  if (stats.percentUsed >= 95) {
    bgColor = 'bg-red-50 border-red-300';
    textColor = 'text-red-900';
    icon = 'üö®';
  } else if (stats.percentUsed >= 80) {
    bgColor = 'bg-orange-50 border-orange-300';
    textColor = 'text-orange-900';
    icon = '‚ö†Ô∏è';
  } else if (stats.percentUsed >= 50) {
    bgColor = 'bg-yellow-50 border-yellow-300';
    textColor = 'text-yellow-900';
    icon = 'üí°';
  }

  display.className = `mb-4 p-3 rounded-lg border ${bgColor}`;
  display.innerHTML = `
    <div class="${textColor}">
      <div class="font-semibold text-sm mb-1">${icon} API Usage This Month</div>
      <div class="text-xs">
        <strong>${stats.used}</strong> of ${stats.limit} searches used (${stats.percentUsed}%)
        <br>
        ${stats.remaining} searches remaining ‚Ä¢ Resets ${stats.resetsOn}
      </div>
      ${stats.restrictionsActive ? '<div class="text-xs mt-1 font-semibold">‚ö†Ô∏è Per-user quotas active</div>' : ''}
    </div>
  `;
}

// Initialize Google Maps API - script loads from <head> tag with callback
function loadGoogleMapsAPI() {
  return new Promise((resolve, reject) => {
    // Check if already loaded
    if (typeof google !== 'undefined' && google.maps && googleMapsLoaded) {
      resolve();
      return;
    }

    // Wait for callback (script is loading from <head>)
    const checkInterval = setInterval(() => {
      if (googleMapsLoaded && typeof google !== 'undefined' && google.maps) {
        clearInterval(checkInterval);
        resolve();
      }
    }, 100);

    // Timeout after 10 seconds
    setTimeout(() => {
      clearInterval(checkInterval);
      if (!googleMapsLoaded) {
        reject(new Error('Google Maps API failed to load within 10 seconds'));
      }
    }, 10000);
  });
}

// ZIP code to city mapping for Western NY area
const zipToCityMap = {
  '14072': ['Grand Island'],
  '14150': ['Tonawanda'],  // Town of Tonawanda only (NOT North Tonawanda)
  '14217': ['Kenmore', 'Buffalo'],
  '14120': ['North Tonawanda'],  // City of North Tonawanda (separate from 14150)
  '14221': ['Williamsville', 'Buffalo'],
  '14225': ['Cheektowaga', 'Buffalo'],
  '14228': ['Amherst', 'Getzville', 'Williamsville'],  // Added for Amherst area
  // Add more as needed
};

// Validate if a business belongs to a ZIP code based on ZIP and/or city
function validateZipMatch(actualZip, actualCity, searchedZip) {
  // First priority: if we have actualZip, use it
  if (actualZip) {
    return actualZip === searchedZip;
  }

  // Second priority: if we have actualCity, validate against expected cities for this ZIP
  if (actualCity && zipToCityMap[searchedZip]) {
    const expectedCities = zipToCityMap[searchedZip];
    // Case-insensitive city match
    return expectedCities.some(city =>
      city.toLowerCase() === actualCity.toLowerCase()
    );
  }

  // If we have neither ZIP nor city, keep it (benefit of doubt - within search radius)
  return true;
}

// Extract ZIP code from an address string

async function convertZipToLatLng(zipCode) {
  try {
    // Ensure Google Maps API is loaded
    await loadGoogleMapsAPI();

    // Use Google Maps Geocoder (client-side, no CORS issues)
    const geocoder = new google.maps.Geocoder();

    return new Promise((resolve, reject) => {
      geocoder.geocode(
        {
          address: zipCode,
          componentRestrictions: { country: 'US' }
        },
        (results, status) => {
          if (status === 'OK' && results.length > 0) {
            const location = results[0].geometry.location;
            resolve({ lat: location.lat(), lng: location.lng() });
          } else {
            reject(new Error(`Geocoding failed: ${status}`));
          }
        }
      );
    });
  } catch(err) {
    console.error('Geocoding error:', err);
    return null;
  }
}

/**
 * Search for business website using multiple APIs in sequence
 * Chain: Brave (2K/mo) ‚Üí Scrapingdog (1K/mo) ‚Üí Serper (2.5K/mo)
 * Total: ~5,500 FREE searches/month
 */
async function searchBusinessWebsite(searchQuery, businessName) {
  try {
    console.log(`üîç Searching: "${searchQuery}"`);

    // 1. Try Brave first (2,000 free/month, fastest at ~500ms)
    try {
      const braveResponse = await fetch('/api/brave-search', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: searchQuery, businessName })
      });

      if (braveResponse.ok) {
        const braveData = await braveResponse.json();
        if (braveData.success && braveData.website) {
          console.log(`ü¶Å Brave found:`, braveData.website);
          return braveData.website;
        }
        if (braveData.error === 'quota_exceeded') {
          console.log(`ü¶Å Brave quota exceeded, trying Scrapingdog...`);
        } else if (braveData.error) {
          console.log(`ü¶Å Brave error: ${braveData.error}, trying Scrapingdog...`);
        }
      }
    } catch (e) {
      console.warn(`ü¶Å Brave failed:`, e.message);
    }

    // 2. Try Scrapingdog (1,000 free/month, ~4s but good quality)
    try {
      const sdResponse = await fetch('/api/scrapingdog-search', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: searchQuery, businessName })
      });

      if (sdResponse.ok) {
        const sdData = await sdResponse.json();
        if (sdData.success && sdData.website) {
          console.log(`üêï Scrapingdog found:`, sdData.website);
          return sdData.website;
        }
        if (sdData.error === 'quota_exceeded') {
          console.log(`üêï Scrapingdog quota exceeded, trying Serper...`);
        } else if (sdData.error) {
          console.log(`üêï Scrapingdog error: ${sdData.error}, trying Serper...`);
        }
      }
    } catch (e) {
      console.warn(`üêï Scrapingdog failed:`, e.message);
    }

    // 3. Try Serper (2,500 free/month, falls back to Google CSE)
    try {
      const serperResponse = await fetch('/api/serper-search', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query: searchQuery, businessName })
      });

      if (serperResponse.ok) {
        const serperData = await serperResponse.json();
        if (serperData.success && serperData.topUrl) {
          console.log(`üîç Serper found:`, serperData.topUrl);
          return serperData.topUrl;
        }
        if (serperData.error) {
          console.warn(`üîç Serper error: ${serperData.error}`);
        }
      }
    } catch (e) {
      console.warn(`üîç Serper failed:`, e.message);
    }

    console.log(`üîç No website found for: "${searchQuery}"`);
    return '';

  } catch (error) {
    console.warn('üîç Website search failed:', error);
    return '';
  }
}

// Test function to check if search APIs are working
async function testSearchAPI() {
  console.log('üß™ Testing Search API...');

  // Test 1: Simple website search
  const test1 = await searchBusinessWebsite('Adams Heating Cooling Buffalo NY official website', 'Adams Heating');
  console.log('Test 1 (website):', test1 || 'FAILED - no result');

  // Test 2: Facebook search
  const test2 = await searchBusinessWebsite('Adams Heating Cooling Buffalo NY site:facebook.com', 'Adams Heating');
  console.log('Test 2 (facebook):', test2 || 'FAILED - no result');

  // Test 3: Instagram search
  const test3 = await searchBusinessWebsite('Adams Heating Cooling Buffalo NY site:instagram.com', 'Adams Heating');
  console.log('Test 3 (instagram):', test3 || 'FAILED - no result');

  alert(`Search API Test Results:\n\nWebsite: ${test1 || 'NONE'}\nFacebook: ${test2 || 'NONE'}\nInstagram: ${test3 || 'NONE'}\n\nCheck browser console for details.`);
}
window.testSearchAPI = testSearchAPI;

// Compare Serper vs Google side-by-side
async function compareSearchAPIs(businessName = 'Adams Heating Cooling', location = 'Buffalo NY') {
  console.log('üß™ COMPARING SEARCH APIs: Serper vs Google');
  console.log('==========================================');

  const queries = [
    { type: 'Website', query: `${businessName} ${location} official website` },
    { type: 'Facebook', query: `${businessName} ${location} site:facebook.com` },
    { type: 'Instagram', query: `${businessName} ${location} site:instagram.com` }
  ];

  const results = [];

  for (const { type, query } of queries) {
    console.log(`\nüîç Testing: ${type}`);
    console.log(`   Query: "${query}"`);

    // Test Serper directly
    let serperResult = null;
    let serperError = null;
    try {
      const serperResp = await fetch('/api/serper-search', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query, businessName, forceSerper: true })
      });
      const serperData = await serperResp.json();
      serperResult = serperData.topUrl;
      if (serperData.error) serperError = serperData.error;
      if (serperData.source) console.log(`   Serper source: ${serperData.source}`);
    } catch (e) {
      serperError = e.message;
    }

    // Test Google directly
    let googleResult = null;
    let googleError = null;
    try {
      const googleResp = await fetch('/api/google-search', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query, businessName })
      });
      const googleData = await googleResp.json();
      googleResult = googleData.website || googleData.topUrl; // google-search returns 'website'
      if (googleData.error) googleError = googleData.error;
    } catch (e) {
      googleError = e.message;
    }

    console.log(`   SERPER: ${serperResult || serperError || 'NO RESULT'}`);
    console.log(`   GOOGLE: ${googleResult || googleError || 'NO RESULT'}`);

    results.push({
      type,
      serper: serperResult || `ERROR: ${serperError || 'none'}`,
      google: googleResult || `ERROR: ${googleError || 'none'}`
    });
  }

  // Display results
  let msg = 'SEARCH API COMPARISON\n';
  msg += '=====================\n\n';
  msg += `Business: ${businessName}, ${location}\n\n`;

  for (const r of results) {
    msg += `${r.type}:\n`;
    msg += `  Serper: ${r.serper}\n`;
    msg += `  Google: ${r.google}\n\n`;
  }

  msg += 'Check browser console for full details.';

  console.log('\nüìä SUMMARY:');
  console.table(results);

  alert(msg);
  return results;
}
window.compareSearchAPIs = compareSearchAPIs;

// ============================================================================
// ENRICHMENT PROGRESS MODAL
// Fun, engaging UI while enriching businesses
// ============================================================================

const ENRICHMENT_MESSAGES = [
  { icon: 'üîç', text: 'Searching the web...' },
  { icon: 'üåê', text: 'Finding official websites...' },
  { icon: 'üìß', text: 'Looking for contact emails...' },
  { icon: 'üéØ', text: 'Verifying business info...' },
  { icon: '‚ú®', text: 'Almost there...' },
  { icon: 'üöÄ', text: 'Turbocharging your leads...' },
  { icon: 'üíº', text: 'Building your prospect list...' },
  { icon: 'üîé', text: 'Digging up gold...' },
  { icon: 'üìä', text: 'Analyzing search results...' },
  { icon: 'üéâ', text: 'Finding the good stuff...' },
  { icon: '‚ö°', text: 'Working at lightning speed...' },
  { icon: 'üß≤', text: 'Attracting quality leads...' },
];

let enrichmentState = {
  isRunning: false,
  cancelled: false,
  total: 0,
  current: 0,
  found: 0,
  startTime: null,
  messageInterval: null
};

/**
 * Show the enrichment progress modal
 * @param {number} totalBusinesses - Total businesses to enrich
 */
function showEnrichmentModal(totalBusinesses) {
  enrichmentState = {
    isRunning: true,
    cancelled: false,
    total: totalBusinesses,
    current: 0,
    found: 0,
    startTime: Date.now(),
    messageInterval: null
  };

  const modal = document.getElementById('enrichmentModal');
  if (!modal) return;

  // Reset UI
  document.getElementById('enrichmentProgressBar').style.width = '0%';
  document.getElementById('enrichmentPercent').textContent = '0%';
  document.getElementById('enrichmentProgressText').textContent = `Enriching 0 of ${totalBusinesses}...`;
  document.getElementById('enrichmentFound').textContent = '0';
  document.getElementById('enrichmentETA').textContent = '--';
  document.getElementById('enrichmentCurrentBusiness').innerHTML = '<span class="inline-block animate-pulse">Starting...</span>';

  // Calculate time saved estimate (assume 2 min per manual lookup)
  const manualMinutes = totalBusinesses * 2;
  const hours = Math.floor(manualMinutes / 60);
  const mins = manualMinutes % 60;
  const timeText = hours > 0 ? `~${hours}h ${mins}m manually` : `~${mins} minutes manually`;
  document.getElementById('enrichmentTimeSaved').textContent = `This would take ${timeText}`;

  // Show modal
  modal.classList.remove('hidden');
  document.body.style.overflow = 'hidden';

  // Start rotating messages
  let messageIndex = 0;
  updateEnrichmentMessage(ENRICHMENT_MESSAGES[0]);
  enrichmentState.messageInterval = setInterval(() => {
    messageIndex = (messageIndex + 1) % ENRICHMENT_MESSAGES.length;
    updateEnrichmentMessage(ENRICHMENT_MESSAGES[messageIndex]);
  }, 3000);
}

/**
 * Update the fun rotating message
 */
function updateEnrichmentMessage(msg) {
  const container = document.getElementById('enrichmentMessage');
  if (!container) return;
  container.innerHTML = `
    <span class="text-lg">${msg.icon}</span>
    <p class="text-gray-700 font-medium mt-1">${msg.text}</p>
  `;
}

/**
 * Update enrichment progress
 * @param {number} current - Current business number
 * @param {string} businessName - Name of current business
 * @param {boolean} foundContact - Whether contact was found
 */
function updateEnrichmentProgress(current, businessName, foundContact = false) {
  if (!enrichmentState.isRunning) return;

  enrichmentState.current = current;
  if (foundContact) enrichmentState.found++;

  const percent = Math.round((current / enrichmentState.total) * 100);
  const elapsed = (Date.now() - enrichmentState.startTime) / 1000;
  const avgTimePerBusiness = elapsed / current;
  const remaining = enrichmentState.total - current;
  const etaSeconds = Math.round(remaining * avgTimePerBusiness);

  // Update UI
  document.getElementById('enrichmentProgressBar').style.width = `${percent}%`;
  document.getElementById('enrichmentPercent').textContent = `${percent}%`;
  document.getElementById('enrichmentProgressText').textContent = `Enriching ${current} of ${enrichmentState.total}...`;
  document.getElementById('enrichmentFound').textContent = enrichmentState.found.toString();

  // Format ETA
  if (etaSeconds > 60) {
    const mins = Math.floor(etaSeconds / 60);
    const secs = etaSeconds % 60;
    document.getElementById('enrichmentETA').textContent = `${mins}m ${secs}s`;
  } else {
    document.getElementById('enrichmentETA').textContent = `${etaSeconds}s`;
  }

  // Show current business
  document.getElementById('enrichmentCurrentBusiness').innerHTML = `
    <span class="text-gray-400">Now processing:</span>
    <span class="font-medium text-gray-700 ml-1">${businessName}</span>
  `;
}

/**
 * Hide the enrichment modal and show completion
 */
function hideEnrichmentModal(success = true) {
  enrichmentState.isRunning = false;

  if (enrichmentState.messageInterval) {
    clearInterval(enrichmentState.messageInterval);
    enrichmentState.messageInterval = null;
  }

  const modal = document.getElementById('enrichmentModal');
  if (!modal) return;

  if (success && enrichmentState.found > 0) {
    // Show success state briefly
    document.getElementById('enrichmentIcon').textContent = 'üéâ';
    document.getElementById('enrichmentIcon').classList.remove('animate-bounce');
    document.getElementById('enrichmentTitle').textContent = 'Enrichment Complete!';
    document.getElementById('enrichmentSubtitle').textContent = `Found contact info for ${enrichmentState.found} businesses`;
    document.getElementById('enrichmentProgressBar').style.width = '100%';
    document.getElementById('enrichmentPercent').textContent = '100%';
    document.getElementById('enrichmentStatus').innerHTML = '<span class="text-green-600 font-medium">‚úì Done!</span>';
    document.getElementById('enrichmentCurrentBusiness').textContent = '';
    document.getElementById('enrichmentCancelBtn').textContent = 'Close';

    // Auto-close after 2 seconds
    setTimeout(() => {
      modal.classList.add('hidden');
      document.body.style.overflow = '';
      resetEnrichmentModal();
    }, 2000);
  } else {
    // Close immediately
    modal.classList.add('hidden');
    document.body.style.overflow = '';
    resetEnrichmentModal();
  }
}

/**
 * Reset modal to initial state
 */
function resetEnrichmentModal() {
  document.getElementById('enrichmentIcon').textContent = 'üîç';
  document.getElementById('enrichmentIcon').classList.add('animate-bounce');
  document.getElementById('enrichmentTitle').textContent = 'Finding Contact Info';
  document.getElementById('enrichmentSubtitle').textContent = "We're doing the tedious work so you don't have to";
  document.getElementById('enrichmentCancelBtn').textContent = 'Cancel';
  document.getElementById('enrichmentStatus').innerHTML = '<span class="inline-block w-2 h-2 bg-green-500 rounded-full animate-pulse mr-2"></span>Working...';
}

/**
 * Cancel enrichment process
 */
function cancelEnrichment() {
  enrichmentState.cancelled = true;
  enrichmentState.isRunning = false;

  if (enrichmentState.messageInterval) {
    clearInterval(enrichmentState.messageInterval);
  }

  const modal = document.getElementById('enrichmentModal');
  if (modal) {
    modal.classList.add('hidden');
    document.body.style.overflow = '';
  }

  resetEnrichmentModal();
  console.log('üõë Enrichment cancelled by user');
}

/**
 * Check if enrichment was cancelled
 */
function isEnrichmentCancelled() {
  return enrichmentState.cancelled;
}

// Expose to window for onclick handlers
window.cancelEnrichment = cancelEnrichment;

/**
 * Bulk enrich multiple businesses with progress modal
 * Uses parallel requests for efficiency (5 concurrent)
 * @param {Array} businesses - Array of business objects to enrich
 * @returns {Promise<{success: number, failed: number}>}
 */
async function bulkEnrichBusinesses(businesses) {
  if (!businesses || businesses.length === 0) {
    return { success: 0, failed: 0 };
  }

  // Filter to only businesses without website/email
  const toEnrich = businesses.filter(b => !b.website && !b.email && !b.enriched);

  if (toEnrich.length === 0) {
    console.log('‚úÖ All businesses already enriched');
    return { success: 0, failed: 0 };
  }

  showEnrichmentModal(toEnrich.length);

  let success = 0;
  let failed = 0;
  const BATCH_SIZE = 5; // Parallel batch size
  const BATCH_DELAY = 15000; // 15s between batches

  try {
    for (let i = 0; i < toEnrich.length; i += BATCH_SIZE) {
      if (isEnrichmentCancelled()) break;

      const batch = toEnrich.slice(i, i + BATCH_SIZE);

      // Process batch in parallel
      const results = await Promise.all(
        batch.map(async (business, idx) => {
          const businessName = business.name || business.businessName || 'Unknown';
          updateEnrichmentProgress(i + idx + 1, businessName, false);

          try {
            // Search for website
            const location = `${business.city || ''} ${business.state || ''}`.trim();
            const websiteQuery = `${businessName} ${location} official website`;
            const website = await searchBusinessWebsite(websiteQuery, businessName);

            if (website) {
              business.website = website;

              // Try to scrape email from website
              const enrichedData = await fetchSmartEnrichment(website, businessName);
              if (enrichedData.email) {
                business.email = enrichedData.email;
              }
              business.facebook = business.facebook || enrichedData.facebook || '';
              business.instagram = business.instagram || enrichedData.instagram || '';
              business.enriched = true;

              updateEnrichmentProgress(i + idx + 1, businessName, true);
              return { success: true, business };
            }
            return { success: false, business };
          } catch (err) {
            console.error(`Failed to enrich ${businessName}:`, err);
            return { success: false, business };
          }
        })
      );

      // Count results
      for (const r of results) {
        if (r.success) success++;
        else failed++;
      }

      // Delay between batches (except for last batch)
      if (i + BATCH_SIZE < toEnrich.length && !isEnrichmentCancelled()) {
        await new Promise(r => setTimeout(r, BATCH_DELAY));
      }
    }
  } catch (err) {
    console.error('Bulk enrichment error:', err);
  }

  hideEnrichmentModal(!isEnrichmentCancelled());

  // Save updated data
  if (success > 0) {
    await saveAllData();
  }

  console.log(`üìä Bulk enrichment complete: ${success} success, ${failed} failed`);
  return { success, failed };
}

// Expose to window
window.bulkEnrichBusinesses = bulkEnrichBusinesses;
window.showEnrichmentModal = showEnrichmentModal;
window.updateEnrichmentProgress = updateEnrichmentProgress;
window.hideEnrichmentModal = hideEnrichmentModal;

/**
 * Enrich a business with website and social media when added to kanban
 * Runs asynchronously so it doesn't block the UI
 * Uses 3 Google Custom Search queries per business (website, facebook, instagram)
 */
async function enrichBusinessWebsite(business) {
  if (!business || business.enriched) {
    return;
  }

  // Check subscription limits for free tier
  const enrichCheck = canEnrich();
  if (!enrichCheck.allowed) {
    console.log('‚õî Enrichment limit reached for today');
    // Don't show prompt for every business - just skip silently
    // User will see the upgrade prompt if they manually try to enrich
    return;
  }

  const businessName = business.name || business.businessName;
  const location = `${business.city || ''} ${business.state || ''}`.trim();

  try {
    console.log(`üîç Enriching: ${businessName}`);
    let foundItems = [];

    // Record enrichment usage for free tier
    recordEnrichmentUsage();

    // Track usage (informational - Serper primary has 2,500/month shared)
    // No hard blocking - Serper will return errors when quota exhausted

    // 1. Search for website (if not already set)
    if (!business.website) {
      const websiteQuery = `${businessName} ${location}`;
      const website = await searchBusinessWebsite(websiteQuery, businessName);
      trackEnrichmentQuery(1);
      if (website) {
        business.website = website;
        foundItems.push('website');
        console.log(`‚úÖ Found website: ${website}`);
      }
    }

    // 2. Search for Facebook page (if not already set) - DISABLED: unreliable results
    if (ENABLE_SOCIAL_MEDIA_SEARCH && !business.facebook) {
      const fbQuery = `${businessName} ${location} site:facebook.com`;
      const fbResult = await searchBusinessWebsite(fbQuery, businessName);
      trackEnrichmentQuery(1);
      console.log(`üîç Facebook search result: ${fbResult || 'none'}`);
      // Validate: must be facebook.com and NOT instagram (Instagram uses /p/ for posts)
      if (fbResult && fbResult.includes('facebook.com') && !fbResult.includes('instagram.com')) {
        // Clean up the URL - try to get the page URL, not a post
        let cleanFbUrl = fbResult;
        // If it's a post URL, try to extract the page
        if (fbResult.includes('/posts/') || fbResult.includes('/photos/') || fbResult.includes('/videos/')) {
          const pageMatch = fbResult.match(/(https?:\/\/[^\/]*facebook\.com\/[^\/\?]+)/);
          if (pageMatch) {
            cleanFbUrl = pageMatch[1];
            console.log(`üîÑ Cleaned Facebook URL: ${cleanFbUrl}`);
          }
        }
        business.facebook = cleanFbUrl;
        foundItems.push('Facebook');
        console.log(`‚úÖ Found Facebook: ${cleanFbUrl}`);
      } else if (fbResult && fbResult.includes('/p/')) {
        // This is actually an Instagram URL, skip it
        console.log(`‚ö†Ô∏è Skipped Instagram URL in Facebook search: ${fbResult}`);
      } else if (fbResult) {
        console.log(`‚ö†Ô∏è Skipped non-Facebook URL: ${fbResult}`);
      }
    }

    // 3. Search for Instagram (if not already set) - DISABLED: unreliable results
    if (ENABLE_SOCIAL_MEDIA_SEARCH && !business.instagram) {
      const igQuery = `${businessName} ${location} site:instagram.com`;
      const igResult = await searchBusinessWebsite(igQuery, businessName);
      trackEnrichmentQuery(1);
      // Validate: must be instagram.com, NOT facebook, prefer profile URLs not posts
      if (igResult &&
          igResult.includes('instagram.com') &&
          !igResult.includes('facebook.com')) {
        // Try to extract profile URL if it's a post URL
        let cleanedUrl = igResult;
        if (igResult.includes('/p/') || igResult.includes('/reel/')) {
          // Extract username from post URL: instagram.com/username/p/xxx -> instagram.com/username
          const match = igResult.match(/instagram\.com\/([^\/\?]+)/);
          if (match && match[1] && !['p', 'reel', 'stories'].includes(match[1])) {
            cleanedUrl = `https://instagram.com/${match[1]}`;
            console.log(`üîÑ Converted Instagram post to profile: ${cleanedUrl}`);
          }
        }
        business.instagram = cleanedUrl;
        foundItems.push('Instagram');
        console.log(`‚úÖ Found Instagram: ${cleanedUrl}`);
      } else if (igResult) {
        console.log(`‚ö†Ô∏è Skipped invalid Instagram URL: ${igResult}`);
      }
    }

    business.enriched = true;

    if (foundItems.length > 0) {
      // Save kanban state with updated info
      saveKanban();

      // Re-render to show the updates
      renderKanban();

      toast(`üîç Found ${foundItems.join(', ')} for ${businessName}`, true);
    } else {
      console.log(`‚ö†Ô∏è No website/social found for ${businessName}`);
    }

  } catch (error) {
    console.warn('Enrichment failed:', error);
    business.enriched = true; // Mark as enriched to avoid retry
  }
}

/**
 * Enrich a single prospect from the Prospect Pool
 * Called when user clicks "Enrich" button on a card
 */
async function enrichSingleProspect(prospectId) {
  // Check enrichment limits for free tier
  const enrichCheck = canEnrich();
  if (!enrichCheck.allowed) {
    showUpgradePrompt(enrichCheck.message);
    return;
  }

  // Find the prospect in placesCache
  let prospect = null;
  let cacheKey = null;
  let isManualProspect = false;

  for (const key of Object.keys(placesCache.searches)) {
    const cached = placesCache.searches[key];
    if (cached.cachedData) {
      const found = cached.cachedData.find(b => b.placeId === prospectId);
      if (found) {
        prospect = found;
        cacheKey = key;
        break;
      }
    }
  }

  // Also check manual prospects
  if (!prospect) {
    prospect = prospectPoolState.manualProspects.find(p => p.placeId === prospectId || p.id === prospectId);
    if (prospect) isManualProspect = true;
  }

  if (!prospect) {
    toast('Could not find prospect to enrich', false);
    return;
  }

  const businessName = prospect.name || prospect.businessName || 'Unknown';
  const btn = document.getElementById(`enrich-btn-${prospectId}`);

  // Update button to show loading
  if (btn) {
    btn.disabled = true;
    btn.innerHTML = '‚è≥ Enriching...';
    btn.classList.add('opacity-60');
  }

  try {
    // Record enrichment usage
    recordEnrichmentUsage();

    const location = `${prospect.city || ''} ${prospect.state || ''}`.trim();
    let foundItems = [];

    // 1. Search for website if missing
    if (!prospect.website) {
      const websiteQuery = `${businessName} ${location}`;
      const website = await searchBusinessWebsite(websiteQuery, businessName);
      if (website) {
        prospect.website = website;
        foundItems.push('website');
      }
    }

    // 2. Scrape email from website if we have one
    if (prospect.website && !prospect.email) {
      try {
        const response = await fetch('/api/scrape-email', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ website: prospect.website, businessName })
        });
        const data = await response.json();
        if (data.primaryEmail) {
          prospect.email = data.primaryEmail;
          foundItems.push('email');
        }
      } catch (e) {
        console.warn('Email scrape failed:', e);
      }
    }

    // Mark as enriched
    prospect.enriched = true;

    // Calculate contact score
    let contactScore = 0;
    if (prospect.phone) contactScore += 3;
    if (prospect.email) contactScore += 4;
    if (prospect.website) contactScore += 2;
    if (prospect.facebook || prospect.instagram) contactScore += 1;
    prospect.contactScore = Math.min(contactScore, 10);

    // Save updated cache (different save path for manual vs cached prospects)
    if (isManualProspect) {
      await saveManualProspects();
    } else {
      await savePlacesCache();
    }

    // Re-render the pool to show updated card
    renderProspectPool();

    // Scroll to and highlight the enriched card after a short delay for DOM to update
    setTimeout(() => {
      // Find the card by prospect ID - it's now in the enriched section
      const enrichedCard = document.querySelector(`[data-place-id="${prospectId}"]`) ||
                          document.querySelector(`[onclick*="${prospectId}"]`);
      if (enrichedCard) {
        // Scroll into view with smooth animation
        enrichedCard.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // Add highlight animation
        enrichedCard.classList.add('ring-4', 'ring-emerald-400', 'ring-opacity-75');
        enrichedCard.style.transition = 'all 0.3s ease';

        // Remove highlight after 3 seconds
        setTimeout(() => {
          enrichedCard.classList.remove('ring-4', 'ring-emerald-400', 'ring-opacity-75');
        }, 3000);
      }
    }, 100);

    if (foundItems.length > 0) {
      toast(`‚úÖ Found ${foundItems.join(', ')} for ${businessName}`, true);
    } else {
      toast(`‚ö†Ô∏è No additional contact info found for ${businessName}`, false);
    }

  } catch (error) {
    console.error('Enrichment error:', error);
    prospect.enriched = true; // Mark as enriched to avoid retry
    toast(`‚ùå Enrichment failed for ${businessName}`, false);

    // Reset button
    if (btn) {
      btn.disabled = false;
      btn.innerHTML = 'üîç Enrich';
      btn.classList.remove('opacity-60');
    }
  }
}

// Expose to window
window.enrichSingleProspect = enrichSingleProspect;

/**
 * Re-enrich a prospect - clears previous data and searches again
 */
async function reEnrichProspect(prospectId) {
  // Find the prospect in placesCache or manual prospects
  let prospect = null;
  let cacheKey = null;
  let isManualProspect = false;

  for (const key of Object.keys(placesCache.searches)) {
    const cached = placesCache.searches[key];
    if (cached.cachedData) {
      const found = cached.cachedData.find(b => b.placeId === prospectId);
      if (found) {
        prospect = found;
        cacheKey = key;
        break;
      }
    }
  }

  if (!prospect) {
    prospect = prospectPoolState.manualProspects.find(p => p.placeId === prospectId || p.id === prospectId);
    if (prospect) isManualProspect = true;
  }

  if (!prospect) {
    toast('Could not find prospect to re-enrich', false);
    return;
  }

  const businessName = prospect.name || prospect.businessName || 'Unknown';

  // Clear previous enrichment data
  prospect.website = null;
  prospect.email = null;
  prospect.enriched = false;
  prospect.contactScore = 0;

  toast(`üîÑ Re-enriching ${businessName}...`, true);

  // Save cleared state (different save path for manual vs cached prospects)
  if (isManualProspect) {
    await saveManualProspects();
  } else {
    await savePlacesCache();
  }
  renderProspectPool();

  // Now run enrichment again (with small delay to allow UI to update)
  setTimeout(() => {
    enrichSingleProspect(prospectId);
  }, 100);
}

window.reEnrichProspect = reEnrichProspect;

/**
 * Enrich a business when moved from Prospect List to To Contact column
 * Runs Serper search + website scraping asynchronously
 */
async function enrichBusinessOnMove(lead) {
  const businessName = lead.businessName || lead.name || 'Unknown';
  const location = lead.address ? lead.address.split(',').slice(-2).join(',').trim() : '';

  console.log(`üéØ Enriching on move: ${businessName}`);
  toast(`üîç Enriching ${businessName}...`, true);

  try {
    // Search for website if missing
    if (!lead.website) {
      const websiteQuery = `${businessName} ${location} official website`;
      const website = await searchBusinessWebsite(websiteQuery, businessName);
      if (website && !website.includes('yelp.com') && !website.includes('facebook.com') && !website.includes('instagram.com')) {
        lead.website = website;
        console.log(`‚úÖ Found website: ${website}`);
      }
    }

    // Search for Facebook if missing - DISABLED: unreliable results
    if (ENABLE_SOCIAL_MEDIA_SEARCH && !lead.facebook) {
      const fbQuery = `${businessName} ${location} site:facebook.com`;
      const fbResult = await searchBusinessWebsite(fbQuery, businessName);
      if (fbResult && fbResult.includes('facebook.com') && !fbResult.includes('instagram.com')) {
        let cleanFbUrl = fbResult;
        if (fbResult.includes('/posts/') || fbResult.includes('/photos/')) {
          const pageMatch = fbResult.match(/(https?:\/\/[^\/]*facebook\.com\/[^\/\?]+)/);
          if (pageMatch) cleanFbUrl = pageMatch[1];
        }
        lead.facebook = cleanFbUrl;
        console.log(`‚úÖ Found Facebook: ${cleanFbUrl}`);
      }
    }

    // Search for Instagram if missing - DISABLED: unreliable results
    if (ENABLE_SOCIAL_MEDIA_SEARCH && !lead.instagram) {
      const igQuery = `${businessName} ${location} site:instagram.com`;
      const igResult = await searchBusinessWebsite(igQuery, businessName);
      if (igResult && igResult.includes('instagram.com') && !igResult.includes('facebook.com')) {
        let cleanedUrl = igResult;
        if (igResult.includes('/p/') || igResult.includes('/reel/')) {
          const match = igResult.match(/instagram\.com\/([^\/\?]+)/);
          if (match && match[1] && !['p', 'reel', 'stories'].includes(match[1])) {
            cleanedUrl = `https://instagram.com/${match[1]}`;
          }
        }
        lead.instagram = cleanedUrl;
        console.log(`‚úÖ Found Instagram: ${cleanedUrl}`);
      }
    }

    // Scrape website for email AND social links if we have a website
    if (lead.website) {
      const enrichedData = await fetchSmartEnrichment(lead.website, businessName);
      lead.email = lead.email || enrichedData.email || '';
      lead.facebook = lead.facebook || enrichedData.facebook || '';
      lead.instagram = lead.instagram || enrichedData.instagram || '';
      lead.linkedin = lead.linkedin || enrichedData.linkedin || '';
      lead.twitter = lead.twitter || enrichedData.twitter || '';
      lead.contactNames = enrichedData.contactNames || lead.contactNames || [];
      if (enrichedData.enriched) {
        lead.enriched = true;
        lead.pagesScraped = enrichedData.pagesScraped;
      }
    }

    lead.enriched = true;

    // Save and re-render to show new data
    await saveKanban();
    renderKanban();

    const foundItems = [];
    if (lead.website) foundItems.push('website');
    if (lead.facebook) foundItems.push('FB');
    if (lead.instagram) foundItems.push('IG');
    if (lead.email) foundItems.push('email');

    if (foundItems.length > 0) {
      toast(`‚úÖ Found ${foundItems.join(', ')} for ${businessName}`, true);
    } else {
      toast(`‚ö†Ô∏è No contact info found for ${businessName}`, false);
    }

  } catch (error) {
    console.error('Enrichment on move failed:', error);
    toast(`‚ö†Ô∏è Enrichment failed for ${businessName}`, false);
  }
}

/**
 * Deduplicate businesses by name - keeps the entry with most contact info
 * Chains with multiple locations are consolidated into one entry
 */
function deduplicateBusinesses(businesses) {
  if (!businesses || businesses.length === 0) return [];

  // Group by normalized business name
  const groups = {};
  businesses.forEach(biz => {
    // Normalize name: lowercase, trim, remove extra spaces
    const normalizedName = (biz.name || '').toLowerCase().trim().replace(/\s+/g, ' ');
    if (!groups[normalizedName]) {
      groups[normalizedName] = [];
    }
    groups[normalizedName].push(biz);
  });

  // For each group, keep the entry with the most contact info
  const deduplicated = [];
  Object.values(groups).forEach(group => {
    if (group.length === 1) {
      deduplicated.push(group[0]);
    } else {
      // Score each entry by contact info completeness
      const scored = group.map(biz => {
        let score = 0;
        if (biz.email) score += 3;
        if (biz.website && !biz.website.includes('facebook.com')) score += 2;
        if (biz.phone) score += 2;
        if (biz.facebook) score += 1;
        if (biz.instagram) score += 1;
        return { biz, score };
      });
      // Sort by score descending and keep the best one
      scored.sort((a, b) => b.score - a.score);
      const best = scored[0].biz;
      // Add note about multiple locations
      best.multipleLocations = group.length;
      deduplicated.push(best);
      console.log(`üìç Deduplicated "${best.name}": kept 1 of ${group.length} locations`);
    }
  });

  return deduplicated;
}

/**
 * Category Search Terms Mapping
 * Maps category values to arrays of search terms for more comprehensive results
 * Each category can have multiple search queries to catch variations in business naming
 */
const categorySearchTerms = {
  // AUTOMOTIVE - different naming conventions
  'car_repair': ['auto repair', 'car repair', 'mechanic', 'automotive repair'],
  'auto_body_shop': ['auto body shop', 'collision repair', 'body shop'],
  'auto_detailing': ['auto detailing', 'car detailing', 'car wash detailing'],
  'auto_glass': ['auto glass', 'windshield repair', 'car glass'],
  'car_dealer': ['car dealer', 'auto dealer', 'car dealership', 'used cars'],
  'car_wash': ['car wash', 'auto wash'],
  'tire_shop': ['tire shop', 'tire store', 'tires'],
  'towing_service': ['towing', 'tow truck', 'roadside assistance'],

  // CONSTRUCTION & CONTRACTORS
  'general_contractor': ['general contractor', 'home builder', 'construction company', 'remodeling contractor'],
  'electrician': ['electrician', 'electrical contractor', 'electrical services'],
  'plumber': ['plumber', 'plumbing', 'plumbing contractor'],
  'roofing_contractor': ['roofing', 'roofer', 'roofing contractor', 'roof repair'],
  'hvac_contractor': ['hvac', 'heating and cooling', 'air conditioning', 'furnace repair'],
  'painter': ['painter', 'painting contractor', 'house painter'],
  'landscaping': ['landscaping', 'landscaper', 'lawn care', 'landscape design'],
  'handyman': ['handyman', 'home repair', 'handyman services'],
  'flooring_contractor': ['flooring', 'floor installation', 'hardwood floors', 'carpet installation'],
  'kitchen_remodeling': ['kitchen remodeling', 'bathroom remodeling', 'kitchen and bath'],
  'window_installation': ['window installation', 'window replacement', 'windows and doors'],
  'fence_contractor': ['fence contractor', 'fence installation', 'fencing'],
  'concrete_contractor': ['concrete contractor', 'concrete work', 'masonry'],
  'deck_builder': ['deck builder', 'deck construction', 'patio builder'],
  'gutter_service': ['gutter installation', 'gutter repair', 'gutters'],
  'siding_contractor': ['siding contractor', 'siding installation', 'vinyl siding'],

  // HOME SERVICES
  'cleaning': ['cleaning service', 'house cleaning', 'maid service', 'janitorial'],
  'pest_control': ['pest control', 'exterminator', 'termite control'],
  'tree_service': ['tree service', 'tree removal', 'tree trimming', 'arborist'],
  'lawn_care': ['lawn care', 'lawn service', 'lawn mowing', 'yard maintenance'],
  'pool_service': ['pool service', 'pool cleaning', 'pool repair', 'swimming pool'],
  'pressure_washing': ['pressure washing', 'power washing'],
  'junk_removal': ['junk removal', 'hauling', 'trash removal'],
  'moving_company': ['moving company', 'movers', 'moving service'],
  'locksmith': ['locksmith', 'lock service', 'key service'],

  // FOOD & DINING
  'restaurant': ['restaurant', 'dining', 'family restaurant'],
  'pizza': ['pizza', 'pizzeria', 'pizza delivery'],
  'cafe': ['cafe', 'coffee shop', 'coffee house', 'bakery cafe'],
  'bar': ['bar', 'pub', 'tavern', 'sports bar'],
  'bakery': ['bakery', 'bakeries', 'cake shop'],
  'meal_delivery': ['catering', 'caterer', 'event catering'],

  // HEALTH & MEDICAL
  'dentist': ['dentist', 'dental', 'dental office', 'family dentist'],
  'doctor': ['doctor', 'physician', 'medical clinic', 'family doctor'],
  'chiropractor': ['chiropractor', 'chiropractic', 'spine care'],
  'veterinary_care': ['veterinarian', 'vet', 'animal hospital', 'pet clinic'],
  'optometrist': ['optometrist', 'eye doctor', 'vision care', 'eye care'],
  'pharmacy': ['pharmacy', 'drug store', 'apothecary'],
  'physiotherapist': ['physical therapy', 'physiotherapy', 'pt clinic'],
  'urgent_care': ['urgent care', 'walk-in clinic', 'immediate care'],

  // PROFESSIONAL SERVICES
  'accountant': ['accountant', 'cpa', 'accounting', 'bookkeeper', 'tax accountant'],
  'attorney': ['attorney', 'lawyer', 'law firm', 'legal services'],
  'insurance_agency': ['insurance', 'insurance agent', 'insurance agency'],
  'real_estate_agency': ['real estate', 'realtor', 'real estate agent', 'property management'],
  'financial_advisor': ['financial advisor', 'financial planner', 'wealth management'],
  'tax_service': ['tax preparation', 'tax service', 'tax preparer', 'income tax'],

  // PERSONAL SERVICES
  'hair_care': ['hair salon', 'hairdresser', 'beauty salon'],
  'barber': ['barber', 'barbershop', 'barber shop'],
  'beauty_salon': ['beauty salon', 'spa', 'nail salon', 'aesthetics'],
  'nail_salon': ['nail salon', 'manicure', 'pedicure', 'nails'],
  'gym': ['gym', 'fitness center', 'health club', 'fitness'],
  'yoga_studio': ['yoga', 'yoga studio', 'pilates'],
  'massage_therapy': ['massage', 'massage therapy', 'spa massage'],
  'dry_cleaning': ['dry cleaning', 'dry cleaner', 'laundry'],
  'dog_grooming': ['dog grooming', 'pet grooming', 'groomer'],

  // CHILDCARE
  'daycare': ['daycare', 'day care', 'childcare', 'child care', 'preschool', 'early childhood', 'nursery school'],

  // RETAIL
  'pet_store': ['pet store', 'pet shop', 'pet supplies'],
  'florist': ['florist', 'flower shop', 'flowers'],
  'jewelry_store': ['jewelry store', 'jeweler', 'jewelry shop'],
  'furniture_store': ['furniture store', 'furniture'],
  'hardware_store': ['hardware store', 'hardware', 'home improvement'],
  'liquor_store': ['liquor store', 'wine shop', 'beer store'],
  'bicycle_store': ['bike shop', 'bicycle store', 'cycling'],
  'sporting_goods': ['sporting goods', 'sports store', 'outdoor store']
};

/**
 * Get search terms for a category - returns array of terms to search
 */
function getSearchTermsForCategory(category) {
  // If we have mapped terms, use them
  if (categorySearchTerms[category]) {
    return categorySearchTerms[category];
  }
  // Otherwise, convert the category value to a search term
  // e.g., "car_repair" -> "car repair"
  const humanReadable = category.replace(/_/g, ' ');
  return [humanReadable];
}

/**
 * Search for businesses using HERE Places API
 * Now searches multiple terms per category for better coverage
 * Returns: name, address, phone, website
 * Cost: FREE (250,000/month)
 */
async function searchFoursquareBusinesses(zipCode, category, progressInfo = null) {
  try {
    const cacheKey = `${zipCode}-${category}`;

    // Check cache first (cached searches don't count against limits)
    if (placesCache.searches[cacheKey]) {
      const cached = placesCache.searches[cacheKey];
      const cacheDate = new Date(cached.cachedUntil);

      if (new Date() < cacheDate) {
        showSuccess('‚úÖ Using cached results');
        return cached.cachedData || cached.businesses || [];
      }
    }

    // Check subscription limits for free tier (only for non-cached searches)
    const zipCheck = canSearchZip(zipCode);
    if (!zipCheck.allowed) {
      showUpgradePrompt(zipCheck.message);
      return [];
    }

    const categoryCheck = canSearchCategory(category);
    if (!categoryCheck.allowed) {
      showUpgradePrompt(categoryCheck.message);
      return [];
    }

    // Record usage for free tier (only if this is a new search)
    if (!zipCheck.alreadySearched) {
      recordZipSearch(zipCode);
    }
    if (!categoryCheck.alreadySearched) {
      recordCategorySearch(category);
    }

    // Get all search terms for this category
    const searchTerms = getSearchTermsForCategory(category);
    const allBusinesses = [];
    const seenPlaceIds = new Set();

    showInfo(`üîç ProspectRadar‚Ñ¢ searching "${category}" in ${zipCode}... (${searchTerms.length} queries)`);

    // Search each term and combine results
    for (let i = 0; i < searchTerms.length; i++) {
      const term = searchTerms[i];

      try {
        const response = await fetch('/api/here-search', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            zipCode: zipCode,
            category: term,
            limit: 50
          })
        });

        if (response.ok) {
          const data = await response.json();
          const businesses = data.businesses || [];
          console.log(`üìç "${term}" returned ${businesses.length} businesses`);

          // Add unique businesses (dedupe by placeId)
          businesses.forEach(biz => {
            if (!seenPlaceIds.has(biz.placeId)) {
              seenPlaceIds.add(biz.placeId);
              // Store the original category for consistency
              biz.category = category;
              allBusinesses.push(biz);
            }
          });
        }
      } catch (termError) {
        console.warn(`‚ö†Ô∏è Search for "${term}" failed:`, termError.message);
      }

      // Small delay between requests to be nice to the API
      if (i < searchTerms.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }

    const rawBusinesses = allBusinesses;
    console.log(`‚úÖ Combined search returned ${rawBusinesses.length} unique businesses from ${searchTerms.length} queries`);

    // Deduplicate businesses with multiple locations (keep best contact info)
    const businesses = deduplicateBusinesses(rawBusinesses);
    if (businesses.length < rawBusinesses.length) {
      console.log(`üìç Deduplicated: ${rawBusinesses.length} ‚Üí ${businesses.length} unique businesses`);
    }

    // Log enrichment stats
    const withEmail = businesses.filter(b => b.email).length;
    const withWebsite = businesses.filter(b => b.website).length;
    const withFacebook = businesses.filter(b => b.facebook).length;
    const withInstagram = businesses.filter(b => b.instagram).length;

    console.log(`üìä Enrichment: ${withEmail} emails, ${withWebsite} websites, ${withFacebook} FB, ${withInstagram} IG`);

    // Cache results for 30 days
    const cachedUntil = new Date();
    cachedUntil.setDate(cachedUntil.getDate() + 30);

    placesCache.searches[cacheKey] = {
      cachedData: businesses,
      cachedUntil: cachedUntil.toISOString(),
      lastFetched: new Date().toISOString()
    };

    // Save cache to cloud
    await savePlacesCache();

    showSuccess(`‚úÖ Found ${businesses.length} businesses in ${zipCode}!`);

    return businesses;

  } catch (error) {
    console.error('ProspectRadar search error:', error);
    showError(`‚ùå Search failed: ${error.message}`);
    return [];
  }
}

// Legacy Yelp function - now redirects to Foursquare
async function searchYelpBusinesses(zipCode, category, progressInfo = null) {
  return await searchFoursquareBusinesses(zipCode, category, progressInfo);
}

/**
 * Search for businesses - uses Foursquare API (FREE)
 * Legacy name kept for compatibility with existing code
 */
async function searchPlaces(zipCode, category, progressInfo = null) {
  return await searchFoursquareBusinesses(zipCode, category, progressInfo);
}

// Alias for backward compatibility
const searchGooglePlaces = searchPlaces;

// Dead code removed - was ~860 lines of unused Google Places API code
// See git history if needed



// Fetch additional details for a place (phone, website, etc.)
async function fetchPlaceDetails(placeId) {
  try {
    await loadGoogleMapsAPI();

    return new Promise((resolve, reject) => {
      const service = new google.maps.places.PlacesService(document.createElement('div'));

      service.getDetails(
        {
          placeId: placeId,
          fields: [
            'formatted_phone_number',
            'international_phone_number',
            'website',
            'url',
            'price_level',
            'user_ratings_total',
            'editorial_summary',
            'reviews'
          ]
        },
        (place, status) => {
          if (status === google.maps.places.PlacesServiceStatus.OK) {
            const hasData = !!(place.formatted_phone_number || place.international_phone_number || place.website);

            // Extract owner/contact name from reviews (sometimes mentioned)
            let ownerName = '';
            if (place.reviews && place.reviews.length > 0) {
              // Look for owner responses or mentions in reviews
              for (const review of place.reviews) {
                if (review.author_name && review.author_name.includes('Owner')) {
                  ownerName = review.author_name.replace('Owner', '').trim();
                  break;
                }
              }
            }

            resolve({
              phone: place.formatted_phone_number || place.international_phone_number || '',
              website: place.website || '',
              email: '', // Will be enriched from website scraping
              facebook: '', // Will be enriched from website scraping
              instagram: '', // Will be enriched from website scraping
              linkedin: '',
              twitter: '',
              googleMapsUrl: place.url || '',
              priceLevel: place.price_level || 0, // 0-4 scale ($ to $$$$)
              reviewCount: place.user_ratings_total || 0,
              description: place.editorial_summary?.overview || '',
              ownerName: ownerName,
              enriched: hasData,
              cost: 0
            });
          } else {
            // Don't reject - just return empty data
            resolve({
              phone: '',
              website: '',
              email: '',
              facebook: '',
              instagram: '',
              linkedin: '',
              twitter: '',
              googleMapsUrl: '',
              priceLevel: 0,
              reviewCount: 0,
              description: '',
              ownerName: '',
              enriched: false,
              cost: 0
            });
          }
        }
      );
    });
  } catch(err) {
    console.error('Error fetching place details:', err);
    return { phone: '', website: '', email: '', facebook: '', instagram: '', googleMapsUrl: '', openingHours: [], enriched: false, cost: 0 };
  }
}

// Smart Social Media Guessing - FREE, client-side only
// Generates probable social media URLs based on business name and website
function guessSocialMediaLinks(businessName, website) {
  // Clean business name for social media handles
  const cleanName = businessName
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '') // Remove special chars
    .replace(/\s+/g, ''); // Remove spaces

  // Try to extract domain name as alternative handle
  let domainHandle = '';
  if (website) {
    try {
      const url = new URL(website.startsWith('http') ? website : `https://${website}`);
      domainHandle = url.hostname
        .replace('www.', '')
        .replace(/\.(com|net|org|co|ca|us)$/i, '')
        .replace(/[^a-z0-9]/g, '');
    } catch (e) {
      // Invalid URL, skip domain extraction
    }
  }

  // Common variations to try
  const handles = [
    cleanName, // adamspizza
    domainHandle, // adamspizza (from adamspizza.com)
    businessName.toLowerCase().replace(/\s+/g, ''), // adams pizza -> adamspizza
    businessName.toLowerCase().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ''), // adam's pizza -> adamspizza
  ].filter(h => h && h.length > 0); // Remove empty

  // Remove duplicates
  const uniqueHandles = [...new Set(handles)];

  // Generate probable URLs
  return {
    instagram: uniqueHandles.map(h => `https://instagram.com/${h}`),
    facebook: uniqueHandles.map(h => `https://facebook.com/${h}`),
    twitter: uniqueHandles.map(h => `https://twitter.com/${h}`),
    linkedin: uniqueHandles.map(h => `https://linkedin.com/company/${h}`)
  };
}

// Verify if a social media URL actually exists
// Uses HEAD request to check without downloading content
async function verifySocialMediaUrl(url) {
  try {
    // Use fetch with no-cors mode to avoid CORS issues
    // This will return opaque response but we can check if it loads
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout

    const response = await fetch(url, {
      method: 'HEAD',
      mode: 'no-cors',
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    // In no-cors mode, we get an opaque response
    // If it doesn't throw, the URL likely exists
    return true;

  } catch (error) {
    // URL doesn't exist or timed out
    return false;
  }
}

// Verify all guessed social media links and return only valid ones
async function verifyAndFilterSocialLinks(guessedLinks) {
  const verified = {
    instagram: '',
    facebook: '',
    linkedin: '',
    twitter: ''
  };

  // Check each platform's variations in order of likelihood
  for (const [platform, urls] of Object.entries(guessedLinks)) {
    for (const url of urls) {
      const isValid = await verifySocialMediaUrl(url);
      if (isValid) {
        verified[platform] = url;
        console.log(`‚úÖ Found valid ${platform}: ${url}`);
        break; // Stop checking variations once we find a valid one
      }
    }
  }

  return verified;
}

// Fetch website HTML with fallback CORS proxies
async function fetchWithFallbackProxies(url, timeout = 10000) {
  // List of CORS proxies to try (in order)
  // corsproxy.io primary (100% success rate), allorigins.win backup (59% success rate)
  const proxies = [
    (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
    (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
    (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
  ];

  for (let i = 0; i < proxies.length; i++) {
    const proxyUrl = proxies[i](url);
    const proxyName = ['corsproxy.io', 'allorigins.win', 'codetabs.com'][i];

    try {
      console.log(`üåê Trying proxy ${i + 1}/${proxies.length} (${proxyName}) for: ${url}`);

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);

      const response = await fetch(proxyUrl, {
        signal: controller.signal
      });

      clearTimeout(timeoutId);

      if (response.ok) {
        const html = await response.text();
        console.log(`‚úÖ Success with ${proxyName} - fetched ${html.length} bytes`);
        return html;
      } else {
        console.warn(`‚ùå ${proxyName} returned status ${response.status}`);
      }
    } catch (err) {
      if (err.name === 'AbortError') {
        console.warn(`‚è±Ô∏è ${proxyName} timeout after ${timeout}ms`);
      } else {
        console.warn(`‚ùå ${proxyName} error: ${err.message}`);
      }
    }
  }

  // All proxies failed
  throw new Error('All CORS proxies failed');
}

// Extract email from website using CORS proxy
async function extractEmailFromWebsite(websiteUrl) {
  if (!websiteUrl) return '';

  try {
    // Ensure URL has protocol
    const url = websiteUrl.startsWith('http') ? websiteUrl : `https://${websiteUrl}`;

    console.log(`üìß Attempting to extract email from: ${url}`);

    // Use fallback CORS proxies to fetch the website content
    const html = await fetchWithFallbackProxies(url, 10000);

    // Email regex patterns (ordered by specificity)
    const emailPatterns = [
      // mailto: links
      /mailto:([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/gi,
      // Email addresses in text
      /\b[a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+\b/gi
    ];

    const emails = new Set();

    // Try each pattern
    for (const pattern of emailPatterns) {
      const matches = html.matchAll(pattern);
      for (const match of matches) {
        const email = match[1] || match[0];

        // Filter out common non-business emails and generic placeholders
        const invalidDomains = [
          'example.com',
          'domain.com',
          'email.com',
          'sentry.io',
          'facebook.com',
          'google.com',
          'twitter.com',
          'linkedin.com',
          'instagram.com',
          'wix.com',
          'squarespace.com',
          'wordpress.com'
        ];

        // Filter out generic/placeholder email prefixes
        const genericPrefixes = [
          'office@',
          'info@',
          'contact@',
          'admin@',
          'support@',
          'sales@',
          'hello@',
          'mail@',
          'email@',
          'noreply@',
          'no-reply@',
          'webmaster@',
          'postmaster@'
        ];

        const domain = email.split('@')[1];
        const lowerEmail = email.toLowerCase();

        // Skip if domain is invalid
        if (invalidDomains.some(d => domain && domain.includes(d))) {
          return;
        }

        // Skip if it's a generic placeholder (only if it matches exactly)
        // But allow them if they're on the business's own domain
        const isGenericPrefix = genericPrefixes.some(prefix => lowerEmail.startsWith(prefix));

        // Allow generic prefixes if the domain looks like a business domain
        // (not a generic email provider like gmail, yahoo, etc.)
        const isBusinessDomain = !['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'aol.com'].includes(domain);

        if (!isGenericPrefix || isBusinessDomain) {
          emails.add(lowerEmail);
        }
      }
    }

    // Return first found email (most likely to be legitimate)
    const emailArray = Array.from(emails);
    if (emailArray.length > 0) {
      console.log(`‚úÖ Found email: ${emailArray[0]}`);
      return emailArray[0];
    }

    console.log(`‚ùå No email found on website`);
    return '';

  } catch (error) {
    if (error.name === 'AbortError') {
      console.warn(`Email extraction timeout for ${websiteUrl}`);
    } else {
      console.warn(`Email extraction error for ${websiteUrl}:`, error.message);
    }
    return '';
  }
}

// Extract social media links from website HTML (REAL links only, no guessing!)
async function extractSocialMediaFromWebsite(websiteUrl) {
  if (!websiteUrl) return { facebook: '', instagram: '', linkedin: '', twitter: '' };

  try {
    // Ensure URL has protocol
    const url = websiteUrl.startsWith('http') ? websiteUrl : `https://${websiteUrl}`;

    console.log(`üîó Attempting to extract social media from: ${url}`);

    // Use fallback CORS proxies to fetch the website content
    const html = await fetchWithFallbackProxies(url, 10000);

    // Social media link patterns (look for actual href links in HTML)
    // Updated to handle various formats: usernames, numeric IDs, profile URLs, page URLs
    const facebookPattern = /href=["'](https?:\/\/(?:www\.)?facebook\.com\/(?:profile\.php\?id=)?[a-zA-Z0-9._\-\/]+?)["']/gi;
    const instagramPattern = /href=["'](https?:\/\/(?:www\.)?instagram\.com\/[a-zA-Z0-9._]+\/?)["']/gi;
    const linkedinPattern = /href=["'](https?:\/\/(?:www\.)?linkedin\.com\/(?:company|in)\/[a-zA-Z0-9._\-]+\/?)["']/gi;
    const twitterPattern = /href=["'](https?:\/\/(?:www\.)?(?:twitter\.com|x\.com)\/[a-zA-Z0-9._]+\/?)["']/gi;

    // Extract links
    const facebookMatches = Array.from(html.matchAll(facebookPattern));
    const instagramMatches = Array.from(html.matchAll(instagramPattern));
    const linkedinMatches = Array.from(html.matchAll(linkedinPattern));
    const twitterMatches = Array.from(html.matchAll(twitterPattern));

    console.log(`üîç Found ${facebookMatches.length} Facebook, ${instagramMatches.length} Instagram, ${linkedinMatches.length} LinkedIn, ${twitterMatches.length} Twitter links`);

    // Filter out common non-business pages (share buttons, generic pages, etc.)
    const excludePatterns = [
      /facebook\.com\/sharer/i,
      /facebook\.com\/share/i,
      /facebook\.com\/pages/i,
      /instagram\.com\/explore/i,
      /instagram\.com\/accounts/i,
      /twitter\.com\/share/i,
      /twitter\.com\/intent/i,
      /linkedin\.com\/shareArticle/i,
      /linkedin\.com\/sharing/i
    ];

    const isValidLink = (url) => {
      return !excludePatterns.some(pattern => pattern.test(url));
    };

    // Get first valid match for each platform (most likely to be the business's official page)
    const facebook = facebookMatches.find(m => isValidLink(m[1]))?.[1] || '';
    const instagram = instagramMatches.find(m => isValidLink(m[1]))?.[1] || '';
    const linkedin = linkedinMatches.find(m => isValidLink(m[1]))?.[1] || '';
    const twitter = twitterMatches.find(m => isValidLink(m[1]))?.[1] || '';

    // Log what we found
    const foundPlatforms = [];
    if (facebook) {
      foundPlatforms.push('Facebook');
      console.log(`  ‚úì Facebook: ${facebook}`);
    }
    if (instagram) {
      foundPlatforms.push('Instagram');
      console.log(`  ‚úì Instagram: ${instagram}`);
    }
    if (linkedin) {
      foundPlatforms.push('LinkedIn');
      console.log(`  ‚úì LinkedIn: ${linkedin}`);
    }
    if (twitter) {
      foundPlatforms.push('Twitter/X');
      console.log(`  ‚úì Twitter: ${twitter}`);
    }

    if (foundPlatforms.length > 0) {
      console.log(`‚úÖ Found social media: ${foundPlatforms.join(', ')}`);
    } else {
      console.log(`‚ùå No social media links found on website`);
    }

    return { facebook, instagram, linkedin, twitter };

  } catch (error) {
    if (error.name === 'AbortError') {
      console.warn(`Social media extraction timeout for ${websiteUrl}`);
    } else {
      console.warn(`Social media extraction error for ${websiteUrl}:`, error.message);
    }
    return { facebook: '', instagram: '', linkedin: '', twitter: '' };
  }
}

// 9x12Pro Smart Enrichment - Our custom website scraper
// Scrapes business websites for emails, social media, contact names
// FREE - no API costs, uses our own serverless function
async function fetchSmartEnrichment(websiteUrl, businessName) {
  try {
    console.log('üéØ Smart enrichment for:', businessName, '- Website:', websiteUrl);

    // Call our Vercel serverless function
    const response = await fetch('/api/enrich-contact', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        websiteUrl: websiteUrl,
        businessName: businessName
      })
    });

    if (!response.ok) {
      console.warn('Smart enrichment API failed:', await response.text());
      return {
        email: '',
        phone: '',
        facebook: '',
        instagram: '',
        linkedin: '',
        twitter: '',
        contactNames: [],
        enriched: false,
        source: '9x12pro-scraper',
        pagesScraped: 0
      };
    }

    const data = await response.json();
    console.log('‚úÖ Smart enrichment data:', data);

    return data;

  } catch(err) {
    console.error('Error fetching smart enrichment:', err);
    return {
      email: '',
      phone: '',
      facebook: '',
      instagram: '',
      linkedin: '',
      twitter: '',
      contactNames: [],
      enriched: false,
      source: '9x12pro-scraper',
      pagesScraped: 0
    };
  }
}

/* ========= PROSPECT SCORING & ENRICHMENT QUEUE ========= */

/**
 * Calculate Prospect Score (0-100)
 * Determines how likely a business is to buy advertising
 * Based on: business type, review count, rating, online presence
 */
function calculateProspectScore(business) {
  let score = 0;

  // SIMPLIFIED LEAD SCORING - Based on real-world 9x12 sales experience
  // Focus: Service businesses, established but not too big, missing online presence

  // 1. BUSINESS TYPE (0-40 points) - Most important factor
  // Service businesses with recurring customers are IDEAL for local advertising
  const serviceTypes = [
    'plumber', 'plumbing', 'electrician', 'electrical', 'hvac', 'heating', 'cooling', 'air_conditioning',
    'roofing', 'roofer', 'contractor', 'general_contractor', 'remodeling',
    'landscaper', 'landscaping', 'lawn_care', 'lawn_service', 'tree_service',
    'pest_control', 'exterminator', 'cleaning_service', 'carpet_cleaning',
    'painter', 'painting', 'flooring', 'tile', 'concrete',
    'garage_door', 'window', 'gutter', 'siding',
    'auto_repair', 'car_repair', 'mechanic', 'auto_body', 'tire',
    'restaurant', 'cafe', 'bakery', 'pizza',
    'hair_salon', 'beauty_salon', 'barber', 'spa', 'nail_salon',
    'gym', 'fitness', 'yoga', 'massage',
    'dentist', 'dental', 'chiropractor', 'physical_therapy',
    'real_estate', 'insurance', 'lawyer', 'attorney', 'accountant'
  ];

  const types = business.types || [];
  const isService = types.some(type =>
    serviceTypes.some(serviceType => type.toLowerCase().includes(serviceType))
  );
  score += isService ? 40 : 10; // Big penalty for non-service businesses

  // 2. REVIEW COUNT (0-30 points) - The SWEET SPOT
  // 20-200 reviews = Established enough to have budget, small enough to need help
  const reviews = business.userRatingsTotal || 0;
  if (reviews >= 20 && reviews <= 200) {
    score += 30; // PERFECT - This is your target market
  } else if (reviews >= 10 && reviews < 20) {
    score += 20; // Good - Growing business
  } else if (reviews > 200 && reviews < 500) {
    score += 10; // Too established, probably has marketing figured out
  } else if (reviews >= 500) {
    score += 0; // Large chain, wrong target
  } else {
    score += 5; // Very new, might not have budget yet
  }

  // 3. GAP OPPORTUNITY (0-20 points) - Missing online presence
  // If they don't have strong digital, they NEED traditional marketing like postcards
  const hasWebsite = !!business.website;
  const hasSocial = !!(business.facebook || business.instagram);

  if (!hasWebsite) score += 10; // No website = Big gap
  if (!hasSocial) score += 10; // No social = Big gap

  // 4. RATING (0-10 points) - Room for improvement
  // 4.0-4.5 stars = Good but not great, need to compete harder
  const rating = business.rating || 0;
  if (rating >= 4.0 && rating <= 4.5) {
    score += 10; // Perfect - They're good but have competition pressure
  } else if (rating >= 3.5 && rating < 4.0) {
    score += 8; // Lower rating = Need to win back customers
  } else if (rating > 4.5) {
    score += 5; // High rating is good, but less urgency
  } else {
    score += 0; // Very low or no rating
  }

  return Math.min(score, 100); // Cap at 100
}

/**
 * Calculate Contact Score (0-10)
 * Measures how many contact methods are available
 */
function calculateContactScore(business) {
  let score = 0;

  if (business.phone) score += 2;
  if (business.email) score += 2;
  if (business.website) score += 2;
  if (business.facebook) score += 1;
  if (business.instagram) score += 1;
  if (business.linkedin) score += 1;
  if (business.twitter) score += 1;

  return Math.min(score, 10);
}

/**
 * Get score category and badge
 */
function getScoreCategory(score) {
  if (score >= 80) return { label: 'HOT LEAD', emoji: 'üî•', color: 'red' };
  if (score >= 60) return { label: 'WARM LEAD', emoji: '‚≠ê', color: 'orange' };
  if (score >= 40) return { label: 'COLD LEAD', emoji: '‚ùÑÔ∏è', color: 'blue' };
  return { label: 'LOW PRIORITY', emoji: 'üí§', color: 'gray' };
}

/**
 * EnrichmentQueue - Background enrichment processor
 * Processes businesses in order of prospect score priority
 */
class EnrichmentQueue {
  constructor() {
    this.queue = [];
    this.processing = [];
    this.completed = [];
    this.failed = [];
    this.concurrency = 3; // Process 3 at a time
    this.isRunning = false;
  }

  /**
   * Add businesses to enrichment queue
   * Automatically sorts by priority score (high to low)
   */
  async add(businesses) {
    // Sort by priority score (high to low)
    const sorted = businesses
      .filter(b => b.website && !b.enriched) // Only enrich businesses with websites that haven't been enriched
      .map(b => ({
        ...b,
        leadScore: b.leadScore || calculateProspectScore(b)
      }))
      .sort((a, b) => b.leadScore - a.leadScore);

    console.log(`üìã Adding ${sorted.length} businesses to enrichment queue (sorted by priority)`);

    this.queue.push(...sorted);

    if (!this.isRunning) {
      this.processQueue();
    }
  }

  /**
   * Process queue with concurrency control
   */
  async processQueue() {
    this.isRunning = true;

    while (this.queue.length > 0 || this.processing.length > 0) {
      // Start new enrichments up to concurrency limit
      while (this.processing.length < this.concurrency && this.queue.length > 0) {
        const business = this.queue.shift();
        this.processing.push(business);
        this.enrichOne(business); // Don't await - run in parallel
      }

      // Wait a bit before checking again
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    this.isRunning = false;
    console.log(`‚úÖ Enrichment queue completed: ${this.completed.length} successful, ${this.failed.length} failed`);
  }

  /**
   * Enrich a single business
   */
  async enrichOne(business) {
    try {
      console.log(`üéØ Enriching: ${business.name} (Score: ${business.leadScore})`);

      // Update UI to show enriching status
      this.updateBusinessCard(business.placeId, { status: 'enriching' });

      // Fetch enrichment data
      const enrichedData = await fetchSmartEnrichment(business.website, business.name);

      // Merge enriched data with existing business data
      // IMPORTANT: Preserve existing data, only add new data from enrichment
      const enrichedBusiness = {
        ...business,
        email: enrichedData.email || business.email || '',
        phone: business.phone || enrichedData.phone || '',
        facebook: enrichedData.facebook || business.facebook || '',
        instagram: enrichedData.instagram || business.instagram || '',
        linkedin: enrichedData.linkedin || business.linkedin || '',
        twitter: enrichedData.twitter || business.twitter || '',
        contactNames: enrichedData.contactNames?.length > 0 ? enrichedData.contactNames : (business.contactNames || []),
        enriched: true,
        enrichmentSource: '9x12pro-scraper',
        pagesScraped: enrichedData.pagesScraped || 0,
        contactScore: calculateContactScore({
          phone: business.phone || enrichedData.phone,
          email: enrichedData.email || business.email,
          website: business.website,
          facebook: enrichedData.facebook || business.facebook,
          instagram: enrichedData.instagram || business.instagram,
          linkedin: enrichedData.linkedin || business.linkedin,
          twitter: enrichedData.twitter || business.twitter
        })
      };

      // Recalculate lead score with enriched data
      enrichedBusiness.leadScore = calculateProspectScore(enrichedBusiness);

      // Update UI with enriched data
      this.updateBusinessCard(business.placeId, { status: 'enriched', data: enrichedBusiness });

      // Move from processing to completed
      this.processing = this.processing.filter(b => b.placeId !== business.placeId);
      this.completed.push(enrichedBusiness);

      console.log(`‚úÖ Enriched: ${business.name} - Contact Score: ${enrichedBusiness.contactScore}/10`);

    } catch (err) {
      console.error(`‚ùå Enrichment failed for ${business.name}:`, err);

      // Update UI to show failed status
      this.updateBusinessCard(business.placeId, { status: 'failed' });

      // Move from processing to failed
      this.processing = this.processing.filter(b => b.placeId !== business.placeId);
      this.failed.push(business);
    }
  }

  /**
   * Update business card in UI (both Prospect Pool and Kanban)
   */
  updateBusinessCard(placeId, update) {
    // Update in Prospect Pool
    const poolCard = document.querySelector(`.prospect-card[data-place-id="${placeId}"]`);
    if (poolCard && update.status) {
      const statusIndicator = poolCard.querySelector('.enrichment-status');
      if (statusIndicator) {
        if (update.status === 'enriching') {
          statusIndicator.innerHTML = '<span class="text-xs text-blue-600">üéØ Enriching...</span>';
        } else if (update.status === 'enriched' && update.data) {
          // Update card with enriched data
          this.renderEnrichedCard(poolCard, update.data);
        } else if (update.status === 'failed') {
          statusIndicator.innerHTML = '<span class="text-xs text-red-600">‚ùå Failed</span>';
        }
      }
    }

    // Update in Kanban if exists
    const kanbanCard = document.querySelector(`.kanban-business-card[data-place-id="${placeId}"]`);
    if (kanbanCard && update.status === 'enriched' && update.data) {
      this.renderEnrichedKanbanCard(kanbanCard, update.data);
    }

    // Update in prospectPoolState
    if (update.status === 'enriched' && update.data) {
      const poolIndex = prospectPoolState.prospects.findIndex(p => p.placeId === placeId);
      if (poolIndex !== -1) {
        prospectPoolState.prospects[poolIndex] = update.data;
      }
    }
  }

  /**
   * Render enriched prospect pool card
   */
  renderEnrichedCard(cardElement, business) {
    const scoreCategory = getScoreCategory(business.leadScore);

    // Update score badge
    const scoreBadge = cardElement.querySelector('.score-badge');
    if (scoreBadge) {
      scoreBadge.innerHTML = `
        <span class="text-${scoreCategory.color}-600 font-bold">${scoreCategory.emoji} ${scoreCategory.label}</span>
        <span class="text-gray-600">Score: ${business.leadScore}/100</span>
      `;
    }

    // Update enrichment status
    const statusIndicator = cardElement.querySelector('.enrichment-status');
    if (statusIndicator) {
      statusIndicator.innerHTML = `
        <span class="text-xs text-green-600">‚úÖ Enriched</span>
        <span class="text-xs text-gray-600">Contact Score: ${business.contactScore}/10</span>
      `;
    }

    // Update contact methods
    const contactMethods = cardElement.querySelector('.contact-methods');
    if (contactMethods) {
      let methods = [];
      if (business.phone) methods.push(`<span title="Phone">‚òéÔ∏è</span>`);
      if (business.email) methods.push(`<span title="Email">‚úâÔ∏è</span>`);
      if (business.website) methods.push(`<span title="Website">üåê</span>`);
      if (business.facebook) methods.push(`<span title="Facebook">üìò</span>`);
      if (business.instagram) methods.push(`<span title="Instagram">üì∑</span>`);
      if (business.linkedin) methods.push(`<span title="LinkedIn">üíº</span>`);
      if (business.twitter) methods.push(`<span title="Twitter">üê¶</span>`);

      contactMethods.innerHTML = methods.join(' ');
    }
  }

  /**
   * Render enriched kanban card
   */
  renderEnrichedKanbanCard(cardElement, business) {
    // Similar to renderEnrichedCard but for kanban layout
    // Update any enriched data display in kanban cards
    const contactInfo = cardElement.querySelector('.contact-info');
    if (contactInfo && business.email) {
      contactInfo.innerHTML += `<div class="text-xs text-gray-600">‚úâÔ∏è ${business.email}</div>`;
    }
  }

  /**
   * Get queue stats
   */
  getStats() {
    return {
      queued: this.queue.length,
      processing: this.processing.length,
      completed: this.completed.length,
      failed: this.failed.length,
      isRunning: this.isRunning
    };
  }

  /**
   * Clear queue
   */
  clear() {
    this.queue = [];
    this.processing = [];
    this.completed = [];
    this.failed = [];
    this.isRunning = false;
  }
}

// Global enrichment queue instance
const enrichmentQueue = new EnrichmentQueue();

/**
 * Re-enrich pipeline businesses that are missing contact data
 * This restores data that may have been lost due to the enrichment bug
 * Fetches fresh data from Serper (website, FB, IG) and scrapes for email
 */
async function reEnrichPipelineBusinesses() {
  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign board found', false);
    return;
  }

  // Collect all businesses from all columns
  const allBusinesses = [];
  Object.keys(board.columns || {}).forEach(colKey => {
    const column = board.columns[colKey];
    if (Array.isArray(column)) {
      column.forEach((business, index) => {
        if (business && business.businessName) {
          allBusinesses.push({ business, colKey, index });
        }
      });
    }
  });

  // Find businesses missing contact data (candidates for re-enrichment)
  const needsEnrichment = allBusinesses.filter(({ business }) => {
    // Missing email OR missing social media
    const missingEmail = !business.email;
    const missingSocial = !business.facebook && !business.instagram;
    // Has a name we can search for
    const hasName = business.businessName && business.businessName !== 'Unknown Business';
    return hasName && (missingEmail || missingSocial);
  });

  if (needsEnrichment.length === 0) {
    toast('All businesses already have contact data!', true);
    return;
  }

  const confirmMsg = `Found ${needsEnrichment.length} businesses missing contact data.\n\nThis will use Serper API credits to search for:\n- Business websites\n- Facebook pages\n- Instagram profiles\n- Emails (from website scraping)\n\nProceed with re-enrichment?`;

  if (!confirm(confirmMsg)) {
    return;
  }

  // Show progress
  const progressToast = document.createElement('div');
  progressToast.id = 're-enrich-progress';
  progressToast.style.cssText = `
    position: fixed;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 16px 24px;
    border-radius: 12px;
    font-weight: bold;
    z-index: 99999;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  `;
  progressToast.textContent = `Re-enriching 0/${needsEnrichment.length}...`;
  document.body.appendChild(progressToast);

  let enrichedCount = 0;
  let foundData = { websites: 0, emails: 0, facebook: 0, instagram: 0 };

  for (let i = 0; i < needsEnrichment.length; i++) {
    const { business, colKey, index } = needsEnrichment[i];
    const businessName = business.businessName;
    const location = business.address ? business.address.split(',').slice(-2).join(',').trim() : (business.town || '');

    progressToast.textContent = `Re-enriching ${i + 1}/${needsEnrichment.length}: ${businessName.substring(0, 30)}...`;

    try {
      // Search for website if missing
      if (!business.website) {
        const websiteQuery = `${businessName} ${location} official website`;
        const website = await searchBusinessWebsite(websiteQuery, businessName);
        if (website && !website.includes('yelp.com') && !website.includes('facebook.com') && !website.includes('instagram.com')) {
          business.website = website;
          foundData.websites++;
          console.log(`‚úÖ Found website for ${businessName}: ${website}`);
        }
      }

      // Search for Facebook if missing - DISABLED: unreliable results
      if (ENABLE_SOCIAL_MEDIA_SEARCH && !business.facebook) {
        const fbQuery = `${businessName} ${location} site:facebook.com`;
        const fbResult = await searchBusinessWebsite(fbQuery, businessName);
        if (fbResult && fbResult.includes('facebook.com') && !fbResult.includes('instagram.com')) {
          let cleanFbUrl = fbResult;
          if (fbResult.includes('/posts/') || fbResult.includes('/photos/')) {
            const pageMatch = fbResult.match(/(https?:\/\/[^\/]*facebook\.com\/[^\/\?]+)/);
            if (pageMatch) cleanFbUrl = pageMatch[1];
          }
          business.facebook = cleanFbUrl;
          foundData.facebook++;
          console.log(`‚úÖ Found Facebook for ${businessName}: ${cleanFbUrl}`);
        }
      }

      // Search for Instagram if missing - DISABLED: unreliable results
      if (ENABLE_SOCIAL_MEDIA_SEARCH && !business.instagram) {
        const igQuery = `${businessName} ${location} site:instagram.com`;
        const igResult = await searchBusinessWebsite(igQuery, businessName);
        if (igResult && igResult.includes('instagram.com') && !igResult.includes('facebook.com')) {
          let cleanedUrl = igResult;
          if (igResult.includes('/p/') || igResult.includes('/reel/')) {
            const match = igResult.match(/instagram\.com\/([^\/\?]+)/);
            if (match && match[1] && !['p', 'reel', 'stories'].includes(match[1])) {
              cleanedUrl = `https://instagram.com/${match[1]}`;
            }
          }
          business.instagram = cleanedUrl;
          foundData.instagram++;
          console.log(`‚úÖ Found Instagram for ${businessName}: ${cleanedUrl}`);
        }
      }

      // Scrape website for email AND social links if we have a website
      if (business.website) {
        const enrichedData = await fetchSmartEnrichment(business.website, businessName);
        if (enrichedData.email) {
          business.email = enrichedData.email;
          foundData.emails++;
          console.log(`‚úÖ Found email for ${businessName}: ${enrichedData.email}`);
        }
        // Also grab any social links found on the website
        if (!business.facebook && enrichedData.facebook) {
          business.facebook = enrichedData.facebook;
          foundData.facebook++;
        }
        if (!business.instagram && enrichedData.instagram) {
          business.instagram = enrichedData.instagram;
          foundData.instagram++;
        }
        if (!business.linkedin && enrichedData.linkedin) {
          business.linkedin = enrichedData.linkedin;
        }
        if (!business.twitter && enrichedData.twitter) {
          business.twitter = enrichedData.twitter;
        }
      }

      // Update the business in the board
      board.columns[colKey][index] = business;
      enrichedCount++;

      // Small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 500));

    } catch (err) {
      console.error(`Failed to re-enrich ${businessName}:`, err);
    }
  }

  // Save the updated board
  await saveCampaignBoards();

  // Remove progress toast
  progressToast.remove();

  // Show results
  const resultMsg = `Re-enrichment complete!\n\n` +
    `Processed: ${enrichedCount} businesses\n` +
    `Found:\n` +
    `  üåê ${foundData.websites} websites\n` +
    `  üìß ${foundData.emails} emails\n` +
    `  üìò ${foundData.facebook} Facebook pages\n` +
    `  üì∑ ${foundData.instagram} Instagram profiles`;

  alert(resultMsg);
  toast(`‚úÖ Re-enriched ${enrichedCount} businesses!`, true);

  // Refresh the UI
  renderKanban();
}

// Expose globally so it can be called from console or UI
window.reEnrichPipelineBusinesses = reEnrichPipelineBusinesses;

async function runAutoPopulate() {
  const zipCode = document.getElementById('autoPopZipCode').value.trim();
  const category = document.getElementById('autoPopCategory').value;
  const radius = parseInt(document.getElementById('autoPopRadius').value);

  // Validation
  if (!zipCode || !/^\d{5}$/.test(zipCode)) {
    toast('Please enter a valid 5-digit zip code', false);
    return;
  }

  if (!category) {
    toast('Please select a business category', false);
    return;
  }

  // Disable button during search
  const btn = document.getElementById('btnRunAutoPopulate');
  const originalText = btn.innerHTML;
  btn.disabled = true;
  btn.innerHTML = '‚è≥ Searching...';

  try {
    const businesses = await searchGooglePlaces(zipCode, category, radius);

    if (businesses.length === 0) {
      toast('No businesses found in this area', false);
      btn.disabled = false;
      btn.innerHTML = originalText;
      return;
    }

    // HYBRID AUTO-ENRICHMENT STRATEGY
    // AUTO-ENRICHMENT - ENRICH ALL BUSINESSES
    const businessesWithWebsites = businesses.filter(b => b.website && !b.enriched);
    console.log(`üéØ Enriching ${businessesWithWebsites.length} businesses...`);

    if (businessesWithWebsites.length > 0) {
      // Enrich ALL businesses with websites - PARALLEL processing (4 at a time)
      const BATCH_SIZE = 4;
      let enrichedCount = 0;

      for (let batchStart = 0; batchStart < businessesWithWebsites.length; batchStart += BATCH_SIZE) {
        const batch = businessesWithWebsites.slice(batchStart, batchStart + BATCH_SIZE);
        btn.innerHTML = `üéØ Enriching batch ${Math.floor(batchStart / BATCH_SIZE) + 1}... (${Math.min(batchStart + BATCH_SIZE, businessesWithWebsites.length)}/${businessesWithWebsites.length})`;

        const batchPromises = batch.map(async (business) => {
          try {
            const enrichedData = await fetchSmartEnrichment(business.website, business.name);

            // Update business in cache
            const cacheKey = `${zipCode}-${category}`;
            const cached = placesCache.searches[cacheKey];
            if (cached && cached.cachedData) {
              const businessIndex = cached.cachedData.findIndex(b => b.placeId === business.placeId);
              if (businessIndex !== -1) {
                const existing = cached.cachedData[businessIndex];
                // IMPORTANT: Preserve existing data, only add new data from enrichment
                cached.cachedData[businessIndex] = {
                  ...existing,
                  email: enrichedData.email || existing.email || '',
                  phone: existing.phone || enrichedData.phone || '',
                  facebook: enrichedData.facebook || existing.facebook || '',
                  instagram: enrichedData.instagram || existing.instagram || '',
                  linkedin: enrichedData.linkedin || existing.linkedin || '',
                  twitter: enrichedData.twitter || existing.twitter || '',
                  contactNames: enrichedData.contactNames?.length > 0 ? enrichedData.contactNames : (existing.contactNames || []),
                  enriched: true,
                  enrichmentSource: '9x12pro-scraper',
                  pagesScraped: enrichedData.pagesScraped || 0,
                  contactScore: calculateContactScore({
                    phone: existing.phone || enrichedData.phone,
                    email: enrichedData.email || existing.email,
                    website: existing.website,
                    facebook: enrichedData.facebook || existing.facebook,
                    instagram: enrichedData.instagram || existing.instagram,
                    linkedin: enrichedData.linkedin || existing.linkedin,
                    twitter: enrichedData.twitter || existing.twitter
                  })
                };

                cached.cachedData[businessIndex].leadScore = calculateProspectScore(cached.cachedData[businessIndex]);
                cached.cachedData[businessIndex].scoreCategory = getScoreCategory(cached.cachedData[businessIndex].leadScore);
              }
            }
            enrichedCount++;
            return { success: true, business };
          } catch (err) {
            console.error(`‚ùå Failed to enrich ${business.name}:`, err);
            return { success: false, business, error: err };
          }
        });

        const results = await Promise.all(batchPromises);
        results.filter(r => !r.success).forEach(r => {
          toast(`‚ö†Ô∏è Couldn't enrich ${r.business.name} - continuing...`, false);
        });

        console.log(`‚úÖ Enriched ${Math.min(batchStart + BATCH_SIZE, businessesWithWebsites.length)}/${businessesWithWebsites.length} businesses`);
      }

      await savePlacesCache();
      console.log(`‚úÖ Enrichment complete! ${enrichedCount}/${businessesWithWebsites.length} businesses enriched.`);
    }

    // Just cache results - searchGooglePlaces already handled caching
    closeAutoPopulateModal();

    // Show success modal with category breakdown (BEFORE enrichment toast)
    const categorizedResults = { [category]: businesses.length };
    showProspectSuccessModal(categorizedResults, businesses.length);

    // Show enrichment status toast AFTER modal
    if (businessesWithWebsites.length > 0) {
      setTimeout(() => {
        toast(`‚úÖ All ${businessesWithWebsites.length} prospects enriched with emails & social media!`, true);
      }, 500);
    }

    // Refresh Prospect Pool to show enriched data
    const prospectsTab = document.querySelector('[data-content="prospects"]');
    if (prospectsTab && !prospectsTab.classList.contains('hidden')) {
      setTimeout(() => renderProspectPool(), 500);
    }

  } catch(err) {
    console.error('Auto-populate error:', err);
    toast('Search failed. Please try again.', false);
  } finally {
    btn.disabled = false;
    btn.innerHTML = originalText;
  }
}

// Toggle custom category input
function toggleBulkCustomCategory() {
  const checkbox = document.getElementById('enableCustomCategory');
  const input = document.getElementById('bulkCustomCategory');
  input.disabled = !checkbox.checked;
  if (checkbox.checked) {
    input.focus();
  } else {
    input.value = '';
  }
}

// Update quick API usage display in prospecting section
function updateQuickApiUsage() {
  const stats = getApiQuota();
  const usageEl = document.getElementById('quickApiUsage');
  const resetEl = document.getElementById('quickApiReset');

  if (usageEl) {
    usageEl.textContent = `${stats.used.toLocaleString()} / ${stats.total.toLocaleString()}`;
  }

  if (resetEl) {
    const nextMonth = new Date();
    nextMonth.setMonth(nextMonth.getMonth() + 1);
    nextMonth.setDate(1);
    const monthName = nextMonth.toLocaleString('en-US', { month: 'short' });
    resetEl.textContent = `Resets ${monthName} 1`;
  }
}

// Toggle all category checkboxes
function toggleAllCategories(event) {
  console.log('toggleAllCategories called');
  console.log('Event:', event);
  console.log('Event target:', event?.target);

  // Get the checkbox - either from event or by ID
  let selectAllCheckbox = event?.target || document.getElementById('selectAllCategories');

  console.log('selectAllCheckbox:', selectAllCheckbox);
  console.log('selectAllCheckbox checked:', selectAllCheckbox?.checked);

  if (!selectAllCheckbox) {
    console.error('selectAllCategories checkbox not found');
    toast('Error: Select All checkbox not found', false);
    return;
  }

  const categoryCheckboxes = document.querySelectorAll('.category-checkbox');
  console.log('Found category checkboxes:', categoryCheckboxes.length);

  if (categoryCheckboxes.length === 0) {
    console.error('No category checkboxes found with class .category-checkbox');
    toast('No categories to select', false);
    return;
  }

  const shouldCheck = selectAllCheckbox.checked;
  categoryCheckboxes.forEach(checkbox => {
    checkbox.checked = shouldCheck;
  });

  console.log('Set all', categoryCheckboxes.length, 'checkboxes to:', shouldCheck);
  toast(shouldCheck ? `Selected all ${categoryCheckboxes.length} categories` : 'Cleared all categories', true);

  // Also update custom category input state when Select All is toggled
  const customCategoryCheckbox = document.getElementById('enableCustomCategory');
  const customCategoryInput = document.getElementById('bulkCustomCategory');
  if (customCategoryCheckbox && customCategoryInput) {
    customCategoryInput.disabled = !customCategoryCheckbox.checked;
    if (!customCategoryCheckbox.checked) {
      customCategoryInput.value = '';
    }
  }
}

/* ========= SALES TOOLKIT FUNCTIONS ========= */

// Sales Toolkit state
let salesToolkitSettings = {
  yourName: '',
  yourCompany: '',
  yourPhone: '',
  yourEmail: '',
  yourWebsite: '',
  spotPrice: '$400',
  homesReached: '5,000'
};

// Toggle Sales Toolkit visibility
function toggleSalesToolkit() {
  const content = document.getElementById('salesToolkitContent');
  const chevron = document.getElementById('salesToolkitChevron');

  if (content.classList.contains('hidden')) {
    content.classList.remove('hidden');
    chevron.classList.add('rotate-180');
    loadSalesToolkitSettings();
  } else {
    content.classList.add('hidden');
    chevron.classList.remove('rotate-180');
  }
}

// Load Sales Toolkit settings from localStorage
function loadSalesToolkitSettings() {
  const saved = localStorage.getItem('salesToolkitSettings');
  if (saved) {
    salesToolkitSettings = JSON.parse(saved);
  }

  // Populate form fields (check if elements exist first)
  const nameEl = document.getElementById('salesToolkitName');
  const companyEl = document.getElementById('salesToolkitCompany');
  const phoneEl = document.getElementById('salesToolkitPhone');
  const priceEl = document.getElementById('salesToolkitSpotPrice');

  if (nameEl) nameEl.value = salesToolkitSettings.yourName || '';
  if (companyEl) companyEl.value = salesToolkitSettings.yourCompany || '';
  if (phoneEl) phoneEl.value = salesToolkitSettings.yourPhone || '';
  if (priceEl) priceEl.value = salesToolkitSettings.spotPrice || '$399';
}

// Save Sales Toolkit settings
function saveSalesToolkitSettings() {
  salesToolkitSettings = {
    yourName: document.getElementById('salesToolkitName')?.value || '',
    yourCompany: document.getElementById('salesToolkitCompany')?.value || '',
    yourPhone: document.getElementById('salesToolkitPhone')?.value || '',
    spotPrice: document.getElementById('salesToolkitSpotPrice')?.value || '$399'
  };

  localStorage.setItem('salesToolkitSettings', JSON.stringify(salesToolkitSettings));
  toast('‚úÖ Settings saved!', true);
}

// Copy email template with placeholders (user fills in business-specific info)
function copyEmailTemplate(templateType) {
  const templates = {
    firstTouch: document.getElementById('firstTouchTemplate').innerText,
    followUp: document.getElementById('followUpTemplate').innerText,
    lastChance: document.getElementById('lastChanceTemplate').innerText
  };

  let template = templates[templateType] || '';

  // Replace user settings placeholders
  template = template.replace(/\[YOUR_NAME\]/g, salesToolkitSettings.yourName || '[YOUR_NAME]');
  template = template.replace(/\[YOUR_PHONE\]/g, salesToolkitSettings.yourPhone || '[YOUR_PHONE]');
  template = template.replace(/\[YOUR_COMPANY\]/g, salesToolkitSettings.yourCompany || '[YOUR_COMPANY]');
  template = template.replace(/\[SPOT_PRICE\]/g, salesToolkitSettings.spotPrice || '[SPOT_PRICE]');

  navigator.clipboard.writeText(template).then(() => {
    toast('üìã Template copied! Paste into your email.', true);
  }).catch(() => {
    toast('‚ùå Failed to copy. Try selecting and copying manually.', false);
  });
}

// Copy call script
function copyCallScript() {
  const scriptEl = document.getElementById('callScriptTemplate');
  let script = scriptEl.innerText;

  // Replace user settings placeholders
  script = script.replace(/\[YOUR_NAME\]/g, salesToolkitSettings.yourName || '[YOUR_NAME]');
  script = script.replace(/\[YOUR_PHONE\]/g, salesToolkitSettings.yourPhone || '[YOUR_PHONE]');
  script = script.replace(/\[YOUR_COMPANY\]/g, salesToolkitSettings.yourCompany || '[YOUR_COMPANY]');
  script = script.replace(/\[SPOT_PRICE\]/g, salesToolkitSettings.spotPrice || '[SPOT_PRICE]');

  navigator.clipboard.writeText(script).then(() => {
    toast('üìã Call script copied!', true);
  }).catch(() => {
    toast('‚ùå Failed to copy. Try selecting and copying manually.', false);
  });
}

// Send pitch email to a prospect (opens email client with pre-filled template)
function sendPitchEmail(prospectOrId) {
  // Support both object and ID lookup
  let prospect = prospectOrId;
  if (typeof prospectOrId === 'string') {
    prospect = prospectPoolState.renderedProspects?.[prospectOrId] || prospectOrId;
  }

  const businessName = prospect.businessName || prospect.name || 'Business Owner';
  const businessType = prospect.category || 'local business';
  const zip = prospect.actualZip || prospect.zipCode || prospect.zip || '';
  const email = prospect.email || '';

  if (!email) {
    toast('‚ùå No email address found for this prospect. Try enriching first.', false);
    return;
  }

  // Build email with merge fields filled in
  const subject = encodeURIComponent(`${businessType} spot in ${zip}?`);

  let body = `Hi,

I'm ${salesToolkitSettings.yourName || '[Your Name]'} with ${salesToolkitSettings.yourCompany || '[Your Company]'}. I'm putting together a community postcard that goes to every single home in ${zip} - delivered by USPS to every mailbox.

I have one spot reserved for a ${businessType} and thought of ${businessName}.

It's ${salesToolkitSettings.spotPrice || '$399'} for the ad. You'd be the only ${businessType} on the card - no competition.

Worth a quick call? I can hold the spot until Friday.

${salesToolkitSettings.yourName || '[Your Name]'}
${salesToolkitSettings.yourPhone || '[Your Phone]'}`;

  const mailtoLink = `mailto:${email}?subject=${subject}&body=${encodeURIComponent(body)}`;

  window.open(mailtoLink, '_blank');
  toast(`üìß Opening email to ${businessName}...`, true);
}

// Send pitch email from prospect pool card
function sendPitchFromPool(prospectData) {
  // Parse the prospect data if it's a string
  const prospect = typeof prospectData === 'string' ? JSON.parse(prospectData) : prospectData;
  sendPitchEmail(prospect);
}

// Copy SMS template with placeholders
function copySmsTemplate(templateType) {
  const templates = {
    firstText: document.getElementById('firstTextTemplate')?.innerText || '',
    followUpText: document.getElementById('followUpTextTemplate')?.innerText || '',
    lastText: document.getElementById('lastTextTemplate')?.innerText || ''
  };

  let template = templates[templateType] || '';

  // Replace user settings placeholders
  template = template.replace(/\[YOUR_NAME\]/g, salesToolkitSettings.yourName || '[YOUR_NAME]');
  template = template.replace(/\[YOUR_PHONE\]/g, salesToolkitSettings.yourPhone || '[YOUR_PHONE]');
  template = template.replace(/\[YOUR_COMPANY\]/g, salesToolkitSettings.yourCompany || '[YOUR_COMPANY]');
  template = template.replace(/\[SPOT_PRICE\]/g, salesToolkitSettings.spotPrice || '[SPOT_PRICE]');

  navigator.clipboard.writeText(template).then(() => {
    toast('üí¨ Text template copied!', true);
  }).catch(() => {
    toast('‚ùå Failed to copy. Try selecting and copying manually.', false);
  });
}

// Copy Social DM template (Facebook Messenger / Instagram)
function copySocialTemplate(templateType) {
  const templates = {
    fbOpener: document.getElementById('fbOpenerTemplate')?.innerText || '',
    fbFollowUp: document.getElementById('fbFollowUpTemplate')?.innerText || '',
    igOpener: document.getElementById('igOpenerTemplate')?.innerText || '',
    igFollowUp: document.getElementById('igFollowUpTemplate')?.innerText || ''
  };

  let template = templates[templateType] || '';

  // Replace user settings placeholders
  template = template.replace(/\[YOUR_NAME\]/g, salesToolkitSettings.yourName || '[YOUR_NAME]');
  template = template.replace(/\[YOUR_PHONE\]/g, salesToolkitSettings.yourPhone || '[YOUR_PHONE]');
  template = template.replace(/\[YOUR_COMPANY\]/g, salesToolkitSettings.yourCompany || '[YOUR_COMPANY]');
  template = template.replace(/\[SPOT_PRICE\]/g, salesToolkitSettings.spotPrice || '[SPOT_PRICE]');

  const platform = templateType.startsWith('fb') ? 'Facebook' : 'Instagram';
  navigator.clipboard.writeText(template).then(() => {
    toast(`üì± ${platform} message copied!`, true);
  }).catch(() => {
    toast('‚ùå Failed to copy. Try selecting and copying manually.', false);
  });
}

// Send text message to a prospect (opens SMS app with pre-filled message)
function sendTextMessage(prospectOrId) {
  // Support both object and ID lookup
  let prospect = prospectOrId;
  if (typeof prospectOrId === 'string') {
    prospect = prospectPoolState.renderedProspects?.[prospectOrId] || prospectOrId;
  }

  const businessName = prospect.businessName || prospect.name || 'there';
  const businessType = prospect.category || 'local business';
  const zip = prospect.actualZip || prospect.zipCode || prospect.zip || '';
  const phone = prospect.phone || '';

  if (!phone) {
    toast('‚ùå No phone number found for this prospect.', false);
    return;
  }

  // Clean phone number (remove non-digits except leading +)
  let cleanPhone = phone.replace(/[^\d+]/g, '');

  // Build short SMS message (curiosity hook style)
  const message = `Hey! Quick question - do you guys do any direct mail advertising? I'm putting a community postcard together for ${zip} and have one ${businessType} spot left.`;

  // Copy message to clipboard and open Google Voice
  navigator.clipboard.writeText(message).then(() => {
    const formattedPhone = cleanPhone.replace(/\D/g, '');
    window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${formattedPhone}`, '_blank');
    toast(`üìã Message copied! Google Voice opened for ${businessName}`, true);
  }).catch(() => {
    // Fallback if clipboard fails
    const formattedPhone = cleanPhone.replace(/\D/g, '');
    window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${formattedPhone}`, '_blank');
    toast(`üì± Google Voice opened for ${businessName}`, true);
  });
}

// ========== AI PITCH GENERATOR (INLINE) ==========

// Store generated results per platform
let aiInlineResults = {
  text: { message: '', subject: '' },
  email: { message: '', subject: '' },
  social: { message: '', subject: '' }
};

// Campaign settings (postcard details)
let campaignSettings = {
  totalSpots: 18,
  homeCount: 5000,
  spotPrice: '$500',
  zipCode: ''
};

// Update campaign settings from inputs and calculate cost per home
function updateCampaignSettings() {
  const spots = parseInt(document.getElementById('campaignTotalSpots')?.value) || 18;
  const homes = parseInt(document.getElementById('campaignHomeCount')?.value) || 5000;
  const priceStr = document.getElementById('salesToolkitSpotPrice')?.value || '$500';
  const zipCode = document.getElementById('campaignZipCode')?.value || '';

  campaignSettings.totalSpots = spots;
  campaignSettings.homeCount = homes;
  campaignSettings.spotPrice = priceStr;
  campaignSettings.zipCode = zipCode;

  // Parse price (remove $ and parse)
  const priceNum = parseFloat(priceStr.replace(/[$,]/g, '')) || 500;

  // Calculate cost per home
  const costPerHome = homes > 0 ? (priceNum / homes).toFixed(2) : '0.00';

  // Update display
  const costDisplay = document.getElementById('costPerHome');
  if (costDisplay) {
    costDisplay.textContent = `$${costPerHome}`;
  }

  // Save to localStorage
  saveSalesToolkitSettings();
}

// Switch between outreach sub-tabs (text, email, phone, objections)
function switchOutreachTab(tabName) {
  // Hide all outreach panes
  document.querySelectorAll('.outreach-pane').forEach(pane => {
    pane.classList.add('hidden');
  });

  // Deactivate all outreach tab buttons
  document.querySelectorAll('.outreach-tab-btn').forEach(btn => {
    btn.classList.remove('active', 'bg-white', 'shadow-md', 'text-orange-600');
  });

  // Show selected pane
  const selectedPane = document.querySelector(`[data-outreach-content="${tabName}"]`);
  if (selectedPane) {
    selectedPane.classList.remove('hidden');
  }

  // Activate selected button
  const selectedBtn = document.querySelector(`[data-outreach-tab="${tabName}"]`);
  if (selectedBtn) {
    selectedBtn.classList.add('active', 'bg-white', 'shadow-md', 'text-orange-600');
  }
}

// Expose functions globally
window.toggleSalesToolkit = toggleSalesToolkit;
window.loadSalesToolkitSettings = loadSalesToolkitSettings;
window.saveSalesToolkitSettings = saveSalesToolkitSettings;
window.copyEmailTemplate = copyEmailTemplate;
window.copyCallScript = copyCallScript;
window.copySmsTemplate = copySmsTemplate;
window.copySocialTemplate = copySocialTemplate;
window.sendPitchEmail = sendPitchEmail;
window.sendPitchFromPool = sendPitchFromPool;
window.sendTextMessage = sendTextMessage;
window.switchOutreachTab = switchOutreachTab;

// ========== CLOSE DEALS PROSPECT LIST FUNCTIONS ==========

// State for Close Deals tab
let closeDealsState = {
  selectedProspect: null,
  currentFilter: 'all'
};

// Filter the Close Deals prospect list by status
function filterCloseDealsStatus(status) {
  closeDealsState.currentFilter = status;

  // Update filter button styles
  document.querySelectorAll('.close-filter-btn').forEach(btn => {
    btn.classList.remove('active', 'bg-white', 'shadow', 'text-gray-900');
    btn.classList.add('text-gray-600');
  });

  const activeBtn = document.querySelector(`[data-close-filter="${status}"]`);
  if (activeBtn) {
    activeBtn.classList.add('active', 'bg-white', 'shadow', 'text-gray-900');
    activeBtn.classList.remove('text-gray-600');
  }

  renderCloseDealsProspects();
}

// Get all prospects from campaign board and map to Close Deals statuses
function getCloseDealsProspects() {
  const prospects = [];

  const board = typeof getCurrentCampaignBoard === 'function' ? getCurrentCampaignBoard() : null;
  if (!board || !board.columns) {
    return prospects;
  }

  // Map board columns to close deals statuses
  // queued is NOT included - it's just a staging area
  const columnMapping = {
    'attempting': 'new',
    'negotiating': 'contacted',
    'invoice-sent': 'interested',
    'proof-approved': 'interested'
  };

  Object.entries(columnMapping).forEach(([column, status]) => {
    const items = board.columns[column] || [];
    items.forEach(item => {
      if (typeof item === 'object' && item) {
        prospects.push({
          ...item,
          closeStatus: status,
          kanbanColumn: column
        });
      }
    });
  });

  return prospects;
}

// Render the Close Deals prospect list
function renderCloseDealsProspects() {
  const container = document.getElementById('closeDealsProspectList');
  if (!container) return;

  const allProspects = getCloseDealsProspects();
  const filter = closeDealsState.currentFilter;

  // Get contact filter states
  const filterPhone = document.getElementById('closeDealsFilterPhone')?.checked || false;
  const filterEmail = document.getElementById('closeDealsFilterEmail')?.checked || false;
  const filterFacebook = document.getElementById('closeDealsFilterFacebook')?.checked || false;
  const filterInstagram = document.getElementById('closeDealsFilterInstagram')?.checked || false;

  // Apply status filter
  let filteredProspects = filter === 'all'
    ? allProspects
    : allProspects.filter(p => p.closeStatus === filter);

  // Apply contact filters (AND logic)
  if (filterPhone) {
    filteredProspects = filteredProspects.filter(p => p.phone && p.phone.trim() !== '');
  }
  if (filterEmail) {
    filteredProspects = filteredProspects.filter(p => p.email && p.email.trim() !== '');
  }
  if (filterFacebook) {
    filteredProspects = filteredProspects.filter(p => p.facebook && p.facebook.trim() !== '');
  }
  if (filterInstagram) {
    filteredProspects = filteredProspects.filter(p => p.instagram && p.instagram.trim() !== '');
  }

  // Update counts on filter buttons
  const counts = {
    all: allProspects.length,
    new: allProspects.filter(p => p.closeStatus === 'new').length,
    contacted: allProspects.filter(p => p.closeStatus === 'contacted').length,
    interested: allProspects.filter(p => p.closeStatus === 'interested').length
  };

  document.querySelectorAll('.close-filter-btn').forEach(btn => {
    const filterType = btn.getAttribute('data-close-filter');
    if (filterType && counts[filterType] !== undefined) {
      const label = filterType === 'all' ? 'All' :
                    filterType === 'new' ? 'New' :
                    filterType === 'contacted' ? 'Contacted' : 'Hot';
      btn.innerHTML = `${label} <span class="text-xs opacity-70">(${counts[filterType]})</span>`;
    }
  });

  const hasContactFilter = filterPhone || filterEmail || filterFacebook || filterInstagram;
  if (filteredProspects.length === 0) {
    container.innerHTML = `
      <div class="p-8 text-center text-gray-400">
        <span class="text-4xl mb-2 block">üéØ</span>
        <p class="font-medium">${hasContactFilter ? 'No prospects match filters' : (filter === 'all' ? 'No prospects yet' : `No ${filter} prospects`)}</p>
        <p class="text-sm">${hasContactFilter ? 'Try unchecking some contact filters above' : (filter === 'all' ? 'Find businesses in the Find tab and add them to your Pool' : 'Prospects will appear here as you work through your pipeline')}</p>
      </div>
    `;
    return;
  }

  // Render prospect cards
  const html = filteredProspects.map(prospect => {
    const isSelected = closeDealsState.selectedProspect?.id === prospect.id;
    const statusColors = {
      'new': 'bg-blue-100 text-blue-700',
      'contacted': 'bg-amber-100 text-amber-700',
      'interested': 'bg-green-100 text-green-700'
    };
    const statusLabels = {
      'new': 'New',
      'contacted': 'Contacted',
      'interested': 'Hot üî•'
    };

    // Get category icon
    const categoryIcons = {
      'restaurant': 'üçΩÔ∏è',
      'plumber': 'üîß',
      'electrician': '‚ö°',
      'hvac': '‚ùÑÔ∏è',
      'landscaping': 'üåø',
      'roofing': 'üè†',
      'auto repair': 'üöó',
      'dentist': 'ü¶∑',
      'salon': 'üíá',
      'gym': 'üí™'
    };
    const icon = categoryIcons[prospect.category?.toLowerCase()] || 'üè¢';

    return `
      <div onclick="selectCloseDealsProspect('${prospect.id}')"
           class="p-3 cursor-pointer hover:bg-indigo-50 transition-all ${isSelected ? 'bg-indigo-100 border-l-4 border-indigo-500' : ''}">
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 bg-gray-100 rounded-full flex items-center justify-center text-lg flex-shrink-0">
            ${icon}
          </div>
          <div class="flex-1 min-w-0">
            <p class="font-bold text-gray-900 text-sm truncate">${prospect.businessName || 'Unknown Business'}</p>
            <p class="text-xs text-gray-500 truncate">${(prospect.category || 'Business').replace(/_/g, ' ')} ‚Ä¢ ${prospect.zipCode || 'N/A'}</p>
          </div>
          <span class="px-2 py-0.5 text-xs font-bold rounded-full ${statusColors[prospect.closeStatus]}">${statusLabels[prospect.closeStatus]}</span>
        </div>
      </div>
    `;
  }).join('');

  container.innerHTML = html;
}

// Update all templates with prospect data
function updateTemplatesWithProspect(prospect) {
  if (!prospect) return;

  // Get sales toolkit settings from inputs OR localStorage
  const savedSettings = JSON.parse(localStorage.getItem('salesToolkitSettings') || '{}');
  const yourName = document.getElementById('salesToolkitName')?.value?.trim() || savedSettings.yourName || '[YOUR_NAME]';
  const yourCompany = document.getElementById('salesToolkitCompany')?.value?.trim() || savedSettings.yourCompany || '[YOUR_COMPANY]';
  const yourPhone = document.getElementById('salesToolkitPhone')?.value?.trim() || savedSettings.yourPhone || '[YOUR_PHONE]';
  const spotPrice = document.getElementById('salesToolkitSpotPrice')?.value?.trim() || savedSettings.spotPrice || '$399';

  // Prospect data
  const zip = prospect.zipCode || prospect.actualZip || '[ZIP]';
  const businessType = (prospect.category || 'business').replace(/_/g, ' ');
  const businessName = prospect.businessName || '[BUSINESS_NAME]';
  const contactName = prospect.contactName || 'there';

  // Helper to replace all placeholders in text
  function fillTemplate(text) {
    return text
      .replace(/\[ZIP\]/g, zip)
      .replace(/\[BUSINESS_TYPE\]/g, businessType)
      .replace(/\[BUSINESS_NAME\]/g, businessName)
      .replace(/\[YOUR_NAME\]/g, yourName)
      .replace(/\[YOUR_COMPANY\]/g, yourCompany)
      .replace(/\[YOUR_PHONE\]/g, yourPhone)
      .replace(/\[SPOT_PRICE\]/g, spotPrice)
      .replace(/\[CONTACT_NAME\]/g, contactName)
      .replace(/\[COMPETITOR_NAME\]/g, 'another ' + businessType);
  }

  // Text templates
  const firstText = document.getElementById('firstTextTemplate');
  const followUpText = document.getElementById('followUpTextTemplate');
  const lastText = document.getElementById('lastTextTemplate');

  if (firstText) firstText.textContent = fillTemplate(`Hey! Quick question - do you guys do any direct mail advertising? I'm putting a community postcard together for ${zip} and have one ${businessType} spot left.`);
  if (followUpText) followUpText.textContent = fillTemplate(`Hey - following up on the postcard. It goes to approximately 5,000 homes in ${zip}, not a mailing list. You'd be the only ${businessType} on it. Still have your spot if you want it.`);
  if (lastText) lastText.textContent = fillTemplate(`Last one - card goes to print Friday. Got another ${businessType} interested in the spot. Yours if you want it, just let me know either way.`);

  // Email templates
  const firstTouch = document.getElementById('firstTouchTemplate');
  const followUp = document.getElementById('followUpTemplate');
  const lastChance = document.getElementById('lastChanceTemplate');

  if (firstTouch) firstTouch.textContent = `Hi,

I'm ${yourName} with ${yourCompany}. I'm putting together a community postcard that goes to approximately 5,000 homes in ${zip} - delivered by USPS to every mailbox.

I have one spot reserved for a ${businessType} and thought of ${businessName}.

It's ${spotPrice} for the ad. You'd be the only ${businessType} on the card - no competition.

Worth a quick call? I can hold the spot until Friday.

${yourName}
${yourPhone}`;

  if (followUp) followUp.textContent = `Hi,

Quick follow-up on the ${zip} postcard - we've got 14 of 18 spots filled already.

The ${businessType} spot is still open at ${spotPrice}. Card goes to print next week and hits approximately 5,000 mailboxes in ${zip}.

Most businesses do this because if even ONE customer calls from the card, they've made their money back. A plumber on last month's card told me he got 6 calls.

Want me to save your spot?

${yourName}
${yourPhone}`;

  if (lastChance) lastChance.textContent = `Hey,

Card goes to print Friday. I've got one ${businessType} spot left and another ${businessType} is interested.

Wanted to give ${businessName} first shot since I reached out to you first.

Yes or no - just let me know.

${yourName}`;
}

// Select a prospect in Close Deals
function selectCloseDealsProspect(prospectId) {
  const allProspects = getCloseDealsProspects();
  const prospect = allProspects.find(p => String(p.id) === String(prospectId));

  if (!prospect) {
    console.warn('Prospect not found:', prospectId);
    return;
  }

  closeDealsState.selectedProspect = prospect;

  // Update templates with this prospect's data
  updateTemplatesWithProspect(prospect);

  // Show the selected prospect banner, hide placeholder
  const banner = document.getElementById('selectedProspectBanner');
  const placeholder = document.getElementById('noProspectSelected');

  if (banner) {
    banner.classList.remove('hidden');

    // Update banner content
    document.getElementById('selectedProspectName').textContent = prospect.businessName || 'Unknown';

    const infoText = [
      prospect.phone ? `üìû ${prospect.phone}` : null,
      prospect.email ? `üìß ${prospect.email}` : null,
      prospect.zipCode ? `üìç ${prospect.zipCode}` : null
    ].filter(Boolean).join(' ‚Ä¢ ') || 'No contact info';

    document.getElementById('selectedProspectInfo').textContent = infoText;

    // Update icon based on category
    const categoryIcons = {
      'restaurant': 'üçΩÔ∏è',
      'plumber': 'üîß',
      'electrician': '‚ö°',
      'hvac': '‚ùÑÔ∏è',
      'landscaping': 'üåø',
      'roofing': 'üè†',
      'auto repair': 'üöó',
      'dentist': 'ü¶∑',
      'salon': 'üíá',
      'gym': 'üí™'
    };
    const icon = categoryIcons[prospect.category?.toLowerCase()] || 'üè¢';
    document.getElementById('selectedProspectIcon').textContent = icon;

    // Update status dropdown
    const statusDropdown = document.getElementById('selectedProspectStatus');
    if (statusDropdown) {
      statusDropdown.value = prospect.closeStatus;
    }
  }

  if (placeholder) {
    placeholder.classList.add('hidden');
  }

  // Auto-fill Spark business name
  const sparkBusinessInput = document.getElementById('sparkBusinessName');
  if (sparkBusinessInput) {
    sparkBusinessInput.value = prospect.businessName || '';
  }

  // Re-render to highlight selected prospect
  renderCloseDealsProspects();
}

// Send text to the selected prospect
function sendTextToSelected() {
  const prospect = closeDealsState.selectedProspect;
  if (!prospect) {
    toast('Please select a prospect first', false);
    return;
  }

  if (!prospect.phone) {
    toast('No phone number for this prospect', false);
    return;
  }

  // Use the existing sendTextMessage function with prospect data
  sendTextMessage(prospect.phone, prospect.businessName, prospect.zipCode || '', prospect.category || 'business');

  // Auto-update status to contacted if currently new
  if (prospect.closeStatus === 'new') {
    moveProspectToColumn(prospect.id, prospect.kanbanColumn, 'to-contact');
  }
}

// Send email to the selected prospect
function sendEmailToSelected() {
  const prospect = closeDealsState.selectedProspect;
  if (!prospect) {
    toast('Please select a prospect first', false);
    return;
  }

  if (!prospect.email) {
    toast('No email for this prospect - copy the template and find their email', false);
    return;
  }

  // Use the existing sendPitchEmail function
  sendPitchEmail(prospect.email, prospect.businessName, prospect.zipCode || '', prospect.category || 'business');

  // Auto-update status to contacted if currently new
  if (prospect.closeStatus === 'new') {
    moveProspectToColumn(prospect.id, prospect.kanbanColumn, 'to-contact');
  }
}

// Call the selected prospect
function callSelected() {
  const prospect = closeDealsState.selectedProspect;
  if (!prospect) {
    toast('Please select a prospect first', false);
    return;
  }

  if (!prospect.phone) {
    toast('No phone number for this prospect', false);
    return;
  }

  // Open phone dialer
  const cleanPhone = prospect.phone.replace(/[^\d+]/g, '');
  window.open(`tel:${cleanPhone}`, '_blank');
  toast(`üìû Calling ${prospect.businessName}...`, true);

  // Auto-update status to contacted if currently new
  if (prospect.closeStatus === 'new') {
    moveProspectToColumn(prospect.id, prospect.kanbanColumn, 'to-contact');
  }
}

// Helper function to move prospect between kanban columns
// Now uses Campaign Board as single source of truth
function moveProspectToColumn(prospectId, fromColumn, toColumn) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  // Map legacy column names to Campaign Board columns
  const fromBoardCol = mapLegacyColumnToCampaignBoard(fromColumn);
  const toBoardCol = mapLegacyColumnToCampaignBoard(toColumn);

  // Use moveCampaignBoardItem for the actual move
  const success = moveCampaignBoardItem(prospectId, fromBoardCol, toBoardCol, board);

  if (success) {
    saveCampaignBoards();
    renderKanban();

    // Update the selected prospect's column reference
    if (closeDealsState.selectedProspect?.id === prospectId) {
      closeDealsState.selectedProspect.kanbanColumn = toColumn;
      closeDealsState.selectedProspect.closeStatus =
        toColumn === 'prospect-list' ? 'new' :
        toColumn === 'to-contact' || toColumn === 'in-progress' ? 'contacted' :
        'interested';
    }

    renderCloseDealsProspects();
  }
}

// Update prospect status from Close Deals (quick status change)
function updateCloseDealsStatus(newStatus) {
  const prospect = closeDealsState.selectedProspect;
  if (!prospect) {
    toast('Please select a prospect first', false);
    return;
  }

  const statusToColumn = {
    'new': 'prospect-list',
    'contacted': 'to-contact',
    'interested': 'committed'
  };

  const toColumn = statusToColumn[newStatus];

  // Check if already in target status
  if (!toColumn) {
    console.error('Invalid status:', newStatus);
    return;
  }

  if (toColumn === prospect.kanbanColumn) {
    toast(`Already marked as ${newStatus}`, true);
    return;
  }

  // Handle in-progress column (also counts as contacted)
  const fromColumn = prospect.kanbanColumn;
  if (newStatus === 'contacted' && fromColumn === 'in-progress') {
    toast(`Already marked as ${newStatus}`, true);
    return;
  }

  moveProspectToColumn(prospect.id, fromColumn, toColumn);
  toast(`‚úÖ Moved to ${newStatus}`, true);
}

// Expose Close Deals functions globally
window.filterCloseDealsStatus = filterCloseDealsStatus;
window.renderCloseDealsProspects = renderCloseDealsProspects;
window.selectCloseDealsProspect = selectCloseDealsProspect;
window.sendTextToSelected = sendTextToSelected;
window.sendEmailToSelected = sendEmailToSelected;
window.callSelected = callSelected;
window.updateCloseDealsStatus = updateCloseDealsStatus;

// Load Sales Toolkit settings on page load (for the Close Deals tab)
document.addEventListener('DOMContentLoaded', function() {
  // Delay slightly to ensure DOM is ready
  setTimeout(loadSalesToolkitSettings, 100);
});

// Clear all search caches (localStorage + cloud)
async function clearAllSearchCaches() {
  if (!confirm('‚ö†Ô∏è This will clear ALL cached searches and prospect data. Your clients will NOT be affected. Continue?')) {
    return;
  }

  try {
    // Clear localStorage
    localStorage.removeItem('mailslot-places-cache');
    localStorage.removeItem('categorizedProspects');
    localStorage.removeItem('manualProspects');
    localStorage.removeItem('notInterestedBusinesses');

    // Clear in-memory cache
    placesCache.searches = {};
    prospectPoolState.selectedIds.clear();

    // Clear cloud storage
    await saveToCloud('placesCache', {});
    await saveToCloud('categorizedProspects', {});
    await saveToCloud('manualProspects', []);
    await saveToCloud('notInterestedBusinesses', []);

    toast('‚úÖ All searches cleared! Reloading...', true);

    // Reload page after a moment
    setTimeout(() => location.reload(), 1000);
  } catch (error) {
    console.error('Error clearing caches:', error);
    toast('‚ùå Error clearing caches. Check console.', false);
  }
}

// ZIP search mode state
let zipSearchMode = 'zips'; // 'zips' or 'radius'

// Toggle between ZIP search modes
function setZipSearchMode(mode) {
  // Block radius mode for free tier
  if (mode === 'radius' && isFreeTier()) {
    showUpgradePrompt('Radius search is available on paid plans. Upgrade to search multiple ZIP codes at once.');
    return;
  }

  zipSearchMode = mode;
  const zipModeTab = document.getElementById('zipModeTab');
  const radiusModeTab = document.getElementById('radiusModeTab');
  const multipleZipsMode = document.getElementById('multipleZipsMode');
  const radiusSearchMode = document.getElementById('radiusSearchMode');

  if (mode === 'zips') {
    zipModeTab.className = 'px-3 py-1 text-sm font-bold rounded-lg bg-white text-purple-600';
    radiusModeTab.className = 'px-3 py-1 text-sm font-bold rounded-lg bg-white/20 text-white hover:bg-white/30';
    multipleZipsMode.classList.remove('hidden');
    radiusSearchMode.classList.add('hidden');
  } else {
    radiusModeTab.className = 'px-3 py-1 text-sm font-bold rounded-lg bg-white text-purple-600';
    zipModeTab.className = 'px-3 py-1 text-sm font-bold rounded-lg bg-white/20 text-white hover:bg-white/30';
    radiusSearchMode.classList.remove('hidden');
    multipleZipsMode.classList.add('hidden');
  }
}

// Apply free tier restrictions to search UI
function applyFreeTierSearchRestrictions() {
  const zip2 = document.getElementById('bulkPopZip2');
  const zip3 = document.getElementById('bulkPopZip3');
  const radiusModeTab = document.getElementById('radiusModeTab');

  if (isFreeTier()) {
    // Disable and style ZIP 2 & 3 inputs
    if (zip2) {
      zip2.disabled = true;
      zip2.value = '';
      zip2.placeholder = 'üîí Pro';
      zip2.classList.add('bg-gray-200', 'cursor-not-allowed', 'opacity-60');
      zip2.title = 'Upgrade to search multiple ZIP codes';
    }
    if (zip3) {
      zip3.disabled = true;
      zip3.value = '';
      zip3.placeholder = 'üîí Pro';
      zip3.classList.add('bg-gray-200', 'cursor-not-allowed', 'opacity-60');
      zip3.title = 'Upgrade to search multiple ZIP codes';
    }
    // Add lock indicator to radius tab
    if (radiusModeTab) {
      radiusModeTab.innerHTML = 'üîí Radius Search';
      radiusModeTab.title = 'Upgrade to use radius search';
    }
  } else {
    // Enable for paid users
    if (zip2) {
      zip2.disabled = false;
      zip2.placeholder = 'ZIP 2';
      zip2.classList.remove('bg-gray-200', 'cursor-not-allowed', 'opacity-60');
      zip2.title = '';
    }
    if (zip3) {
      zip3.disabled = false;
      zip3.placeholder = 'ZIP 3';
      zip3.classList.remove('bg-gray-200', 'cursor-not-allowed', 'opacity-60');
      zip3.title = '';
    }
    if (radiusModeTab) {
      radiusModeTab.innerHTML = 'Radius Search';
      radiusModeTab.title = '';
    }
  }
}

// Expose to window
window.setZipSearchMode = setZipSearchMode;
window.applyFreeTierSearchRestrictions = applyFreeTierSearchRestrictions;

// Get neighboring ZIP codes within a radius
async function getZipsInRadius(centerZip, radiusMiles) {
  try {
    const response = await fetch('/api/zip-neighbors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ zipCode: centerZip, radius: radiusMiles })
    });

    if (!response.ok) {
      throw new Error('Failed to get neighboring ZIPs');
    }

    const data = await response.json();
    // Return center ZIP + all neighbors within radius
    const zips = [centerZip];
    if (data.neighbors) {
      data.neighbors.forEach(n => {
        if (n.distance <= radiusMiles) {
          zips.push(n.zipCode);
        }
      });
    }
    return zips;
  } catch (error) {
    console.error('Error getting ZIP neighbors:', error);
    return [centerZip]; // Fall back to just center ZIP
  }
}

// Run bulk auto-populate with multiple categories - shows results in modal
async function runBulkAutoPopulate() {
  let zipCodes = [];

  const btn = document.getElementById('btnRunBulkPopulate');
  const originalBtnText = btn.innerHTML;

  // Check which mode we're in
  if (zipSearchMode === 'radius') {
    // Radius mode - get center ZIP and radius
    const centerZip = document.getElementById('radiusCenterZip')?.value.trim() || '';
    const radiusMiles = parseInt(document.getElementById('radiusMiles')?.value) || 5;

    if (!centerZip || !/^\d{5}$/.test(centerZip)) {
      toast('Please enter a valid 5-digit ZIP code', false);
      return;
    }

    if (radiusMiles < 1 || radiusMiles > 50) {
      toast('Radius must be between 1 and 50 miles', false);
      return;
    }

    // Get neighboring ZIPs within radius
    btn.innerHTML = '‚è≥ Finding ZIP codes in radius...';
    btn.disabled = true;

    try {
      zipCodes = await getZipsInRadius(centerZip, radiusMiles);
      // Limit to max 10 ZIPs to avoid extremely long searches
      if (zipCodes.length > 10) {
        toast(`Found ${zipCodes.length} ZIPs, limiting to closest 10`, true);
        zipCodes = zipCodes.slice(0, 10);
      } else {
        toast(`Found ${zipCodes.length} ZIP code${zipCodes.length > 1 ? 's' : ''} within ${radiusMiles} miles`, true);
      }
    } catch (error) {
      btn.innerHTML = originalBtnText;
      btn.disabled = false;
      toast('Error finding ZIP codes. Please try again.', false);
      return;
    }

  } else {
    // Multiple ZIPs mode
    const zip1 = document.getElementById('bulkPopZip1')?.value.trim() || '';
    const zip2 = document.getElementById('bulkPopZip2')?.value.trim() || '';
    const zip3 = document.getElementById('bulkPopZip3')?.value.trim() || '';
    zipCodes = [zip1, zip2, zip3].filter(z => z.length > 0);
  }

  // Validation
  if (zipCodes.length === 0) {
    toast('Please enter at least one ZIP code', false);
    return;
  }

  // Validate all ZIP codes are 5 digits
  const invalidZips = zipCodes.filter(z => !/^\d{5}$/.test(z));
  if (invalidZips.length > 0) {
    toast(`Invalid ZIP code(s): ${invalidZips.join(', ')}. Must be 5 digits.`, false);
    return;
  }

  // Remove duplicate ZIP codes
  const uniqueZips = [...new Set(zipCodes)];
  if (uniqueZips.length < zipCodes.length) {
    toast(`Duplicate ZIP codes removed. Searching ${uniqueZips.length} unique ZIP${uniqueZips.length > 1 ? 's' : ''}.`, true);
  }
  zipCodes = uniqueZips;

  // Get selected categories
  const categoryCheckboxes = document.querySelectorAll('.category-checkbox:checked');
  const selectedCategories = [];

  categoryCheckboxes.forEach(checkbox => {
    if (checkbox.id === 'enableCustomCategory') {
      // Handle custom category
      const customInput = document.getElementById('bulkCustomCategory');
      if (customInput.value.trim()) {
        selectedCategories.push(customInput.value.trim());
      }
    } else {
      selectedCategories.push(checkbox.value);
    }
  });

  if (selectedCategories.length === 0) {
    toast('Please select at least one business category', false);
    return;
  }

  // Disable button during search (btn already defined above)
  btn.disabled = true;
  btn.innerHTML = '‚è≥ Searching...';

  // Check free tier limits BEFORE starting searches
  if (isFreeTier()) {
    // Check zip code limits
    const newZips = zipCodes.filter(z => !dailyUsage.zipsSearched.includes(z));
    const allowedNewZips = FREE_TIER_LIMITS.zipSearchesPerDay - dailyUsage.zipSearches;

    if (newZips.length > allowedNewZips) {
      btn.disabled = false;
      btn.innerHTML = originalBtnText;
      if (allowedNewZips <= 0) {
        showUpgradePrompt(`You've reached your daily limit of ${FREE_TIER_LIMITS.zipSearchesPerDay} ZIP code search. Upgrade for unlimited searches.`);
      } else {
        showUpgradePrompt(`Free tier allows ${FREE_TIER_LIMITS.zipSearchesPerDay} ZIP code per day. You're trying to search ${newZips.length} new ZIP codes. Upgrade for unlimited searches.`);
      }
      return;
    }

    // Check category limits
    const newCategories = selectedCategories.filter(c => !dailyUsage.categoriesSearched.includes(c));
    const allowedNewCategories = FREE_TIER_LIMITS.categorySearchesPerDay - dailyUsage.categorySearches;

    if (newCategories.length > allowedNewCategories) {
      btn.disabled = false;
      btn.innerHTML = originalBtnText;
      if (allowedNewCategories <= 0) {
        showUpgradePrompt(`You've reached your daily limit of ${FREE_TIER_LIMITS.categorySearchesPerDay} category searches. Upgrade for unlimited searches.`);
      } else {
        showUpgradePrompt(`Free tier allows ${FREE_TIER_LIMITS.categorySearchesPerDay} categories per day. You're trying to search ${newCategories.length} new categories. Upgrade for unlimited searches.`);
      }
      return;
    }
  }

  try {
    // Track all businesses found across all categories and ZIP codes
    const allBusinesses = [];
    const seenPlaceIds = new Set();
    const categorizedResults = {}; // Track counts per category
    let successfulSearches = 0;
    let failedSearches = 0;
    const totalSearches = zipCodes.length * selectedCategories.length;

    // Search each ZIP code and category combination
    for (const zipCode of zipCodes) {
      for (const category of selectedCategories) {
        try {
          const currentSearch = successfulSearches + failedSearches + 1;
          btn.innerHTML = `‚è≥ Searching ${category} in ${zipCode}... (${currentSearch}/${totalSearches})`;

          const businesses = await searchGooglePlaces(zipCode, category, null, {
            currentSearch: currentSearch,
            totalSearches: totalSearches,
            totalCategories: selectedCategories.length,
            totalZipCodes: zipCodes.length,
            totalBusinessesFound: allBusinesses.length // Running total
          });

          let categoryCount = 0;
          // Deduplicate by place ID and filter out "not interested"
          businesses.forEach(business => {
            if (!seenPlaceIds.has(business.placeId) && !notInterestedState.placeIds.has(business.placeId)) {
              seenPlaceIds.add(business.placeId);
              allBusinesses.push(business);
              categoryCount++;
            }
          });

          if (categoryCount > 0) {
            categorizedResults[category] = (categorizedResults[category] || 0) + categoryCount;
          }

          successfulSearches++;

          // Small delay between requests to be polite to the API
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (err) {
          console.error(`Failed to search category ${category} in ${zipCode}:`, err);
          failedSearches++;
        }
      }
    }

    // Remove progress overlay after all searches complete
    const existingProgressOverlay = document.getElementById('enrichment-progress-overlay');
    if (existingProgressOverlay && existingProgressOverlay.parentNode) {
      existingProgressOverlay.remove();
    }

    if (allBusinesses.length === 0) {
      toast(`Searched ${selectedCategories.length} categories in ${zipCodes.length} ZIP code${zipCodes.length > 1 ? 's' : ''}. No new businesses found.`, false);
      btn.disabled = false;
      btn.innerHTML = originalBtnText;
      updateQuickApiUsage();

      // Still switch to Prospect Pool to show existing cached searches
      setTimeout(() => {
        switchTab('clients');
      }, 1500);
      return;
    }

    // Check which businesses already exist
    const existingLeads = new Set();
    Object.values(kanbanState.columns).forEach(column => {
      if (Array.isArray(column)) {
        column.forEach(lead => {
          if (lead && lead.placeId) {
            existingLeads.add(lead.placeId);
          }
        });
      }
    });

    Object.values(crmState.clients).forEach(client => {
      if (client.placeId) {
        existingLeads.add(client.placeId);
      }
    });

    // Mark businesses with status
    allBusinesses.forEach(business => {
      business.alreadyExists = existingLeads.has(business.placeId);
    });

    // AUTO-ENRICHMENT STRATEGY - ENRICH ALL BUSINESSES
    const businessesWithWebsites = allBusinesses.filter(b => b.website && !b.enriched);

    if (businessesWithWebsites.length > 0) {
      console.log(`üéØ Enriching ${businessesWithWebsites.length} businesses...`);

      // Enrich ALL businesses with websites - PARALLEL processing (4 at a time)
      const BATCH_SIZE = 4;
      let enrichedCount = 0;

      // Process businesses in parallel batches
      for (let batchStart = 0; batchStart < businessesWithWebsites.length; batchStart += BATCH_SIZE) {
        const batch = businessesWithWebsites.slice(batchStart, batchStart + BATCH_SIZE);
        btn.innerHTML = `üéØ Enriching batch ${Math.floor(batchStart / BATCH_SIZE) + 1}... (${Math.min(batchStart + BATCH_SIZE, businessesWithWebsites.length)}/${businessesWithWebsites.length})`;

        // Process batch in parallel
        const batchPromises = batch.map(async (business) => {
          try {
            const enrichedData = await fetchSmartEnrichment(business.website, business.name);

            // Update business in cache
            const cacheKey = `${business.searchedZipCode}-${business.category}`;
            const cached = placesCache.searches[cacheKey];
            if (cached && cached.cachedData) {
              const businessIndex = cached.cachedData.findIndex(b => b.placeId === business.placeId);
              if (businessIndex !== -1) {
                const existing = cached.cachedData[businessIndex];
                // IMPORTANT: Preserve existing data, only add new data from enrichment
                cached.cachedData[businessIndex] = {
                  ...existing,
                  email: enrichedData.email || existing.email || '',
                  phone: existing.phone || enrichedData.phone || '',
                  facebook: enrichedData.facebook || existing.facebook || '',
                  instagram: enrichedData.instagram || existing.instagram || '',
                  linkedin: enrichedData.linkedin || existing.linkedin || '',
                  twitter: enrichedData.twitter || existing.twitter || '',
                  contactNames: enrichedData.contactNames?.length > 0 ? enrichedData.contactNames : (existing.contactNames || []),
                  enriched: true,
                  enrichmentSource: '9x12pro-scraper',
                  pagesScraped: enrichedData.pagesScraped || 0,
                  contactScore: calculateContactScore({
                    phone: existing.phone || enrichedData.phone,
                    email: enrichedData.email || existing.email,
                    website: existing.website,
                    facebook: enrichedData.facebook || existing.facebook,
                    instagram: enrichedData.instagram || existing.instagram,
                    linkedin: enrichedData.linkedin || existing.linkedin,
                    twitter: enrichedData.twitter || existing.twitter
                  })
                };

                cached.cachedData[businessIndex].leadScore = calculateProspectScore(cached.cachedData[businessIndex]);
                cached.cachedData[businessIndex].scoreCategory = getScoreCategory(cached.cachedData[businessIndex].leadScore);
              }
            }
            enrichedCount++;
            return { success: true, business };
          } catch (err) {
            console.error(`‚ùå Failed to enrich ${business.name}:`, err);
            return { success: false, business, error: err };
          }
        });

        // Wait for batch to complete
        const results = await Promise.all(batchPromises);

        // Show errors for failed enrichments
        results.filter(r => !r.success).forEach(r => {
          toast(`‚ö†Ô∏è Couldn't enrich ${r.business.name} - continuing...`, false);
        });

        // Log progress after each batch
        console.log(`‚úÖ Enriched ${Math.min(batchStart + BATCH_SIZE, businessesWithWebsites.length)}/${businessesWithWebsites.length} businesses`);
      }

      // Save all enriched data to cache
      await savePlacesCache();
      console.log(`‚úÖ Enrichment complete! ${enrichedCount}/${businessesWithWebsites.length} businesses enriched.`);
    }

    // Just cache results - don't auto-add to prospecting
    // Update API usage display
    updateQuickApiUsage();

    // Show review modal so user can select which prospects to keep
    // (Review modal handles tracking, toasts, and tab switching)
    showProspectReviewModal(allBusinesses, categorizedResults);

  } catch(err) {
    console.error('Bulk auto-populate error:', err);
    toast('Search failed. Please try again.', false);
  } finally {
    // Always remove progress overlay
    const progressOverlay = document.getElementById('enrichment-progress-overlay');
    if (progressOverlay && progressOverlay.parentNode) {
      progressOverlay.remove();
    }
    btn.disabled = false;
    btn.innerHTML = originalBtnText;
  }
}

/* ========= PROSPECTS RESULTS MODAL FUNCTIONS ========= */

function openProspectsResultsModal() {
  const modal = document.getElementById('prospectsResultsModal');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
}

function closeProspectsResultsModal() {
  const modal = document.getElementById('prospectsResultsModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
}

function renderProspectsResults() {
  const { businesses, selectedIds } = prospectsResultsState;
  const container = document.getElementById('prospectsResultsContainer');
  const statsContainer = document.getElementById('prospectsResultsStats');

  // Calculate stats
  const newBusinesses = businesses.filter(b => !b.alreadyExists).length;
  const existingBusinesses = businesses.filter(b => b.alreadyExists).length;
  const selectedCount = selectedIds.size;

  // Render stats
  statsContainer.innerHTML = `
    <div class="bg-green-50 border border-green-200 rounded-lg p-3 text-center">
      <div class="text-2xl font-bold text-green-600">${newBusinesses}</div>
      <div class="text-xs text-green-800">New Businesses</div>
    </div>
    <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 text-center">
      <div class="text-2xl font-bold text-gray-600">${existingBusinesses}</div>
      <div class="text-xs text-gray-800">Already in System</div>
    </div>
    <div class="bg-indigo-50 border border-indigo-200 rounded-lg p-3 text-center">
      <div class="text-2xl font-bold text-indigo-600">${selectedCount}</div>
      <div class="text-xs text-indigo-800">Selected to Add</div>
    </div>
  `;

  // Render business list
  container.innerHTML = businesses.map(business => {
    const isSelected = selectedIds.has(business.placeId);
    const isDisabled = business.alreadyExists;

    return `
      <div class="border rounded-lg p-3 ${isDisabled ? 'bg-gray-50 opacity-60' : 'bg-white hover:shadow-md'} transition">
        <div class="flex items-start gap-3">
          <input
            type="checkbox"
            ${isSelected ? 'checked' : ''}
            ${isDisabled ? 'disabled' : ''}
            onchange="toggleProspectSelection('${business.placeId}')"
            class="mt-1 w-5 h-5 text-indigo-600 rounded cursor-pointer"
          />
          <div class="flex-1 min-w-0">
            <div class="flex items-start justify-between gap-2">
              <div class="flex-1 min-w-0">
                <h4 class="font-semibold text-gray-900 truncate">${esc(business.name)}</h4>
                <p class="text-sm text-gray-600 mt-0.5">${esc(business.address)}</p>
                <div class="flex items-center gap-3 mt-1 text-xs text-gray-500">
                  ${business.rating ? `<span>‚≠ê ${business.rating} (${business.userRatingsTotal || 0} reviews)</span>` : ''}
                </div>
              </div>
              ${isDisabled
                ? '<span class="text-xs font-medium px-2 py-1 bg-gray-200 text-gray-600 rounded whitespace-nowrap">Already in System</span>'
                : `<button onclick="markNotInterested('${business.placeId}')" class="text-xs font-medium px-2 py-1 bg-red-50 text-red-600 rounded hover:bg-red-100 whitespace-nowrap">Not Interested</button>`
              }
            </div>
          </div>
        </div>
      </div>
    `;
  }).join('');

  // Update button text
  const addButton = document.getElementById('btnAddSelectedProspects');
  addButton.textContent = `Add ${selectedCount} to Pipeline`;
  addButton.disabled = selectedCount === 0;
  addButton.classList.toggle('opacity-50', selectedCount === 0);
  addButton.classList.toggle('cursor-not-allowed', selectedCount === 0);
}

function toggleProspectSelection(placeId) {
  if (prospectsResultsState.selectedIds.has(placeId)) {
    prospectsResultsState.selectedIds.delete(placeId);
  } else {
    prospectsResultsState.selectedIds.add(placeId);
  }
  renderProspectsResults();
}

function markNotInterested(placeId) {
  // Find the business
  const business = prospectsResultsState.businesses.find(b => b.placeId === placeId);
  if (!business) return;

  // Confirmation dialog
  if (!confirm(`Mark "${business.name}" as "Not Interested"?\n\nThis business will be permanently hidden from all future searches.\n\nYou can undo this later from the Not Interested list.`)) {
    return;
  }

  // Add to not interested list
  notInterestedState.placeIds.add(placeId);
  notInterestedState.businesses[placeId] = {
    name: business.name,
    address: business.address,
    addedDate: new Date().toISOString()
  };
  saveNotInterestedList();

  // Remove from results
  prospectsResultsState.businesses = prospectsResultsState.businesses.filter(b => b.placeId !== placeId);
  prospectsResultsState.selectedIds.delete(placeId);

  toast(`"${business.name}" marked as not interested and will be hidden from future searches`, true);
  renderProspectsResults();
}

async function addSelectedProspects() {
  // UPDATED: Now uses proper Serper enrichment like addFromProspectPool
  const { businesses, selectedIds } = prospectsResultsState;

  if (selectedIds.size === 0) {
    toast('No businesses selected', false);
    return;
  }

  // Disable button while fetching details
  const btn = document.getElementById('btnAddSelectedProspects');
  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = '‚è≥ Processing...';

  // Use Campaign Board (single source of truth)
  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign selected. Please select a campaign first.', false);
    btn.disabled = false;
    btn.textContent = originalText;
    return;
  }
  if (!board.columns) board.columns = {};
  if (!board.columns['queued']) board.columns['queued'] = [];

  const existingPlaceIds = getCampaignBoardPlaceIds();
  let addedCount = 0;
  let skippedCount = 0;
  const selectedBusinesses = businesses.filter(b => selectedIds.has(b.placeId) && !b.alreadyExists);

  // Filter out already existing ones first
  const toProcess = selectedBusinesses.filter(b => !existingPlaceIds.has(b.placeId || b.id));
  skippedCount = selectedBusinesses.length - toProcess.length;

  // Show enrichment modal for better UX
  if (toProcess.length > 0) {
    showEnrichmentModal(toProcess.length);
  }

  try {
    for (let i = 0; i < toProcess.length; i++) {
      // Check if user cancelled
      if (isEnrichmentCancelled()) {
        console.log('üõë Enrichment cancelled by user');
        break;
      }

      const business = toProcess[i];
      const businessName = business.name || business.businessName || 'Unknown Business';

      // Update modal progress
      updateEnrichmentProgress(i + 1, businessName, false);

      // Start with existing data from HERE API
      let details = {
        phone: business.phone || '',
        website: business.website || '',
        email: business.email || '',
        facebook: business.facebook || '',
        instagram: business.instagram || '',
        linkedin: business.linkedin || '',
        twitter: business.twitter || '',
        source: business.source || 'search'
      };

      // NOTE: Google Places fetchPlaceDetails removed - HERE API already provides phone/website
      const location = business.address ? business.address.split(',').slice(-2).join(',').trim() : '';

      // SERPER ENRICHMENT: Search for website if missing
      if (!details.website) {
        const websiteQuery = `${businessName} ${location} official website`;
        const website = await searchBusinessWebsite(websiteQuery, businessName);
        if (website && !website.includes('yelp.com') && !website.includes('facebook.com') && !website.includes('instagram.com')) {
          details.website = website;
        }
      }

      // SERPER ENRICHMENT: Search for Facebook if missing - DISABLED: unreliable results
      if (ENABLE_SOCIAL_MEDIA_SEARCH && !details.facebook) {
        const fbQuery = `${businessName} ${location} site:facebook.com`;
        const fbResult = await searchBusinessWebsite(fbQuery, businessName);
        if (fbResult && fbResult.includes('facebook.com') && !fbResult.includes('instagram.com')) {
          let cleanFbUrl = fbResult;
          if (fbResult.includes('/posts/') || fbResult.includes('/photos/')) {
            const pageMatch = fbResult.match(/(https?:\/\/[^\/]*facebook\.com\/[^\/\?]+)/);
            if (pageMatch) cleanFbUrl = pageMatch[1];
          }
          details.facebook = cleanFbUrl;
        }
      }

      // SERPER ENRICHMENT: Search for Instagram if missing - DISABLED: unreliable results
      if (ENABLE_SOCIAL_MEDIA_SEARCH && !details.instagram) {
        const igQuery = `${businessName} ${location} site:instagram.com`;
        const igResult = await searchBusinessWebsite(igQuery, businessName);
        if (igResult && igResult.includes('instagram.com') && !igResult.includes('facebook.com')) {
          let cleanedUrl = igResult;
          if (igResult.includes('/p/') || igResult.includes('/reel/')) {
            const match = igResult.match(/instagram\.com\/([^\/\?]+)/);
            if (match && match[1] && !['p', 'reel', 'stories'].includes(match[1])) {
              cleanedUrl = `https://instagram.com/${match[1]}`;
            }
          }
          details.instagram = cleanedUrl;
        }
      }

      // WEBSITE SCRAPING: Get email AND social links from website
      let foundContact = false;
      if (details.website) {
        const enrichedData = await fetchSmartEnrichment(details.website, businessName);
        details.email = enrichedData.email || details.email || '';
        details.facebook = details.facebook || enrichedData.facebook || '';
        details.instagram = details.instagram || enrichedData.instagram || '';
        details.linkedin = details.linkedin || enrichedData.linkedin || '';
        details.twitter = details.twitter || enrichedData.twitter || '';

        // Count as "found" if we got email or website
        if (details.email || details.website) {
          foundContact = true;
        }
      }

      // Update modal with found status
      updateEnrichmentProgress(i + 1, businessName, foundContact);

      // Build notes
      let notes = `Found via ${details.source}\nAddress: ${business.address}\nRating: ${business.rating} (${business.userRatingsTotal} reviews)\n`;
      if (details.phone) notes += `Phone: ${details.phone}\n`;
      if (details.website) notes += `Website: ${details.website}\n`;
      if (details.email) notes += `üìß Email: ${details.email}\n`;
      if (details.facebook) notes += `üìò Facebook: ${details.facebook}\n`;
      if (details.instagram) notes += `üì∑ Instagram: ${details.instagram}\n`;

      const newLead = {
        id: Date.now() + Math.random(),
        businessName: businessName,
        contactName: '',
        phone: details.phone || '',
        email: details.email || '',
        estimatedValue: 500,
        notes: notes,
        source: details.source,
        placeId: business.placeId,
        address: business.address || '',
        rating: business.rating || 0,
        userRatingsTotal: business.userRatingsTotal || 0,
        website: details.website || '',
        facebook: details.facebook || '',
        instagram: details.instagram || '',
        linkedin: details.linkedin || '',
        twitter: details.twitter || '',
        category: business.category || 'other',
        zipCode: truncateZipTo5(business.zipCode) || null,
        mailerId: state.current?.Mailer_ID || null,
        addedDate: new Date().toISOString(),
        interactions: [],
        enriched: true
      };

      // Add to Campaign Board (single source of truth)
      const enhancedLead = enhanceBusinessForCampaignBoard(newLead, board.config?.maxAttempts || 4);
      board.columns['queued'].push(enhancedLead);
      addedCount++;

      // Delay between requests to avoid rate limiting (Scrapingdog limit ~30/min)
      if (i < toProcess.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }

    // Hide enrichment modal
    hideEnrichmentModal(true);

    // Save to Campaign Board
    await saveCampaignBoards();
    renderKanban();
    closeProspectsResultsModal();

    // Show success message
    let message = `‚úÖ Added ${addedCount} prospect${addedCount === 1 ? '' : 's'}!`;
    if (skippedCount > 0) {
      message += ` ${skippedCount} duplicate${skippedCount === 1 ? '' : 's'} skipped.`;
    }
    toast(message, true);

    // Switch to Pipeline tab
    setTimeout(() => {
      switchTab('pipeline');
    }, 100);
  } catch(err) {
    console.error('Error adding prospects:', err);
    hideEnrichmentModal(false);
    toast('Failed to add prospects. Please try again.', false);
  } finally {
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

/* ========= PROSPECT POOL FUNCTIONS ========= */

// State for prospect pool selections and manual moves
let prospectPoolState = {
  selectedIds: new Set(),
  manualProspects: [], // Prospects manually moved from Prospecting to Pool
  renderedProspects: {} // Lookup table for all rendered prospects by ID
};

// Track search API usage (Serper primary: 2,500/month, Google fallback: 100/day)
// This is informational only - Serper doesn't enforce per-user limits
let enrichmentQuota = {
  dailyLimit: 83, // ~2,500/month √∑ 30 days
  queriesUsed: 0,
  lastResetDate: null
};

// Load enrichment quota from Supabase (persists across refreshes/updates)
async function loadEnrichmentQuota() {
  try {
    const cloudData = await loadFromCloud('apiUsage');
    const today = new Date().toDateString();

    if (cloudData) {
      // Reset if it's a new day
      if (cloudData.lastResetDate !== today) {
        console.log('üìä API Usage: New day detected, resetting counter');
        enrichmentQuota.queriesUsed = 0;
        enrichmentQuota.lastResetDate = today;
        await saveEnrichmentQuota();
      } else {
        enrichmentQuota.queriesUsed = cloudData.queriesUsed || 0;
        enrichmentQuota.lastResetDate = cloudData.lastResetDate;
        console.log(`üìä API Usage: Loaded ${enrichmentQuota.queriesUsed} queries used today`);
      }
    } else {
      // First time - initialize
      enrichmentQuota.lastResetDate = today;
      await saveEnrichmentQuota();
      console.log('üìä API Usage: Initialized new tracking');
    }
  } catch (e) {
    console.warn('Failed to load API usage from cloud, using localStorage fallback:', e);
    // Fallback to localStorage
    const saved = localStorage.getItem('9x12_enrichment_quota');
    if (saved) {
      const data = JSON.parse(saved);
      enrichmentQuota.queriesUsed = data.queriesUsed || 0;
      enrichmentQuota.lastResetDate = data.lastResetDate;
    }
  }
  updateEnrichmentCounter();
}

// Save enrichment quota to Supabase
async function saveEnrichmentQuota() {
  const data = {
    queriesUsed: enrichmentQuota.queriesUsed,
    lastResetDate: enrichmentQuota.lastResetDate,
    lastUpdated: new Date().toISOString()
  };

  // Save to cloud (primary)
  try {
    await saveToCloud('apiUsage', data);
  } catch (e) {
    console.warn('Failed to save API usage to cloud:', e);
  }

  // Also save to localStorage as backup
  localStorage.setItem('9x12_enrichment_quota', JSON.stringify(data));
  updateEnrichmentCounter();
}

// Increment the query counter
async function trackEnrichmentQuery(count = 1) {
  enrichmentQuota.queriesUsed += count;
  await saveEnrichmentQuota();
}

// Update the UI counter
function updateEnrichmentCounter() {
  const counter = document.getElementById('enrichmentQuotaCounter');
  if (counter) {
    const remaining = Math.max(0, enrichmentQuota.dailyLimit - enrichmentQuota.queriesUsed);
    const percentage = (enrichmentQuota.queriesUsed / enrichmentQuota.dailyLimit) * 100;

    let colorClass = 'text-green-600';
    if (percentage >= 80) colorClass = 'text-red-600';
    else if (percentage >= 50) colorClass = 'text-yellow-600';

    counter.innerHTML = `
      <span class="${colorClass} font-bold">${enrichmentQuota.queriesUsed}</span>
      <span class="text-gray-500">/ ${enrichmentQuota.dailyLimit}</span>
      <span class="text-gray-400 text-xs ml-1">searches today</span>
    `;
  }
}

// State for tracking selected prospects in Prospecting column
let prospectingSelectionState = {
  selectedIds: new Set()
};

// To Contact selection state for bulk messaging
let toContactSelectionState = {
  selectedIds: new Set()
};

// In Progress selection state for bulk operations
let inProgressSelectionState = {
  selectedIds: new Set()
};

// Committed selection state for bulk operations
let committedSelectionState = {
  selectedIds: new Set()
};

// Business Categories State
let businessCategories = [
  // AUTOMOTIVE
  { value: "auto_body_shop", label: "Auto Body Shop" },
  { value: "auto_detailing", label: "Auto Detailing" },
  { value: "auto_glass", label: "Auto Glass Repair" },
  { value: "car_repair", label: "Auto Repair" },
  { value: "car_dealer", label: "Car Dealer" },
  { value: "car_wash", label: "Car Wash" },
  { value: "motorcycle_dealer", label: "Motorcycle Dealer" },
  { value: "rv_dealer", label: "RV Dealer" },
  { value: "tire_shop", label: "Tire Shop" },
  { value: "towing_service", label: "Towing Service" },
  { value: "truck_repair", label: "Truck Repair" },

  // CONSTRUCTION & CONTRACTORS
  { value: "cabinet_maker", label: "Cabinet Maker" },
  { value: "carpenter", label: "Carpenter" },
  { value: "concrete_contractor", label: "Concrete Contractor" },
  { value: "deck_builder", label: "Deck Builder" },
  { value: "drywall_contractor", label: "Drywall Contractor" },
  { value: "electrician", label: "Electrician" },
  { value: "fence_contractor", label: "Fence Installation" },
  { value: "flooring_contractor", label: "Flooring Contractor" },
  { value: "foundation_repair", label: "Foundation Repair" },
  { value: "general_contractor", label: "General Contractor" },
  { value: "gutter_service", label: "Gutter Installation/Repair" },
  { value: "handyman", label: "Handyman" },
  { value: "hvac_contractor", label: "HVAC" },
  { value: "insulation_contractor", label: "Insulation Contractor" },
  { value: "kitchen_remodeling", label: "Kitchen & Bath Remodeling" },
  { value: "masonry", label: "Masonry" },
  { value: "painter", label: "Painter" },
  { value: "plumber", label: "Plumber" },
  { value: "roofing_contractor", label: "Roofer" },
  { value: "siding_contractor", label: "Siding Contractor" },
  { value: "waterproofing", label: "Waterproofing" },
  { value: "window_installation", label: "Window Installation" },

  // FOOD & BEVERAGE (Use "Restaurant" for all dining; specific types can be searched via custom category)
  { value: "bakery", label: "Bakery" },
  { value: "bar", label: "Bar/Pub" },
  { value: "cafe", label: "Cafe/Coffee Shop" },
  { value: "meal_delivery", label: "Catering" },
  { value: "food_truck", label: "Food Truck" },
  { value: "restaurant", label: "Restaurant" },

  // HEALTH & MEDICAL
  { value: "acupuncture", label: "Acupuncture" },
  { value: "chiropractor", label: "Chiropractor" },
  { value: "dentist", label: "Dentist" },
  { value: "doctor", label: "Doctor/Physician" },
  { value: "hearing_aid", label: "Hearing Aid Provider" },
  { value: "medical_spa", label: "Medical Spa" },
  { value: "mental_health", label: "Mental Health Services" },
  { value: "optometrist", label: "Optometrist" },
  { value: "pediatrician", label: "Pediatrician" },
  { value: "pharmacy", label: "Pharmacy" },
  { value: "physiotherapist", label: "Physical Therapy" },
  { value: "senior_care", label: "Senior Care/Assisted Living" },
  { value: "urgent_care", label: "Urgent Care" },
  { value: "veterinary_care", label: "Veterinarian" },

  // HOME & OUTDOOR SERVICES
  { value: "cleaning", label: "Cleaning Service" },
  { value: "gutter_cleaning", label: "Gutter Cleaning" },
  { value: "home_inspection", label: "Home Inspection" },
  { value: "junk_removal", label: "Junk Removal" },
  { value: "landscaping", label: "Landscaping" },
  { value: "lawn_care", label: "Lawn Care/Mowing" },
  { value: "locksmith", label: "Locksmith" },
  { value: "moving_company", label: "Moving Company" },
  { value: "pest_control", label: "Pest Control" },
  { value: "pool_service", label: "Pool Service & Repair" },
  { value: "pressure_washing", label: "Pressure Washing" },
  { value: "septic_service", label: "Septic Service" },
  { value: "tree_service", label: "Tree Service" },
  { value: "well_drilling", label: "Well Drilling & Repair" },
  { value: "window_cleaning", label: "Window Washing" },

  // REGIONAL: NORTHERN STATES (Snow/Winter)
  { value: "firewood_delivery", label: "Firewood Delivery" },
  { value: "heating_oil", label: "Heating Oil Delivery" },
  { value: "ice_dam_removal", label: "Ice Dam Removal" },
  { value: "snowplowing", label: "Snow Plowing" },
  { value: "snow_removal", label: "Snow Removal" },

  // REGIONAL: SOUTHERN/COASTAL (Hurricane/Tropical)
  { value: "hurricane_shutters", label: "Hurricane Shutters" },
  { value: "storm_cleanup", label: "Storm Cleanup & Restoration" },

  // REGIONAL: SOUTHWEST (Desert/Arid)
  { value: "desert_landscaping", label: "Desert Landscaping/Xeriscaping" },
  { value: "irrigation_systems", label: "Irrigation Systems" },

  // REGIONAL: COASTAL (Marine)
  { value: "boat_repair", label: "Boat Repair & Service" },
  { value: "dock_builder", label: "Dock & Pier Construction" },
  { value: "marina", label: "Marina" },

  // PERSONAL SERVICES
  { value: "barber", label: "Barber Shop" },
  { value: "beauty_salon", label: "Hair & Beauty Salon" },
  { value: "day_spa", label: "Spa/Massage" },
  { value: "dog_grooming", label: "Pet Grooming" },
  { value: "dry_cleaning", label: "Dry Cleaner" },
  { value: "gym", label: "Gym/Fitness Center" },
  { value: "laundromat", label: "Laundromat" },
  { value: "nail_salon", label: "Nail Salon" },
  { value: "tanning_salon", label: "Tanning Salon" },
  { value: "tattoo_shop", label: "Tattoo Shop" },
  { value: "yoga_studio", label: "Yoga/Pilates Studio" },

  // PROFESSIONAL SERVICES
  { value: "accountant", label: "Accountant/CPA" },
  { value: "attorney", label: "Attorney/Lawyer" },
  { value: "financial_advisor", label: "Financial Advisor" },
  { value: "insurance_agency", label: "Insurance Agency" },
  { value: "marketing_agency", label: "Marketing Agency" },
  { value: "photographer", label: "Photography" },
  { value: "printing_service", label: "Printing Service" },
  { value: "real_estate_agency", label: "Real Estate" },
  { value: "tax_service", label: "Tax Preparation" },
  { value: "web_design", label: "Web Design" },

  // RETAIL
  { value: "antique_store", label: "Antique Store" },
  { value: "bicycle_store", label: "Bicycle Shop" },
  { value: "boat_dealer", label: "Boat Dealer" },
  { value: "boutique", label: "Boutique" },
  { value: "furniture_store", label: "Furniture Store" },
  { value: "garden_center", label: "Garden Center/Nursery" },
  { value: "gun_shop", label: "Gun Shop" },
  { value: "hardware_store", label: "Hardware Store" },
  { value: "jewelry_store", label: "Jewelry Store" },
  { value: "liquor_store", label: "Liquor Store" },
  { value: "mattress_store", label: "Mattress Store" },
  { value: "pet_store", label: "Pet Store" },
  { value: "sporting_goods", label: "Sporting Goods" },
  { value: "thrift_store", label: "Thrift Store" },

  // RECREATION & ENTERTAINMENT
  { value: "bowling_alley", label: "Bowling Alley" },
  { value: "golf_course", label: "Golf Course" },
  { value: "mini_golf", label: "Mini Golf" },
  { value: "movie_theater", label: "Movie Theater" },

  // EDUCATION & CHILDCARE
  { value: "dance_studio", label: "Dance Studio" },
  { value: "daycare", label: "Daycare/Preschool" },
  { value: "martial_arts", label: "Martial Arts Studio" },
  { value: "music_school", label: "Music School" },
  { value: "tutoring", label: "Tutoring Service" },

  // OTHER SERVICES
  { value: "event_planning", label: "Event Planning" },
  { value: "florist", label: "Florist" },
  { value: "funeral_home", label: "Funeral Home" },
  { value: "hotel", label: "Hotel/Motel" },
  { value: "storage", label: "Storage Facility" },
  { value: "wedding_venue", label: "Wedding Venue" }
];

// Load business categories from cloud/localStorage
async function loadBusinessCategories() {
  try {
    const cloudData = await loadFromCloud('businessCategories');

    // ONE-TIME MIGRATION: Force update to simplified category list
    // v5: Added Daycare/Preschool category
    const CATEGORY_VERSION = '2026-02-04-v5';
    const currentVersion = localStorage.getItem('categoryVersion');

    if (currentVersion !== CATEGORY_VERSION) {
      console.log('üîÑ Migrating to simplified business categories (consolidated similar categories)');
      // Use the new default categories
      businessCategories.sort((a, b) => a.label.localeCompare(b.label));
      await saveToCloud('businessCategories', businessCategories);
      localStorage.setItem('categoryVersion', CATEGORY_VERSION);
      console.log('‚úÖ Categories migrated and saved to cloud');
    } else if (cloudData && Array.isArray(cloudData) && cloudData.length > 0) {
      businessCategories = cloudData;
    }

    // Sort alphabetically by label
    businessCategories.sort((a, b) => a.label.localeCompare(b.label));
    renderBusinessCategories();
  } catch(err) {
    console.warn('Using default business categories:', err);
    businessCategories.sort((a, b) => a.label.localeCompare(b.label));
    renderBusinessCategories();
  }
}

// Save business categories to cloud
async function saveBusinessCategories() {
  try {
    // Sort alphabetically before saving
    businessCategories.sort((a, b) => a.label.localeCompare(b.label));
    await saveToCloud('businessCategories', businessCategories);
    toast('Categories saved', true);
  } catch(err) {
    console.warn('Failed to save categories:', err);
    toast('Categories saved locally only', false);
  }
}

// Render business categories dynamically
function renderBusinessCategories() {
  const container = document.getElementById('categoryCheckboxContainer');
  if (!container) return;

  container.innerHTML = businessCategories.map(cat => `
    <label class="flex items-center gap-2 text-sm cursor-pointer hover:bg-white/10 p-2 rounded transition">
      <input type="checkbox" value="${cat.value}" class="category-checkbox rounded text-purple-600 focus:ring-purple-500" />
      <span>${cat.label}</span>
    </label>
  `).join('');

  // Also update client category dropdowns
  populateClientCategoryDropdowns();
}


// Populate client category dropdowns with current businessCategories
function populateClientCategoryDropdowns() {
  // Update client modal category dropdown
  const clientCategorySelect = document.getElementById('clientCategory');
  if (clientCategorySelect) {
    const currentValue = clientCategorySelect.value;
    const options = businessCategories.map(cat =>
      `<option value="${esc(cat.label)}">${esc(cat.label)}</option>`
    ).join('');
    clientCategorySelect.innerHTML = `<option value="">Select category...</option>${options}`;
    if (currentValue) clientCategorySelect.value = currentValue;
  }

  // Update business modal category dropdown (unified modal)
  const businessCategorySelect = document.getElementById('businessCategory');
  if (businessCategorySelect) {
    const currentValue = businessCategorySelect.value;
    const options = businessCategories.map(cat =>
      `<option value="${esc(cat.label)}">${esc(cat.label)}</option>`
    ).join('');
    businessCategorySelect.innerHTML = `<option value="">Select category...</option>${options}`;
    if (currentValue) businessCategorySelect.value = currentValue;
  }

  // Update manual business category dropdown
  const manualBusinessCategorySelect = document.getElementById('manualBusinessCategory');
  if (manualBusinessCategorySelect) {
    const currentValue = manualBusinessCategorySelect.value;
    const options = businessCategories.map(cat =>
      `<option value="${esc(cat.label)}">${esc(cat.label)}</option>`
    ).join('');
    manualBusinessCategorySelect.innerHTML = `<option value="">Select category...</option>${options}`;
    if (currentValue) manualBusinessCategorySelect.value = currentValue;
  }

  // Update client filter dropdown
  const categoryFilter = document.getElementById('categoryFilter');
  if (categoryFilter) {
    const currentValue = categoryFilter.value;
    const options = businessCategories.map(cat =>
      `<option value="${esc(cat.label)}">${esc(cat.label)}</option>`
    ).join('');
    categoryFilter.innerHTML = `<option value="">All Categories</option>${options}`;
    if (currentValue) categoryFilter.value = currentValue;
  }
}

// Open Manage Categories Modal
function openManageCategoriesModal() {
  const modal = document.getElementById('manageCategoriesModal');
  if (!modal) return;

  // Sort categories alphabetically before displaying
  businessCategories.sort((a, b) => a.label.localeCompare(b.label));
  renderManageCategoriesList();

  lastFocusedElementBeforeModal = document.activeElement;
  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);

  // Focus on input field
  const input = document.getElementById('newCategoryInput');
  if (input) input.focus();
}

// Close Manage Categories Modal
function closeManageCategoriesModal() {
  const modal = document.getElementById('manageCategoriesModal');
  if (!modal) return;

  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
  if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();

  // Clear input field
  const input = document.getElementById('newCategoryInput');
  if (input) input.value = '';
}

// Render the categories list in the manage modal
function renderManageCategoriesList() {
  const container = document.getElementById('manageCategoriesList');
  if (!container) return;

  if (businessCategories.length === 0) {
    container.innerHTML = '<p class="text-gray-500 text-sm italic">No categories yet. Add one above!</p>';
    return;
  }

  container.innerHTML = businessCategories.map((cat, index) => `
    <div class="flex items-center justify-between p-3 bg-white/10 border border-white/20 rounded-lg hover:bg-white/20 transition">
      <span class="font-medium">${cat.label}</span>
      <button
        onclick="removeCategory(${index})"
        class="px-3 py-1 text-sm bg-red-500 hover:bg-red-600 text-white rounded transition font-semibold"
        title="Remove ${cat.label}"
      >
        ‚ùå Remove
      </button>
    </div>
  `).join('');
}

// Add a new category
function addNewCategory() {
  const input = document.getElementById('newCategoryInput');
  if (!input) return;

  const newLabel = input.value.trim();
  if (!newLabel) {
    toast('Please enter a category name', false);
    return;
  }

  // Check for duplicates (case-insensitive)
  const exists = businessCategories.some(cat =>
    cat.label.toLowerCase() === newLabel.toLowerCase()
  );

  if (exists) {
    toast('Category already exists', false);
    return;
  }

  // Create a value from the label (lowercase, replace spaces with hyphens)
  const newValue = newLabel.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

  // Add the new category
  businessCategories.push({
    value: newValue,
    label: newLabel
  });

  // Sort alphabetically
  businessCategories.sort((a, b) => a.label.localeCompare(b.label));

  // Re-render the list
  renderManageCategoriesList();

  // Clear input
  input.value = '';
  input.focus();

  toast(`Added "${newLabel}"`, true);
}

// Remove a category
function removeCategory(index) {
  if (index < 0 || index >= businessCategories.length) return;

  const category = businessCategories[index];

  if (!confirm(`Remove "${category.label}" from categories?`)) {
    return;
  }

  businessCategories.splice(index, 1);
  renderManageCategoriesList();
  toast(`Removed "${category.label}"`, true);
}

// Save categories and close modal
async function saveManageCategories() {
  await saveBusinessCategories();
  renderBusinessCategories();
  closeManageCategoriesModal();
}

/**
 * Category Normalization Mapping
 * Maps various category strings to a canonical form
 * Keys are lowercase versions of category strings that should be merged
 * Values are the canonical category label to use
 */
const categoryMergeMapping = {
  // Automotive variations
  "auto repair": "Auto Repair",
  "car repair": "Auto Repair",
  "auto service": "Auto Repair",
  "automotive repair": "Auto Repair",
  "mechanic": "Auto Repair",
  "car mechanic": "Auto Repair",
  "auto body": "Auto Body Shop",
  "body shop": "Auto Body Shop",
  "collision repair": "Auto Body Shop",
  "car dealer": "Car Dealer",
  "auto dealer": "Car Dealer",
  "used cars": "Car Dealer",
  "car dealership": "Car Dealer",

  // Real Estate variations
  "real estate": "Real Estate",
  "real estate agency": "Real Estate",
  "realtor": "Real Estate",
  "real estate agent": "Real Estate",
  "realty": "Real Estate",

  // Plumbing variations
  "plumber": "Plumber",
  "plumbing": "Plumber",
  "plumbing services": "Plumber",
  "plumbing contractor": "Plumber",

  // HVAC variations
  "hvac": "HVAC",
  "hvac contractor": "HVAC",
  "heating and cooling": "HVAC",
  "air conditioning": "HVAC",
  "heating": "HVAC",
  "ac repair": "HVAC",

  // Roofing variations
  "roofer": "Roofer",
  "roofing": "Roofer",
  "roofing contractor": "Roofer",
  "roof repair": "Roofer",

  // Electrician variations
  "electrician": "Electrician",
  "electrical": "Electrician",
  "electrical contractor": "Electrician",
  "electric": "Electrician",

  // Dentist variations
  "dentist": "Dentist",
  "dental": "Dentist",
  "dental office": "Dentist",
  "dentistry": "Dentist",

  // Hair/Beauty variations
  "hair salon": "Hair Salon",
  "hair care": "Hair Salon",
  "hairdresser": "Hair Salon",
  "beauty salon": "Beauty Salon",
  "beauty shop": "Beauty Salon",
  "barber": "Barber Shop",
  "barber shop": "Barber Shop",
  "barbershop": "Barber Shop",

  // Restaurant variations
  "restaurant": "Restaurant",
  "restaurants": "Restaurant",
  "dining": "Restaurant",
  "eatery": "Restaurant",

  // Contractor variations
  "general contractor": "General Contractor",
  "contractor": "General Contractor",
  "home improvement": "General Contractor",
  "remodeling": "General Contractor",

  // Attorney/Lawyer variations
  "attorney": "Attorney/Lawyer",
  "lawyer": "Attorney/Lawyer",
  "law firm": "Attorney/Lawyer",
  "legal services": "Attorney/Lawyer",

  // Insurance variations
  "insurance": "Insurance Agency",
  "insurance agency": "Insurance Agency",
  "insurance agent": "Insurance Agency",

  // Landscaping variations
  "landscaping": "Landscaping",
  "landscaper": "Landscaping",
  "landscape": "Landscaping",
  "lawn care": "Lawn Care/Mowing",
  "lawn service": "Lawn Care/Mowing",
  "lawn mowing": "Lawn Care/Mowing",

  // Cleaning variations
  "cleaning service": "Cleaning Service",
  "cleaning": "Cleaning Service",
  "house cleaning": "Cleaning Service",
  "maid service": "Cleaning Service",
  "janitorial": "Cleaning Service",

  // Moving variations
  "moving company": "Moving Company",
  "movers": "Moving Company",
  "moving": "Moving Company",
  "moving service": "Moving Company",

  // Photography variations
  "photography": "Photography",
  "photographer": "Photography",
  "photo studio": "Photography",

  // Pet variations
  "veterinarian": "Veterinarian",
  "vet": "Veterinarian",
  "veterinary": "Veterinarian",
  "animal hospital": "Veterinarian",
  "pet store": "Pet Store",
  "pet shop": "Pet Store",

  // Fitness variations
  "gym": "Gym/Fitness Center",
  "fitness": "Gym/Fitness Center",
  "fitness center": "Gym/Fitness Center",
  "health club": "Gym/Fitness Center",

  // Tree service variations
  "tree service": "Tree Service",
  "tree removal": "Tree Service",
  "tree trimming": "Tree Service",
  "arborist": "Tree Service",

  // Pest control variations
  "pest control": "Pest Control",
  "exterminator": "Pest Control",
  "pest removal": "Pest Control",

  // Veterinary variations (additional)
  "veterinary hospital": "Veterinarian",
  "animal clinic": "Veterinarian",
  "pet hospital": "Veterinarian",

  // Pressure washing variations
  "power washing": "Pressure Washing",
  "powerwashing": "Pressure Washing",
  "pressure wash": "Pressure Washing",

  // Daycare variations
  "daycare": "Daycare/Preschool",
  "day care": "Daycare/Preschool",
  "preschool": "Daycare/Preschool",
  "childcare": "Daycare/Preschool",
  "child care": "Daycare/Preschool",

  // Pet care variations
  "pet care": "Pet Store",
  "pet services": "Pet Store",

  // Home improvement/construction variations
  "home remodeling": "General Contractor",
  "home construction": "General Contractor",
  "home renovation": "General Contractor",
  "renovation": "General Contractor",

  // Marketing variations
  "marketing": "Marketing Agency",
  "digital marketing": "Marketing Agency",
  "advertising": "Marketing Agency",

  // Automotive general
  "automotive": "Auto Repair"
};

/**
 * Analyze categories currently used in the client database
 * Shows unique categories and their counts
 */
function analyzeDatabaseCategories() {
  const clients = Object.values(crmState.clients);
  const categoryCounts = {};
  let uncategorized = 0;

  clients.forEach(client => {
    const cat = (client.category || "").trim();
    if (!cat) {
      uncategorized++;
    } else {
      categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
    }
  });

  // Sort by count descending
  const sorted = Object.entries(categoryCounts)
    .sort((a, b) => b[1] - a[1]);

  console.log('=== DATABASE CATEGORY ANALYSIS ===');
  console.log(`Total clients: ${clients.length}`);
  console.log(`Uncategorized: ${uncategorized}`);
  console.log(`Unique categories: ${sorted.length}`);
  console.log('---');

  sorted.forEach(([cat, count]) => {
    const normalizedTo = getCategoryNormalization(cat);
    const marker = normalizedTo !== cat ? ` ‚Üí "${normalizedTo}"` : '';
    console.log(`  "${cat}": ${count}${marker}`);
  });

  // Count how many would be normalized
  const needsNormalization = sorted.filter(([cat]) => getCategoryNormalization(cat) !== cat);
  console.log('---');
  console.log(`Categories that will be normalized: ${needsNormalization.length}`);

  return { categoryCounts, uncategorized, total: clients.length };
}

/**
 * Get the normalized/canonical category for a given category string
 */
function getCategoryNormalization(category) {
  if (!category) return "";

  const lower = category.toLowerCase().trim();

  // Check if there's a merge mapping
  if (categoryMergeMapping[lower]) {
    return categoryMergeMapping[lower];
  }

  // Check if it matches a businessCategories label (case-insensitive)
  const matchedCategory = businessCategories.find(c =>
    c.label.toLowerCase() === lower
  );
  if (matchedCategory) {
    return matchedCategory.label; // Return with proper casing
  }

  // Return as-is if no mapping found
  return category;
}

/**
 * Normalize all categories in the client database
 * Merges similar categories to canonical forms
 */
async function normalizeDatabaseCategories() {
  const clients = Object.values(crmState.clients);
  let updated = 0;
  const changes = [];

  for (const client of clients) {
    const oldCategory = client.category || "";
    const newCategory = getCategoryNormalization(oldCategory);

    if (oldCategory && newCategory !== oldCategory) {
      changes.push({
        business: client.businessName,
        from: oldCategory,
        to: newCategory
      });
      client.category = newCategory;
      updated++;
    }
  }

  if (updated > 0) {
    // Save to cloud
    await saveClients();

    console.log('=== CATEGORY NORMALIZATION COMPLETE ===');
    console.log(`Updated ${updated} clients:`);
    changes.forEach(c => {
      console.log(`  "${c.business}": "${c.from}" ‚Üí "${c.to}"`);
    });

    // Refresh the client list
    renderClientList();

    toast(`Normalized ${updated} client categories`, true);
  } else {
    console.log('No categories needed normalization');
    toast('All categories are already normalized', true);
  }

  return { updated, changes };
}

/**
 * Show category normalization dialog
 */
function showCategoryNormalizationDialog() {
  // First analyze
  const analysis = analyzeDatabaseCategories();

  const categoriesNeedingUpdate = Object.entries(analysis.categoryCounts)
    .filter(([cat]) => getCategoryNormalization(cat) !== cat);

  if (categoriesNeedingUpdate.length === 0) {
    toast('All categories are already normalized!', true);
    return;
  }

  // Build preview message
  let message = `Found ${categoriesNeedingUpdate.length} categories to normalize:\n\n`;
  categoriesNeedingUpdate.forEach(([cat, count]) => {
    message += `‚Ä¢ "${cat}" (${count} clients) ‚Üí "${getCategoryNormalization(cat)}"\n`;
  });
  message += '\nProceed with normalization?';

  if (confirm(message)) {
    normalizeDatabaseCategories();
  }
}

// Expose category normalization functions globally for console access
window.analyzeDatabaseCategories = analyzeDatabaseCategories;
window.normalizeDatabaseCategories = normalizeDatabaseCategories;
window.showCategoryNormalizationDialog = showCategoryNormalizationDialog;

// Deduplicate manual prospects pool
function deduplicateManualProspects() {
  const seenPlaceIds = new Set();
  const seenNormalizedNames = new Map(); // Map of normalizedName -> index in deduped array
  const deduped = [];
  let totalRemoved = 0;

  // Helper to normalize name for deduplication (handles &/and, apostrophes, spacing)
  const normalizeNameForDedup = (name) => {
    if (!name) return '';
    // First, truncate at common separators to get core business name
    // Includes: bullets (‚Ä¢¬∑‚óè), pipes (|), colons (:), dashes (-‚Äì‚Äî), and other separators
    let coreName = name.split(/[‚Ä¢¬∑‚óè|:\-‚Äì‚Äî‚ñ∫‚ñ∏‚Ä£‚ÅÉ]/)[0];
    return coreName.toLowerCase()
      .replace(/&/g, 'and')
      .replace(/['''`¬¥]/g, '')  // Remove all apostrophe variations
      .replace(/\s+/g, ' ')
      .replace(/[^\w\s]/g, '')
      .trim();
  };

  // Helper to calculate "data richness" score for keeping the best version
  const getDataScore = (p) => {
    let score = 0;
    if (p.phone) score += 1;
    if (p.email) score += 2;
    if (p.website) score += 2;
    if (p.facebook) score += 1;
    if (p.instagram) score += 1;
    if (p.linkedin) score += 1;
    if (p.contactName) score += 1;
    if (p.isEnriched) score += 3;
    return score;
  };

  prospectPoolState.manualProspects.forEach(prospect => {
    if (typeof prospect !== 'object') {
      deduped.push(prospect);
      return;
    }

    const prospectName = prospect.businessName || prospect.name || prospect.title || '';
    const normalizedName = normalizeNameForDedup(prospectName);

    // Check 1: Skip if we've seen this placeId
    if (prospect.placeId && seenPlaceIds.has(prospect.placeId)) {
      totalRemoved++;
      console.log(`üßπ Removing duplicate (placeId): ${prospectName}`);
      return;
    }

    // Check 2: Skip/merge if we've seen this normalized business name
    if (normalizedName && seenNormalizedNames.has(normalizedName)) {
      const existingIndex = seenNormalizedNames.get(normalizedName);
      const existingProspect = deduped[existingIndex];

      // Keep the version with more data (merge if new has better data)
      const existingScore = getDataScore(existingProspect);
      const newScore = getDataScore(prospect);

      if (newScore > existingScore) {
        // Merge new prospect into existing, keeping the richer data
        deduped[existingIndex] = {
          ...existingProspect,
          ...prospect,
          // Keep earliest movedToPoolDate
          movedToPoolDate: existingProspect.movedToPoolDate && prospect.movedToPoolDate
            ? (new Date(existingProspect.movedToPoolDate) < new Date(prospect.movedToPoolDate)
              ? existingProspect.movedToPoolDate : prospect.movedToPoolDate)
            : existingProspect.movedToPoolDate || prospect.movedToPoolDate
        };
        console.log(`üßπ Merged duplicate (name), kept richer data: ${prospectName}`);
      } else {
        console.log(`üßπ Removing duplicate (name): ${prospectName}`);
      }
      totalRemoved++;

      // Also track the new placeId if different
      if (prospect.placeId) {
        seenPlaceIds.add(prospect.placeId);
      }
      return;
    }

    // Not a duplicate - add to deduped list
    deduped.push(prospect);

    // Track this prospect
    if (prospect.placeId) {
      seenPlaceIds.add(prospect.placeId);
    }
    if (normalizedName) {
      seenNormalizedNames.set(normalizedName, deduped.length - 1);
    }
  });

  prospectPoolState.manualProspects = deduped;

  if (totalRemoved > 0) {
    console.log(`üßπ Removed/merged ${totalRemoved} duplicate prospect(s) from manual prospects pool`);
  }

  return totalRemoved;
}

// Load manual prospects from localStorage
async function loadManualProspects() {
  console.log('üì• LOADING MANUAL PROSPECTS...');
  try {
    // Try loading from cloud first
    const cloudData = await loadFromCloud('manualProspects');
    console.log('üì• Manual prospects cloud data:', cloudData ? `${cloudData.length} items` : 'null');

    if (cloudData && Array.isArray(cloudData)) {
      prospectPoolState.manualProspects = cloudData;
    } else {
      // Fallback to localStorage
      const saved = localStorage.getItem('9x12_manual_prospects');
      if (saved) {
        prospectPoolState.manualProspects = JSON.parse(saved);
        // Sync to cloud
        saveToCloud('manualProspects', prospectPoolState.manualProspects).catch(e => console.warn('Failed to sync manual prospects to cloud:', e));
      }
    }

    // Deduplicate after loading
    const duplicatesRemoved = deduplicateManualProspects();
    if (duplicatesRemoved > 0) {
      // Save cleaned data back
      await saveToCloud('manualProspects', prospectPoolState.manualProspects).catch(e => console.warn('Failed to save deduplicated manual prospects:', e));
    }

    // Auto-cleanup: Run once to remove town field (v4 - preserves isEnriched)
    const hasRunCleanup = localStorage.getItem('hasRunProspectPoolCleanup_v4');
    console.log('üîç Checking cleanup status:', hasRunCleanup ? 'Already run' : 'Need to run');
    console.log('üîç Manual prospects count:', prospectPoolState.manualProspects.length);

    if (!hasRunCleanup) {
      console.log('üîß Running one-time prospect pool cleanup (v4 - remove town field, preserve enrichment)...');
      await cleanupProspectPoolEnrichment();
      localStorage.setItem('hasRunProspectPoolCleanup_v4', 'true');
      console.log('‚úÖ One-time cleanup complete. Will not run again.');
    } else {
      console.log('‚è≠Ô∏è Cleanup already completed previously.');
    }

    // v5 cleanup: Normalize ZIP codes to 5 digits
    const hasRunZipCleanup = localStorage.getItem('hasRunZipNormalization_v5');
    if (!hasRunZipCleanup) {
      console.log('üîß Running one-time ZIP code normalization (v5)...');
      await normalizeAllZipCodes();
      localStorage.setItem('hasRunZipNormalization_v5', 'true');
      console.log('‚úÖ ZIP normalization complete. Will not run again.');
    }

    // v7 cleanup: Normalize categories with EXPANDED aliases (car wash ‚Üí auto_detailing, etc.)
    const hasRunCategoryCleanup = localStorage.getItem('hasRunCategoryNormalization_v7');
    if (!hasRunCategoryCleanup) {
      console.log('üîß Running category normalization with expanded aliases (v7)...');
      await normalizeAllCategories();
      localStorage.setItem('hasRunCategoryNormalization_v7', 'true');
      console.log('‚úÖ Category normalization complete. Will not run again.');
    }
  } catch(err) {
    console.error('Error loading manual prospects:', err);
  }
}

// Save manual prospects to cloud and localStorage
async function saveManualProspects() {
  try {
    // Deduplicate before saving
    deduplicateManualProspects();

    await saveToCloud('manualProspects', prospectPoolState.manualProspects);
  } catch(err) {
    console.warn('‚ö†Ô∏è Manual prospects saved to localStorage only (cloud sync failed):', err);
  }
}

// One-time cleanup: Remove town field and restore enrichment flags
// v4: Intelligently restore isEnriched flag based on actual enrichment data
async function cleanupProspectPoolEnrichment() {
  console.log('üßπ Starting prospect pool cleanup v4...');
  console.log(`Total items before cleanup: ${prospectPoolState.manualProspects.length}`);

  let townFieldsRemoved = 0;
  let enrichmentRestored = 0;
  prospectPoolState.manualProspects = prospectPoolState.manualProspects.map(prospect => {
    let needsUpdate = false;
    const updated = { ...prospect };

    // Remove town field (campaign name should not be stored in prospect data)
    if (prospect.town) {
      delete updated.town;
      needsUpdate = true;
      townFieldsRemoved++;
      console.log(`üóëÔ∏è Removed town field from: ${prospect.businessName || prospect.name}`);
    }

    // RESTORE isEnriched flag if prospect has enrichment data
    // Check if prospect has email, social media, or came from kanban
    const hasEnrichmentData = !!(
      prospect.email ||
      prospect.facebook ||
      prospect.instagram ||
      prospect.linkedin ||
      prospect.twitter ||
      prospect.contactName
    );

    if (hasEnrichmentData && prospect.isEnriched !== true) {
      updated.isEnriched = true;
      needsUpdate = true;
      enrichmentRestored++;
      console.log(`‚úÖ Restored isEnriched flag for: ${prospect.businessName || prospect.name}`);
    }

    return needsUpdate ? updated : prospect;
  });

  console.log(`‚úÖ Removed town field from ${townFieldsRemoved} prospects`);
  console.log(`‚úÖ Restored isEnriched flag for ${enrichmentRestored} prospects with enrichment data`);

  // Save to cloud and localStorage
  await saveManualProspects();

  // Re-render prospect pool
  renderProspectPool();

  // Only show toast if actual work was done
  if (enrichmentRestored > 0 || townFieldsRemoved > 0) {
    toast(`üßπ Cleaned up ${townFieldsRemoved} town fields, restored ${enrichmentRestored} enrichment flags`, true);
  }
  console.log('‚úÖ Cleanup complete!');
}

// Expose cleanup function globally (can be called from console)
window.cleanupProspectPoolEnrichment = cleanupProspectPoolEnrichment;

// One-time cleanup v5: Normalize all ZIP codes to 5 digits
async function normalizeAllZipCodes() {
  console.log('üßπ Starting ZIP code normalization (v5)...');
  console.log(`Total items to process: ${prospectPoolState.manualProspects.length}`);

  let normalized = 0;
  prospectPoolState.manualProspects = prospectPoolState.manualProspects.map(prospect => {
    let needsUpdate = false;
    const updated = { ...prospect };

    // Normalize zipCode field
    if (prospect.zipCode && prospect.zipCode.length > 5) {
      updated.zipCode = truncateZipTo5(prospect.zipCode);
      needsUpdate = true;
    }

    // Normalize actualZip field
    if (prospect.actualZip && prospect.actualZip.length > 5) {
      updated.actualZip = truncateZipTo5(prospect.actualZip);
      needsUpdate = true;
    }

    // Normalize zip field
    if (prospect.zip && prospect.zip.length > 5) {
      updated.zip = truncateZipTo5(prospect.zip);
      needsUpdate = true;
    }

    // Normalize searchedZipCode field
    if (prospect.searchedZipCode && prospect.searchedZipCode.length > 5) {
      updated.searchedZipCode = truncateZipTo5(prospect.searchedZipCode);
      needsUpdate = true;
    }

    if (needsUpdate) {
      normalized++;
      console.log(`üìç Normalized ZIP for: ${prospect.businessName || prospect.name} (${prospect.zipCode} ‚Üí ${updated.zipCode})`);
    }

    return needsUpdate ? updated : prospect;
  });

  console.log(`‚úÖ Normalized ZIP codes for ${normalized} prospects`);

  if (normalized > 0) {
    // Save to cloud and localStorage
    await saveManualProspects();
    toast(`üìç Normalized ${normalized} ZIP codes to 5-digit format`, true);
  }

  console.log('‚úÖ ZIP normalization complete!');
}

// Expose ZIP normalization function globally
window.normalizeAllZipCodes = normalizeAllZipCodes;

// One-time cleanup v6: Normalize all categories to canonical form
async function normalizeAllCategories() {
  console.log('üßπ Starting category normalization (v6)...');

  let manualNormalized = 0;
  let cacheNormalized = 0;
  const categoryChanges = {}; // Track what changed for logging

  // 1. Normalize manual prospects
  console.log(`Processing ${prospectPoolState.manualProspects.length} manual prospects...`);
  prospectPoolState.manualProspects = prospectPoolState.manualProspects.map(prospect => {
    if (prospect.category) {
      const original = prospect.category;
      const normalized = normalizeCategory(original);
      if (original !== normalized) {
        manualNormalized++;
        const key = `${original} ‚Üí ${normalized}`;
        categoryChanges[key] = (categoryChanges[key] || 0) + 1;
        return { ...prospect, category: normalized };
      }
    }
    return prospect;
  });

  // 2. Normalize places cache
  const cacheKeys = Object.keys(placesCache.searches);
  console.log(`Processing ${cacheKeys.length} cache entries...`);

  cacheKeys.forEach(cacheKey => {
    const cache = placesCache.searches[cacheKey];
    if (cache.cachedData && Array.isArray(cache.cachedData)) {
      cache.cachedData = cache.cachedData.map(biz => {
        if (biz.category) {
          const original = biz.category;
          const normalized = normalizeCategory(original);
          if (original !== normalized) {
            cacheNormalized++;
            const key = `${original} ‚Üí ${normalized}`;
            categoryChanges[key] = (categoryChanges[key] || 0) + 1;
            return { ...biz, category: normalized };
          }
        }
        return biz;
      });
    }
  });

  // Log changes
  console.log(`\nüìä Category normalization summary:`);
  console.log(`   Manual prospects: ${manualNormalized} normalized`);
  console.log(`   Cache businesses: ${cacheNormalized} normalized`);
  if (Object.keys(categoryChanges).length > 0) {
    console.log(`\nüìù Changes made:`);
    Object.entries(categoryChanges).sort((a, b) => b[1] - a[1]).forEach(([change, count]) => {
      console.log(`   ${change}: ${count} items`);
    });
  }

  // Save if changes were made
  if (manualNormalized > 0) {
    await saveManualProspects();
  }
  if (cacheNormalized > 0) {
    await savePlacesCache();
  }

  if (manualNormalized > 0 || cacheNormalized > 0) {
    toast(`üìÅ Normalized ${manualNormalized + cacheNormalized} categories`, true);
    // Re-render to show merged categories
    renderProspectPool();
  }

  console.log('‚úÖ Category normalization complete!');
}

// Expose category normalization function globally
window.normalizeAllCategories = normalizeAllCategories;

// Toggle selection of a prospect in Prospecting column
function toggleProspectingSelection(leadId) {
  // Ensure consistent type - convert to string for comparison
  const id = String(leadId);

  console.log('üîµ toggleProspectingSelection called with:', leadId, 'converted to:', id);
  console.log('üîµ Current selection state:', Array.from(prospectingSelectionState.selectedIds));

  if (prospectingSelectionState.selectedIds.has(id)) {
    prospectingSelectionState.selectedIds.delete(id);
    console.log('üîµ Deselected:', id);
  } else {
    prospectingSelectionState.selectedIds.add(id);
    console.log('üîµ Selected:', id);
  }

  console.log('üîµ New selection state:', Array.from(prospectingSelectionState.selectedIds));

  updateMoveToPoolButton();
  renderKanban();
}

// Select all prospects in the prospect-list column (uses Campaign Board)
function selectAllProspects() {
  const board = getCurrentCampaignBoard();
  // Campaign Board 'queued' = legacy 'prospect-list'
  const items = board?.columns?.['queued'] || [];

  // Clear existing selections first
  prospectingSelectionState.selectedIds.clear();

  // Add all prospect IDs to selection
  items.forEach((item, idx) => {
    if (typeof item === 'object' && item) {
      const leadId = item.id || idx;
      prospectingSelectionState.selectedIds.add(leadId);
    }
  });

  // Update UI
  updateMoveToPoolButton();
  renderKanban();

  toast(`Selected ${prospectingSelectionState.selectedIds.size} prospects`, true);
}

// Clear all prospect selections
function clearProspectingSelection() {
  const previousCount = prospectingSelectionState.selectedIds.size;
  prospectingSelectionState.selectedIds.clear();

  // Update UI
  updateMoveToPoolButton();
  renderKanban();

  if (previousCount > 0) {
    toast(`Cleared ${previousCount} selections`, true);
  }
}

// Toggle selection of a prospect in To Contact column for bulk messaging
function toggleToContactSelection(leadId) {
  // Ensure consistent type - convert to string for comparison
  const id = String(leadId);

  if (toContactSelectionState.selectedIds.has(id)) {
    toContactSelectionState.selectedIds.delete(id);
  } else {
    toContactSelectionState.selectedIds.add(id);
  }
  updateBulkSendSection();
  renderKanban();
}

// Select all items in Queued column for outreach (uses Campaign Board)
function selectAllToContact() {
  const board = getCurrentCampaignBoard();
  // Outreach is done from Queued column (column 1)
  const items = board?.columns?.['queued'] || [];

  if (items.length === 0) {
    toast('No items in Queued column for outreach', false);
    return;
  }

  // Add all items to selection
  items.forEach(item => {
    if (typeof item === 'object' && item.id) {
      toContactSelectionState.selectedIds.add(String(item.id));
    }
  });

  updateBulkSendSection();
  renderKanban();
  toast(`Selected ${items.length} item${items.length === 1 ? '' : 's'}`, true);
}

// Clear To Contact column selection
function clearToContactSelection() {
  const previousCount = toContactSelectionState.selectedIds.size;
  toContactSelectionState.selectedIds.clear();
  updateBulkSendSection();
  renderKanban();

  if (previousCount > 0) {
    toast(`Cleared ${previousCount} selection${previousCount === 1 ? '' : 's'}`, true);
  }
}

// Toggle selection of a prospect in In Progress column
function toggleInProgressSelection(leadId) {
  const id = String(leadId);
  if (inProgressSelectionState.selectedIds.has(id)) {
    inProgressSelectionState.selectedIds.delete(id);
  } else {
    inProgressSelectionState.selectedIds.add(id);
  }
  renderKanban();
}

// Select all items in In Progress column (uses Campaign Board)
function selectAllInProgress() {
  const board = getCurrentCampaignBoard();
  // Campaign Board 'negotiating' = legacy 'in-progress'
  const items = board?.columns?.['negotiating'] || [];
  if (items.length === 0) {
    toast('No items in In Progress column', false);
    return;
  }
  items.forEach(item => {
    if (typeof item === 'object' && item.id) {
      inProgressSelectionState.selectedIds.add(String(item.id));
    }
  });
  renderKanban();
  toast(`Selected ${items.length} item${items.length === 1 ? '' : 's'}`, true);
}

// Clear In Progress column selection
function clearInProgressSelection() {
  const previousCount = inProgressSelectionState.selectedIds.size;
  inProgressSelectionState.selectedIds.clear();
  renderKanban();
  if (previousCount > 0) {
    toast(`Cleared ${previousCount} selection${previousCount === 1 ? '' : 's'}`, true);
  }
}

// Toggle selection of a prospect in Committed column
function toggleCommittedSelection(leadId) {
  const id = String(leadId);
  if (committedSelectionState.selectedIds.has(id)) {
    committedSelectionState.selectedIds.delete(id);
  } else {
    committedSelectionState.selectedIds.add(id);
  }
  renderKanban();
}

// Select all items in Committed column (uses Campaign Board)
function selectAllCommitted() {
  const board = getCurrentCampaignBoard();
  // Campaign Board 'invoice-sent' + 'proof-approved' = legacy 'committed'
  const invoiceSent = board?.columns?.['invoice-sent'] || [];
  const proofApproved = board?.columns?.['proof-approved'] || [];
  const items = [...invoiceSent, ...proofApproved];
  if (items.length === 0) {
    toast('No items in Committed column', false);
    return;
  }
  items.forEach(item => {
    if (typeof item === 'object' && item.id) {
      committedSelectionState.selectedIds.add(String(item.id));
    }
  });
  renderKanban();
  toast(`Selected ${items.length} item${items.length === 1 ? '' : 's'}`, true);
}

// Clear Committed column selection
function clearCommittedSelection() {
  const previousCount = committedSelectionState.selectedIds.size;
  committedSelectionState.selectedIds.clear();
  renderKanban();
  if (previousCount > 0) {
    toast(`Cleared ${previousCount} selection${previousCount === 1 ? '' : 's'}`, true);
  }
}

// Generic function to move selected items between adjacent columns
// Now uses Campaign Board as single source of truth
async function moveSelectedBetweenColumns(fromColumn, toColumn, selectionState) {
  const selectedCount = selectionState.selectedIds.size;
  if (selectedCount === 0) {
    toast('No items selected', false);
    return;
  }

  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign board found', false);
    return;
  }

  const columnTitles = {
    'prospect-list': 'Prospect List',
    'to-contact': 'To Contact',
    'in-progress': 'In Progress',
    'committed': 'Committed'
  };

  if (!confirm(`Move ${selectedCount} item${selectedCount === 1 ? '' : 's'} to ${columnTitles[toColumn]}?`)) {
    return;
  }

  // Map legacy column names to Campaign Board columns
  const fromBoardCol = mapLegacyColumnToCampaignBoard(fromColumn);
  const toBoardCol = mapLegacyColumnToCampaignBoard(toColumn);

  const fromItems = board.columns[fromBoardCol] || [];
  if (!board.columns[toBoardCol]) {
    board.columns[toBoardCol] = [];
  }

  let movedCount = 0;

  // Move each selected item using Campaign Board
  selectionState.selectedIds.forEach(leadId => {
    const success = moveCampaignBoardItem(leadId, fromBoardCol, toBoardCol, board);
    if (success) movedCount++;
  });

  // Clear selections
  selectionState.selectedIds.clear();

  await saveCampaignBoards();
  renderKanban();

  toast(`‚úÖ Moved ${movedCount} item${movedCount === 1 ? '' : 's'} to ${columnTitles[toColumn]}`, true);
}

// Move selected in-progress items left (to to-contact)
async function moveSelectedInProgressLeft() {
  await moveSelectedBetweenColumns('in-progress', 'to-contact', inProgressSelectionState);
}

// Move selected in-progress items right (to committed)
async function moveSelectedInProgressRight() {
  await moveSelectedBetweenColumns('in-progress', 'committed', inProgressSelectionState);
}

// Move selected committed items left (to in-progress)
async function moveSelectedCommittedLeft() {
  await moveSelectedBetweenColumns('committed', 'in-progress', committedSelectionState);
}

// Move selected to-contact items right (to in-progress)
async function moveSelectedToContactRight() {
  await moveSelectedBetweenColumns('to-contact', 'in-progress', toContactSelectionState);
}

// Move selected prospect-list items right (to to-contact) - updated version of moveSelectedToContact
async function moveSelectedProspectListRight() {
  await moveSelectedBetweenColumns('prospect-list', 'to-contact', prospectingSelectionState);
}

// Move selected items from To Contact back to Prospect List (column 2 -> column 1)
// Move selected items from To Contact back to Prospect List
// Now uses Campaign Board as single source of truth
async function moveSelectedToProspectList() {
  console.log('üîµ moveSelectedToProspectList CALLED - Starting');
  const selectedCount = toContactSelectionState.selectedIds.size;

  if (selectedCount === 0) {
    toast('No items selected', false);
    return;
  }

  // Single confirmation for all
  if (!confirm(`Move ${selectedCount} item${selectedCount === 1 ? '' : 's'} back to Prospect List?`)) {
    return;
  }

  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign board found', false);
    return;
  }

  // Map: to-contact -> attempting, prospect-list -> queued
  let movedCount = 0;

  // Move each selected item using Campaign Board
  toContactSelectionState.selectedIds.forEach(leadId => {
    const success = moveCampaignBoardItem(leadId, 'attempting', 'queued', board);
    if (success) {
      movedCount++;
      console.log(`‚úÖ Moved to queued (Prospect List)`);
    }
  });

  // Clear selections
  toContactSelectionState.selectedIds.clear();

  console.log(`üîµ moveSelectedToProspectList - Moved ${movedCount} items`);

  await saveCampaignBoards();
  updateBulkSendSection();
  renderKanban();

  toast(`‚úÖ Moved ${movedCount} item${movedCount === 1 ? '' : 's'} back to Prospect List`, true);
  console.log('üîµ moveSelectedToProspectList - COMPLETE');
}

// Update bulk send section visibility and content
function updateBulkSendSection() {
  const bulkSection = document.getElementById('bulkSendSection');
  const bulkCount = document.getElementById('bulkSendCount');
  const btnSMS = document.getElementById('btnBulkSendSMS');
  const btnGoogleVoice = document.getElementById('btnBulkSendGoogleVoice');
  const btnEmail = document.getElementById('btnBulkSendEmail');
  const btnLinkedIn = document.getElementById('btnBulkOpenLinkedIn');
  const btnFacebook = document.getElementById('btnBulkOpenFacebook');

  if (!bulkSection || !bulkCount) return;

  const selectedCount = toContactSelectionState.selectedIds.size;

  if (selectedCount > 0) {
    bulkSection.classList.remove('hidden');
    bulkCount.textContent = `(${selectedCount} selected)`;
    if (btnSMS) btnSMS.disabled = false;
    if (btnGoogleVoice) btnGoogleVoice.disabled = false;
    if (btnEmail) btnEmail.disabled = false;
    if (btnLinkedIn) btnLinkedIn.disabled = false;
    if (btnFacebook) btnFacebook.disabled = false;
  } else {
    bulkSection.classList.add('hidden');
    if (btnSMS) btnSMS.disabled = true;
    if (btnGoogleVoice) btnGoogleVoice.disabled = true;
    if (btnEmail) btnEmail.disabled = true;
    if (btnLinkedIn) btnLinkedIn.disabled = true;
    if (btnFacebook) btnFacebook.disabled = true;
  }
}

// Update visibility of "Move Selected to Pool" button
function updateMoveToPoolButton() {
  const btn = document.getElementById('btnMoveSelectedToPool');
  if (btn) {
    if (prospectingSelectionState.selectedIds.size > 0) {
      btn.classList.remove('hidden');
      btn.textContent = `‚¨Ö Move ${prospectingSelectionState.selectedIds.size} to Pool`;
    } else {
      btn.classList.add('hidden');
    }
  }
}

// Move all selected prospects to Prospect Pool (bulk operation)
// Now uses Campaign Board as single source of truth
async function moveSelectedToPool() {
  console.log('üîµ moveSelectedToPool CALLED - Starting');
  const selectedCount = prospectingSelectionState.selectedIds.size;

  if (selectedCount === 0) {
    toast('No prospects selected', false);
    return;
  }

  // Single confirmation for all
  if (!confirm(`Move ${selectedCount} prospect${selectedCount === 1 ? '' : 's'} to Prospect Pool?`)) {
    return;
  }

  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign board found', false);
    return;
  }

  // Campaign Board 'queued' = legacy 'prospect-list'
  const items = board.columns['queued'] || [];
  console.log(`üîµ moveSelectedToPool - queued has ${items.length} items before removal`);
  const movedProspects = [];

  // Collect all selected prospects
  prospectingSelectionState.selectedIds.forEach(leadId => {
    // Convert both to strings for comparison (IDs can be numbers or strings)
    const leadIdStr = String(leadId);
    const leadIndex = items.findIndex(item => typeof item === 'object' && String(item.id) === leadIdStr);
    console.log(`üîµ Looking for leadId: ${leadIdStr}, found at index: ${leadIndex}`);
    if (leadIndex !== -1) {
      movedProspects.push({
        lead: items[leadIndex],
        index: leadIndex
      });
    }
  });

  // Sort by index descending to safely remove from array
  movedProspects.sort((a, b) => b.index - a.index);

  // Move each prospect
  movedProspects.forEach(({ lead, index }) => {
    // DEBUG: Log the lead data to see what's being moved
    console.log('üîµ moveSelectedToPool - Lead data:', {
      businessName: lead.businessName,
      phone: lead.phone,
      email: lead.email,
      website: lead.website,
      facebook: lead.facebook,
      instagram: lead.instagram,
      linkedin: lead.linkedin,
      twitter: lead.twitter
    });

    // Check if prospect already exists in pool (prevent duplicates)
    const existingIndex = prospectPoolState.manualProspects.findIndex(p =>
      p.id === lead.id ||
      (p.placeId && p.placeId === lead.placeId) ||
      (p.businessName && lead.businessName && p.businessName.toLowerCase() === lead.businessName.toLowerCase() && p.mailerId === lead.mailerId)
    );

    // Determine if lead has enriched data (has contact info beyond just phone)
    const hasEnrichedData = !!(lead.email || lead.website || lead.facebook || lead.instagram || lead.linkedin);
    console.log('üîµ hasEnrichedData:', hasEnrichedData, 'existingIndex:', existingIndex);

    if (existingIndex !== -1) {
      // Update existing prospect instead of creating duplicate
      // IMPORTANT: Only overwrite with lead values if they're not null/undefined
      // This prevents losing data like ZIP codes when moving back and forth
      const existing = prospectPoolState.manualProspects[existingIndex];
      const updatedProspect = {
        ...existing,
        // Only overwrite with lead values if they exist (preserve existing data)
        businessName: lead.businessName || existing.businessName,
        name: lead.name || existing.name,
        title: lead.title || existing.title,
        phone: lead.phone || existing.phone,
        email: lead.email || existing.email,
        website: lead.website || existing.website,
        facebook: lead.facebook || existing.facebook,
        instagram: lead.instagram || existing.instagram,
        linkedin: lead.linkedin || existing.linkedin,
        twitter: lead.twitter || existing.twitter,
        contactName: lead.contactName || existing.contactName,
        address: lead.address || existing.address,
        notes: lead.notes || existing.notes,
        category: lead.category || existing.category,
        // ZIP codes - preserve existing if lead has null/undefined (truncate to 5 digits)
        zipCode: truncateZipTo5(lead.zipCode || lead.actualZip || lead.zip || existing.zipCode || existing.actualZip || existing.zip),
        actualZip: truncateZipTo5(lead.actualZip || lead.zipCode || lead.zip || existing.actualZip || existing.zipCode || existing.zip),
        zip: lead.zip || lead.zipCode || lead.actualZip || existing.zip || existing.zipCode || existing.actualZip,
        placeId: lead.placeId || existing.placeId,
        // Always update these
        movedToPoolDate: new Date().toISOString(),
        mailerId: state.current?.Mailer_ID || null,
        isEnriched: hasEnrichedData,
        enriched: hasEnrichedData
      };
      prospectPoolState.manualProspects[existingIndex] = updatedProspect;
      console.log('üîµ Updated existing prospect:', {
        website: updatedProspect.website,
        facebook: updatedProspect.facebook,
        instagram: updatedProspect.instagram,
        isEnriched: updatedProspect.isEnriched,
        zipCode: updatedProspect.zipCode,
        actualZip: updatedProspect.actualZip
      });
    } else {
      // Add new prospect to pool
      // Clear contact tracking so they start fresh when re-added
      const newProspect = {
        ...lead,
        movedToPoolDate: new Date().toISOString(),
        mailerId: state.current?.Mailer_ID || null,
        // Preserve enriched status if lead has contact data
        isEnriched: hasEnrichedData,
        enriched: hasEnrichedData,
        contactTracking: null,  // Clear so they show as not contacted when re-added
        attemptTracking: null,  // Reset attempt tracking
        channelStatus: null     // Reset channel status
      };
      prospectPoolState.manualProspects.push(newProspect);
      console.log('üîµ Added new prospect:', {
        website: newProspect.website,
        facebook: newProspect.facebook,
        instagram: newProspect.instagram,
        isEnriched: newProspect.isEnriched
      });
    }

    // Remove from Campaign Board 'queued' column
    board.columns['queued'].splice(index, 1);
  });

  // Clear selections
  prospectingSelectionState.selectedIds.clear();

  console.log(`üîµ moveSelectedToPool - queued has ${board.columns['queued'].length} items after removal`);
  console.log('üîµ moveSelectedToPool - About to save');

  await saveManualProspects(); // AWAIT to ensure data is saved before continuing
  await saveCampaignBoards(); // Save Campaign Board (single source of truth)

  console.log(`üîµ moveSelectedToPool - After saveCampaignBoards, queued has ${board.columns['queued']?.length} items`);
  console.log('üîµ moveSelectedToPool - About to renderKanban');
  renderKanban();

  toast(`‚úÖ Moved ${selectedCount} prospect${selectedCount === 1 ? '' : 's'} to Prospect Pool for ${state.current?.Town || 'current campaign'}`, true);
  console.log('üîµ moveSelectedToPool - COMPLETE');
}

// Move all selected prospects from Prospect List (column 1) to To Contact (column 2)
// Now uses Campaign Board as single source of truth
async function moveSelectedToContact() {
  console.log('üîµ moveSelectedToContact CALLED - Starting');
  const selectedCount = prospectingSelectionState.selectedIds.size;

  if (selectedCount === 0) {
    toast('No prospects selected', false);
    return;
  }

  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign board found', false);
    return;
  }

  // Map: prospect-list -> queued, to-contact -> attempting
  let movedCount = 0;

  // Move each selected item using Campaign Board
  prospectingSelectionState.selectedIds.forEach(leadId => {
    const success = moveCampaignBoardItem(leadId, 'queued', 'attempting', board);
    if (success) {
      movedCount++;
      console.log(`‚úÖ Moved to attempting (To Contact)`);
    }
  });

  // Clear selection
  prospectingSelectionState.selectedIds.clear();

  // Save and re-render
  await saveCampaignBoards();
  renderKanban();

  toast(`‚úÖ Moved ${movedCount} prospect${movedCount === 1 ? '' : 's'} to To Contact`, true);
  console.log('üîµ moveSelectedToContact - COMPLETE');
}

// Legacy function - kept for backwards compatibility but now uses bulk selection
// Now uses Campaign Board as single source of truth
async function moveProspectToPool(leadId, event) {
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign board found', false);
    return;
  }

  // Campaign Board 'queued' = legacy 'prospect-list'
  const items = board.columns['queued'] || [];
  const leadIndex = items.findIndex(item => typeof item === 'object' && item.id === leadId);

  if (leadIndex === -1) {
    toast('Prospect not found', false);
    return;
  }

  const lead = items[leadIndex];

  // Check if prospect already exists in pool (prevent duplicates)
  const existingIndex = prospectPoolState.manualProspects.findIndex(p =>
    p.id === lead.id ||
    (p.placeId && p.placeId === lead.placeId) ||
    (p.businessName && p.businessName.toLowerCase() === lead.businessName.toLowerCase() && p.mailerId === lead.mailerId)
  );

  if (existingIndex !== -1) {
    // Update existing prospect instead of creating duplicate
    // Clear contact tracking so they start fresh when re-added
    prospectPoolState.manualProspects[existingIndex] = {
      ...prospectPoolState.manualProspects[existingIndex],
      ...lead,
      movedToPoolDate: new Date().toISOString(),
      mailerId: state.current?.Mailer_ID || null,
      contactTracking: null,  // Clear so they show as not contacted when re-added
      attemptTracking: null,
      channelStatus: null
    };
  } else {
    // Add new prospect to pool
    // Clear contact tracking so they start fresh when re-added
    prospectPoolState.manualProspects.push({
      ...lead,
      movedToPoolDate: new Date().toISOString(),
      mailerId: state.current?.Mailer_ID || null,
      contactTracking: null,  // Clear so they show as not contacted when re-added
      attemptTracking: null,
      channelStatus: null
    });
  }

  // Remove from Campaign Board 'queued' column
  board.columns['queued'].splice(leadIndex, 1);

  // Clear this prospect from selection if it was selected
  prospectingSelectionState.selectedIds.delete(leadId);

  saveManualProspects();
  await saveCampaignBoards(); // Save Campaign Board (single source of truth)
  renderKanban();

  toast(`"${lead.businessName}" moved to Prospect Pool for ${state.current?.Town || 'current campaign'}`, true);

  // Ask if user wants to view the pool
  setTimeout(() => {
    if (confirm('Go to Prospect Pool to view this prospect?')) {
      switchTab('clients');
    }
  }, 500);
}

// Move prospect from Pool back to Prospecting
function moveProspectFromPool(prospectId) {
  // First try to find in manual prospects (by id or placeId)
  let prospectIndex = prospectPoolState.manualProspects.findIndex(p =>
    p.id === prospectId || p.placeId === prospectId
  );
  let prospect = null;
  let isFromManualProspects = false;

  if (prospectIndex !== -1) {
    prospect = prospectPoolState.manualProspects[prospectIndex];
    isFromManualProspects = true;
  } else {
    // Try to find in search cache (by placeId)
    for (const cacheKey of Object.keys(placesCache.searches)) {
      const cached = placesCache.searches[cacheKey];
      if (cached.cachedData) {
        const found = cached.cachedData.find(b => b.placeId === prospectId);
        if (found) {
          prospect = { ...found };
          break;
        }
      }
    }
  }

  if (!prospect) {
    // Last resort: check the rendered prospects lookup
    prospect = prospectPoolState.renderedProspects?.[prospectId];
  }

  if (!prospect) {
    console.error('Prospect not found:', prospectId);
    toast('Prospect not found in pool', false);
    return;
  }

  // Check for duplicate by placeId OR by normalized name
  const prospectingColumn = 'prospect-list';
  const existingLeads = kanbanState.columns[prospectingColumn] || [];
  const currentMailerId = state.current?.Mailer_ID;

  // Get the business name for duplicate checking
  const businessNameForCheck = prospect.businessName || prospect.name || prospect.title || '';

  // Helper to normalize name for comparison (handles &/and, apostrophes, etc.)
  const normalizeForDupeCheck = (name) => {
    if (!name) return '';
    return name.toLowerCase()
      .replace(/&/g, 'and')
      .replace(/[''`]/g, '')
      .replace(/\s+/g, ' ')
      .replace(/[^\w\s]/g, '')
      .trim();
  };

  const normalizedProspectName = normalizeForDupeCheck(businessNameForCheck);

  // Check by placeId first
  if (prospect.placeId) {
    const duplicateByPlaceId = existingLeads.find(lead =>
      lead.placeId === prospect.placeId &&
      lead.mailerId === currentMailerId
    );

    if (duplicateByPlaceId) {
      toast(`"${businessNameForCheck}" already exists in Prospecting for this card`, false);
      return;
    }
  }

  // Also check by normalized business name (catches same business with different placeIds)
  if (normalizedProspectName) {
    const duplicateByName = existingLeads.find(lead => {
      const leadName = lead.businessName || lead.name || lead.title || '';
      const normalizedLeadName = normalizeForDupeCheck(leadName);
      return normalizedLeadName === normalizedProspectName && lead.mailerId === currentMailerId;
    });

    if (duplicateByName) {
      toast(`"${businessNameForCheck}" already exists in Prospecting (same business name)`, false);
      return;
    }
  }

  // DON'T remove from manualProspects - keep it there so it shows as "In System"
  // This allows users to see which prospects they've already added to the kanban
  // The prospect will appear faded with "In System" badge after re-render

  // Build a proper lead object for the kanban
  // HERE API uses 'title', Google uses 'name', manual prospects use 'businessName'
  const businessName = prospect.businessName || prospect.name || prospect.title || 'Unknown Business';
  const zipCode = truncateZipTo5(prospect.zipCode || prospect.actualZip || prospect.zip) || null;
  const newLead = {
    id: Date.now() + Math.random(),
    businessName: businessName,
    name: businessName, // Also set 'name' for compatibility with pool renderer
    title: businessName, // Also set 'title' for compatibility
    contactName: prospect.contactName || prospect.ownerName || '',
    phone: prospect.phone || prospect.contact?.phone || '',
    email: prospect.email || prospect.contact?.email || '',
    estimatedValue: prospect.estimatedValue || 500,
    notes: prospect.notes || `Added from Prospect Pool\nAddress: ${prospect.address || ''}\nCategory: ${prospect.category || ''}`,
    source: prospect.source || 'prospect-pool',
    placeId: prospect.placeId || prospect.id,
    website: prospect.website || '',
    facebook: prospect.facebook || '',
    instagram: prospect.instagram || '',
    linkedin: prospect.linkedin || '',
    twitter: prospect.twitter || '',
    category: prospect.category || 'other',
    zipCode: zipCode,
    actualZip: zipCode, // Also set actualZip for pool renderer
    address: prospect.address || prospect.vicinity || '',
    mailerId: prospect.mailerId || state.current?.Mailer_ID,
    movedBackDate: new Date().toISOString(),
    doNotContact: prospect.doNotContact || false // Preserve Do Not Contact status
  };

  // Add to prospecting
  kanbanState.columns[prospectingColumn].push(newLead);

  saveKanban();
  renderProspectPool();
  renderKanban();

  toast(`"${businessName}" moved to Prospecting`, true);
}

// Expose functions globally
window.toggleProspectingSelection = toggleProspectingSelection;
window.moveSelectedToPool = moveSelectedToPool;
window.moveProspectToPool = moveProspectToPool;
window.moveProspectFromPool = moveProspectFromPool;
window.filterProspectPoolByDate = filterProspectPoolByDate;
window.toggleAllZips = toggleAllZips;
window.handleZipChange = handleZipChange;
window.selectAllToContact = selectAllToContact;
window.clearToContactSelection = clearToContactSelection;
window.moveSelectedToProspectList = moveSelectedToProspectList;

function filterProspectPoolByDate() {
  renderProspectPool();
}

function toggleAllZips(checkbox) {
  let container = document.getElementById('prospectPoolZipCheckboxes');
  if (!container) container = document.getElementById('inlineProspectPoolZipCheckboxes');
  if (!container) return;

  if (checkbox.checked) {
    // When ALL is checked, uncheck all individual ZIPs
    const individualCheckboxes = container.querySelectorAll('input[type="checkbox"]:not([value="all"])');
    individualCheckboxes.forEach(cb => cb.checked = false);
  }
  updateZipFilterSummary();
  // Re-render to apply filter
  renderProspectPool();
}

function handleZipChange(checkbox) {
  let container = document.getElementById('prospectPoolZipCheckboxes');
  if (!container) container = document.getElementById('inlineProspectPoolZipCheckboxes');
  if (!container) return;

  if (checkbox.checked) {
    // When an individual ZIP is checked, uncheck ALL
    const allCheckbox = container.querySelector('input[value="all"]');
    if (allCheckbox) allCheckbox.checked = false;
  }
  updateZipFilterSummary();
  // Re-render to apply filter
  renderProspectPool();
}

// Contact data filter functions
function applyProspectPoolFilters() {
  renderProspectPool();
}

function clearContactFilters() {
  const filters = ['filterHasEmail', 'filterHasPhone', 'filterHasFacebook', 'filterHasInstagram', 'filterHasWebsite'];
  filters.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.checked = false;
  });
  renderProspectPool();
}

// Helper function to check if business matches contact filters
function matchesContactFilters(business) {
  // Get filter checkboxes - some may not exist if removed from UI
  const emailFilter = document.getElementById('filterHasEmail');
  const phoneFilter = document.getElementById('filterHasPhone');
  const facebookFilter = document.getElementById('filterHasFacebook');
  const instagramFilter = document.getElementById('filterHasInstagram'); // Optional - may not exist
  const websiteFilter = document.getElementById('filterHasWebsite');

  // Get checked state (false if element doesn't exist)
  const hasEmail = emailFilter?.checked || false;
  const hasPhone = phoneFilter?.checked || false;
  const hasFacebook = facebookFilter?.checked || false;
  const hasInstagram = instagramFilter?.checked || false;
  const hasWebsite = websiteFilter?.checked || false;

  // If no filters are selected, show all
  if (!hasEmail && !hasPhone && !hasFacebook && !hasInstagram && !hasWebsite) {
    return true;
  }

  // Helper to check if a field has a valid value
  const hasValue = (field) => {
    if (!field) return false;
    if (typeof field !== 'string') return false;
    const trimmed = field.trim();
    return trimmed !== '' && trimmed !== 'undefined' && trimmed !== 'null';
  };

  // Check each filter (AND logic - business must match ALL selected filters)
  // Support both direct fields and nested contact object (for different data structures)
  if (hasEmail) {
    const email = business.email || business.contact?.email;
    if (!hasValue(email)) return false;
  }

  if (hasPhone) {
    const phone = business.phone || business.contact?.phone;
    if (!hasValue(phone)) return false;
  }

  if (hasFacebook) {
    const facebook = business.facebook || business.socialMedia?.facebook;
    if (!hasValue(facebook)) return false;
  }

  if (hasInstagram) {
    const instagram = business.instagram || business.socialMedia?.instagram;
    if (!hasValue(instagram)) return false;
  }

  if (hasWebsite) {
    const website = business.website;
    if (!hasValue(website)) return false;
  }

  return true;
}

// Store search term to preserve during re-renders
var prospectPoolSearchTerm = '';

// Store category filter state (Set for multiple selections)
var prospectPoolSelectedCategories = new Set();

// Store client filter state: 'all' | 'new' | 'existing'
var prospectPoolClientFilter = 'all';

// Helper to normalize business names for matching
function normalizeBusinessName(name) {
  if (!name) return '';
  return name.toLowerCase()
    .replace(/[^a-z0-9]/g, '') // Remove non-alphanumeric
    .replace(/\s+/g, '');
}

// Truncate ZIP to 5 digits (remove +4 suffix)
function truncateZipTo5(zip) {
  if (!zip) return null;
  const str = String(zip).trim();
  // Return first 5 digits only
  return str.substring(0, 5);
}

// Extract ZIP code from an address string
function extractZipFromAddress(address) {
  if (!address) return null;
  // Match 5-digit ZIP (optionally with -4 suffix)
  const match = address.match(/\b(\d{5})(?:-\d{4})?\b/);
  return match ? match[1] : null; // match[1] is just the 5 digits
}

// Get the best available ZIP for a prospect (always returns 5 digits)
function getProspectActualZip(prospect) {
  // Priority: actualZip > zip (from API) > extracted from address > zipCode (searched)
  if (prospect.actualZip) return truncateZipTo5(prospect.actualZip);
  if (prospect.zip && prospect.zip !== prospect.searchedZipCode) return truncateZipTo5(prospect.zip);

  // Try to extract from address
  const addressZip = extractZipFromAddress(prospect.address || prospect.fullAddress);
  if (addressZip) return addressZip; // Already 5 digits from regex

  // Fallback to zipCode (but this might be searched ZIP)
  return truncateZipTo5(prospect.zipCode) || null;
}

// Build a set of normalized client business names for fast lookup
function getClientNameSet() {
  const clients = Object.values(crmState.clients || {});
  const nameSet = new Set();
  clients.forEach(client => {
    if (client.businessName) {
      nameSet.add(normalizeBusinessName(client.businessName));
    }
  });
  return nameSet;
}

// Check if a prospect matches an existing client
function isExistingClient(prospect, clientNameSet) {
  const prospectName = normalizeBusinessName(prospect.name || prospect.businessName);
  return clientNameSet.has(prospectName);
}

// Filter prospect pool by client status
function filterProspectPoolByClientStatus() {
  const select = document.getElementById('prospectPoolClientFilter');
  if (select) {
    prospectPoolClientFilter = select.value;
  }
  renderProspectPool();
}

// Toggle ProspectRadar section collapse/expand
function toggleProspectRadar() {
  const collapsed = document.getElementById('prospectRadarCollapsed');
  const expanded = document.getElementById('prospectRadarExpanded');

  if (!collapsed || !expanded) return;

  if (expanded.classList.contains('hidden')) {
    // Expand
    expanded.classList.remove('hidden');
    collapsed.classList.add('hidden');
  } else {
    // Collapse
    expanded.classList.add('hidden');
    collapsed.classList.remove('hidden');
  }
}

// Toggle filter dropdowns
function toggleFilterDropdown(type) {
  const zipDropdown = document.getElementById('zipFilterDropdown');
  const categoryDropdown = document.getElementById('categoryFilterDropdown');
  const statusDropdown = document.getElementById('statusFilterDropdown');

  if (type === 'zip') {
    zipDropdown?.classList.toggle('hidden');
    categoryDropdown?.classList.add('hidden');
    statusDropdown?.classList.add('hidden');
  } else if (type === 'category') {
    categoryDropdown?.classList.toggle('hidden');
    zipDropdown?.classList.add('hidden');
    statusDropdown?.classList.add('hidden');
  } else if (type === 'status') {
    statusDropdown?.classList.toggle('hidden');
    zipDropdown?.classList.add('hidden');
    categoryDropdown?.classList.add('hidden');
  }
}

// Set prospect status filter (for new button dropdown)
function setProspectStatusFilter(value) {
  const select = document.getElementById('prospectPoolClientFilter');
  const summary = document.getElementById('statusFilterSummary');
  const dropdown = document.getElementById('statusFilterDropdown');

  if (select) select.value = value;

  const labels = { all: 'All Prospects', new: 'New Only', existing: 'Existing Clients' };
  if (summary) summary.textContent = labels[value] || 'All Prospects';

  dropdown?.classList.add('hidden');
  filterProspectPoolByClientStatus();
}
window.setProspectStatusFilter = setProspectStatusFilter;

// Close dropdowns when clicking outside
document.addEventListener('click', function(e) {
  const zipDropdown = document.getElementById('zipFilterDropdown');
  const categoryDropdown = document.getElementById('categoryFilterDropdown');
  const statusDropdown = document.getElementById('statusFilterDropdown');

  // Check if click is outside ZIP dropdown
  if (zipDropdown && !zipDropdown.classList.contains('hidden')) {
    const zipButton = zipDropdown.previousElementSibling;
    if (!zipDropdown.contains(e.target) && !zipButton?.contains(e.target)) {
      zipDropdown.classList.add('hidden');
    }
  }

  // Check if click is outside Category dropdown
  if (categoryDropdown && !categoryDropdown.classList.contains('hidden')) {
    const catButton = categoryDropdown.previousElementSibling;
    if (!categoryDropdown.contains(e.target) && !catButton?.contains(e.target)) {
      categoryDropdown.classList.add('hidden');
    }
  }

  // Check if click is outside Status dropdown
  if (statusDropdown && !statusDropdown.classList.contains('hidden')) {
    const statusButton = statusDropdown.previousElementSibling;
    if (!statusDropdown.contains(e.target) && !statusButton?.contains(e.target)) {
      statusDropdown.classList.add('hidden');
    }
  }
});

// Update ZIP filter summary text
function updateZipFilterSummary() {
  const summary = document.getElementById('zipFilterSummary');
  if (!summary) return;

  const container = document.getElementById('inlineProspectPoolZipCheckboxes');
  if (!container) return;

  const allCheckbox = container.querySelector('input[value="all"]');
  const checkedBoxes = container.querySelectorAll('input[type="checkbox"]:checked:not([value="all"])');

  if (allCheckbox?.checked || checkedBoxes.length === 0) {
    summary.textContent = 'All';
  } else {
    summary.textContent = `${checkedBoxes.length} selected`;
  }
}

// Update Category filter summary text
function updateCategoryFilterSummary() {
  const summary = document.getElementById('categoryFilterSummary');
  if (!summary) return;

  if (prospectPoolSelectedCategories.size === 0) {
    summary.textContent = 'All';
  } else {
    summary.textContent = `${prospectPoolSelectedCategories.size} selected`;
  }
}

// Scroll to next category section
function scrollToNextCategory(currentCategory) {
  const sections = document.querySelectorAll('.category-section');
  const sectionIds = Array.from(sections).map(s => s.id.replace('category-', ''));
  const currentIndex = sectionIds.indexOf(currentCategory);

  if (currentIndex !== -1 && currentIndex < sectionIds.length - 1) {
    const nextCategory = sectionIds[currentIndex + 1];
    const nextSection = document.getElementById(`category-${nextCategory}`);
    if (nextSection) {
      nextSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  } else {
    // If last category, scroll back to top of first category
    const firstSection = sections[0];
    if (firstSection) {
      firstSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }
}
window.scrollToNextCategory = scrollToNextCategory;

// Toggle all categories on/off
function toggleAllCategories(checkbox) {
  const container = document.getElementById('prospectPoolCategoryCheckboxes');
  if (!container) return;

  if (checkbox.checked) {
    // When ALL is checked, clear individual selections
    prospectPoolSelectedCategories.clear();
    const individualCheckboxes = container.querySelectorAll('input[type="checkbox"]:not([value="all"])');
    individualCheckboxes.forEach(cb => cb.checked = false);
  }
  updateCategoryFilterSummary();
  renderProspectPool();
}

// Handle individual category checkbox change
function handleCategoryChange(checkbox) {
  const container = document.getElementById('prospectPoolCategoryCheckboxes');
  if (!container) return;

  if (checkbox.checked) {
    // Add to selected categories
    prospectPoolSelectedCategories.add(checkbox.value);
    // Uncheck "ALL" when individual is selected
    const allCheckbox = container.querySelector('input[value="all"]');
    if (allCheckbox) allCheckbox.checked = false;
  } else {
    // Remove from selected categories
    prospectPoolSelectedCategories.delete(checkbox.value);
    // If nothing selected, check "ALL"
    if (prospectPoolSelectedCategories.size === 0) {
      const allCheckbox = container.querySelector('input[value="all"]');
      if (allCheckbox) allCheckbox.checked = true;
    }
  }
  updateCategoryFilterSummary();
  renderProspectPool();
}

// Populate category checkboxes from available categories
function populateCategoryDropdown(categories) {
  const container = document.getElementById('prospectPoolCategoryCheckboxes');
  if (!container) return;

  // Sort categories alphabetically
  const sortedCategories = [...categories].sort((a, b) => a.localeCompare(b));

  // Determine if ALL should be checked (no individual selections)
  const allSelected = prospectPoolSelectedCategories.size === 0;

  container.innerHTML = `
    <label class="inline-flex items-center gap-1 px-2 py-1 bg-white border-2 rounded-lg cursor-pointer hover:bg-emerald-50 hover:border-emerald-400 transition-colors text-xs ${allSelected ? 'border-emerald-500 bg-emerald-50' : 'border-gray-300'}">
      <input type="checkbox" value="all" ${allSelected ? 'checked' : ''} onchange="toggleAllCategories(this)" class="w-3 h-3 text-emerald-600 rounded">
      <span class="font-bold text-gray-900">ALL</span>
    </label>
  ` + sortedCategories.map(cat => {
    const isSelected = prospectPoolSelectedCategories.has(cat);
    const displayName = cat.charAt(0).toUpperCase() + cat.slice(1);
    return `
      <label class="inline-flex items-center gap-1 px-2 py-1 bg-white border-2 rounded-lg cursor-pointer hover:bg-emerald-50 hover:border-emerald-400 transition-colors text-xs ${isSelected ? 'border-emerald-500 bg-emerald-50' : 'border-gray-300'}">
        <input type="checkbox" value="${cat}" ${isSelected ? 'checked' : ''} onchange="handleCategoryChange(this)" class="w-3 h-3 text-emerald-600 rounded">
        <span class="text-gray-700">${displayName}</span>
      </label>
    `;
  }).join('');
}

// Legacy function for backwards compatibility
function filterProspectPoolByCategory() {
  renderProspectPool();
}

// Expose new functions globally
window.toggleProspectRadar = toggleProspectRadar;
window.filterProspectPoolByCategory = filterProspectPoolByCategory;
window.applyProspectPoolFilters = applyProspectPoolFilters;
window.clearContactFilters = clearContactFilters;
window.filterProspectPoolByClientStatus = filterProspectPoolByClientStatus;
window.toggleAllCategories = toggleAllCategories;
window.handleCategoryChange = handleCategoryChange;
window.toggleFilterDropdown = toggleFilterDropdown;

function renderProspectPool() {
  // Clear the rendered prospects lookup at the start of each render
  prospectPoolState.renderedProspects = {};

  // Save current search value if it exists
  const searchInput = document.getElementById('prospectPoolSearch');
  if (searchInput) {
    prospectPoolSearchTerm = searchInput.value;
  }

  // Try main containers first, fallback to inline containers (Search tab merged view)
  let container = document.getElementById('prospectPoolContainer');
  let statsContainer = document.getElementById('prospectPoolStats');
  let zipCheckboxContainer = document.getElementById('prospectPoolZipCheckboxes');

  // If main containers don't exist, use inline containers directly
  const useInlineOnly = !container;
  if (useInlineOnly) {
    container = document.getElementById('inlineProspectPoolContainer');
    statsContainer = document.getElementById('inlineProspectPoolStats');
    zipCheckboxContainer = document.getElementById('inlineProspectPoolZipCheckboxes');
  }

  if (!container || !statsContainer) return;

  // Get selected ZIP codes from checkboxes
  const selectedZips = [];
  let allSelected = false;

  // Check if this is first load (no checkboxes exist yet)
  const isFirstLoad = !zipCheckboxContainer || !zipCheckboxContainer.querySelector('input[type="checkbox"]');

  if (zipCheckboxContainer) {
    const checkboxes = zipCheckboxContainer.querySelectorAll('input[type="checkbox"]:checked');
    checkboxes.forEach(cb => {
      if (cb.value === 'all') {
        allSelected = true;
      } else {
        selectedZips.push(cb.value);
      }
    });
  }

  // On first load, default to showing ALL (no filter)
  if (isFirstLoad) {
    allSelected = true;
  }

  // ZIP filter logic:
  // - ALL selected: show all ZIPs (no filter)
  // - Specific ZIPs selected: show only those ZIPs
  // - NONE selected: show nothing (filter with empty list)
  const showAllZips = allSelected;
  const showNoZips = !allSelected && selectedZips.length === 0;
  const filterByZip = !allSelected; // Always filter unless ALL is checked

  // Get date filter selection
  const filterDays = document.getElementById('prospectPoolDateFilter')?.value || 'all';
  const now = new Date();
  const cutoffDate = filterDays === 'all' ? null : new Date(now.getTime() - (parseInt(filterDays) * 24 * 60 * 60 * 1000));

  // Get all cached searches and organize by category
  const categorizedProspects = {};
  let totalProspects = 0;
  let alreadyInSystem = 0;

  // Check what's already in the Campaign Board (by placeId AND by normalized name)
  // NOTE: Only check Campaign Board columns, NOT CRM clients - we want to show "In System" only for
  // prospects that are currently in the pipeline, not for existing CRM clients
  // Uses Campaign Board as single source of truth
  const existingPlaceIds = new Set();
  const existingNormalizedNames = new Set();

  // Helper to normalize name for matching
  const normalizeForMatch = (name) => {
    if (!name) return '';
    return name.toLowerCase()
      .replace(/&/g, 'and')
      .replace(/[''`]/g, '')
      .replace(/\s+/g, ' ')
      .replace(/[^\w\s]/g, '')
      .trim();
  };

  // Get Campaign Board data (single source of truth)
  const board = getCurrentCampaignBoard();
  if (board && board.columns) {
    Object.values(board.columns).forEach(column => {
      if (Array.isArray(column)) {
        column.forEach(lead => {
          if (lead && lead.placeId) {
            existingPlaceIds.add(lead.placeId);
          }
          if (lead && lead.id) {
            existingPlaceIds.add(String(lead.id));
          }
          // Also track by normalized name
          const leadName = lead?.businessName || lead?.name || lead?.title || '';
          if (leadName) {
            existingNormalizedNames.add(normalizeForMatch(leadName));
          }
        });
      }
    });
  }

  // DON'T add CRM clients to "In System" check - existing clients should still be
  // available to add to kanban for the current campaign

  // Collect all available ZIP codes for the filter dropdown
  const availableZips = new Set();

  // Add ZIP codes from manual prospects FIRST (so they appear in filter)
  // Always normalize to 5 digits for consistent display
  prospectPoolState.manualProspects.forEach(prospect => {
    if (prospect.zipCode) {
      availableZips.add(truncateZipTo5(prospect.zipCode));
    }
  });

  // Process cached searches (with deduplication)
  const seenPlaceIds = new Set(); // Track placeIds to prevent duplicates
  let skippedByZip = 0;
  let skippedByDate = 0;
  let processedCaches = 0;

  Object.keys(placesCache.searches).forEach(cacheKey => {
    const [searchedZipCode, category] = cacheKey.split('-');
    const cached = placesCache.searches[cacheKey];

    if (!cached.cachedData || cached.cachedData.length === 0) return;

    // NOTE: Don't check cache expiration - user should always see their prospect data
    // even if it's older than 30 days. They worked hard to build this list!

    // Apply date filter - ONLY if lastFetched exists and cutoff is set
    if (cutoffDate && cached.lastFetched) {
      const fetchedDate = new Date(cached.lastFetched);
      if (fetchedDate < cutoffDate) {
        skippedByDate++;
        return; // Skip if outside date range
      }
    }

    processedCaches++;

    if (!categorizedProspects[category]) {
      categorizedProspects[category] = [];
    }

    cached.cachedData.forEach(business => {
      // Skip if already seen (prevents duplicates across searches)
      if (seenPlaceIds.has(business.placeId)) return;

      if (!notInterestedState.placeIds.has(business.placeId)) {
        // Check if in system by placeId OR by normalized business name
        const businessName = business.name || business.businessName || business.title || '';
        const normalizedBusinessName = normalizeForMatch(businessName);
        const isInSystem = existingPlaceIds.has(business.placeId) ||
                          (normalizedBusinessName && existingNormalizedNames.has(normalizedBusinessName));

        // Use smart ZIP extraction - tries actualZip, zip, address extraction, then searchedZipCode
        const businessZip = getProspectActualZip(business) || searchedZipCode;

        // Track this ZIP as available for filtering (normalized to 5 digits)
        availableZips.add(truncateZipTo5(businessZip));

        // Filter by selected ZIP codes (use actualZip, not searched ZIP)
        // Normalize both sides to 5 digits for comparison
        if (filterByZip) {
          const normalizedBusinessZip = truncateZipTo5(businessZip);
          const matchesFilter = selectedZips.some(sz => truncateZipTo5(sz) === normalizedBusinessZip);
          if (!matchesFilter) {
            skippedByZip++;
            return; // Skip if this business's actual ZIP doesn't match filter
          }
        }

        // Filter by contact data
        if (!matchesContactFilters(business)) {
          return; // Skip if business doesn't match contact filters
        }

        categorizedProspects[category].push({
          ...business,
          category: category, // Use search category, not stored category (fixes wrong category from previous searches)
          zipCode: searchedZipCode, // Keep track of which search found this
          actualZip: businessZip, // Store the smart-extracted ZIP
          inSystem: isInSystem
        });
        seenPlaceIds.add(business.placeId); // Mark as seen
        totalProspects++;
        if (isInSystem) alreadyInSystem++;
      }
    });
  });

  // Render stats - only count categories with actual businesses (after filtering)
  const categoriesWithBusinesses = Object.keys(categorizedProspects).filter(cat => categorizedProspects[cat].length > 0).length;
  const selectedCount = prospectPoolState.selectedIds.size;
  const available = totalProspects - alreadyInSystem;

  // Count total businesses across all 4 Kanban columns
  const kanbanTotalCount =
    (kanbanState.columns['prospect-list'] || []).length +
    (kanbanState.columns['to-contact'] || []).length +
    (kanbanState.columns['in-progress'] || []).length +
    (kanbanState.columns['committed'] || []).length;

  // Stats will be updated after client counting - placeholder for now
  statsContainer.innerHTML = '<div class="col-span-4 text-center text-gray-400 py-2">Loading stats...</div>';

  // Populate ZIP code checkboxes
  if (zipCheckboxContainer) {
    // Ensure all ZIPs are normalized to 5 digits and deduplicated
    const normalizedZips = new Set();
    availableZips.forEach(zip => {
      const normalized = truncateZipTo5(zip);
      if (normalized) normalizedZips.add(normalized);
    });
    const sortedZips = Array.from(normalizedZips).sort();

    // Determine what should be checked
    // Default: ALL is checked
    // If user has made selections: honor those
    const isFirstLoad = !zipCheckboxContainer.querySelector('input[type="checkbox"]');
    const shouldCheckAll = isFirstLoad || (allSelected && selectedZips.length === 0);

    zipCheckboxContainer.innerHTML = `
      <label class="inline-flex items-center gap-2 px-4 py-2 bg-white border-2 rounded-lg cursor-pointer hover:bg-blue-50 hover:border-blue-400 transition-colors font-semibold ${shouldCheckAll ? 'border-blue-500 bg-blue-50' : 'border-gray-300'}">
        <input type="checkbox" value="all" ${shouldCheckAll ? 'checked' : ''} onchange="toggleAllZips(this)" class="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500">
        <span class="text-sm font-bold text-gray-900">ALL</span>
      </label>
    ` + sortedZips.map(zip => `
      <div class="inline-flex items-center gap-1 px-3 py-2 bg-white border-2 rounded-lg hover:bg-indigo-50 hover:border-indigo-300 transition-colors ${selectedZips.includes(zip) ? 'border-indigo-500 bg-indigo-50' : 'border-gray-300'}">
        <label class="inline-flex items-center gap-2 cursor-pointer">
          <input type="checkbox" value="${zip}" ${selectedZips.includes(zip) ? 'checked' : ''} onchange="handleZipChange(this)" class="w-4 h-4 text-indigo-600 rounded focus:ring-2 focus:ring-indigo-500">
          <span class="text-sm font-medium text-gray-700">${zip}</span>
        </label>
        <button
          onclick="event.stopPropagation(); clearCacheByZip('${zip}')"
          class="ml-1 px-2 py-1 text-xs text-red-600 hover:bg-red-100 rounded transition-colors"
          title="Delete all cached searches for ZIP ${zip}"
        >
          üóëÔ∏è
        </button>
      </div>
    `).join('');
  }

  // ========= UNIFIED POOL: Merge manual prospects + search results by category =========

  // Check if we have any prospects at all
  if (Object.keys(categorizedProspects).length === 0 && prospectPoolState.manualProspects.length === 0) {
    container.innerHTML = `
      <div class="text-center py-16 bg-gradient-to-br from-purple-50 to-pink-50 rounded-2xl border-2 border-dashed border-purple-300">
        <div class="text-7xl mb-6 animate-pulse">üéØ</div>
        <h3 class="text-3xl font-black text-gray-900 mb-3">Your Prospect Pool is Empty</h3>
        <p class="text-lg text-gray-600 mb-8 max-w-md mx-auto">
          Use the <strong>Prospect Generator</strong> to discover businesses in your area.
          They'll appear here for review before adding to your sales pipeline.
        </p>
        <button onclick="switchTab('lead-generation')" class="px-8 py-4 bg-gradient-to-r from-indigo-600 to-purple-600 text-white rounded-xl hover:from-indigo-700 hover:to-purple-700 font-black text-lg shadow-xl transform hover:scale-105 transition">
          üîç Generate Prospects Now ‚Üí
        </button>
      </div>
    `;
    return;
  }

  // Merge both manual prospects and search results into unified categories
  const unifiedByCategory = {};
  // Track placeIds to prevent duplicates between manual prospects and search results
  const unifiedSeenPlaceIds = new Set();
  // Also track normalized business names to catch duplicates with different placeIds
  const unifiedSeenNames = new Set();
  let manualProspectsAdded = 0;
  let manualProspectsSkipped = 0;

  // Helper to normalize business name for deduplication (handles "& vs and", spacing, apostrophes, etc)
  const normalizeNameForDedup = (name) => {
    if (!name) return '';
    // First, truncate at common separators to get core business name
    // Includes: bullets (‚Ä¢¬∑‚óè), pipes (|), colons (:), dashes (-‚Äì‚Äî), and other separators
    let coreName = name.split(/[‚Ä¢¬∑‚óè|:\-‚Äì‚Äî‚ñ∫‚ñ∏‚Ä£‚ÅÉ]/)[0];
    return coreName.toLowerCase()
      .replace(/&/g, 'and')
      .replace(/['''`¬¥]/g, '')  // Remove all apostrophe variations
      .replace(/\s+/g, ' ')
      .replace(/[^\w\s]/g, '')
      .trim();
  };

  // 1. Add manual prospects (enriched) to unified pool - filter by ZIP and date
  prospectPoolState.manualProspects
    .filter(prospect => {
      // Filter by selected ZIP codes - use smart ZIP extraction
      // Normalize both sides to 5 digits for comparison
      const prospectZip = getProspectActualZip(prospect);
      if (filterByZip) {
        // If filtering by ZIP, exclude prospects without a ZIP
        if (!prospectZip) {
          return false;
        }
        const normalizedProspectZip = truncateZipTo5(prospectZip);
        const matchesFilter = selectedZips.some(sz => truncateZipTo5(sz) === normalizedProspectZip);
        if (!matchesFilter) {
          return false; // Skip if ZIP doesn't match filter
        }
      }
      return true;
    })
    .filter(prospect => {
      // Apply date filter
      if (!cutoffDate) return true; // Show all if no date filter
      if (!prospect.movedToPoolDate) return true; // Show if no date (legacy)
      const movedDate = new Date(prospect.movedToPoolDate);
      return movedDate >= cutoffDate;
    })
    .filter(prospect => {
      // Filter by contact data
      return matchesContactFilters(prospect);
    })
    .forEach(prospect => {
      // Skip duplicates by placeId
      if (prospect.placeId && unifiedSeenPlaceIds.has(prospect.placeId)) {
        manualProspectsSkipped++;
        return;
      }

      // Also skip duplicates by normalized name (catches "& vs and" variations)
      const prospectName = prospect.businessName || prospect.name || prospect.title || '';
      const normalizedName = normalizeNameForDedup(prospectName);
      if (normalizedName && unifiedSeenNames.has(normalizedName)) {
        manualProspectsSkipped++;
        return;
      }

      // Normalize category to canonical form for consistent grouping
      // This merges "Plumbing", "Plumber", "Plumbing Service" into "plumber"
      const category = normalizeCategory(prospect.category || 'other');
      if (!unifiedByCategory[category]) {
        unifiedByCategory[category] = [];
      }
      // Get the actual ZIP for this prospect (smart extraction)
      const actualZipForProspect = getProspectActualZip(prospect);
      // Track this ZIP as available for filtering (normalized to 5 digits)
      if (actualZipForProspect) {
        availableZips.add(truncateZipTo5(actualZipForProspect));
      }

      // Check if prospect has contact data (for enrichment status)
      const hasContactData = !!(prospect.email || prospect.website || prospect.facebook || prospect.instagram || prospect.linkedin);

      // Check if this manual prospect is already in the system (kanban or clients)
      const manualProspectName = prospect.businessName || prospect.name || prospect.title || '';
      const normalizedManualName = normalizeForMatch ? normalizeForMatch(manualProspectName) : normalizeNameForDedup(manualProspectName);
      const isManualInSystem = existingPlaceIds.has(prospect.placeId) ||
                               existingPlaceIds.has(prospect.id) ||
                               (normalizedManualName && existingNormalizedNames.has(normalizedManualName));

      unifiedByCategory[category].push({
        ...prospect,
        // Override actualZip with smart extraction for accurate display
        actualZip: actualZipForProspect,
        // Respect existing isEnriched value OR detect from contact data presence
        isEnriched: prospect.isEnriched === true || hasContactData,
        // Mark if already in kanban/clients
        inSystem: isManualInSystem,
        type: 'manual'
      });

      // Mark this placeId and name as seen
      if (prospect.placeId) {
        unifiedSeenPlaceIds.add(prospect.placeId);
      }
      if (normalizedName) {
        unifiedSeenNames.add(normalizedName);
      }
      manualProspectsAdded++;
    });

  // 2. Add search results (raw) to unified pool - SKIP duplicates already added from manual
  let searchProspectsAdded = 0;
  let searchProspectsSkipped = 0;

  Object.keys(categorizedProspects).forEach(rawCategory => {
    // Normalize category to canonical form for consistent grouping
    const category = normalizeCategory(rawCategory);
    if (!unifiedByCategory[category]) {
      unifiedByCategory[category] = [];
    }
    categorizedProspects[rawCategory].forEach(prospect => {
      // Skip if this placeId was already added
      if (prospect.placeId && unifiedSeenPlaceIds.has(prospect.placeId)) {
        searchProspectsSkipped++;
        return; // Skip duplicate
      }

      // Also skip if normalized name already exists (catches "& vs and" variations)
      const prospectName = prospect.name || prospect.businessName || prospect.title || '';
      const normalizedName = normalizeNameForDedup(prospectName);
      if (normalizedName && unifiedSeenNames.has(normalizedName)) {
        searchProspectsSkipped++;
        return;
      }

      unifiedByCategory[category].push({
        ...prospect,
        category: category, // Use search category from cache key
        isEnriched: false, // From search = no contact info yet
        type: 'search'
      });

      // Mark as seen
      if (prospect.placeId) {
        unifiedSeenPlaceIds.add(prospect.placeId);
      }
      if (normalizedName) {
        unifiedSeenNames.add(normalizedName);
      }
      searchProspectsAdded++;
    });
  });

  // ========= CLIENT MATCHING: Tag and count existing clients =========
  const clientNameSet = getClientNameSet();
  let existingClientsCount = 0;
  let newProspectsCount = 0;
  let withContactCount = 0;
  let totalUnifiedCount = 0;

  // Tag each prospect and count metrics
  Object.keys(unifiedByCategory).forEach(category => {
    unifiedByCategory[category].forEach(prospect => {
      totalUnifiedCount++;
      const isClient = isExistingClient(prospect, clientNameSet);
      prospect.isExistingClient = isClient;
      if (isClient) {
        existingClientsCount++;
      } else {
        newProspectsCount++;
      }
      // Count with contact info (has phone, email, or website)
      const hasContact = prospect.phone || prospect.email || prospect.website ||
                         prospect.contact?.phone || prospect.contact?.email;
      if (hasContact) {
        withContactCount++;
      }
    });
  });

  // Collect all available categories for the dropdown
  const allCategories = Object.keys(unifiedByCategory).filter(cat => unifiedByCategory[cat].length > 0);

  // Clean up selected categories that no longer exist in current data
  const validSelectedCategories = new Set();
  prospectPoolSelectedCategories.forEach(cat => {
    if (allCategories.includes(cat)) {
      validSelectedCategories.add(cat);
    }
  });
  // If all selected categories were invalid, clear the selection
  if (prospectPoolSelectedCategories.size > 0 && validSelectedCategories.size === 0) {
    prospectPoolSelectedCategories.clear();
  } else {
    // Update to only valid categories
    prospectPoolSelectedCategories.clear();
    validSelectedCategories.forEach(cat => prospectPoolSelectedCategories.add(cat));
  }

  populateCategoryDropdown(allCategories);
  updateCategoryFilterSummary();

  // Apply category filter if specific categories are selected
  let filteredByCategory = unifiedByCategory;
  if (prospectPoolSelectedCategories.size > 0) {
    filteredByCategory = {};
    prospectPoolSelectedCategories.forEach(cat => {
      if (unifiedByCategory[cat]) {
        filteredByCategory[cat] = unifiedByCategory[cat];
      }
    });
  }

  // Apply client status filter if set
  if (prospectPoolClientFilter && prospectPoolClientFilter !== 'all') {
    const tempFiltered = {};
    Object.keys(filteredByCategory).forEach(category => {
      const filtered = filteredByCategory[category].filter(prospect => {
        if (prospectPoolClientFilter === 'existing') {
          return prospect.isExistingClient === true;
        } else if (prospectPoolClientFilter === 'new') {
          return prospect.isExistingClient !== true;
        }
        return true;
      });
      if (filtered.length > 0) {
        tempFiltered[category] = filtered;
      }
    });
    filteredByCategory = tempFiltered;
  }

  // Count what's actually showing after all filters
  let showingCount = 0;
  Object.values(filteredByCategory).forEach(prospects => {
    showingCount += prospects.length;
  });

  // Now render the real stats with accurate counts
  statsContainer.innerHTML = `
    <div class="bg-white border rounded-lg p-3 text-center">
      <div class="text-2xl font-bold text-indigo-600">${showingCount}<span class="text-sm text-gray-400 font-normal">/${totalUnifiedCount}</span></div>
      <div class="text-xs text-gray-600 mt-1">Showing</div>
    </div>
    <div class="bg-white border rounded-lg p-3 text-center cursor-pointer hover:bg-blue-50 transition-colors ${prospectPoolClientFilter === 'new' ? 'ring-2 ring-blue-500' : ''}" onclick="document.getElementById('prospectPoolClientFilter').value='new'; filterProspectPoolByClientStatus();">
      <div class="text-2xl font-bold text-blue-600">${newProspectsCount}</div>
      <div class="text-xs text-gray-600 mt-1">New Prospects</div>
    </div>
    <div class="bg-white border rounded-lg p-3 text-center cursor-pointer hover:bg-amber-50 transition-colors ${prospectPoolClientFilter === 'existing' ? 'ring-2 ring-amber-500' : ''}" onclick="document.getElementById('prospectPoolClientFilter').value='existing'; filterProspectPoolByClientStatus();">
      <div class="text-2xl font-bold text-amber-600">${existingClientsCount}</div>
      <div class="text-xs text-gray-600 mt-1">Existing Clients</div>
    </div>
    <div class="bg-white border rounded-lg p-3 text-center">
      <div class="text-2xl font-bold text-green-600">${withContactCount}</div>
      <div class="text-xs text-gray-600 mt-1">With Contact Info</div>
    </div>
  `;

  // Render unified pool header
  container.innerHTML = `
    <div class="bg-indigo-50 border-2 border-indigo-200 rounded-lg p-4 mb-6">
      <div class="mb-4">
        <h3 class="text-lg font-bold text-indigo-900">üéØ Prospect Pool</h3>
        <p class="text-sm text-indigo-700 mt-1">All prospects organized by category - click to add to your pipeline</p>
      </div>
      <div class="relative flex items-center">
        <svg class="absolute left-2 h-4 w-4 text-indigo-400 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
        </svg>
        <input
          type="text"
          id="prospectPoolSearch"
          placeholder="Search businesses by name..."
          oninput="filterProspectPool(this.value)"
          value="${prospectPoolSearchTerm}"
          class="w-full py-2 border-2 border-indigo-300 rounded-lg focus:border-indigo-500 focus:outline-none"
          style="padding-left: 2rem;"
        />
      </div>
    </div>

    ${Object.keys(filteredByCategory).sort().map(category => {
    const prospects = filteredByCategory[category];

    // Hide categories with zero businesses
    if (!prospects || prospects.length === 0) {
      return '';
    }

    const categoryName = category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    const enrichedCount = prospects.filter(p => p.isEnriched || p.enriched).length;
    const rawCount = prospects.filter(p => !p.isEnriched && !p.enriched).length;

    // Count how many are NOT already in system (available to add)
    const availableToAdd = prospects.filter(p => !p.inSystem).length;

    return `
      <div class="mb-8 category-section" id="category-${category}">
        <div class="flex items-center justify-between mb-4 pb-2 border-b-2 border-gray-200">
          <div class="flex items-center gap-3">
            <button onclick="scrollToNextCategory('${category}')" class="p-2 bg-gray-100 hover:bg-indigo-100 rounded-lg transition-colors group" title="Next category">
              <svg class="w-5 h-5 text-gray-500 group-hover:text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3"></path></svg>
            </button>
            <div>
              <h4 class="text-lg font-bold text-gray-900">${categoryName}</h4>
              <p class="text-sm text-gray-600">${prospects.length} total ‚Ä¢ <span class="text-green-600">${enrichedCount} enriched</span> ‚Ä¢ <span class="text-blue-600">${rawCount} raw</span></p>
            </div>
          </div>
          ${availableToAdd > 0 ? `
          <button onclick="selectAllInCategory('${category}')" class="px-3 py-1.5 bg-purple-600 text-white text-sm font-bold rounded-lg hover:bg-purple-700 transition-all flex items-center gap-2">
            ‚òëÔ∏è Select All ${availableToAdd}
          </button>
          ` : `<span class="text-xs text-gray-400 italic">All added</span>`}
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
          ${prospects
            // Calculate scores for all prospects
            .map(p => ({
              ...p,
              leadScore: p.leadScore || calculateProspectScore(p),
              contactScore: p.contactScore || (p.enriched ? calculateContactScore(p) : 0)
            }))
            // Sort: enriched first, then by rating, then by ZIP
            .sort((a, b) => {
              // Enriched businesses first
              const aEnriched = a.enriched || a.isEnriched ? 1 : 0;
              const bEnriched = b.enriched || b.isEnriched ? 1 : 0;
              if (bEnriched !== aEnriched) return bEnriched - aEnriched;

              // Then alphabetically by name
              const nameA = (a.name || a.businessName || a.title || '').toLowerCase();
              const nameB = (b.name || b.businessName || b.title || '').toLowerCase();
              if (nameA !== nameB) return nameA.localeCompare(nameB);

              // Then by lead score (higher first)
              const scoreA = a.leadScore || 0;
              const scoreB = b.leadScore || 0;
              return scoreB - scoreA;
            })
            .map(prospect => {
            // Store prospect in lookup table for later retrieval (avoids unsafe JSON in onclick)
            const prospectLookupId = prospect.placeId || prospect.id;
            if (prospectLookupId) {
              prospectPoolState.renderedProspects[prospectLookupId] = prospect;
            }

            // For enriched prospects (isEnriched OR enriched flag) - show with green background
            if (prospect.isEnriched || prospect.enriched) {
              // Build compact clickable icon display
              const contactIcons = [];
              if (prospect.phone) contactIcons.push(`<a href="tel:${esc(prospect.phone)}" onclick="event.stopPropagation()" class="w-8 h-8 flex items-center justify-center bg-white rounded-full shadow-sm hover:shadow-md hover:scale-110 transition-all" title="${esc(prospect.phone)}">üìû</a>`);
              if (prospect.website) contactIcons.push(`<a href="${esc(ensureHttps(prospect.website))}" onclick="event.stopPropagation()" target="_blank" class="w-8 h-8 flex items-center justify-center bg-white rounded-full shadow-sm hover:shadow-md hover:scale-110 transition-all" title="${esc(prospect.website)}">üåê</a>`);
              if (prospect.email) contactIcons.push(`<a href="mailto:${esc(prospect.email)}" onclick="event.stopPropagation()" class="w-8 h-8 flex items-center justify-center bg-white rounded-full shadow-sm hover:shadow-md hover:scale-110 transition-all" title="${esc(prospect.email)}">‚úâÔ∏è</a>`);
              if (prospect.facebook) contactIcons.push(`<a href="${esc(ensureHttps(prospect.facebook))}" onclick="event.stopPropagation()" target="_blank" class="w-8 h-8 flex items-center justify-center bg-white rounded-full shadow-sm hover:shadow-md hover:scale-110 transition-all" title="Facebook">üìò</a>`);
              if (prospect.instagram) contactIcons.push(`<a href="${esc(ensureHttps(prospect.instagram))}" onclick="event.stopPropagation()" target="_blank" class="w-8 h-8 flex items-center justify-center bg-white rounded-full shadow-sm hover:shadow-md hover:scale-110 transition-all" title="Instagram">üì∑</a>`);
              if (prospect.linkedin) contactIcons.push(`<a href="${esc(ensureHttps(prospect.linkedin))}" onclick="event.stopPropagation()" target="_blank" class="w-8 h-8 flex items-center justify-center bg-white rounded-full shadow-sm hover:shadow-md hover:scale-110 transition-all" title="LinkedIn">üíº</a>`);
              if (prospect.twitter) contactIcons.push(`<a href="${esc(ensureHttps(prospect.twitter))}" onclick="event.stopPropagation()" target="_blank" class="w-8 h-8 flex items-center justify-center bg-white rounded-full shadow-sm hover:shadow-md hover:scale-110 transition-all" title="Twitter">üê¶</a>`);

              // Extract address and rating
              let displayAddress = prospect.address || '';
              let displayRating = prospect.rating || 0;
              if (!displayAddress && prospect.notes) {
                const addressMatch = prospect.notes.match(/Address:\s*([^\n]+)/);
                if (addressMatch) displayAddress = addressMatch[1];
              }
              if (!displayRating && prospect.notes) {
                const ratingMatch = prospect.notes.match(/Rating:\s*([\d.]+)/);
                if (ratingMatch) displayRating = parseFloat(ratingMatch[1]);
              }

              // ZIP code
              const rawZipValue = prospect.actualZip || prospect.zipCode || prospect.zip || '';
              const isValidZip = rawZipValue && rawZipValue !== 'undefined' && rawZipValue !== 'null';

              // Contact score
              const enrichedContactScore = prospect.contactScore || calculateContactScore(prospect);

              // Status flags
              const isEnrichedInSystem = prospect.inSystem;
              const isPoolDoNotContact = prospect.doNotContact === true;
              const displayName = prospect.name || prospect.businessName || prospect.title || 'Unnamed';

              return `
                <div class="rounded-xl overflow-hidden ${isPoolDoNotContact ? 'bg-red-50 border-2 border-red-300' : 'bg-gradient-to-br from-emerald-50 to-green-100 border-l-4 border-l-emerald-500'} ${isEnrichedInSystem || isPoolDoNotContact ? 'opacity-60' : 'hover:shadow-lg hover:scale-[1.02]'} transition-all duration-200 cursor-pointer relative" onclick="openClientModalForProspect('${prospect.id || prospect.placeId}')">
                  ${isPoolDoNotContact ? `<div class="absolute inset-0 flex items-center justify-center pointer-events-none z-10"><span class="text-6xl text-red-400 font-bold opacity-30">‚úï</span></div>` : ''}

                  <!-- Header with score -->
                  <div class="px-4 py-3 flex items-start justify-between gap-2">
                    <div class="flex-1 min-w-0">
                      <h5 class="font-bold text-gray-900 ${isPoolDoNotContact ? 'line-through' : ''} truncate">${esc(displayName)}</h5>
                      <div class="flex items-center gap-2 mt-1 text-xs text-gray-600">
                        ${isValidZip ? `<span>üìç ${rawZipValue}</span>` : ''}
                        ${displayRating ? `<span>‚≠ê ${displayRating}</span>` : ''}
                      </div>
                    </div>
                    <div class="flex flex-col items-end gap-1">
                      ${isPoolDoNotContact ? '<span class="px-2 py-0.5 rounded-full text-xs font-bold bg-red-500 text-white">DNC</span>' : ''}
                      ${isEnrichedInSystem ? '<span class="px-2 py-0.5 rounded-full text-xs font-bold bg-gray-400 text-white">In Pipeline</span>' : ''}
                      <span class="px-2 py-1 rounded-lg text-xs font-bold bg-emerald-600 text-white shadow-sm">
                        ${enrichedContactScore}/10
                      </span>
                    </div>
                  </div>

                  <!-- Contact icons -->
                  ${contactIcons.length > 0 ? `
                    <div class="px-4 pb-2 flex gap-2 flex-wrap">
                      ${contactIcons.join('')}
                    </div>
                  ` : ''}

                  <!-- Action buttons -->
                  <div class="px-3 pb-3 flex gap-2">
                    ${prospect.phone ? `<button onclick="event.stopPropagation(); sendTextMessage('${prospectLookupId}')" class="flex-1 px-3 py-2 bg-teal-500 text-white rounded-lg hover:bg-teal-600 font-semibold text-xs shadow-sm">üí¨ Text</button>` : ''}
                    ${prospect.email ? `<button onclick="event.stopPropagation(); sendPitchEmail('${prospectLookupId}')" class="flex-1 px-3 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 font-semibold text-xs shadow-sm">üìß Email</button>` : ''}
                    ${isEnrichedInSystem ? `
                      <span class="flex-1 px-3 py-2 bg-gray-300 text-gray-600 rounded-lg font-semibold text-xs text-center">‚úì Added</span>
                    ` : `
                      <button onclick="event.stopPropagation(); moveProspectFromPool('${prospect.placeId || prospect.id}')" class="flex-1 px-3 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 font-semibold text-xs shadow-sm">Pipeline ‚Üí</button>
                    `}
                    <button onclick="event.stopPropagation(); reEnrichProspect('${prospect.placeId || prospect.id}')" class="w-9 h-9 flex items-center justify-center bg-purple-100 hover:bg-purple-200 text-purple-700 rounded-lg font-semibold text-sm transition-colors" title="Re-enrich (search again)">üîÑ</button>
                    <button onclick="event.stopPropagation(); togglePoolDoNotContact('${prospect.placeId || prospect.id}')" class="${isPoolDoNotContact ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-400 hover:bg-red-500'} w-9 h-9 flex items-center justify-center text-white rounded-lg font-semibold text-sm transition-colors" title="${isPoolDoNotContact ? 'Remove DNC' : 'Do Not Contact'}">üö´</button>
                  </div>
                </div>
              `;
            }

            // For raw prospects (not enriched) - show with checkbox and prominent Enrich button
            const prospectId = prospect.placeId || prospect.id;
            prospectPoolState.renderedProspects[prospectId] = prospect;
            const isSelected = prospectPoolState.selectedIds.has(prospectId);
            const isDisabled = prospect.inSystem;
            const isRawDoNotContact = prospect.doNotContact === true;

            const displayName = prospect.name || prospect.businessName || prospect.title || 'Unnamed Business';
            const rawZip = prospect.actualZip || prospect.zipCode || prospect.zip;
            const hasValidZip = rawZip && rawZip !== 'undefined' && rawZip !== 'null';

            return `
              <div class="prospect-card rounded-xl overflow-hidden ${isRawDoNotContact ? 'bg-red-50 border-2 border-red-300 opacity-60' : (isDisabled ? 'bg-gray-100 opacity-60' : 'bg-white border border-gray-200 hover:shadow-lg hover:border-purple-300')} transition-all duration-200 relative" data-place-id="${prospectId}">
                ${isRawDoNotContact ? `<div class="absolute inset-0 flex items-center justify-center pointer-events-none z-10"><span class="text-6xl text-red-400 font-bold opacity-30">‚úï</span></div>` : ''}

                <!-- Header row with checkbox and name -->
                <div class="px-4 py-3 flex items-start gap-3" onclick="openClientModalForProspect('${prospectId}')">
                  <input
                    type="checkbox"
                    ${isSelected ? 'checked' : ''}
                    ${isDisabled || isRawDoNotContact ? 'disabled' : ''}
                    onchange="event.stopPropagation(); togglePoolProspect('${prospectId}')"
                    onclick="event.stopPropagation()"
                    class="mt-1 w-5 h-5 text-purple-600 rounded cursor-pointer flex-shrink-0 border-2 border-gray-300"
                  />
                  <div class="flex-1 min-w-0 cursor-pointer">
                    <h5 class="font-bold text-gray-900 ${isRawDoNotContact ? 'line-through' : ''} truncate">${esc(displayName)}</h5>
                    <div class="flex items-center gap-2 mt-1 text-xs text-gray-500">
                      ${hasValidZip ? `<span>üìç ${rawZip}</span>` : ''}
                      ${prospect.rating ? `<span>‚≠ê ${prospect.rating}</span>` : ''}
                      ${isDisabled ? '<span class="px-1.5 py-0.5 bg-gray-200 text-gray-600 rounded text-xs">In System</span>' : ''}
                    </div>
                  </div>
                  <div class="flex flex-col items-end gap-1">
                    ${isRawDoNotContact ? '<span class="px-2 py-0.5 rounded-full text-xs font-bold bg-red-500 text-white">DNC</span>' : ''}
                    ${prospect.isExistingClient ? '<span class="px-2 py-0.5 rounded-full text-xs font-bold bg-amber-500 text-white">Client</span>' : ''}
                  </div>
                </div>

                <!-- Prominent Enrich Button -->
                ${!isDisabled && !isRawDoNotContact ? `
                <div class="px-4 pb-3">
                  <button onclick="event.stopPropagation(); enrichSingleProspect('${prospectId}')"
                          id="enrich-btn-${prospectId}"
                          class="w-full px-4 py-2.5 bg-gradient-to-r from-purple-600 to-indigo-600 text-white rounded-lg font-bold text-sm hover:from-purple-700 hover:to-indigo-700 transition-all shadow-md hover:shadow-lg flex items-center justify-center gap-2">
                    <span class="text-lg">üîç</span> Find Contact Info
                  </button>
                </div>
                ` : ''}

                <!-- DNC toggle for disabled/DNC cards -->
                ${isDisabled || isRawDoNotContact ? `
                <div class="px-4 pb-3">
                  <button onclick="event.stopPropagation(); togglePoolDoNotContact('${prospectId}')" class="${isRawDoNotContact ? 'bg-green-600 hover:bg-green-700' : 'bg-gray-400 hover:bg-red-500'} w-full py-2 text-white rounded-lg text-xs font-semibold transition-colors" title="${isRawDoNotContact ? 'Remove DNC' : 'Do Not Contact'}">
                    ${isRawDoNotContact ? '‚úì Remove Do Not Contact' : 'üö´ Do Not Contact'}
                  </button>
                </div>
                ` : ''}
              </div>
            `;
          }).join('')}
        </div>
      </div>
    `;
  }).join('')}
  `;

  // ZIP code filter is now handled by checkboxes above
  // No need to populate a dropdown anymore

  // Update selected count
  updatePoolSelectedCount();

  // Re-apply search filter if one exists
  if (prospectPoolSearchTerm) {
    // Use setTimeout to ensure DOM is fully rendered
    setTimeout(function() {
      filterProspectPool(prospectPoolSearchTerm);
    }, 0);
  }

  // ALSO render to inline containers in Search tab (merged Pool view)
  // Only copy if we're NOT already rendering directly to inline containers
  if (!useInlineOnly) {
    const inlineContainer = document.getElementById('inlineProspectPoolContainer');
    const inlineStatsContainer = document.getElementById('inlineProspectPoolStats');
    const inlineZipCheckboxes = document.getElementById('inlineProspectPoolZipCheckboxes');

    if (inlineContainer && container) {
      inlineContainer.innerHTML = container.innerHTML;
    }
    if (inlineStatsContainer && statsContainer) {
      inlineStatsContainer.innerHTML = statsContainer.innerHTML;
    }
    if (inlineZipCheckboxes && zipCheckboxContainer) {
      inlineZipCheckboxes.innerHTML = zipCheckboxContainer.innerHTML;
    }
  }
}

function togglePoolProspect(placeId) {
  if (prospectPoolState.selectedIds.has(placeId)) {
    prospectPoolState.selectedIds.delete(placeId);
  } else {
    prospectPoolState.selectedIds.add(placeId);
  }
  updatePoolSelectedCount();
}

function areCategoryProspectsSelected(category) {
  const cached = placesCache.searches;
  let allSelected = true;
  let hasAny = false;

  Object.keys(cached).forEach(cacheKey => {
    if (!cacheKey.endsWith(`-${category}`)) return;

    cached[cacheKey].cachedData?.forEach(business => {
      if (notInterestedState.placeIds.has(business.placeId)) return;

      // Check if in system
      const existingPlaceIds = new Set();
      Object.values(kanbanState.columns).forEach(column => {
        column.forEach(lead => {
          if (lead && lead.placeId) existingPlaceIds.add(lead.placeId);
        });
      });

      if (existingPlaceIds.has(business.placeId)) return;

      hasAny = true;
      if (!prospectPoolState.selectedIds.has(business.placeId)) {
        allSelected = false;
      }
    });
  });

  return hasAny && allSelected;
}

function selectCategoryProspects(category, select) {
  const cached = placesCache.searches;

  // Get existing place IDs
  const existingPlaceIds = new Set();
  Object.values(kanbanState.columns).forEach(column => {
    column.forEach(lead => {
      if (lead && lead.placeId) existingPlaceIds.add(lead.placeId);
    });
  });

  Object.keys(cached).forEach(cacheKey => {
    if (!cacheKey.endsWith(`-${category}`)) return;

    cached[cacheKey].cachedData?.forEach(business => {
      if (notInterestedState.placeIds.has(business.placeId)) return;
      if (existingPlaceIds.has(business.placeId)) return;

      if (select) {
        prospectPoolState.selectedIds.add(business.placeId);
      } else {
        prospectPoolState.selectedIds.delete(business.placeId);
      }
    });
  });

  renderProspectPool();
}

function updatePoolSelectedCount() {
  const countEl = document.getElementById('prospectPoolSelectedCount');
  const btnEl = document.getElementById('btnAddFromPool');
  const actionBar = document.getElementById('prospectPoolActionBar');

  // Also get inline elements (in Search tab)
  const inlineCountEl = document.getElementById('inlineProspectPoolSelectedCount');
  const inlineActionBar = document.getElementById('inlineProspectPoolActionBar');

  const count = prospectPoolState.selectedIds.size;

  if (countEl) {
    countEl.textContent = count;
  }
  if (inlineCountEl) {
    inlineCountEl.textContent = count;
  }

  if (btnEl) {
    btnEl.disabled = count === 0;
  }

  // Show/hide the action bar based on selection
  if (actionBar) {
    actionBar.style.display = count > 0 ? 'block' : 'none';
  }
  if (inlineActionBar) {
    inlineActionBar.style.display = count > 0 ? 'block' : 'none';
  }
}

function clearProspectPoolSelection() {
  prospectPoolState.selectedIds.clear();
  updatePoolSelectedCount();
  renderProspectPool();
}

async function addFromProspectPool() {
  console.log('üîµ addFromProspectPool called');
  if (prospectPoolState.selectedIds.size === 0) {
    toast('No prospects selected', false);
    return;
  }

  // Get current mailer ID (optional - can be null)
  const currentMailerId = state.current?.Mailer_ID || null;
  console.log('üîµ currentMailerId:', currentMailerId);

  const btn = document.getElementById('btnAddFromPool');
  const originalText = btn.textContent;
  btn.disabled = true;
  btn.textContent = '‚è≥ Adding...';

  try {
    // Collect all selected businesses from both sources
    const selectedBusinesses = [];
    const seenPlaceIds = new Set(); // Prevent duplicates
    console.log('üîµ Collecting selected businesses...');

    // From Google Places searches
    Object.values(placesCache.searches).forEach(cached => {
      cached.cachedData?.forEach(business => {
        if (prospectPoolState.selectedIds.has(business.placeId) && !seenPlaceIds.has(business.placeId)) {
          selectedBusinesses.push(business);
          seenPlaceIds.add(business.placeId);
        }
      });
    });

    // From manually added prospects
    prospectPoolState.manualProspects?.forEach(business => {
      const businessId = business.id || business.placeId;
      if (prospectPoolState.selectedIds.has(businessId) && !seenPlaceIds.has(businessId)) {
        selectedBusinesses.push(business);
        seenPlaceIds.add(businessId);
        console.log('üîµ Found selected manual business:', business.businessName, 'ID:', businessId);
      }
    });

    console.log('üîµ Total selected businesses:', selectedBusinesses.length, '(deduplicated)');

    // Fetch details and add to Campaign Board (single source of truth)
    // Ensure Campaign Board exists for this mailer
    const board = getCurrentCampaignBoard();
    if (!board) {
      toast('No campaign selected. Please select a campaign first.', false);
      btn.disabled = false;
      btn.textContent = originalText;
      return;
    }
    if (!board.columns) board.columns = {};
    if (!board.columns['queued']) board.columns['queued'] = [];

    console.log('üîµ Existing leads in Campaign Board queued:', board.columns['queued'].length);

    // Get existing placeIds to prevent duplicates (check Campaign Board - single source of truth)
    const existingPlaceIds = getCampaignBoardPlaceIds();

    // Filter out already existing ones first
    const toProcess = selectedBusinesses.filter(b => !existingPlaceIds.has(b.placeId || b.id));
    const skippedCount = selectedBusinesses.length - toProcess.length;
    let addedCount = 0;

    // Show enrichment modal for better UX
    if (toProcess.length > 0) {
      showEnrichmentModal(toProcess.length);
    }

    for (let i = 0; i < toProcess.length; i++) {
      // Check if user cancelled
      if (isEnrichmentCancelled()) {
        console.log('üõë Enrichment cancelled by user');
        break;
      }

      const business = toProcess[i];
      const businessName = business.businessName || business.name || business.title || 'Unknown Business';

      // Update modal progress
      updateEnrichmentProgress(i + 1, businessName, false);

      let newLead;

      // Handle manually added businesses (with enrichment for missing contact info)
      if (business.type === 'manual') {
        console.log('üîµ Processing manual business:', business.businessName);
        const manualBusinessName = business.businessName || business.name || business.title || 'Unknown Business';
        const manualLocation = business.address || business.town || '';

        // Start with existing data from manual entry
        let manualDetails = {
          phone: business.phone || '',
          website: business.website || '',
          email: business.email || '',
          facebook: business.facebook || '',
          instagram: business.instagram || '',
          linkedin: business.linkedin || '',
          twitter: business.twitter || '',
          contactName: business.contactName || ''
        };

        // Search for website if missing
        if (!manualDetails.website) {
          const websiteQuery = `${manualBusinessName} ${manualLocation} official website`;
          const website = await searchBusinessWebsite(websiteQuery, manualBusinessName);
          if (website && !website.includes('yelp.com') && !website.includes('facebook.com') && !website.includes('instagram.com')) {
            manualDetails.website = website;
          }
        }

        // Search for Facebook if missing - DISABLED: unreliable results
        if (ENABLE_SOCIAL_MEDIA_SEARCH && !manualDetails.facebook) {
          const fbQuery = `${manualBusinessName} ${manualLocation} site:facebook.com`;
          const fbResult = await searchBusinessWebsite(fbQuery, manualBusinessName);
          if (fbResult && fbResult.includes('facebook.com') && !fbResult.includes('instagram.com')) {
            let cleanFbUrl = fbResult;
            if (fbResult.includes('/posts/') || fbResult.includes('/photos/')) {
              const pageMatch = fbResult.match(/(https?:\/\/[^\/]*facebook\.com\/[^\/\?]+)/);
              if (pageMatch) cleanFbUrl = pageMatch[1];
            }
            manualDetails.facebook = cleanFbUrl;
          }
        }

        // Search for Instagram if missing - DISABLED: unreliable results
        if (ENABLE_SOCIAL_MEDIA_SEARCH && !manualDetails.instagram) {
          const igQuery = `${manualBusinessName} ${manualLocation} site:instagram.com`;
          const igResult = await searchBusinessWebsite(igQuery, manualBusinessName);
          if (igResult && igResult.includes('instagram.com') && !igResult.includes('facebook.com')) {
            let cleanedUrl = igResult;
            if (igResult.includes('/p/') || igResult.includes('/reel/')) {
              const match = igResult.match(/instagram\.com\/([^\/\?]+)/);
              if (match && match[1] && !['p', 'reel', 'stories'].includes(match[1])) {
                cleanedUrl = `https://instagram.com/${match[1]}`;
              }
            }
            manualDetails.instagram = cleanedUrl;
          }
        }

        // Scrape website for email and social links if we have a website
        let manualFoundContact = false;
        if (manualDetails.website) {
          const enrichedData = await fetchSmartEnrichment(manualDetails.website, manualBusinessName);
          manualDetails.email = manualDetails.email || enrichedData.email || '';
          manualDetails.facebook = manualDetails.facebook || enrichedData.facebook || '';
          manualDetails.instagram = manualDetails.instagram || enrichedData.instagram || '';
          manualDetails.linkedin = manualDetails.linkedin || enrichedData.linkedin || '';
          manualDetails.twitter = manualDetails.twitter || enrichedData.twitter || '';
          if (enrichedData.contactNames && enrichedData.contactNames.length > 0 && !manualDetails.contactName) {
            manualDetails.contactName = enrichedData.contactNames[0];
          }
          if (manualDetails.email || manualDetails.website) {
            manualFoundContact = true;
          }
        }
        updateEnrichmentProgress(i + 1, manualBusinessName, manualFoundContact);

        // Build notes for manual business
        let manualNotes = business.notes || `Manually added business\nAddress: ${business.address || 'N/A'}\nTown: ${business.town || 'N/A'}`;
        if (manualDetails.website && !business.website) manualNotes += `\nüåê Website found: ${manualDetails.website}`;
        if (manualDetails.email && !business.email) manualNotes += `\nüìß Email found: ${manualDetails.email}`;
        if (manualDetails.facebook && !business.facebook) manualNotes += `\nüìò Facebook found: ${manualDetails.facebook}`;
        if (manualDetails.instagram && !business.instagram) manualNotes += `\nüì∑ Instagram found: ${manualDetails.instagram}`;

        newLead = {
          id: Date.now() + Math.random(),
          businessName: manualBusinessName,
          contactName: manualDetails.contactName,
          phone: manualDetails.phone,
          email: manualDetails.email,
          estimatedValue: 500,
          notes: manualNotes,
          source: 'manual',
          placeId: business.id || business.placeId, // Use the manual ID or placeId for tracking
          website: manualDetails.website,
          facebook: manualDetails.facebook,
          instagram: manualDetails.instagram,
          linkedin: manualDetails.linkedin,
          twitter: manualDetails.twitter,
          category: business.category || 'other',
          zipCode: business.zipCode || null,
          actualZip: business.actualZip || null,
          town: business.town || business.actualCity || state.current?.Town,
          address: business.address || '',
          rating: business.rating || 0,
          userRatingsTotal: business.userRatingsTotal || 0,
          mailerId: currentMailerId,
          addedDate: new Date().toISOString(),
          interactions: [],
          enriched: true
        };
        console.log('üîµ Created enriched manual newLead:', newLead);
      } else {
        // Handle HERE/Foursquare businesses
        // IMPORTANT: Use existing data from business object if already available (from cache)

        // Start with data already in the business object (may be enriched from previous scraping)
        let details = {
          phone: business.phone || '',
          website: business.website || '',
          email: business.email || '',
          facebook: business.facebook || '',
          instagram: business.instagram || '',
          linkedin: business.linkedin || '',
          twitter: business.twitter || '',
          contactNames: [],
          source: business.source || 'here',
          enriched: business.enriched || false
        };
        const location = business.address ? business.address.split(',').slice(-2).join(',').trim() : '';

        // Search for website if missing
        if (!details.website) {
          const websiteQuery = `${businessName} ${location} official website`;
          const website = await searchBusinessWebsite(websiteQuery, businessName);
          if (website && !website.includes('yelp.com') && !website.includes('facebook.com') && !website.includes('instagram.com')) {
            details.website = website;
          }
        }

        // Search for Facebook if missing - DISABLED: unreliable results
        if (ENABLE_SOCIAL_MEDIA_SEARCH && !details.facebook) {
          const fbQuery = `${businessName} ${location} site:facebook.com`;
          const fbResult = await searchBusinessWebsite(fbQuery, businessName);
          if (fbResult && fbResult.includes('facebook.com') && !fbResult.includes('instagram.com')) {
            let cleanFbUrl = fbResult;
            if (fbResult.includes('/posts/') || fbResult.includes('/photos/')) {
              const pageMatch = fbResult.match(/(https?:\/\/[^\/]*facebook\.com\/[^\/\?]+)/);
              if (pageMatch) cleanFbUrl = pageMatch[1];
            }
            details.facebook = cleanFbUrl;
          }
        }

        // Search for Instagram if missing - DISABLED: unreliable results
        if (ENABLE_SOCIAL_MEDIA_SEARCH && !details.instagram) {
          const igQuery = `${businessName} ${location} site:instagram.com`;
          const igResult = await searchBusinessWebsite(igQuery, businessName);
          if (igResult && igResult.includes('instagram.com') && !igResult.includes('facebook.com')) {
            let cleanedUrl = igResult;
            if (igResult.includes('/p/') || igResult.includes('/reel/')) {
              const match = igResult.match(/instagram\.com\/([^\/\?]+)/);
              if (match && match[1] && !['p', 'reel', 'stories'].includes(match[1])) {
                cleanedUrl = `https://instagram.com/${match[1]}`;
              }
            }
            details.instagram = cleanedUrl;
          }
        }

        // Scrape website for email AND social links if we have a website
        let foundContact = false;
        if (details.website) {
          const enrichedData = await fetchSmartEnrichment(details.website, businessName);
          details.email = details.email || enrichedData.email || '';
          details.facebook = details.facebook || enrichedData.facebook || '';
          details.instagram = details.instagram || enrichedData.instagram || '';
          details.linkedin = details.linkedin || enrichedData.linkedin || '';
          details.twitter = details.twitter || enrichedData.twitter || '';
          details.contactNames = enrichedData.contactNames || details.contactNames || [];
          if (enrichedData.enriched) {
            details.enriched = true;
            details.pagesScraped = enrichedData.pagesScraped;
            details.source = '9x12pro-scraper';
          }
          // Count as found if we got email or website
          if (details.email || details.website) {
            foundContact = true;
          }
        }

        // Update modal with found status
        updateEnrichmentProgress(i + 1, businessName, foundContact);

        details.enriched = true;

        // Build notes
        let notes = `Found via ${details.source || 'Yelp'}\nAddress: ${business.address}\nRating: ${business.rating} (${business.userRatingsTotal} reviews)\n`;
        if (details.phone) notes += `Phone: ${details.phone}\n`;
        if (details.website) notes += `Website: ${details.website}\n`;
        if (details.email) notes += `üìß Email: ${details.email}\n`;
        if (details.facebook) notes += `üìò Facebook: ${details.facebook}\n`;
        if (details.instagram) notes += `üì∑ Instagram: ${details.instagram}\n`;
        if (details.linkedin) notes += `üíº LinkedIn: ${details.linkedin}\n`;
        if (details.twitter) notes += `üê¶ Twitter: ${details.twitter}\n`;
        if (details.contactNames && details.contactNames.length > 0) {
          notes += `üë§ Contacts: ${details.contactNames.join(', ')}\n`;
        }
        notes += `Place ID: ${business.placeId}`;
        if (details.source === '9x12pro-scraper' && details.enriched) {
          notes += `\n\n‚úÖ Enriched with Smart Scraper (${details.pagesScraped} pages scraped)`;
        }

        newLead = {
          id: Date.now() + Math.random(),
          businessName: business.name || business.businessName || business.title || 'Unknown Business',
          contactName: details.contactNames && details.contactNames.length > 0 ? details.contactNames[0] : '',
          phone: details.phone || '',
          email: details.email || '',
          estimatedValue: 500,
          notes: notes,
          source: details.source || 'google-places',
          placeId: business.placeId,
          website: details.website || '',
          facebook: details.facebook || '',
          instagram: details.instagram || '',
          linkedin: details.linkedin || '',
          twitter: details.twitter || '',
          category: business.category || 'other',
          zipCode: business.zipCode || null,
          actualZip: business.actualZip || null,
          town: business.actualCity || state.current?.Town,
          address: business.address || '',
          rating: business.rating || 0,
          userRatingsTotal: business.userRatingsTotal || 0,
          mailerId: currentMailerId,
          addedDate: new Date().toISOString(),
          interactions: []
        };
      }

      // Add to Campaign Board (single source of truth)
      const boardBusinessId = newLead.placeId || newLead.id;
      const existsInBoard = Object.values(board.columns).some(col =>
        col.some(item => (item.placeId || item.id) === boardBusinessId)
      );

      if (!existsInBoard) {
        const enhancedLead = enhanceBusinessForCampaignBoard(newLead, board.config?.maxAttempts || 4);
        board.columns['queued'].push(enhancedLead);
        console.log('üìä Added to Campaign Board queued column:', newLead.businessName);
        addedCount++;
      }

      // Delay between requests to avoid rate limiting (Scrapingdog limit ~30/min)
      if (i < toProcess.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }

    // Hide enrichment modal
    hideEnrichmentModal(true);

    // Save Campaign Boards (single source of truth)
    if (addedCount > 0) {
      await saveCampaignBoards();
      console.log('üìä Campaign Boards saved with new prospects');
    }

    renderKanban();

    // Clear selections and re-render pool
    prospectPoolState.selectedIds.clear();
    renderProspectPool();

    // Show success message
    let message = `‚úÖ Added ${addedCount} prospect${addedCount === 1 ? '' : 's'}! Ready to start outreach.`;
    if (skippedCount > 0) {
      message += ` ${skippedCount} duplicate${skippedCount === 1 ? '' : 's'} skipped.`;
    }
    toast(message, true);

    // Track Getting Started progress
    if (addedCount > 0) {
      markGettingStartedComplete('review_prospects');
      markGettingStartedComplete('add_to_pipeline');
    }

    // Switch to Pipeline tab
    switchTab('pipeline');
  } catch(err) {
    console.error('Error adding from pool:', err);
    hideEnrichmentModal(false);
    toast('Failed to add prospects. Please try again.', false);
  } finally {
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

function clearProspectPool() {
  if (!confirm('Are you sure you want to clear the entire prospect pool? This will remove all cached searches.')) {
    return;
  }

  placesCache.searches = {};
  savePlacesCache();
  prospectPoolState.selectedIds.clear();
  renderProspectPool();
  toast('Prospect pool cleared', true);
}

// Select all businesses in a category (check their checkboxes)
// SIMPLIFIED: Uses renderedProspects which already has all filtering/deduplication applied
function selectAllInCategory(category) {
  console.log('üîç selectAllInCategory called with:', category);

  // Use the renderedProspects lookup table - this contains exactly what's displayed
  // All filtering, deduplication, and ZIP matching is already done by renderProspectPool
  const eligibleIds = new Set();

  Object.entries(prospectPoolState.renderedProspects || {}).forEach(([id, prospect]) => {
    // Normalize the prospect's category to match the button's category
    const prospectCategory = normalizeCategory(prospect.category || 'other');

    // Only include if:
    // 1. Category matches
    // 2. Not already in system (inSystem flag)
    if (prospectCategory === category && !prospect.inSystem) {
      eligibleIds.add(id);
    }
  });

  console.log(`üîç Found ${eligibleIds.size} eligible businesses in rendered prospects for category "${category}"`);

  if (eligibleIds.size === 0) {
    toast('No businesses available in this category', false);
    return;
  }

  // Check if all eligible are already selected (toggle logic)
  let allSelected = true;
  eligibleIds.forEach(id => {
    if (!prospectPoolState.selectedIds.has(id)) {
      allSelected = false;
    }
  });

  let actionTaken = '';
  let count = 0;

  if (allSelected) {
    // UNCHECK all eligible
    eligibleIds.forEach(id => {
      prospectPoolState.selectedIds.delete(id);
      count++;
    });
    actionTaken = 'unchecked';
  } else {
    // CHECK all eligible
    eligibleIds.forEach(id => {
      prospectPoolState.selectedIds.add(id);
      count++;
    });
    actionTaken = 'selected';
  }

  // Update UI - just update checkboxes and count, don't re-render entire pool
  updatePoolSelectedCount();

  // Update checkbox states in DOM
  eligibleIds.forEach(id => {
    const checkbox = document.querySelector(`input[type="checkbox"][value="${id}"]`);
    if (checkbox) {
      checkbox.checked = (actionTaken === 'selected');
    }
  });

  // Show toast
  const categoryDisplay = category.replace(/_/g, ' ');
  if (actionTaken === 'selected') {
    toast(`‚úÖ Selected ${count} ${categoryDisplay} businesses. Click "Add to Pipeline" to add them.`, true);
  } else {
    toast(`‚òê Unchecked ${count} ${categoryDisplay} businesses`, true);
  }
}
window.selectAllInCategory = selectAllInCategory;

// Keep old function name for backwards compatibility (now just calls select)
function addAllCategoryToKanban(category) {
  selectAllInCategory(category);
}
window.addAllCategoryToKanban = addAllCategoryToKanban;

// ========= CATEGORY NORMALIZATION SYSTEM =========
// Maps various category names to canonical categories
// EXPANDED: Includes related business types so you don't miss leads
// You can always recategorize businesses using the edit pencil icon
const CATEGORY_ALIASES = {
  // Canonical category: [list of aliases that map to it]
  'accountant': ['accountant', 'accounting', 'cpa', 'bookkeeper', 'bookkeeping', 'tax preparer', 'tax preparation', 'tax service', 'payroll', 'financial advisor', 'financial planner', 'tax consultant', 'enrolled agent'],

  'auto_detailing': ['auto detailing', 'car detailing', 'vehicle detailing', 'auto detail', 'car detail', 'detailing', 'mobile detailing', 'car wash', 'auto wash', 'auto spa', 'window tinting', 'tint shop', 'tinting', 'ceramic coating', 'paint protection', 'ppf', 'clear bra', 'car care', 'auto appearance', 'vehicle wrap', 'car wrap', 'vinyl wrap', 'paint correction', 'buffing', 'polishing', 'interior detailing', 'headlight restoration'],

  'auto_repair': ['auto repair', 'car repair', 'mechanic', 'auto mechanic', 'car mechanic', 'automotive repair', 'auto service', 'car service', 'auto shop', 'garage', 'transmission', 'brake shop', 'brakes', 'muffler', 'exhaust', 'oil change', 'lube', 'tune up', 'auto body', 'body shop', 'collision', 'dent repair', 'paintless dent', 'auto electric', 'auto glass', 'windshield'],

  'bakery': ['bakery', 'baker', 'bake shop', 'pastry shop', 'cake shop', 'cupcake', 'donut', 'doughnut', 'bagel', 'bread', 'pastry', 'dessert', 'sweet shop', 'confectionery'],

  'bar': ['bar', 'pub', 'tavern', 'nightclub', 'lounge', 'sports bar', 'wine bar', 'cocktail bar', 'brewery', 'taproom', 'beer garden', 'club', 'cantina', 'saloon'],

  'barber': ['barber', 'barbershop', 'barber shop', 'mens haircut', 'mens grooming', 'fade', 'haircut', 'mens salon', 'gentleman'],

  'cafe': ['cafe', 'coffee shop', 'coffee house', 'coffeehouse', 'espresso bar', 'tea house', 'tea room', 'bistro', 'brunch', 'breakfast'],

  'chiropractor': ['chiropractor', 'chiropractic', 'chiropractic clinic', 'spine', 'back doctor', 'spinal', 'adjustment', 'wellness center', 'pain relief', 'physical therapy', 'pt', 'rehab', 'rehabilitation', 'sports medicine', 'acupuncture', 'holistic'],

  'contractor': ['contractor', 'general contractor', 'construction', 'builder', 'home builder', 'remodeling', 'renovation', 'handyman', 'home improvement', 'home repair', 'kitchen remodel', 'bathroom remodel', 'basement', 'addition', 'deck', 'patio', 'concrete', 'masonry', 'framing', 'drywall', 'carpentry', 'carpenter'],

  'dentist': ['dentist', 'dental', 'dental office', 'dental clinic', 'dental practice', 'orthodontist', 'oral surgeon', 'teeth', 'tooth', 'orthodontics', 'braces', 'invisalign', 'implant', 'cosmetic dentist', 'family dentist', 'pediatric dentist', 'endodontist', 'periodontist', 'dentures'],

  'doctor': ['doctor', 'physician', 'medical', 'clinic', 'medical office', 'family medicine', 'primary care', 'healthcare', 'urgent care', 'walk in clinic', 'pediatrician', 'internist', 'dermatologist', 'cardiologist', 'obgyn', 'gynecologist', 'orthopedic', 'podiatrist', 'psychiatrist', 'psychologist', 'therapist', 'counselor', 'mental health'],

  'dry_cleaner': ['dry cleaner', 'dry cleaning', 'laundry', 'laundromat', 'cleaners', 'wash and fold', 'coin laundry', 'laundry service', 'pressing', 'ironing'],

  'electrician': ['electrician', 'electrical', 'electrical contractor', 'electric', 'electrical service', 'electrical repair', 'wiring', 'rewire', 'panel', 'circuit', 'lighting', 'generator', 'solar', 'ev charger', 'smart home'],

  'florist': ['florist', 'flower shop', 'floral', 'flowers', 'floral design', 'flower delivery', 'bouquet', 'arrangement', 'wedding flowers', 'event flowers', 'plant shop', 'nursery', 'garden center'],

  'funeral_home': ['funeral home', 'funeral', 'mortuary', 'funeral service', 'cremation', 'memorial', 'cemetery', 'burial', 'mortician', 'funeral director'],

  'gift_shop': ['gift shop', 'gift store', 'gifts', 'novelty', 'souvenir', 'card shop', 'boutique', 'specialty shop', 'antique', 'collectible', 'home decor', 'candle shop'],

  'groomer': ['groomer', 'pet grooming', 'dog grooming', 'pet groomer', 'dog groomer', 'cat grooming', 'animal grooming', 'pet salon', 'dog wash', 'pet spa', 'mobile grooming', 'pet boarding', 'kennel', 'doggy daycare', 'dog training', 'pet sitting', 'dog walker'],

  'gym': ['gym', 'fitness', 'fitness center', 'health club', 'workout', 'exercise', 'crossfit', 'personal training', 'trainer', 'weight loss', 'boot camp', 'spin', 'cycling', 'barre', 'zumba', 'aerobics', 'strength training', 'bodybuilding', 'athletic club', '24 hour fitness', 'anytime fitness'],

  'hvac': ['hvac', 'hvac contractor', 'heating', 'air conditioning', 'ac repair', 'heating and cooling', 'furnace', 'heat pump', 'ac service', 'air conditioner', 'cooling', 'ductwork', 'ventilation', 'indoor air quality', 'thermostat', 'boiler', 'radiant heat', 'mini split', 'central air'],

  'insurance': ['insurance', 'insurance agent', 'insurance agency', 'insurance broker', 'auto insurance', 'home insurance', 'life insurance', 'health insurance', 'commercial insurance', 'business insurance', 'renters insurance', 'motorcycle insurance', 'boat insurance', 'umbrella insurance'],

  'jewelry': ['jewelry', 'jeweler', 'jewelry store', 'jewelers', 'jewelry repair', 'watch repair', 'gold buyer', 'diamond', 'engagement ring', 'wedding ring', 'custom jewelry', 'pawn shop', 'gold exchange', 'silver', 'gemstone'],

  'landscaping': ['landscaping', 'landscaper', 'lawn care', 'lawn service', 'yard work', 'garden', 'gardening', 'lawn maintenance', 'tree service', 'tree trimming', 'tree removal', 'stump grinding', 'irrigation', 'sprinkler', 'hardscape', 'paver', 'retaining wall', 'sod', 'mulch', 'snow removal', 'leaf removal', 'hedge trimming', 'bush trimming', 'weed control', 'fertilizing', 'aeration'],

  'lawyer': ['lawyer', 'attorney', 'law firm', 'legal', 'law office', 'legal service', 'paralegal', 'personal injury', 'divorce', 'family law', 'criminal defense', 'dui', 'bankruptcy', 'estate planning', 'wills', 'trusts', 'real estate attorney', 'business attorney', 'immigration', 'workers comp'],

  'martial_arts': ['martial arts', 'karate', 'taekwondo', 'jiu jitsu', 'mma', 'boxing', 'kickboxing', 'self defense', 'dojo', 'kung fu', 'aikido', 'judo', 'krav maga', 'muay thai', 'brazilian jiu jitsu', 'bjj', 'wrestling', 'mixed martial arts'],

  'nail_salon': ['nail salon', 'nails', 'manicure', 'pedicure', 'nail spa', 'nail bar', 'nail tech', 'gel nails', 'acrylic nails', 'nail art', 'lash', 'eyelash', 'lash extensions', 'brow', 'eyebrow', 'waxing', 'threading'],

  'pet_store': ['pet store', 'pet shop', 'pet supplies', 'pet food', 'aquarium', 'fish store', 'reptile', 'bird', 'small animal', 'pet accessories', 'dog food', 'cat food', 'pet boutique'],

  'pizza': ['pizza', 'pizzeria', 'pizza shop', 'pizza restaurant', 'pizza delivery', 'italian', 'pasta', 'sub shop', 'sandwich', 'wings', 'calzone', 'stromboli'],

  'plumber': ['plumber', 'plumbing', 'plumbing service', 'plumbing contractor', 'drain cleaning', 'pipe repair', 'water heater', 'sewer', 'septic', 'rooter', 'leak', 'faucet', 'toilet', 'garbage disposal', 'water softener', 'water filtration', 'backflow', 'gas line', 'repiping', 'hydro jetting'],

  'real_estate': ['real estate', 'realtor', 'real estate agent', 'real estate broker', 'property', 'realty', 'home sales', 'homes for sale', 'listing agent', 'buyers agent', 'property management', 'rental', 'apartment', 'commercial real estate', 'land', 'mortgage', 'home loan', 'title company', 'escrow', 'home inspection', 'appraiser'],

  'restaurant': ['restaurant', 'dining', 'eatery', 'food', 'diner', 'bistro', 'grill', 'kitchen', 'steakhouse', 'seafood', 'mexican', 'chinese', 'thai', 'indian', 'japanese', 'sushi', 'korean', 'vietnamese', 'greek', 'mediterranean', 'american', 'bbq', 'barbecue', 'buffet', 'fine dining', 'casual dining', 'family restaurant', 'catering', 'food truck'],

  'roofing': ['roofing', 'roofer', 'roof repair', 'roofing contractor', 'roof replacement', 'roof installation', 'shingle', 'metal roof', 'flat roof', 'gutter', 'siding', 'soffit', 'fascia', 'roof inspection', 'roof leak', 'storm damage', 'hail damage'],

  'salon': ['salon', 'hair salon', 'beauty salon', 'hairdresser', 'hair stylist', 'beauty shop', 'hair care', 'cosmetology', 'color', 'highlights', 'balayage', 'extensions', 'blowout', 'keratin', 'perm', 'relaxer', 'braids', 'weave', 'wig', 'beauty supply'],

  'spa': ['spa', 'day spa', 'massage', 'massage therapy', 'wellness', 'relaxation', 'facial', 'body treatment', 'med spa', 'medical spa', 'botox', 'filler', 'laser', 'skin care', 'esthetician', 'body sculpting', 'coolsculpting', 'microneedling', 'chemical peel', 'dermaplaning', 'hydrafacial', 'sauna', 'float', 'cryotherapy'],

  'tailor': ['tailor', 'alterations', 'seamstress', 'clothing alterations', 'suit tailor', 'dress alterations', 'custom suit', 'bespoke', 'tuxedo', 'formal wear', 'bridal alterations', 'leather repair', 'shoe repair', 'cobbler'],

  'tire_shop': ['tire shop', 'tire store', 'tires', 'tire service', 'tire repair', 'wheel alignment', 'tire center', 'wheel', 'rim', 'flat repair', 'rotation', 'balancing', 'discount tire', 'used tire'],

  'veterinarian': ['veterinarian', 'vet', 'veterinary', 'animal hospital', 'pet clinic', 'animal clinic', 'pet hospital', 'vet clinic', 'emergency vet', 'spay', 'neuter', 'vaccination', 'pet surgery', 'animal care', 'exotic vet', 'equine', 'large animal'],

  'yoga': ['yoga', 'yoga studio', 'pilates', 'yoga class', 'hot yoga', 'meditation', 'mindfulness', 'stretch', 'flexibility', 'vinyasa', 'hatha', 'bikram', 'power yoga', 'restorative yoga', 'yin yoga', 'prenatal yoga'],

  'other': ['other', 'miscellaneous', 'general', 'unknown', 'service', 'business', 'company', 'shop', 'store']
};

// Build reverse lookup: alias -> canonical category
const CATEGORY_LOOKUP = {};
Object.keys(CATEGORY_ALIASES).forEach(canonical => {
  CATEGORY_ALIASES[canonical].forEach(alias => {
    // Store lowercase version for case-insensitive lookup
    CATEGORY_LOOKUP[alias.toLowerCase()] = canonical;
  });
});

/**
 * Normalize a category string to its canonical form
 * "Plumbing Service" -> "plumber"
 * "HVAC Contractor" -> "hvac"
 * @param {string} category - Raw category string
 * @returns {string} - Canonical category (lowercase with underscores)
 */
function normalizeCategory(category) {
  if (!category) return 'other';

  // Clean up the input: lowercase, trim, replace underscores with spaces
  const cleaned = category.toLowerCase().trim().replace(/_/g, ' ');

  // Direct lookup
  if (CATEGORY_LOOKUP[cleaned]) {
    return CATEGORY_LOOKUP[cleaned];
  }

  // Try partial matching - check if any alias is contained in the category
  // e.g., "Joe's Plumbing Service LLC" contains "plumbing service"
  for (const [canonical, aliases] of Object.entries(CATEGORY_ALIASES)) {
    for (const alias of aliases) {
      if (cleaned.includes(alias.toLowerCase())) {
        return canonical;
      }
    }
  }

  // Try matching the other way - category contained in alias
  // e.g., "hvac" is contained in "hvac contractor"
  for (const [canonical, aliases] of Object.entries(CATEGORY_ALIASES)) {
    for (const alias of aliases) {
      if (alias.toLowerCase().includes(cleaned) && cleaned.length >= 3) {
        return canonical;
      }
    }
  }

  // No match found - return cleaned version with underscores
  return cleaned.replace(/ /g, '_') || 'other';
}

// Expose globally for console access
window.normalizeCategory = normalizeCategory;
window.CATEGORY_ALIASES = CATEGORY_ALIASES;

// Common business categories for dropdown (canonical names)
// Note: car_wash is now merged into auto_detailing
const BUSINESS_CATEGORIES = [
  'accountant', 'auto_detailing', 'auto_repair', 'bakery', 'bar', 'barber',
  'cafe', 'chiropractor', 'contractor',
  'dentist', 'doctor', 'dry_cleaner',
  'electrician',
  'florist', 'funeral_home',
  'gift_shop', 'groomer', 'gym',
  'hvac',
  'insurance',
  'jewelry',
  'landscaping', 'lawyer',
  'martial_arts',
  'nail_salon',
  'pet_store', 'pizza', 'plumber',
  'real_estate', 'restaurant', 'roofing',
  'salon', 'spa',
  'tailor', 'tire_shop',
  'veterinarian',
  'yoga',
  'other'  // Keep 'other' at the end
];

// Edit a prospect's category with dropdown
function editProspectCategory(placeId, currentCategory) {
  // Create modal for category selection
  const modal = document.createElement('div');
  modal.id = 'categoryEditModal';
  modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50';
  modal.innerHTML = `
    <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 shadow-2xl">
      <h3 class="text-lg font-bold text-gray-900 mb-4">Edit Category</h3>
      <p class="text-sm text-gray-600 mb-4">Current: <strong>${currentCategory.replace(/_/g, ' ')}</strong></p>
      <select id="categorySelect" class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg text-sm focus:border-indigo-500 focus:outline-none mb-4">
        ${BUSINESS_CATEGORIES.map(cat => `
          <option value="${cat}" ${cat === currentCategory ? 'selected' : ''}>
            ${cat.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}
          </option>
        `).join('')}
      </select>
      <div class="flex gap-3">
        <button onclick="document.getElementById('categoryEditModal').remove()" class="flex-1 px-4 py-2 border-2 border-gray-300 rounded-lg font-semibold hover:bg-gray-50">
          Cancel
        </button>
        <button onclick="applyProspectCategoryChange('${placeId}', '${currentCategory}')" class="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-lg font-semibold hover:bg-indigo-700">
          Save
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);

  // Close on backdrop click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

function applyProspectCategoryChange(placeId, oldCategory) {
  const select = document.getElementById('categorySelect');
  const newCategory = normalizeCategory(select.value);

  // Close modal
  document.getElementById('categoryEditModal')?.remove();

  if (newCategory === oldCategory) {
    return; // No change
  }

  let businessData = null;
  let updated = false;

  // Find and update in placesCache.searches - also move to correct category cache
  Object.keys(placesCache.searches).forEach(cacheKey => {
    const cached = placesCache.searches[cacheKey];
    if (cached.cachedData) {
      const index = cached.cachedData.findIndex(b => b.placeId === placeId);
      if (index !== -1) {
        // Get the business data
        businessData = { ...cached.cachedData[index], category: newCategory };
        // Remove from old cache
        cached.cachedData.splice(index, 1);
        updated = true;
      }
    }
  });

  // If found in cache, add to new category cache
  if (businessData) {
    const zip = businessData.actualZip || businessData.zipCode || '00000';
    const newCacheKey = `${zip}-${newCategory}`;
    if (!placesCache.searches[newCacheKey]) {
      placesCache.searches[newCacheKey] = {
        cachedData: [],
        lastFetched: new Date().toISOString()
      };
    }
    placesCache.searches[newCacheKey].cachedData.push(businessData);
  }

  // Update in manualProspects
  prospectPoolState.manualProspects.forEach(prospect => {
    if (prospect.placeId === placeId || prospect.id === placeId) {
      prospect.category = newCategory;
      updated = true;
    }
  });

  // Update in kanban columns
  Object.values(kanbanState.columns).forEach(column => {
    if (Array.isArray(column)) {
      column.forEach(item => {
        if (item && (item.placeId === placeId || item.id === placeId)) {
          item.category = newCategory;
          updated = true;
        }
      });
    }
  });

  if (updated) {
    savePlacesCache();
    saveManualProspects();
    saveKanban();
    renderProspectPool();
    toast(`‚úÖ Moved to "${newCategory.replace(/_/g, ' ')}"`, true);
  } else {
    toast('Could not find prospect to update', false);
  }
}
window.editProspectCategory = editProspectCategory;
window.applyProspectCategoryChange = applyProspectCategoryChange;

// Clear prospects for CURRENT CARD only
function clearAllProspects() {
  const currentMailerId = state.current?.Mailer_ID;
  if (!currentMailerId) {
    toast('Please select a postcard first', false);
    return;
  }

  const cardName = `${state.current.Town} ‚Äî ${state.current.Mail_Date}`;

  if (!confirm(`‚ö†Ô∏è This will clear all prospects for:\n"${cardName}"\n\n‚Ä¢ All search results in the prospect pool\n‚Ä¢ All prospects in the pipeline (all stages)\n\nAre you sure?`)) {
    return;
  }

  // Clear ALL cached search results (entire prospect pool)
  placesCache.searches = {};
  savePlacesCache();

  // Clear manual prospects for this card only
  prospectPoolState.manualProspects = prospectPoolState.manualProspects.filter(
    p => p.mailerId && p.mailerId !== currentMailerId
  );

  // Clear campaign board columns for this card
  const board = getCurrentCampaignBoard();
  if (board && board.columns) {
    Object.keys(board.columns).forEach(colKey => {
      board.columns[colKey] = [];
    });
  }

  prospectPoolState.selectedIds.clear();

  saveManualProspects();
  saveCampaignBoards();

  renderProspectPool();
  renderKanban();

  toast(`‚úÖ All prospects cleared for ${cardName}!`, true);
}

// Filter prospect pool by search term
function filterProspectPool(searchTerm) {
  prospectPoolSearchTerm = searchTerm; // Save for re-renders
  const term = searchTerm.toLowerCase().trim();

  // Get the prospect pool container - check both standalone and inline versions
  let container = document.getElementById('prospectPoolContainer');
  if (!container) {
    container = document.getElementById('inlineProspectPoolContainer');
  }
  if (!container) {
    console.log('üîç filterProspectPool: No container found');
    return;
  }

  // Get all category sections (with mb-8 class)
  const categorySections = container.querySelectorAll('.mb-8');
  console.log('üîç filterProspectPool: Found', categorySections.length, 'category sections in', container.id);

  categorySections.forEach(categorySection => {
    // Find the grid container with all prospect cards
    const grid = categorySection.querySelector('.grid');
    if (!grid) return;

    // Get all direct children of the grid (the prospect cards)
    const prospectCards = grid.children;
    console.log('üîç filterProspectPool: Found', prospectCards.length, 'cards in grid');

    let visibleCount = 0;

    Array.from(prospectCards).forEach(card => {
      // Get the business name from h5 tag
      const businessName = card.querySelector('h5')?.textContent || '';
      // Get all text content for searching
      const allText = card.textContent || '';

      const matches = businessName.toLowerCase().includes(term) || allText.toLowerCase().includes(term);

      if (term === '' || matches) {
        card.style.display = '';
        visibleCount++;
      } else {
        card.style.display = 'none';
      }
    });

    // Hide entire category if no visible prospects
    if (visibleCount === 0 && term !== '') {
      categorySection.style.display = 'none';
    } else {
      categorySection.style.display = '';
    }
  });
}

/**
 * Clear cached search results for a specific ZIP code
 * @param {string} zipCode - The ZIP code to clear (e.g., '14150')
 */
function clearCacheByZip(zipCode) {
  if (!zipCode) {
    showError('Please provide a ZIP code (e.g., clearCacheByZip("14150"))');
    return;
  }

  // Check for manual prospects with this ZIP first (normalize to 5 digits for comparison)
  const normalizedZip = truncateZipTo5(zipCode);
  const manualMatches = prospectPoolState.manualProspects.filter(p =>
    truncateZipTo5(p.actualZip) === normalizedZip ||
    truncateZipTo5(p.zipCode) === normalizedZip ||
    truncateZipTo5(p.zip) === normalizedZip
  );
  const manualCount = manualMatches.length;

  const allKeys = Object.keys(placesCache.searches);

  // Find all cache keys that start with this ZIP code
  const keysToDelete = allKeys.filter(key => key.startsWith(`${zipCode}-`));

  // Check ALL cache entries for businesses with matching ZIP (handles legacy data and mismatched keys)
  let otherKeysWithMatches = [];
  let otherBusinessCount = 0;

  allKeys.forEach(key => {
    // Skip keys we're already deleting
    if (keysToDelete.includes(key)) return;

    const cache = placesCache.searches[key];
    if (cache && cache.cachedData && Array.isArray(cache.cachedData)) {
      const matchingBusinesses = cache.cachedData.filter(b =>
        truncateZipTo5(b.actualZip) === normalizedZip ||
        truncateZipTo5(b.zipCode) === normalizedZip ||
        truncateZipTo5(b.zip) === normalizedZip
      );
      if (matchingBusinesses.length > 0) {
        otherKeysWithMatches.push({ key, count: matchingBusinesses.length });
        otherBusinessCount += matchingBusinesses.length;
      }
    }
  });

  const hasOtherData = otherBusinessCount > 0;

  if (keysToDelete.length === 0 && !hasOtherData && manualCount === 0) {
    showWarning(`No prospects found for ZIP ${zipCode}\n\nAvailable cache keys: ${allKeys.join(', ')}`);
    return;
  }

  const categoryCount = keysToDelete.length;
  const businessCount = keysToDelete.reduce((sum, key) => {
    const cached = placesCache.searches[key];
    return sum + (cached.cachedData ? cached.cachedData.length : 0);
  }, 0);

  const totalBusinesses = businessCount + otherBusinessCount + manualCount;

  // Build descriptive message
  let messageParts = [];
  if (categoryCount > 0) messageParts.push(`${businessCount} from ${categoryCount} category searches`);
  if (otherBusinessCount > 0) messageParts.push(`${otherBusinessCount} from other cache entries`);
  if (manualCount > 0) messageParts.push(`${manualCount} manual prospects`);

  const message = `Clear all prospects for ZIP ${zipCode}?\n\nThis will remove ${totalBusinesses} businesses:\n- ${messageParts.join('\n- ')}\n\nYou can re-run searches to get fresh results.`;

  if (!confirm(message)) {
    return;
  }

  // Delete the cache entries for this ZIP
  keysToDelete.forEach(key => {
    delete placesCache.searches[key];
  });

  // Remove businesses from OTHER cache entries that have matching ZIP
  if (hasOtherData) {
    otherKeysWithMatches.forEach(({ key }) => {
      const cache = placesCache.searches[key];
      if (cache && cache.cachedData && Array.isArray(cache.cachedData)) {
        const originalLength = cache.cachedData.length;
        cache.cachedData = cache.cachedData.filter(b =>
          (b.actualZip !== zipCode) && (b.zipCode !== zipCode) && (b.zip !== zipCode)
        );
        console.log(`üóëÔ∏è Removed ${originalLength - cache.cachedData.length} businesses from cache key '${key}'`);

        // If cache is now empty, delete the key entirely
        if (cache.cachedData.length === 0) {
          delete placesCache.searches[key];
          console.log(`üóëÔ∏è Removed empty cache key '${key}'`);
        }
      }
    });
  }

  // Remove manual prospects with this ZIP
  if (manualCount > 0) {
    const originalLength = prospectPoolState.manualProspects.length;
    prospectPoolState.manualProspects = prospectPoolState.manualProspects.filter(p =>
      (p.actualZip !== zipCode) && (p.zipCode !== zipCode) && (p.zip !== zipCode)
    );
    console.log(`üóëÔ∏è Removed ${originalLength - prospectPoolState.manualProspects.length} manual prospects for ZIP ${zipCode}`);

    // Save manual prospects to cloud
    saveManualProspects();
  }

  // Save search cache to cloud and localStorage
  savePlacesCache();

  // Refresh the prospect pool display
  renderProspectPool();

  showSuccess(`‚úÖ Cleared data for ZIP ${zipCode} (${totalBusinesses} businesses removed)`);
  console.log(`üóëÔ∏è Cleared cache keys:`, keysToDelete, 'Other keys cleaned:', otherKeysWithMatches.map(k => k.key));
}

// Expose globally
window.clearAllProspects = clearAllProspects;
window.clearCacheByZip = clearCacheByZip;
window.filterProspectPool = filterProspectPool;

/* ========= PROSPECT POOL CSV EXPORT/IMPORT ========= */

function exportProspectListCSV() {
  // Export ONLY prospects from the "Prospect List" (Campaign Board 'queued')
  const board = getCurrentCampaignBoard();
  const prospectList = board?.columns?.['queued'] || [];

  if (prospectList.length === 0) {
    toast('‚ö†Ô∏è No prospects in Prospect List to export', false);
    return;
  }

  const allProspects = prospectList
    .filter(item => item && typeof item === 'object')
    .map(item => ({
      businessName: item.businessName || item.name || '',
      phone: item.phone || '',
      website: item.website || '',
      email: item.email || '',
      facebook: item.facebook || '',
      instagram: item.instagram || '',
      category: item.category || '',
      zipCode: item.zipCode || '',
      address: item.address || '',
      rating: item.rating || '',
      reviewsCount: item.reviewsCount || item.userRatingsTotal || '',
      placeId: item.placeId || '',
      notes: item.notes || '',
      dateAdded: item.dateAdded || new Date().toISOString().split('T')[0]
    }));

  // Create CSV
  const headers = [
    'Business Name',
    'Phone',
    'Website',
    'Email',
    'Facebook',
    'Instagram',
    'Category',
    'ZIP Code',
    'Address',
    'Rating',
    'Review Count',
    'Place ID',
    'Notes',
    'Date Added'
  ];

  const csvContent = [
    headers.join(','),
    ...allProspects.map(p => [
      `"${(p.businessName || '').replace(/"/g, '""')}"`,
      `"${(p.phone || '').replace(/"/g, '""')}"`,
      `"${(p.website || '').replace(/"/g, '""')}"`,
      `"${(p.email || '').replace(/"/g, '""')}"`,
      `"${(p.facebook || '').replace(/"/g, '""')}"`,
      `"${(p.instagram || '').replace(/"/g, '""')}"`,
      `"${(p.category || '').replace(/"/g, '""')}"`,
      `"${(p.zipCode || '').replace(/"/g, '""')}"`,
      `"${(p.address || '').replace(/"/g, '""')}"`,
      `"${(p.rating || '').toString().replace(/"/g, '""')}"`,
      `"${(p.reviewsCount || '').toString().replace(/"/g, '""')}"`,
      `"${(p.placeId || '').replace(/"/g, '""')}"`,
      `"${(p.notes || '').replace(/"/g, '""')}"`,
      `"${(p.dateAdded || '').replace(/"/g, '""')}"`
    ].join(','))
  ].join('\n');

  // Trigger download
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `prospect-list-${new Date().toISOString().split('T')[0]}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  toast(`‚úÖ Exported ${allProspects.length} prospects from Prospect List`, true);
}

function exportProspectPoolCSV() {
  // Collect all prospects from searches cache AND manual prospects
  const allProspects = [];
  const seenIds = new Set(); // Prevent duplicates

  // First, add from search cache
  Object.keys(placesCache.searches).forEach(cacheKey => {
    const cached = placesCache.searches[cacheKey];
    if (cached.cachedData && cached.cachedData.length > 0) {
      cached.cachedData.forEach(business => {
        // Skip if already in system
        if (notInterestedState.placeIds.has(business.placeId)) return;
        // Skip duplicates
        if (business.placeId && seenIds.has(business.placeId)) return;
        if (business.placeId) seenIds.add(business.placeId);

        allProspects.push({
          businessName: business.name || '',
          phone: business.phone || '',
          website: business.website || '',
          email: business.email || '',
          facebook: business.facebook || '',
          instagram: business.instagram || '',
          category: business.category || '',
          zipCode: business.zipCode || business.actualZip || '',
          address: business.address || '',
          rating: business.rating || '',
          reviewsCount: business.reviewsCount || '',
          placeId: business.placeId || '',
          notes: business.notes || '',
          dateAdded: business.dateAdded || new Date().toISOString().split('T')[0]
        });
      });
    }
  });

  // Also add manually added prospects
  if (prospectPoolState.manualProspects && prospectPoolState.manualProspects.length > 0) {
    prospectPoolState.manualProspects.forEach(prospect => {
      const prospectId = prospect.placeId || prospect.id;
      // Skip if already added from search cache
      if (prospectId && seenIds.has(prospectId)) return;
      if (prospectId) seenIds.add(prospectId);

      allProspects.push({
        businessName: prospect.businessName || prospect.name || '',
        phone: prospect.phone || '',
        website: prospect.website || '',
        email: prospect.email || '',
        facebook: prospect.facebook || '',
        instagram: prospect.instagram || '',
        category: prospect.category || '',
        zipCode: prospect.zipCode || prospect.actualZip || '',
        address: prospect.address || '',
        rating: prospect.rating || '',
        reviewsCount: prospect.reviewsCount || prospect.userRatingsTotal || '',
        placeId: prospectId || '',
        notes: prospect.notes || '',
        dateAdded: prospect.dateAdded || new Date().toISOString().split('T')[0]
      });
    });
  }

  if (allProspects.length === 0) {
    toast('‚ö†Ô∏è No prospects to export', false);
    return;
  }

  // Create CSV
  const headers = [
    'Business Name',
    'Phone',
    'Website',
    'Email',
    'Facebook',
    'Instagram',
    'Category',
    'ZIP Code',
    'Address',
    'Rating',
    'Review Count',
    'Place ID',
    'Notes',
    'Date Added'
  ];

  const rows = allProspects.map(p => [
    p.businessName,
    p.phone,
    p.website,
    p.email,
    p.facebook,
    p.instagram,
    p.category,
    p.zipCode,
    p.address,
    p.rating,
    p.reviewsCount,
    p.placeId,
    p.notes,
    p.dateAdded
  ]);

  let csv = headers.join(',') + '\n';
  rows.forEach(row => {
    csv += row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',') + '\n';
  });

  // Download
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `prospect-pool-${new Date().toISOString().split('T')[0]}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);

  toast(`‚úÖ Exported ${allProspects.length} prospects to CSV`, true);
}

function importProspectPoolCSV(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const csv = e.target.result;
      const lines = csv.split('\n').filter(line => line.trim());

      if (lines.length < 2) {
        toast('‚ö†Ô∏è CSV file is empty or invalid', false);
        return;
      }

      // Parse CSV (simple parser for quoted fields)
      const parseCsvLine = (line) => {
        const result = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            result.push(current);
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current);
        return result;
      };

      const headers = parseCsvLine(lines[0]);

      // Find column indices
      const colMap = {
        businessName: headers.findIndex(h => h.toLowerCase().includes('business')),
        phone: headers.findIndex(h => h.toLowerCase().includes('phone')),
        website: headers.findIndex(h => h.toLowerCase().includes('website')),
        email: headers.findIndex(h => h.toLowerCase().includes('email')),
        facebook: headers.findIndex(h => h.toLowerCase().includes('facebook')),
        instagram: headers.findIndex(h => h.toLowerCase().includes('instagram')),
        category: headers.findIndex(h => h.toLowerCase().includes('category')),
        zipCode: headers.findIndex(h => h.toLowerCase().includes('zip')),
        address: headers.findIndex(h => h.toLowerCase().includes('address')),
        rating: headers.findIndex(h => h.toLowerCase().includes('rating')),
        reviewsCount: headers.findIndex(h => h.toLowerCase().includes('review')),
        placeId: headers.findIndex(h => h.toLowerCase().includes('place')),
        notes: headers.findIndex(h => h.toLowerCase().includes('notes')),
        dateAdded: headers.findIndex(h => h.toLowerCase().includes('date'))
      };

      let updated = 0;
      let added = 0;

      // Process each row
      for (let i = 1; i < lines.length; i++) {
        const fields = parseCsvLine(lines[i]);
        if (fields.length < 2) continue; // Skip empty/invalid rows

        const businessName = fields[colMap.businessName] || '';
        if (!businessName.trim()) continue;

        const prospectData = {
          name: businessName,
          businessName: businessName,
          phone: fields[colMap.phone] || '',
          website: fields[colMap.website] || '',
          email: fields[colMap.email] || '',
          facebook: fields[colMap.facebook] || '',
          instagram: fields[colMap.instagram] || '',
          category: fields[colMap.category] || 'other',
          zipCode: fields[colMap.zipCode] || '',
          address: fields[colMap.address] || '',
          rating: parseFloat(fields[colMap.rating]) || 0,
          reviewsCount: parseInt(fields[colMap.reviewsCount]) || 0,
          placeId: fields[colMap.placeId] || `MANUAL-${Date.now()}-${Math.random()}`,
          notes: fields[colMap.notes] || '',
          dateAdded: fields[colMap.dateAdded] || new Date().toISOString().split('T')[0]
        };

        // Try to find existing prospect by Place ID or business name
        let found = false;

        // FIRST: Check kanban columns (Prospect List, To Contact, In Progress, Committed)
        Object.keys(kanbanState.columns).forEach(columnKey => {
          const column = kanbanState.columns[columnKey];
          if (!Array.isArray(column)) return;

          const existingIndex = column.findIndex(item =>
            item && typeof item === 'object' && (
              item.placeId === prospectData.placeId ||
              item.id === prospectData.placeId ||
              (item.businessName && item.businessName.toLowerCase() === businessName.toLowerCase())
            )
          );

          if (existingIndex !== -1) {
            // Update existing prospect in kanban with enriched data
            kanbanState.columns[columnKey][existingIndex] = {
              ...kanbanState.columns[columnKey][existingIndex],
              ...prospectData,
              id: kanbanState.columns[columnKey][existingIndex].id || prospectData.placeId
            };
            found = true;
            updated++;
          }
        });

        // SECOND: Check places cache
        if (!found) {
          Object.keys(placesCache.searches).forEach(cacheKey => {
            const cached = placesCache.searches[cacheKey];
            if (cached.cachedData) {
              const existingIndex = cached.cachedData.findIndex(p =>
                p.placeId === prospectData.placeId ||
                (p.name && p.name.toLowerCase() === businessName.toLowerCase())
              );

              if (existingIndex !== -1) {
                // Update existing prospect with enriched data
                cached.cachedData[existingIndex] = {
                  ...cached.cachedData[existingIndex],
                  ...prospectData,
                  interactions: cached.cachedData[existingIndex].interactions || []
                };
                found = true;
                updated++;
              }
            }
          });
        }

        // If not found, add to appropriate category in cache
        if (!found) {
          const category = prospectData.category || 'other';
          const cacheKey = `${prospectData.zipCode || 'UNKNOWN'}-${category}`;

          if (!placesCache.searches[cacheKey]) {
            placesCache.searches[cacheKey] = {
              cachedData: [],
              cachedAt: Date.now(),
              zipCode: prospectData.zipCode,
              category: category
            };
          }

          placesCache.searches[cacheKey].cachedData.push({
            ...prospectData,
            interactions: []
          });
          added++;
        }
      }

      // Save to localStorage (use safeSetItem to handle quota)
      idbSet('mailslot-places-cache', placesCache.searches);

      // Save kanban changes to cloud
      saveKanban();

      // Re-render both prospect pool and kanban
      renderProspectPool();
      renderKanban();

      toast(`‚úÖ CSV Import Complete: ${updated} updated, ${added} added`, true);

      // Reset file input
      event.target.value = '';

    } catch (error) {
      console.error('CSV import error:', error);
      toast('‚ö†Ô∏è Failed to import CSV. Check format and try again.', false);
    }
  };

  reader.readAsText(file);
}

// Expose globally
window.exportProspectListCSV = exportProspectListCSV;
window.exportProspectPoolCSV = exportProspectPoolCSV;
window.importProspectPoolCSV = importProspectPoolCSV;

/* ========= PROSPECT DETAIL MODAL FUNCTIONS ========= */

// Global variable to track current prospect being viewed
let currentProspectDetail = null;

function openProspectDetailModal(prospectData, source = 'prospect') {
  const modal = document.getElementById('prospectDetailModal');
  if (!modal) return;

  // Normalize business name field (raw prospects have 'name', enriched have 'businessName')
  const businessName = prospectData.businessName || prospectData.name || 'Unknown Business';

  // Store current prospect data with normalized businessName
  currentProspectDetail = { ...prospectData, businessName, source };

  // === HEADER SECTION ===
  document.getElementById('detailBusinessName').textContent = businessName;

  // Category display
  const categoryObj = businessCategories.find(c => c.value === prospectData.category);
  const categoryLabel = categoryObj ? categoryObj.label : (prospectData.category || 'Uncategorized');
  document.getElementById('detailCategoryText').textContent = categoryLabel;

  // ZIP code display
  document.getElementById('detailZipCode').textContent = prospectData.zipCode || prospectData.town || '‚Äî';

  // Stage badge
  const stageBadge = document.getElementById('detailStageBadge');
  if (source === 'client') {
    stageBadge.textContent = 'Client';
    stageBadge.className = 'px-3 py-1 bg-green-500/30 rounded-full text-sm font-semibold';
  } else {
    // Determine stage from kanban column or campaign board
    const stage = prospectData.stage || prospectData.columnKey || 'Prospect';
    const stageLabels = {
      'cold': 'Cold Lead',
      'to-contact': 'To Contact',
      'contacted': 'Contacted',
      'follow-up': 'Follow Up',
      'interested': 'Interested',
      'client': 'Client'
    };
    stageBadge.textContent = stageLabels[stage] || 'Prospect';
    stageBadge.className = 'px-3 py-1 bg-white/20 rounded-full text-sm font-semibold';
  }

  // Contact score (calculate based on available info)
  const score = calculateContactScore(prospectData);
  document.getElementById('detailContactScore').textContent = `Score: ${score}/10`;

  // === QUICK ACTION BUTTONS (Header) ===
  const phone = prospectData.phone || '';
  const email = prospectData.email || '';
  const website = prospectData.website || '';

  document.getElementById('btnHeaderCall').disabled = !phone;
  document.getElementById('btnHeaderSMS').disabled = !phone;
  document.getElementById('btnHeaderEmail').disabled = !email;
  document.getElementById('btnHeaderWebsite').disabled = !website;

  // === CONTACT INFO TAB ===
  document.getElementById('detailPhone').textContent = phone || '‚Äî';
  document.getElementById('btnContactCall').disabled = !phone;
  document.getElementById('btnContactSMS').disabled = !phone;

  document.getElementById('detailEmail').textContent = email || '‚Äî';
  document.getElementById('btnContactEmail').disabled = !email;

  document.getElementById('detailWebsite').textContent = website || '‚Äî';
  document.getElementById('btnContactWebsite').disabled = !website;

  // Address
  const address = prospectData.address || prospectData.fullAddress || '';
  document.getElementById('detailAddress').textContent = address || '‚Äî';
  document.getElementById('btnContactDirections').style.display = address ? 'block' : 'none';

  // Social links
  renderSocialLinks(prospectData);

  // === DEAL INFO TAB ===
  populateDealCampaigns();

  // Load existing deal info if present
  const dealInfo = prospectData.dealInfo || {};
  document.getElementById('dealCampaign').value = dealInfo.campaignId || '';
  document.getElementById('dealSpot').value = dealInfo.interestedSpot || '';
  document.getElementById('dealQuotedPrice').value = dealInfo.quotedPrice || '';
  document.getElementById('dealExpectedClose').value = dealInfo.expectedCloseDate || '';
  document.getElementById('dealContactName').value = dealInfo.decisionMaker?.name || '';
  document.getElementById('dealContactRole').value = dealInfo.decisionMaker?.role || '';
  document.getElementById('dealNotes').value = dealInfo.dealNotes || '';

  // === NOTES TAB ===
  document.getElementById('notesBestTime').value = prospectData.bestTimeToContact || '';
  document.getElementById('notesKeyInfo').value = prospectData.keyNotes || '';
  renderTags(prospectData.tags || []);

  // === ACTIVITY TAB ===
  renderCrmActivityTimeline(prospectData.interactions || []);

  // Reset to Activity tab
  switchCrmTab('activity');

  // Update footer buttons based on client vs prospect
  const isClient = source === 'client';
  const btnConvert = document.getElementById('btnCrmConvertToClient');
  const btnEdit = document.getElementById('btnCrmEditClient');
  const btnNotInterested = document.getElementById('btnCrmNotInterested');

  // Use direct style manipulation for reliability
  if (btnConvert) btnConvert.style.display = isClient ? 'none' : 'flex';
  if (btnEdit) btnEdit.style.display = isClient ? 'flex' : 'none';
  if (btnNotInterested) btnNotInterested.style.display = isClient ? 'none' : 'flex';

  // Show modal
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
}

// Calculate contact score based on available information
function calculateContactScore(prospect) {
  let score = 0;
  if (prospect.phone) score += 3;
  if (prospect.email) score += 2;
  if (prospect.website) score += 1;
  if (prospect.facebook || prospect.instagram) score += 1;
  if (prospect.rating && prospect.rating >= 4) score += 1;
  if (prospect.interactions && prospect.interactions.length > 0) score += 2;
  return Math.min(score, 10);
}

// Switch between CRM card tabs
function switchCrmTab(tabName) {
  // Update tab buttons
  document.querySelectorAll('.crm-tab').forEach(btn => {
    const isActive = btn.dataset.crmTab === tabName;
    const isPitchTab = btn.dataset.crmTab === 'pitch';

    // Remove all active states first
    btn.classList.remove('border-indigo-600', 'text-indigo-600', 'border-purple-600', 'text-purple-600', 'bg-white');

    if (isActive) {
      btn.classList.add('bg-white');
      if (isPitchTab) {
        btn.classList.add('border-purple-600', 'text-purple-600');
      } else {
        btn.classList.add('border-indigo-600', 'text-indigo-600');
      }
      btn.classList.remove('border-transparent', 'text-gray-500', 'text-purple-500');
    } else {
      btn.classList.add('border-transparent');
      if (isPitchTab) {
        btn.classList.add('text-purple-500');
      } else {
        btn.classList.add('text-gray-500');
      }
    }
  });

  // Update tab content
  document.querySelectorAll('.crm-tab-content').forEach(content => {
    content.classList.add('hidden');
  });

  const activeContent = document.getElementById(`crmTab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
  if (activeContent) {
    activeContent.classList.remove('hidden');
  }
}

// Render activity timeline with enhanced design
function renderCrmActivityTimeline(interactions) {
  const timeline = document.getElementById('crmActivityTimeline');
  if (!timeline) return;

  if (!interactions || interactions.length === 0) {
    timeline.innerHTML = `
      <div class="text-center py-8 text-gray-400">
        <div class="text-4xl mb-2">üìã</div>
        <p class="font-medium">No activity yet</p>
        <p class="text-sm">Click "+ Add Activity" to log your first interaction</p>
      </div>
    `;
    return;
  }

  // Sort interactions by date (newest first)
  const sorted = [...interactions].sort((a, b) => new Date(b.date) - new Date(a.date));

  // Group by date
  const grouped = {};
  sorted.forEach(interaction => {
    const dateKey = new Date(interaction.date).toLocaleDateString('en-US', {
      year: 'numeric', month: 'long', day: 'numeric'
    });
    if (!grouped[dateKey]) grouped[dateKey] = [];
    grouped[dateKey].push(interaction);
  });

  const typeIcons = {
    call: 'üìû', sms: 'üí¨', email: '‚úâÔ∏è', facebook: 'üìò',
    instagram: 'üì∑', meeting: 'ü§ù', note: 'üìù',
    messenger: 'üìò', 'in-person': 'ü§ù', other: 'üìù'
  };

  const directionLabels = {
    outbound: '‚Üí Outbound',
    inbound: '‚Üê Inbound'
  };

  const outcomeColors = {
    interested: 'bg-green-100 text-green-700',
    callback: 'bg-blue-100 text-blue-700',
    no_answer: 'bg-yellow-100 text-yellow-700',
    voicemail: 'bg-orange-100 text-orange-700',
    not_interested: 'bg-red-100 text-red-700'
  };

  let html = '';
  Object.keys(grouped).forEach(dateKey => {
    const isToday = new Date(dateKey).toDateString() === new Date().toDateString();
    const isYesterday = new Date(dateKey).toDateString() === new Date(Date.now() - 86400000).toDateString();
    const displayDate = isToday ? 'TODAY' : isYesterday ? 'YESTERDAY' : dateKey.toUpperCase();

    html += `<div class="text-xs font-bold text-gray-400 mb-2 mt-4 first:mt-0">${displayDate}</div>`;

    grouped[dateKey].forEach(interaction => {
      const time = new Date(interaction.date).toLocaleTimeString('en-US', {
        hour: 'numeric', minute: '2-digit', hour12: true
      });

      const icon = typeIcons[interaction.type] || 'üìù';
      const typeLabel = (interaction.type || 'note').toUpperCase();
      const direction = interaction.direction ? `<span class="text-xs text-gray-400 ml-2">${directionLabels[interaction.direction] || ''}</span>` : '';

      let outcomeHtml = '';
      if (interaction.outcome) {
        const outcomeLabel = interaction.outcome.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
        const outcomeClass = outcomeColors[interaction.outcome] || 'bg-gray-100 text-gray-700';
        outcomeHtml = `<span class="text-xs px-2 py-0.5 rounded-full ${outcomeClass} ml-2">${outcomeLabel}</span>`;
      }

      let followUpHtml = '';
      if (interaction.followUpDate || interaction.nextFollowUp) {
        const followUpDate = new Date(interaction.followUpDate || interaction.nextFollowUp).toLocaleDateString('en-US', {
          month: 'short', day: 'numeric'
        });
        followUpHtml = `<div class="text-xs text-purple-600 mt-2 flex items-center gap-1">üìÖ Follow-up: ${followUpDate}</div>`;
      }

      html += `
        <div class="bg-white rounded-xl p-4 border border-gray-200 mb-2">
          <div class="flex justify-between items-start mb-2">
            <div class="flex items-center">
              <span class="text-lg mr-2">${icon}</span>
              <span class="font-semibold text-sm text-gray-900">${typeLabel}</span>
              ${direction}
              ${outcomeHtml}
            </div>
            <span class="text-xs text-gray-400">${time}</span>
          </div>
          ${interaction.notes ? `<div class="text-sm text-gray-700">${esc(interaction.notes)}</div>` : ''}
          ${followUpHtml}
        </div>
      `;
    });
  });

  timeline.innerHTML = html;
}

// Render social media links
function renderSocialLinks(prospect) {
  const container = document.getElementById('detailSocialLinks');
  if (!container) return;

  const links = [];

  if (prospect.facebook) {
    links.push({ type: 'Facebook', icon: 'üìò', url: prospect.facebook });
  }
  if (prospect.instagram) {
    links.push({ type: 'Instagram', icon: 'üì∑', url: prospect.instagram });
  }
  if (prospect.linkedin) {
    links.push({ type: 'LinkedIn', icon: 'üíº', url: prospect.linkedin });
  }
  if (prospect.twitter) {
    links.push({ type: 'Twitter', icon: 'üê¶', url: prospect.twitter });
  }

  if (links.length === 0) {
    container.innerHTML = '<span class="text-sm text-gray-400">No social links</span>';
    return;
  }

  container.innerHTML = links.map(link => `
    <a href="${esc(link.url)}" target="_blank" class="flex items-center gap-2 px-3 py-2 bg-gray-100 rounded-lg hover:bg-gray-200 transition text-sm">
      <span>${link.icon}</span>
      <span>${link.type}</span>
    </a>
  `).join('');
}

// Populate campaign dropdown for deal info
function populateDealCampaigns() {
  const select = document.getElementById('dealCampaign');
  if (!select) return;

  select.innerHTML = '<option value="">‚Äî Select Campaign ‚Äî</option>';

  // Get campaigns from campaign boards
  if (campaignBoardsState && campaignBoardsState.boards) {
    Object.keys(campaignBoardsState.boards).forEach(boardId => {
      const board = campaignBoardsState.boards[boardId];
      const option = document.createElement('option');
      option.value = boardId;
      option.textContent = board.name || boardId;
      select.appendChild(option);
    });
  }
}

// Open add activity modal
function openAddActivityForm() {
  const modal = document.getElementById('addActivityModal');
  if (!modal) return;

  // Reset form
  document.querySelectorAll('.activity-type-btn').forEach(btn => {
    btn.classList.remove('border-indigo-500', 'bg-indigo-50');
    btn.classList.add('border-gray-200');
  });

  // Default to 'call' type
  const callBtn = document.querySelector('[data-activity-type="call"]');
  if (callBtn) {
    callBtn.classList.add('border-indigo-500', 'bg-indigo-50');
    callBtn.classList.remove('border-gray-200');
  }
  window.selectedActivityType = 'call';

  // Default to outbound
  selectActivityDirection('outbound');
  window.selectedActivityDirection = 'outbound';

  // Clear other fields
  document.getElementById('activityOutcome').value = '';
  document.getElementById('activityNotes').value = '';
  document.getElementById('activityFollowUp').value = '';

  modal.classList.remove('hidden');
  modal.style.display = 'flex';
}

// Close add activity modal
function closeAddActivityModal() {
  const modal = document.getElementById('addActivityModal');
  if (!modal) return;

  modal.classList.add('hidden');
  modal.style.display = 'none';
}

// Select activity type
function selectActivityType(type) {
  window.selectedActivityType = type;

  document.querySelectorAll('.activity-type-btn').forEach(btn => {
    const isSelected = btn.dataset.activityType === type;
    btn.classList.toggle('border-indigo-500', isSelected);
    btn.classList.toggle('bg-indigo-50', isSelected);
    btn.classList.toggle('border-gray-200', !isSelected);
  });
}

// Select activity direction
function selectActivityDirection(direction) {
  window.selectedActivityDirection = direction;

  document.querySelectorAll('.direction-btn').forEach(btn => {
    const isSelected = btn.dataset.direction === direction;
    btn.classList.toggle('border-indigo-500', isSelected);
    btn.classList.toggle('bg-indigo-50', isSelected);
    btn.classList.toggle('text-indigo-700', isSelected);
    btn.classList.toggle('border-gray-200', !isSelected);
  });
}

// Save new activity
async function saveActivity() {
  if (!currentProspectDetail) {
    toast('No prospect selected', false);
    return;
  }

  const type = window.selectedActivityType || 'note';
  const direction = window.selectedActivityDirection || 'outbound';
  const outcome = document.getElementById('activityOutcome').value || null;
  const notes = document.getElementById('activityNotes').value.trim();
  const followUpDate = document.getElementById('activityFollowUp').value || null;

  const newActivity = {
    id: Date.now().toString(),
    type: type,
    direction: direction,
    outcome: outcome,
    date: new Date().toISOString(),
    notes: notes,
    followUpDate: followUpDate,
    createdAt: new Date().toISOString()
  };

  // Initialize interactions array if needed
  if (!currentProspectDetail.interactions) {
    currentProspectDetail.interactions = [];
  }
  currentProspectDetail.interactions.push(newActivity);

  // Save to appropriate data store
  await saveProspectInteractions(currentProspectDetail, newActivity);

  // Re-render timeline
  renderCrmActivityTimeline(currentProspectDetail.interactions);

  // Close modal
  closeAddActivityModal();

  toast('Activity logged!', true);
}

// Save prospect interactions to the appropriate data store
async function saveProspectInteractions(prospect, newInteraction) {
  const source = prospect.source;
  const prospectId = prospect.id;
  const placeId = prospect.placeId;
  const businessName = prospect.businessName;

  // Save to clients if it's a client
  if (source === 'client') {
    if (crmState.clients[prospectId]) {
      if (!crmState.clients[prospectId].interactions) {
        crmState.clients[prospectId].interactions = [];
      }
      crmState.clients[prospectId].interactions.push(newInteraction);
      await saveClients();
      return;
    }
  }

  // Save to campaign boards
  if (campaignBoardsState && campaignBoardsState.boards) {
    for (const boardId of Object.keys(campaignBoardsState.boards)) {
      const board = campaignBoardsState.boards[boardId];
      if (board.columns) {
        for (const columnKey of Object.keys(board.columns)) {
          const items = board.columns[columnKey];
          const index = items.findIndex(item =>
            item.id === prospectId ||
            (placeId && item.placeId === placeId) ||
            (item.businessName && item.businessName === businessName)
          );
          if (index !== -1) {
            if (!items[index].interactions) items[index].interactions = [];
            items[index].interactions.push(newInteraction);
            await saveCampaignBoards();
            return;
          }
        }
      }
    }
  }

  // Save to legacy kanban
  for (const columnKey of Object.keys(kanbanState.columns)) {
    const items = kanbanState.columns[columnKey];
    const index = items.findIndex(item =>
      typeof item === 'object' && (
        item.id === prospectId ||
        (placeId && item.placeId === placeId) ||
        (item.businessName && item.businessName === businessName)
      )
    );
    if (index !== -1) {
      if (!items[index].interactions) items[index].interactions = [];
      items[index].interactions.push(newInteraction);
      await saveKanban();
      return;
    }
  }

  // Save to manual prospects
  const manualIndex = prospectPoolState.manualProspects.findIndex(p =>
    p.id === prospectId ||
    (placeId && p.placeId === placeId) ||
    (p.businessName && p.businessName === businessName)
  );
  if (manualIndex !== -1) {
    if (!prospectPoolState.manualProspects[manualIndex].interactions) {
      prospectPoolState.manualProspects[manualIndex].interactions = [];
    }
    prospectPoolState.manualProspects[manualIndex].interactions.push(newInteraction);
    saveManualProspects();
  }
}

// Update deal info
async function updateDealInfo() {
  if (!currentProspectDetail) return;

  const dealInfo = {
    campaignId: document.getElementById('dealCampaign').value || null,
    interestedSpot: document.getElementById('dealSpot').value || null,
    quotedPrice: parseFloat(document.getElementById('dealQuotedPrice').value) || null,
    expectedCloseDate: document.getElementById('dealExpectedClose').value || null,
    decisionMaker: {
      name: document.getElementById('dealContactName').value || null,
      role: document.getElementById('dealContactRole').value || null
    },
    dealNotes: document.getElementById('dealNotes').value || null
  };

  currentProspectDetail.dealInfo = dealInfo;
  await saveProspectField(currentProspectDetail, 'dealInfo', dealInfo);
}

// Update notes info
async function updateNotesInfo() {
  if (!currentProspectDetail) return;

  const bestTimeToContact = document.getElementById('notesBestTime').value || null;
  const keyNotes = document.getElementById('notesKeyInfo').value || null;

  currentProspectDetail.bestTimeToContact = bestTimeToContact;
  currentProspectDetail.keyNotes = keyNotes;

  await saveProspectField(currentProspectDetail, 'bestTimeToContact', bestTimeToContact);
  await saveProspectField(currentProspectDetail, 'keyNotes', keyNotes);
}

// Save a single field to prospect data store
async function saveProspectField(prospect, fieldName, value) {
  const source = prospect.source;
  const prospectId = prospect.id;
  const placeId = prospect.placeId;
  const businessName = prospect.businessName;

  // Save to clients
  if (source === 'client' && crmState.clients[prospectId]) {
    crmState.clients[prospectId][fieldName] = value;
    await saveClients();
    return;
  }

  // Save to campaign boards
  if (campaignBoardsState && campaignBoardsState.boards) {
    for (const boardId of Object.keys(campaignBoardsState.boards)) {
      const board = campaignBoardsState.boards[boardId];
      if (board.columns) {
        for (const columnKey of Object.keys(board.columns)) {
          const items = board.columns[columnKey];
          const index = items.findIndex(item =>
            item.id === prospectId ||
            (placeId && item.placeId === placeId) ||
            (item.businessName && item.businessName === businessName)
          );
          if (index !== -1) {
            items[index][fieldName] = value;
            await saveCampaignBoards();
            return;
          }
        }
      }
    }
  }

  // Save to legacy kanban
  for (const columnKey of Object.keys(kanbanState.columns)) {
    const items = kanbanState.columns[columnKey];
    const index = items.findIndex(item =>
      typeof item === 'object' && (
        item.id === prospectId ||
        (placeId && item.placeId === placeId) ||
        (item.businessName && item.businessName === businessName)
      )
    );
    if (index !== -1) {
      items[index][fieldName] = value;
      await saveKanban();
      return;
    }
  }

  // Save to manual prospects
  const manualIndex = prospectPoolState.manualProspects.findIndex(p =>
    p.id === prospectId ||
    (placeId && p.placeId === placeId) ||
    (p.businessName && p.businessName === businessName)
  );
  if (manualIndex !== -1) {
    prospectPoolState.manualProspects[manualIndex][fieldName] = value;
    saveManualProspects();
  }
}

// Render tags
function renderTags(tags) {
  const container = document.getElementById('notesTags');
  if (!container) return;

  if (!tags || tags.length === 0) {
    container.innerHTML = '<span class="text-sm text-gray-400">No tags yet</span>';
    return;
  }

  container.innerHTML = tags.map(tag => `
    <span class="inline-flex items-center gap-1 px-3 py-1 bg-indigo-100 text-indigo-700 rounded-full text-sm">
      ${esc(tag)}
      <button onclick="removeTag('${esc(tag)}')" class="hover:text-red-600 ml-1">&times;</button>
    </span>
  `).join('');
}

// Add a new tag
async function addTag() {
  if (!currentProspectDetail) return;

  const input = document.getElementById('notesNewTag');
  const tag = input.value.trim();

  if (!tag) return;

  if (!currentProspectDetail.tags) {
    currentProspectDetail.tags = [];
  }

  if (!currentProspectDetail.tags.includes(tag)) {
    currentProspectDetail.tags.push(tag);
    await saveProspectField(currentProspectDetail, 'tags', currentProspectDetail.tags);
    renderTags(currentProspectDetail.tags);
  }

  input.value = '';
}

// Remove a tag
async function removeTag(tagToRemove) {
  if (!currentProspectDetail || !currentProspectDetail.tags) return;

  currentProspectDetail.tags = currentProspectDetail.tags.filter(t => t !== tagToRemove);
  await saveProspectField(currentProspectDetail, 'tags', currentProspectDetail.tags);
  renderTags(currentProspectDetail.tags);
}

// Open directions in maps
function openDirections() {
  if (!currentProspectDetail) return;

  const address = currentProspectDetail.address || currentProspectDetail.fullAddress;
  if (!address) {
    toast('No address available', false);
    return;
  }

  const encodedAddress = encodeURIComponent(address);
  window.open(`https://www.google.com/maps/dir/?api=1&destination=${encodedAddress}`, '_blank');
}

// Copy text to clipboard
function copyToClipboard(text) {
  if (!text || text === '‚Äî') {
    toast('Nothing to copy', false);
    return;
  }

  navigator.clipboard.writeText(text).then(() => {
    toast('Copied to clipboard!', true);
  }).catch(() => {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
      toast('Copied to clipboard!', true);
    } catch (e) {
      toast('Failed to copy', false);
    }
    document.body.removeChild(textArea);
  });
}

// Open CRM contact card for a client
function openClientCrmCard(clientId) {
  const client = crmState.clients[clientId];
  if (!client) {
    // Might be a pipeline prospect shown in client list
    const allClients = Object.values(crmState.clients);
    const pipelineClient = allClients.find(c => c.id === clientId);
    if (pipelineClient) {
      openProspectDetailModal(pipelineClient, 'client');
      return;
    }
    toast('Client not found', false);
    return;
  }

  // Convert client data to prospect format for the CRM card
  const prospectData = {
    id: clientId,
    placeId: client.placeId || clientId,
    businessName: client.businessName,
    name: client.businessName,
    category: client.category,
    phone: client.contact?.phone || client.phone,
    email: client.contact?.email || client.email,
    website: client.website,
    facebook: client.facebook,
    instagram: client.instagram,
    linkedin: client.linkedin,
    twitter: client.twitter,
    address: client.address || client.fullAddress,
    fullAddress: client.fullAddress || client.address,
    zipCode: client.zipCode || client.town,
    town: client.town || client.zipCode,
    rating: client.rating,
    reviewsCount: client.reviewCount || client.reviewsCount,
    contactName: client.contact?.name || client.ownerName,
    ownerName: client.ownerName || client.contact?.name,
    interactions: client.interactions || [],
    dealInfo: client.dealInfo || {},
    bestTimeToContact: client.bestTimeToContact,
    keyNotes: client.keyNotes || client.notes,
    tags: client.tags || [],
    status: client.status,
    monthlyPrice: client.monthlyPrice,
    lifetime: client.lifetime,
    history: client.history,
    convertedAt: client.convertedAt
  };

  openProspectDetailModal(prospectData, 'client');
}

// Open edit contact modal (from CRM card)
function openEditContactModal() {
  if (!currentProspectDetail) {
    toast('No contact selected', false);
    return;
  }

  // If it's a client, open the client edit modal
  if (currentProspectDetail.source === 'client') {
    const clientId = currentProspectDetail.id;
    closeProspectDetailModal();
    openClientModal(clientId);
    return;
  }

  // Populate the edit form with current data
  const modal = document.getElementById('editContactModal');
  if (!modal) return;

  document.getElementById('editContactName').value = currentProspectDetail.businessName || currentProspectDetail.name || '';
  document.getElementById('editContactPhone').value = currentProspectDetail.phone || '';
  document.getElementById('editContactEmail').value = currentProspectDetail.email || '';
  document.getElementById('editContactWebsite').value = currentProspectDetail.website || '';
  document.getElementById('editContactAddress').value = currentProspectDetail.address || currentProspectDetail.fullAddress || '';
  document.getElementById('editContactFacebook').value = currentProspectDetail.facebook || '';
  document.getElementById('editContactInstagram').value = currentProspectDetail.instagram || '';

  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
}

function closeEditContactModal() {
  const modal = document.getElementById('editContactModal');
  if (modal) {
    modal.style.display = 'none';
    modal.setAttribute('aria-hidden', 'true');
  }
}

async function saveEditedContact() {
  if (!currentProspectDetail) {
    toast('No contact selected', false);
    return;
  }

  // Get updated values
  const updates = {
    businessName: document.getElementById('editContactName').value.trim(),
    name: document.getElementById('editContactName').value.trim(),
    phone: document.getElementById('editContactPhone').value.trim(),
    email: document.getElementById('editContactEmail').value.trim(),
    website: document.getElementById('editContactWebsite').value.trim(),
    address: document.getElementById('editContactAddress').value.trim(),
    fullAddress: document.getElementById('editContactAddress').value.trim(),
    facebook: document.getElementById('editContactFacebook').value.trim(),
    instagram: document.getElementById('editContactInstagram').value.trim()
  };

  const prospectId = currentProspectDetail.id || currentProspectDetail.placeId;
  let saved = false;

  // 1. Try to find and update in campaign board
  const board = getCurrentCampaignBoard();
  if (board) {
    for (const colKey of Object.keys(board.columns)) {
      const items = board.columns[colKey] || [];
      const idx = items.findIndex(item => {
        const itemId = item.id || item.placeId;
        return String(itemId) === String(prospectId);
      });
      if (idx !== -1) {
        Object.assign(items[idx], updates);
        await saveCampaignBoards();
        saved = true;
        break;
      }
    }
  }

  // 2. Try to find and update in placesCache (search results)
  if (!saved) {
    for (const key of Object.keys(placesCache.searches || {})) {
      const cached = placesCache.searches[key];
      if (cached.cachedData) {
        const idx = cached.cachedData.findIndex(b => String(b.placeId) === String(prospectId));
        if (idx !== -1) {
          Object.assign(cached.cachedData[idx], updates);
          await savePlacesCache();
          saved = true;
          break;
        }
      }
    }
  }

  // 3. Try to find and update in manual prospects
  if (!saved) {
    const idx = prospectPoolState.manualProspects.findIndex(p =>
      String(p.id) === String(prospectId) || String(p.placeId) === String(prospectId)
    );
    if (idx !== -1) {
      Object.assign(prospectPoolState.manualProspects[idx], updates);
      await saveManualProspects();
      saved = true;
    }
  }

  // 4. Also update in renderedProspects lookup (for immediate UI consistency)
  if (prospectPoolState.renderedProspects && prospectPoolState.renderedProspects[prospectId]) {
    Object.assign(prospectPoolState.renderedProspects[prospectId], updates);
  }

  // Update the current prospect detail
  Object.assign(currentProspectDetail, updates);

  // Update the CRM modal display
  document.getElementById('detailBusinessName').textContent = updates.businessName || 'Unknown Business';
  document.getElementById('detailPhone').textContent = updates.phone || '‚Äî';
  document.getElementById('detailEmail').textContent = updates.email || '‚Äî';
  document.getElementById('detailWebsite').textContent = updates.website || '‚Äî';
  document.getElementById('detailAddress').textContent = updates.address || '‚Äî';

  // Update button states
  document.getElementById('btnContactCall').disabled = !updates.phone;
  document.getElementById('btnContactSMS').disabled = !updates.phone;
  document.getElementById('btnContactEmail').disabled = !updates.email;
  document.getElementById('btnContactWebsite').disabled = !updates.website;
  document.getElementById('btnHeaderCall').disabled = !updates.phone;
  document.getElementById('btnHeaderSMS').disabled = !updates.phone;
  document.getElementById('btnHeaderEmail').disabled = !updates.email;
  document.getElementById('btnHeaderWebsite').disabled = !updates.website;

  // Re-render social links
  renderSocialLinks(currentProspectDetail);

  // Re-render the campaign board to show updated info
  renderCampaignBoard();

  // Re-render prospect pool to show updated info
  renderProspectPool();

  closeEditContactModal();
  toast('Contact info updated!', true);
}

// Expose edit contact functions
window.openEditContactModal = openEditContactModal;
window.closeEditContactModal = closeEditContactModal;
window.saveEditedContact = saveEditedContact;

// Mark prospect as not interested (called from CRM card footer)
async function markProspectNotInterested() {
  if (!currentProspectDetail) {
    toast('No prospect selected', false);
    return;
  }

  const placeId = currentProspectDetail.placeId || currentProspectDetail.id;
  const businessName = currentProspectDetail.businessName || currentProspectDetail.name;

  const confirmed = confirm(`Mark "${businessName}" as Not Interested?\n\nThis business will be removed from your prospect lists.`);
  if (!confirmed) return;

  // Add to Not Interested list
  if (!notInterestedState.placeIds) notInterestedState.placeIds = new Set();
  if (!notInterestedState.businesses) notInterestedState.businesses = {};

  notInterestedState.placeIds.add(placeId);
  notInterestedState.businesses[placeId] = {
    businessName,
    placeId: placeId,
    dateMarked: new Date().toISOString(),
    reason: 'User marked as not interested from CRM card'
  };

  // Save to cloud/local
  await saveNotInterestedList();

  // Remove from campaign boards if present
  if (campaignBoardsState && campaignBoardsState.boards) {
    for (const boardId of Object.keys(campaignBoardsState.boards)) {
      const board = campaignBoardsState.boards[boardId];
      if (board.columns) {
        for (const columnKey of Object.keys(board.columns)) {
          const items = board.columns[columnKey];
          const index = items.findIndex(item =>
            item.placeId === placeId || item.id === placeId
          );
          if (index !== -1) {
            items.splice(index, 1);
          }
        }
      }
    }
    await saveCampaignBoards();
  }

  // Close modal and refresh
  closeProspectDetailModal();
  toast(`"${businessName}" marked as not interested`, true);

  // Refresh displays
  if (typeof renderCampaignBoards === 'function') renderCampaignBoards();
  renderKanban();
  if (typeof renderProspectPool === 'function') renderProspectPool();
}

// Convert prospect to client (called from CRM card footer)
async function convertToClient() {
  if (!currentProspectDetail) {
    toast('No prospect selected', false);
    return;
  }

  const businessName = currentProspectDetail.businessName || currentProspectDetail.name;
  const prospectId = currentProspectDetail.id;
  const placeId = currentProspectDetail.placeId;

  const confirmed = confirm(`Convert "${businessName}" to a Client?\n\nThis will move them to your Clients list.`);
  if (!confirmed) return;

  // Create client record
  const clientId = placeId || prospectId || Date.now().toString();
  const clientData = {
    ...currentProspectDetail,
    id: clientId,
    convertedAt: new Date().toISOString(),
    status: 'active'
  };

  // Remove source field as it's no longer a prospect
  delete clientData.source;

  // Add to clients
  crmState.clients[clientId] = clientData;
  await saveClients();

  // Remove from campaign boards if present
  if (campaignBoardsState && campaignBoardsState.boards) {
    for (const boardId of Object.keys(campaignBoardsState.boards)) {
      const board = campaignBoardsState.boards[boardId];
      if (board.columns) {
        for (const columnKey of Object.keys(board.columns)) {
          const items = board.columns[columnKey];
          const index = items.findIndex(item =>
            item.placeId === placeId || item.id === prospectId
          );
          if (index !== -1) {
            items.splice(index, 1);
          }
        }
      }
    }
    await saveCampaignBoards();
  }

  // Close modal
  closeProspectDetailModal();
  toast(`"${businessName}" converted to Client!`, true);

  // Refresh displays
  if (typeof renderCampaignBoards === 'function') renderCampaignBoards();
  renderKanban();
  if (typeof renderClientList === 'function') renderClientList();
  if (typeof renderDashboardStats === 'function') renderDashboardStats();
}

// Update prospect category when changed in detail modal
async function updateProspectCategory(newCategory) {
  if (!currentProspectDetail) return;

  const prospectId = currentProspectDetail.id;
  const placeId = currentProspectDetail.placeId;
  const businessName = currentProspectDetail.businessName || currentProspectDetail.name;
  const source = currentProspectDetail.source;

  console.log('üìù Updating category for:', businessName, 'to:', newCategory, 'source:', source);

  // Update in currentProspectDetail
  currentProspectDetail.category = newCategory;

  let updated = false;

  // Update in kanban (all columns)
  if (source === 'kanban') {
    Object.keys(kanbanState.columns).forEach(columnKey => {
      const items = kanbanState.columns[columnKey];
      const index = items.findIndex(item =>
        typeof item === 'object' && (
          item.id === prospectId ||
          (placeId && item.placeId === placeId) ||
          (item.businessName && item.businessName === businessName)
        )
      );
      if (index !== -1) {
        kanbanState.columns[columnKey][index].category = newCategory;
        updated = true;
        console.log('‚úÖ Updated category in kanban column:', columnKey);
      }
    });

    if (updated) {
      await saveKanban();
      renderKanban();
    }
  }

  // Update in prospect pool (manual prospects)
  const manualIndex = prospectPoolState.manualProspects.findIndex(p =>
    p.id === prospectId ||
    (placeId && p.placeId === placeId) ||
    (p.businessName && p.businessName === businessName)
  );

  if (manualIndex !== -1) {
    prospectPoolState.manualProspects[manualIndex].category = newCategory;
    saveManualProspects();
    updated = true;
    console.log('‚úÖ Updated category in manual prospects');
  }

  // Update in places cache (search results)
  if (placeId) {
    let foundInCache = false;
    Object.keys(placesCache.searches).forEach(searchKey => {
      const search = placesCache.searches[searchKey];
      if (search && search.results) {
        Object.keys(search.results).forEach(category => {
          const categoryResults = search.results[category];
          if (Array.isArray(categoryResults)) {
            const index = categoryResults.findIndex(p => p.placeId === placeId);
            if (index !== -1) {
              categoryResults[index].category = newCategory;
              foundInCache = true;
            }
          }
        });
      }
    });

    if (foundInCache) {
      savePlacesCache();
      updated = true;
      console.log('‚úÖ Updated category in places cache');
    }
  }

  // Update in clients (clients is an object, not array)
  let clientKey = null;
  Object.keys(crmState.clients).forEach(key => {
    const c = crmState.clients[key];
    if (c.id === prospectId ||
        (placeId && c.placeId === placeId) ||
        (c.businessName && c.businessName === businessName)) {
      clientKey = key;
    }
  });

  if (clientKey) {
    crmState.clients[clientKey].category = newCategory;
    await saveClients();
    renderClientList();
    updated = true;
    console.log('‚úÖ Updated category in clients');
  }

  if (updated) {
    // Re-render prospect pool to show updated category
    if (source === 'prospect') {
      renderProspectPool();
    }

    // Get category label for display
    const categoryObj = businessCategories.find(c => c.value === newCategory);
    const categoryLabel = categoryObj ? categoryObj.label : newCategory;

    toast(`‚úÖ Category updated to "${categoryLabel}"`, true);
  } else {
    console.warn('‚ö†Ô∏è Could not find prospect to update category');
  }
}

function populateQuickSendTemplates() {
  const selector = document.getElementById('quickSendTemplateSelector');
  if (!selector) return;

  // Get all templates
  const allTemplates = Object.values(userTemplatesState.templates);

  // Build options HTML
  let optionsHTML = '<option value="">-- Choose a template --</option>';

  // Group by category
  const categories = {
    prospect: 'üéØ Prospect Templates',
    client: 'üë• Client Templates',
    followup: 'üîÑ Follow-up Templates'
  };

  Object.keys(categories).forEach(category => {
    const templates = allTemplates.filter(t => t.category === category);
    if (templates.length > 0) {
      optionsHTML += `<optgroup label="${categories[category]}">`;
      templates.forEach(t => {
        const icon = t.type === 'email' ? 'üìß' : t.type === 'sms' ? 'üì±' : t.type === 'messenger' ? 'üìò' : 'üì∑';
        optionsHTML += `<option value="${t.id}">${icon} ${esc(t.name)}</option>`;
      });
      optionsHTML += '</optgroup>';
    }
  });

  selector.innerHTML = optionsHTML;

  // Reset preview and disable buttons
  document.getElementById('quickSendPreview').classList.add('hidden');
  document.getElementById('btnQuickSendSMS').disabled = true;
  document.getElementById('btnQuickSendEmail').disabled = true;
}

let currentQuickSendTemplate = null;

function previewQuickSendTemplate() {
  const selector = document.getElementById('quickSendTemplateSelector');
  const templateId = selector.value;

  if (!templateId) {
    document.getElementById('quickSendPreview').classList.add('hidden');
    document.getElementById('btnQuickSendSMS').disabled = true;
    document.getElementById('btnQuickSendEmail').disabled = true;
    currentQuickSendTemplate = null;
    return;
  }

  const template = userTemplatesState.templates[templateId];
  if (!template) return;

  currentQuickSendTemplate = template;

  // Prepare data from current prospect
  const data = {
    businessName: currentProspectDetail.businessName || currentProspectDetail.name || 'Business',
    contactName: currentProspectDetail.contactName || '',
    phone: currentProspectDetail.phone || '',
    email: currentProspectDetail.email || '',
    town: currentProspectDetail.town || currentProspectDetail.zipCode || '',
    zipCode: currentProspectDetail.zipCode || '',
    campaign: '',
    amount: '',
    date: new Date().toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' })
  };

  // Fill template variables
  const filled = fillTemplateVariables(template, data);

  // Show preview
  const previewSubject = document.getElementById('quickSendPreviewSubject');
  const previewBody = document.getElementById('quickSendPreviewBody');

  if (filled.subject) {
    previewSubject.textContent = `Subject: ${filled.subject}`;
    previewSubject.style.display = 'block';
  } else {
    previewSubject.style.display = 'none';
  }

  previewBody.textContent = filled.body;
  document.getElementById('quickSendPreview').classList.remove('hidden');

  // Enable appropriate buttons based on template type and available contact info
  const hasSMS = currentProspectDetail.phone && (template.type === 'sms' || template.type === 'messenger' || template.type === 'instagram');
  const hasEmail = currentProspectDetail.email && template.type === 'email';

  document.getElementById('btnQuickSendSMS').disabled = !hasSMS;
  document.getElementById('btnQuickSendEmail').disabled = !hasEmail;
}

async function quickSendWithTemplate(sendType) {
  if (!currentQuickSendTemplate || !currentProspectDetail) return;

  // Prepare data
  const data = {
    businessName: currentProspectDetail.businessName || currentProspectDetail.name || 'Business',
    contactName: currentProspectDetail.contactName || '',
    phone: currentProspectDetail.phone || '',
    email: currentProspectDetail.email || '',
    town: currentProspectDetail.town || currentProspectDetail.zipCode || '',
    zipCode: currentProspectDetail.zipCode || '',
    campaign: '',
    amount: '',
    date: new Date().toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' })
  };

  const filled = fillTemplateVariables(currentQuickSendTemplate, data);

  if (sendType === 'sms') {
    // Open SMS app with message
    if (!currentProspectDetail.phone) {
      toast('‚ö†Ô∏è No phone number available', false);
      return;
    }

    const cleanPhone = currentProspectDetail.phone.replace(/\D/g, '');

    // Always use Google Voice for consistency across all devices
    navigator.clipboard.writeText(filled.body).then(() => {
      window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
      toast('üìã Message copied! Google Voice opened', true);
    }).catch(() => {
      window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
      toast('üì± Google Voice opened', true);
    });

    // Auto-log interaction
    await logQuickSendInteraction('sms', currentQuickSendTemplate.name);

  } else if (sendType === 'email') {
    // Open email client
    if (!currentProspectDetail.email) {
      toast('‚ö†Ô∏è No email address available', false);
      return;
    }

    const mailtoLink = `mailto:${currentProspectDetail.email}?subject=${encodeURIComponent(filled.subject)}&body=${encodeURIComponent(filled.body)}`;
    window.location.href = mailtoLink;

    // Auto-log interaction
    await logQuickSendInteraction('email', currentQuickSendTemplate.name);
  }

  toast(`‚úÖ Opening ${sendType === 'sms' ? 'SMS' : 'Email'} app...`, true);
}

async function logQuickSendInteraction(type, templateName) {
  if (!currentProspectDetail) return;

  const newInteraction = {
    type: type,
    date: new Date().toISOString(),
    notes: `Sent ${type === 'sms' ? 'SMS' : 'Email'} - Template: ${templateName}`,
    nextFollowUp: null
  };

  // If this is a client, save to client database
  if (currentProspectDetail.source === 'client') {
    const clientId = currentProspectDetail.id;
    if (crmState.clients[clientId]) {
      if (!crmState.clients[clientId].interactions) crmState.clients[clientId].interactions = [];
      crmState.clients[clientId].interactions.push(newInteraction);
      saveClients();
    }
  } else {
    // If prospect is in kanban, save to kanban
    let foundInKanban = false;
    Object.keys(kanbanState.columns).forEach(columnKey => {
      kanbanState.columns[columnKey].forEach(prospect => {
        if (prospect.id === currentProspectDetail.id || prospect.placeId === currentProspectDetail.placeId) {
          if (!prospect.interactions) prospect.interactions = [];
          prospect.interactions.push(newInteraction);
          foundInKanban = true;
        }
      });
    });
    if (foundInKanban) {
      saveKanban();
    }
  }

  // Update current prospect detail and re-render timeline
  if (!currentProspectDetail.interactions) currentProspectDetail.interactions = [];
  currentProspectDetail.interactions.push(newInteraction);
  renderInteractionTimeline(currentProspectDetail.interactions);

  // Update last used timestamp on template
  if (currentQuickSendTemplate) {
    currentQuickSendTemplate.lastUsed = new Date().toISOString();
    saveUserTemplates();
  }

  console.log('‚úÖ Interaction logged:', newInteraction);
}

function closeProspectDetailModal() {
  const modal = document.getElementById('prospectDetailModal');
  if (!modal) return;

  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
  currentProspectDetail = null;
}

// SMS/Email Templates for Prospect Outreach
const prospectSMSTemplates = {
  intro: "Hi! I'm reaching out from 9x12 Pro to help grow your business with targeted direct mail campaigns. Would you be interested in learning how we can help you reach more customers?",
  'follow-up': "Just following up on my previous message. I'd love to show you how 9x12 Pro can help grow your customer base. Do you have 10 minutes this week to chat?"
};

const prospectEmailTemplates = {
  intro: {
    subject: "Grow Your Business with Targeted Direct Mail",
    body: "Hi,\n\nI hope this email finds you well. I'm reaching out because I believe 9x12 Pro can help you reach more potential customers in your area.\n\nWe specialize in targeted direct mail campaigns that get results. Our clients typically see a significant increase in customer inquiries and sales.\n\nWould you be interested in a quick 15-minute call to discuss how we can help your business grow?\n\nBest regards"
  },
  'follow-up': {
    subject: "Following Up - Direct Mail Opportunity",
    body: "Hi,\n\nI wanted to follow up on my previous message about our direct mail services at 9x12 Pro.\n\nMany businesses in your area have seen great results with our campaigns. I'd love to share some success stories and discuss how we can help you reach new customers.\n\nDo you have time this week for a brief conversation?\n\nBest regards"
  },
  'special-offer': {
    subject: "Special Offer - Limited Time Direct Mail Promotion",
    body: "Hi,\n\nI have exciting news! We're currently running a special promotion for new clients.\n\nFor a limited time, we're offering a discount on your first direct mail campaign with 9x12 Pro. This is a great opportunity to test our services and see real results.\n\nWould you like to learn more about this exclusive offer?\n\nBest regards"
  }
};

// Global variable to track which business we're sending to
let currentSMSBusinessId = null;
let currentEmailBusinessId = null;

function openSendSMSModal(leadId, event) {
  if (event) {
    event.stopPropagation();
  }

  // Find the business in column 2
  const business = (kanbanState.columns['to-contact'] || []).find(item => {
    return typeof item === 'object' && item.id === leadId;
  });

  if (!business) {
    showError('Business not found');
    return;
  }

  currentSMSBusinessId = leadId;

  // Populate modal
  const businessName = business.businessName || business.name || 'Unknown Business';
  const phone = business.phone || 'No phone on file';
  document.getElementById('smsBusinessName').textContent = businessName;
  document.getElementById('smsPhoneNumber').textContent = phone;

  // Reset form
  document.getElementById('smsTemplate').value = '';
  document.getElementById('smsMessage').value = '';
  updateSMSCharCount();

  // Show modal
  const modal = document.getElementById('sendSMSModal');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
}

function closeSendSMSModal() {
  const modal = document.getElementById('sendSMSModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
  currentSMSBusinessId = null;
}

function loadSMSTemplate() {
  const templateSelect = document.getElementById('smsTemplate');
  const messageArea = document.getElementById('smsMessage');
  const templateValue = templateSelect.value;

  if (templateValue && templateValue !== 'custom') {
    messageArea.value = prospectSMSTemplates[templateValue] || '';
  } else if (templateValue === 'custom') {
    messageArea.value = '';
  }

  updateSMSCharCount();
}

function updateSMSCharCount() {
  const message = document.getElementById('smsMessage').value;
  const charCount = document.getElementById('smsCharCount');
  charCount.textContent = message.length;

  // Change color if approaching limit
  if (message.length > 160) {
    charCount.parentElement.classList.add('text-red-600');
    charCount.parentElement.classList.remove('text-gray-500');
  } else {
    charCount.parentElement.classList.add('text-gray-500');
    charCount.parentElement.classList.remove('text-red-600');
  }
}

function sendSMSMessage() {
  const message = document.getElementById('smsMessage').value.trim();

  if (!message) {
    showWarning('Please enter a message');
    return;
  }

  if (!currentSMSBusinessId) {
    showWarning('No business selected');
    return;
  }

  // Find the business
  const business = (kanbanState.columns['to-contact'] || []).find(item => {
    return typeof item === 'object' && item.id === currentSMSBusinessId;
  });

  if (!business) {
    showError('Business not found');
    return;
  }

  const phone = business.phone || '';

  if (!phone) {
    showWarning('This business does not have a phone number on file');
    return;
  }

  const cleanPhone = phone.replace(/\D/g, ''); // Remove non-digits

  // Always use Google Voice for consistency across all devices
  navigator.clipboard.writeText(message).then(() => {
    window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
    showSuccess(`üìã Message copied! Google Voice opened for: ${phone}`);
  }).catch(() => {
    window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
    showInfo(`Google Voice opened. Send to: ${phone}`);
  });

  // Log this interaction
  if (!business.interactions) {
    business.interactions = [];
  }

  business.interactions.push({
    date: new Date().toISOString(),
    type: 'sms',
    notes: `SMS sent: ${message.substring(0, 50)}${message.length > 50 ? '...' : ''}`
  });

  // Save to storage
  saveKanbanStateToStorage();

  closeSendSMSModal();
}

function openSendEmailModal(leadId, event) {
  if (event) {
    event.stopPropagation();
  }

  // Find the business in column 2
  const business = (kanbanState.columns['to-contact'] || []).find(item => {
    return typeof item === 'object' && item.id === leadId;
  });

  if (!business) {
    showError('Business not found');
    return;
  }

  currentEmailBusinessId = leadId;

  // Populate modal
  const businessName = business.businessName || business.name || 'Unknown Business';
  document.getElementById('emailBusinessName').textContent = businessName;

  const email = business.email || '';
  document.getElementById('emailAddress').textContent = email || 'No email on file';

  // Reset form
  document.getElementById('emailTemplate').value = '';
  document.getElementById('emailSubject').value = '';
  document.getElementById('emailMessage').value = '';

  // Show modal
  const modal = document.getElementById('sendEmailModal');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
}

function closeSendEmailModal() {
  const modal = document.getElementById('sendEmailModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
  currentEmailBusinessId = null;
}

function loadProspectEmailTemplate(source) {
  // Support both original emailTemplate and renamed emailTemplatePipeline
  const templateSelect = document.getElementById(source === 'pipeline' ? 'emailTemplatePipeline' : 'emailTemplate');
  const subjectInput = document.getElementById('emailSubject');
  const messageArea = document.getElementById('emailMessage');
  if (!templateSelect) return;
  const templateValue = templateSelect.value;

  if (templateValue && templateValue !== 'custom') {
    const template = prospectEmailTemplates[templateValue];
    if (template) {
      subjectInput.value = template.subject;
      messageArea.value = template.body;
    }
  } else if (templateValue === 'custom') {
    subjectInput.value = '';
    messageArea.value = '';
  }
}

function sendEmailMessage() {
  const subject = document.getElementById('emailSubject').value.trim();
  const message = document.getElementById('emailMessage').value.trim();

  if (!subject) {
    showWarning('Please enter a subject');
    return;
  }

  if (!message) {
    showWarning('Please enter a message');
    return;
  }

  if (!currentEmailBusinessId) {
    showWarning('No business selected');
    return;
  }

  // Find the business
  const business = (kanbanState.columns['to-contact'] || []).find(item => {
    return typeof item === 'object' && item.id === currentEmailBusinessId;
  });

  if (!business) {
    showError('Business not found');
    return;
  }

  const email = business.email || '';

  if (!email) {
    showWarning('This business does not have an email address on file');
    return;
  }

  // Log this interaction
  if (!business.interactions) {
    business.interactions = [];
  }

  business.interactions.push({
    date: new Date().toISOString(),
    type: 'email',
    notes: `Email sent: ${subject}`
  });

  // Save to storage
  saveKanbanStateToStorage();

  // Open mailto link
  const mailtoUrl = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(message)}`;
  window.location.href = mailtoUrl;

  closeSendEmailModal();
}

// Client Database SMS/Email Functions
function openClientSMS(clientId) {
  const client = crmState.clients[clientId];
  if (!client) {
    toast('Client not found', false);
    return;
  }

  if (!client.contact || !client.contact.phone) {
    toast('This client does not have a phone number on file', false);
    return;
  }

  // Show inline template picker
  showQuickTemplatePickerForClient(clientId, 'sms');
}

function openClientEmail(clientId) {
  const client = crmState.clients[clientId];
  if (!client) {
    toast('Client not found', false);
    return;
  }

  if (!client.contact || !client.contact.email) {
    toast('This client does not have an email address on file', false);
    return;
  }

  // Show inline template picker
  showQuickTemplatePickerForClient(clientId, 'email');
}

// Quick Template Picker for Client Cards
function showQuickTemplatePickerForClient(clientId, sendType) {
  const client = crmState.clients[clientId];
  if (!client) return;

  // Get all templates matching the send type
  const allTemplates = Object.values(userTemplatesState.templates);
  const matchingTemplates = allTemplates.filter(t => {
    if (sendType === 'sms') {
      return t.type === 'sms' || t.type === 'messenger' || t.type === 'instagram';
    } else if (sendType === 'email') {
      return t.type === 'email';
    }
    return false;
  });

  if (matchingTemplates.length === 0) {
    toast(`No ${sendType.toUpperCase()} templates found. Create one in Settings ‚Üí Message Templates.`, false);
    return;
  }

  // Build template options HTML
  const templateOptions = matchingTemplates.map(t => {
    const icon = t.type === 'email' ? 'üìß' : t.type === 'sms' ? 'üì±' : t.type === 'messenger' ? 'üìò' : 'üì∑';
    const categoryLabel = t.category === 'prospect' ? 'üéØ' : t.category === 'client' ? 'üë•' : 'üîÑ';
    return `<option value="${t.id}">${icon} ${categoryLabel} ${esc(t.name)}</option>`;
  }).join('');

  // Create modal HTML
  const modalHTML = `
    <div id="quickTemplatePicker" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onclick="if(event.target.id==='quickTemplatePicker') closeQuickTemplatePicker()">
      <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="border-b border-gray-200 px-6 py-4 flex justify-between items-center sticky top-0 bg-white">
          <h3 class="text-lg font-semibold text-gray-900">
            ${sendType === 'sms' ? 'üì± Send SMS' : '‚úâÔ∏è Send Email'} - ${esc(client.businessName)}
          </h3>
          <button onclick="closeQuickTemplatePicker()" class="text-gray-400 hover:text-gray-600 text-2xl leading-none">&times;</button>
        </div>
        <div class="px-6 py-4 space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Select Template:</label>
            <select id="quickTemplateSelect" class="w-full border border-gray-300 rounded-md p-2 text-sm" onchange="previewQuickTemplate('${clientId}', '${sendType}')">
              <option value="">-- Choose a template --</option>
              ${templateOptions}
            </select>
          </div>
          <div id="quickTemplatePreview" class="hidden">
            <div class="flex justify-between items-center mb-2">
              <label class="block text-sm font-medium text-gray-700">Preview:</label>
              <button id="btnEditTemplate" onclick="toggleTemplateEdit()" class="text-xs px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 font-medium">
                ‚úèÔ∏è Edit Message
              </button>
            </div>

            <!-- Read-only preview -->
            <div id="templateReadOnlyView" class="bg-gray-50 border border-gray-200 rounded-lg p-4">
              <div id="quickTemplatePreviewSubject" class="font-semibold text-gray-900 mb-2"></div>
              <pre id="quickTemplatePreviewBody" class="text-sm text-gray-700 whitespace-pre-wrap font-sans max-h-64 overflow-y-auto"></pre>
            </div>

            <!-- Editable view (hidden by default) -->
            <div id="templateEditView" class="hidden space-y-3">
              <div id="editSubjectContainer" class="hidden">
                <label class="block text-xs font-medium text-gray-700 mb-1">Subject:</label>
                <input id="editTemplateSubject" type="text" class="w-full border border-gray-300 rounded-md p-2 text-sm" placeholder="Email subject...">
              </div>
              <div>
                <label class="block text-xs font-medium text-gray-700 mb-1">Message:</label>
                <textarea id="editTemplateBody" rows="8" class="w-full border border-gray-300 rounded-md p-2 text-sm font-sans" placeholder="Message body..."></textarea>
              </div>
              <div class="flex gap-2">
                <button onclick="saveTemplateEdits()" class="flex-1 px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 text-sm font-medium">
                  ‚úì Save Edits
                </button>
                <button onclick="cancelTemplateEdits()" class="flex-1 px-3 py-2 bg-gray-400 text-white rounded-md hover:bg-gray-500 text-sm font-medium">
                  ‚úï Cancel
                </button>
              </div>
            </div>
          </div>
          <div class="flex gap-3 pt-4">
            <button onclick="closeQuickTemplatePicker()" class="flex-1 px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 font-medium">
              Cancel
            </button>
            <button id="btnSendQuickTemplate" onclick="sendQuickTemplateFromPicker('${clientId}', '${sendType}')" class="flex-1 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 font-medium disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
              ${sendType === 'sms' ? 'üì± Send SMS' : '‚úâÔ∏è Send Email'}
            </button>
          </div>
        </div>
      </div>
    </div>
  `;

  // Insert modal into page
  const existingModal = document.getElementById('quickTemplatePicker');
  if (existingModal) existingModal.remove();
  document.body.insertAdjacentHTML('beforeend', modalHTML);

  // Store current client ID
  window.currentQuickTemplateClientId = clientId;
  window.currentQuickTemplateSendType = sendType;
}

function previewQuickTemplate(clientId, sendType) {
  const templateId = document.getElementById('quickTemplateSelect').value;
  const previewContainer = document.getElementById('quickTemplatePreview');
  const sendButton = document.getElementById('btnSendQuickTemplate');

  if (!templateId) {
    previewContainer.classList.add('hidden');
    sendButton.disabled = true;
    return;
  }

  const template = userTemplatesState.templates[templateId];
  const client = crmState.clients[clientId];

  if (!template || !client) {
    previewContainer.classList.add('hidden');
    sendButton.disabled = true;
    return;
  }

  // Prepare data with EXPANDED fields
  const data = {
    // Business info
    businessName: client.businessName || '',
    name: client.businessName || '',

    // Contact person info
    contactName: client.contact?.name || client.ownerName || '',
    firstName: client.contact?.firstName || (client.contact?.name?.split(' ')[0]) || '',
    lastName: client.contact?.lastName || (client.contact?.name?.split(' ').slice(1).join(' ')) || '',
    ownerName: client.ownerName || client.contact?.name || '',

    // Business details
    industry: client.industry || client.category || '',
    category: client.category || client.industry || '',
    website: client.website || '',
    phone: client.contact?.phone || client.phone || '',
    email: client.contact?.email || client.email || '',

    // Location
    address: client.address || '',
    city: client.city || client.town || '',
    town: client.town || client.city || '',
    state: client.state || '',
    zipCode: client.zipCode || '',
    zip: client.zipCode || '',

    // Pricing
    price: client.pricing?.finalPrice ? `$${client.pricing.finalPrice}` : '',
    amount: client.pricing?.finalPrice ? `$${client.pricing.finalPrice}` : '',
    discount: client.pricing?.discount || '',

    // Campaign info
    campaign: state.current?.mailerName || '',

    // User info (from Sales Toolkit settings)
    yourName: salesToolkitSettings.yourName || '',
    yourPhone: salesToolkitSettings.yourPhone || '',
    yourEmail: salesToolkitSettings.yourEmail || '',
    yourCompany: salesToolkitSettings.yourCompany || '',
    yourWebsite: salesToolkitSettings.yourWebsite || '',

    // Date
    date: new Date().toLocaleDateString()
  };

  const filled = fillTemplateVariables(template, data);

  // Detect missing variables
  const missingVars = detectMissingVariables(filled.subject + ' ' + filled.body);

  // Show preview
  const previewSubject = document.getElementById('quickTemplatePreviewSubject');
  const previewBody = document.getElementById('quickTemplatePreviewBody');

  if (template.type === 'email' && filled.subject) {
    previewSubject.textContent = filled.subject;
    previewSubject.style.display = 'block';
  } else {
    previewSubject.style.display = 'none';
  }

  previewBody.textContent = filled.body;

  // Show warning if there are missing variables
  let warningDiv = document.getElementById('templateWarning');
  if (missingVars.length > 0) {
    if (!warningDiv) {
      warningDiv = document.createElement('div');
      warningDiv.id = 'templateWarning';
      previewContainer.insertBefore(warningDiv, previewContainer.firstChild);
    }
    warningDiv.className = 'bg-yellow-50 border border-yellow-300 rounded-md p-3 mb-3';
    warningDiv.innerHTML = `
      <div class="flex items-start gap-2">
        <span class="text-yellow-600 text-lg">‚ö†Ô∏è</span>
        <div class="flex-1">
          <div class="font-semibold text-yellow-900 text-sm">Missing Information</div>
          <div class="text-yellow-800 text-xs mt-1">
            The following variables are not filled: <strong>${missingVars.join(', ')}</strong>
            <br>Please review the message carefully before sending.
          </div>
        </div>
      </div>
    `;
    sendButton.textContent = `‚ö†Ô∏è Send Anyway (${missingVars.length} missing)`;
    sendButton.className = 'flex-1 px-4 py-2 bg-yellow-600 text-white rounded-md hover:bg-yellow-700 font-medium';
  } else {
    if (warningDiv) warningDiv.remove();
    sendButton.textContent = sendType === 'sms' ? 'üì± Send SMS' : '‚úâÔ∏è Send Email';
    sendButton.className = 'flex-1 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 font-medium';
  }

  previewContainer.classList.remove('hidden');
  sendButton.disabled = false;

  // Store selected template and data for editing
  window.currentQuickTemplateSelected = template;
  window.currentQuickTemplateData = data;
  window.currentQuickTemplateFilled = filled;
}

// Toggle between read-only preview and editable mode
function toggleTemplateEdit() {
  const readOnlyView = document.getElementById('templateReadOnlyView');
  const editView = document.getElementById('templateEditView');
  const editButton = document.getElementById('btnEditTemplate');
  const editSubject = document.getElementById('editTemplateSubject');
  const editBody = document.getElementById('editTemplateBody');
  const subjectContainer = document.getElementById('editSubjectContainer');

  if (!window.currentQuickTemplateFilled) return;

  const sendType = window.currentQuickTemplateSendType;

  // Show edit view
  readOnlyView.classList.add('hidden');
  editView.classList.remove('hidden');
  editButton.classList.add('hidden');

  // Populate edit fields
  if (sendType === 'email' && window.currentQuickTemplateFilled.subject) {
    subjectContainer.classList.remove('hidden');
    editSubject.value = window.currentQuickTemplateFilled.subject;
  } else {
    subjectContainer.classList.add('hidden');
  }
  editBody.value = window.currentQuickTemplateFilled.body;

  // Focus on body
  editBody.focus();
}

// Save edits to the template
function saveTemplateEdits() {
  const editSubject = document.getElementById('editTemplateSubject');
  const editBody = document.getElementById('editTemplateBody');
  const sendType = window.currentQuickTemplateSendType;

  if (!editBody.value.trim()) {
    toast('Message cannot be empty', false);
    return;
  }

  // Update the filled template with edited content
  window.currentQuickTemplateFilled = {
    subject: sendType === 'email' ? editSubject.value : '',
    body: editBody.value
  };

  // Update read-only preview
  const previewSubject = document.getElementById('quickTemplatePreviewSubject');
  const previewBody = document.getElementById('quickTemplatePreviewBody');

  if (sendType === 'email' && editSubject.value) {
    previewSubject.textContent = editSubject.value;
    previewSubject.style.display = 'block';
  } else {
    previewSubject.style.display = 'none';
  }
  previewBody.textContent = editBody.value;

  // Check for missing variables after editing
  const missingVars = detectMissingVariables(editSubject.value + ' ' + editBody.value);
  const sendButton = document.getElementById('btnSendQuickTemplate');
  let warningDiv = document.getElementById('templateWarning');

  if (missingVars.length > 0) {
    if (!warningDiv) {
      warningDiv = document.createElement('div');
      warningDiv.id = 'templateWarning';
      const previewContainer = document.getElementById('quickTemplatePreview');
      previewContainer.insertBefore(warningDiv, previewContainer.firstChild);
    }
    warningDiv.className = 'bg-yellow-50 border border-yellow-300 rounded-md p-3 mb-3';
    warningDiv.innerHTML = `
      <div class="flex items-start gap-2">
        <span class="text-yellow-600 text-lg">‚ö†Ô∏è</span>
        <div class="flex-1">
          <div class="font-semibold text-yellow-900 text-sm">Missing Information</div>
          <div class="text-yellow-800 text-xs mt-1">
            The following variables are not filled: <strong>${missingVars.join(', ')}</strong>
            <br>Please review the message carefully before sending.
          </div>
        </div>
      </div>
    `;
    sendButton.textContent = `‚ö†Ô∏è Send Anyway (${missingVars.length} missing)`;
    sendButton.className = 'flex-1 px-4 py-2 bg-yellow-600 text-white rounded-md hover:bg-yellow-700 font-medium';
  } else {
    if (warningDiv) warningDiv.remove();
    sendButton.textContent = sendType === 'sms' ? 'üì± Send SMS' : '‚úâÔ∏è Send Email';
    sendButton.className = 'flex-1 px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 font-medium';
  }

  // Switch back to read-only view
  cancelTemplateEdits();

  toast('‚úì Message updated', true);
}

// Cancel editing and return to read-only view
function cancelTemplateEdits() {
  const readOnlyView = document.getElementById('templateReadOnlyView');
  const editView = document.getElementById('templateEditView');
  const editButton = document.getElementById('btnEditTemplate');

  editView.classList.add('hidden');
  readOnlyView.classList.remove('hidden');
  editButton.classList.remove('hidden');
}

async function sendQuickTemplateFromPicker(clientId, sendType) {
  const template = window.currentQuickTemplateSelected;
  const client = crmState.clients[clientId];

  if (!template || !client) {
    toast('Template or client not found', false);
    return;
  }

  // Use the filled template (which may have been edited by user)
  const filled = window.currentQuickTemplateFilled;

  if (!filled || !filled.body) {
    toast('No message to send', false);
    return;
  }

  // Send based on type
  if (sendType === 'sms') {
    const cleanPhone = client.contact.phone.replace(/\D/g, '');

    // Always use Google Voice for consistency across all devices
    try {
      await navigator.clipboard.writeText(filled.body);
      window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
      toast('üìã Message copied! Google Voice opened', true);
    } catch (err) {
      window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
      toast('üì± Google Voice opened', true);
    }

    // Log interaction
    await logClientInteraction(clientId, 'sms', `Sent SMS - Template: ${template.name}`);

  } else if (sendType === 'email') {
    const mailtoLink = `mailto:${client.contact.email}?subject=${encodeURIComponent(filled.subject || '')}&body=${encodeURIComponent(filled.body)}`;
    window.location.href = mailtoLink;

    // Log interaction
    await logClientInteraction(clientId, 'email', `Sent Email - Template: ${template.name}`);
  }

  // Update template last used
  template.lastUsed = new Date().toISOString();
  saveUserTemplates();

  // Close modal
  closeQuickTemplatePicker();

  toast(`‚úÖ Opening ${sendType === 'sms' ? 'SMS' : 'Email'} app...`, true);
}

async function logClientInteraction(clientId, type, notes) {
  const client = crmState.clients[clientId];
  if (!client) return;

  const newInteraction = {
    type: type,
    date: new Date().toISOString(),
    notes: notes,
    nextFollowUp: null
  };

  if (!client.interactions) client.interactions = [];
  client.interactions.push(newInteraction);

  await saveClients();
}

function closeQuickTemplatePicker() {
  const modal = document.getElementById('quickTemplatePicker');
  if (modal) modal.remove();
  window.currentQuickTemplateClientId = null;
  window.currentQuickTemplateSendType = null;
  window.currentQuickTemplateSelected = null;
}

// Variables to track which client we're messaging
let currentSMSClientId = null;
let currentEmailClientId = null;

// Move Client to Pipeline "Attempting" Column
function moveClientToKanban(clientId) {
  const client = crmState.clients[clientId];
  if (!client) {
    toast('Client not found', false);
    return;
  }

  // Check if already in any campaign board
  if (isInCampaignBoard(client.placeId || clientId)) {
    toast(`${client.businessName} is already in the pipeline`, false);
    return;
  }

  // Create prospect object from client
  const prospect = {
    id: `client_${client.id}_${Date.now()}`,
    businessName: client.businessName,
    contactName: client.contact?.name || '',
    phone: client.contact?.phone || '',
    email: client.contact?.email || '',
    website: client.contact?.website || '',
    facebook: client.contact?.facebook || '',
    instagram: client.contact?.instagram || '',
    town: client.town || '',
    zipCode: client.zipCode || '',
    placeId: client.placeId || null,
    category: client.category || '',
    interactions: client.interactions || [],
    source: 'client',
    originalClientId: client.id,
    addedAt: new Date().toISOString()
  };

  // Add to campaign board "attempting" column
  const board = getCurrentCampaignBoard();
  if (board && board.columns) {
    if (!board.columns['attempting']) board.columns['attempting'] = [];
    board.columns['attempting'].unshift(prospect);
    saveCampaignBoards();
  }

  renderKanban();
  toast(`${client.businessName} added to pipeline - Attempting`, true);
}

// Complete and Remove Client from Kanban
function completeAndRemoveFromKanban(leadId, columnName) {
  console.log('completeAndRemoveFromKanban called with:', leadId, columnName);

  // Find the prospect in the specified column
  const prospect = (kanbanState.columns[columnName] || []).find(item => {
    return typeof item === 'object' && String(item.id) === String(leadId);
  });

  if (!prospect) {
    console.log('Prospect not found. Available IDs:', kanbanState.columns[columnName]?.map(i => i.id));
    toast('Prospect not found in Kanban', false);
    return;
  }

  const businessName = prospect.businessName || prospect.name || 'this business';

  // Remove from kanban column (no confirmation needed)
  const columnIndex = kanbanState.columns[columnName].findIndex(item =>
    typeof item === 'object' && String(item.id) === String(leadId)
  );

  if (columnIndex > -1) {
    kanbanState.columns[columnName].splice(columnIndex, 1);
    saveKanban();
    renderKanban();
    toast(`‚úÖ ${businessName} marked complete and removed from Kanban`, true);
  } else {
    toast('Failed to remove from Kanban', false);
  }
}

// Convert Prospect to Client Function
function convertProspectToClient(leadId, columnName) {
  // Find the prospect in the specified column - use string comparison for floating point IDs
  const prospect = (kanbanState.columns[columnName] || []).find(item => {
    if (typeof item !== 'object' || !item) return false;
    return String(item.id) === String(leadId);
  });

  if (!prospect) {
    showError('Prospect not found');
    return;
  }

  // Check if already exists in clients
  const existingClient = Object.values(crmState.clients).find(c =>
    c.businessName.toLowerCase() === prospect.businessName.toLowerCase()
  );

  if (existingClient) {
    showInfo('This business is already in your Client Database');
    return;
  }

  // Create new client from prospect data
  const clientId = `client_${Date.now()}`;
  const newClient = {
    id: clientId,
    businessName: prospect.businessName,
    category: prospect.category || 'Other',
    contact: {
      name: prospect.contactName || '',
      phone: prospect.phone || '',
      email: prospect.email || ''
    },
    address: prospect.notes ? prospect.notes.split('\n')[1] || '' : '',
    lifetime: {
      totalSpent: 0,
      cardsBought: 0
    },
    history: [],
    notes: prospect.notes || '',
    createdDate: new Date().toISOString()
  };

  // Add to clients
  crmState.clients[clientId] = newClient;

  // Save and refresh
  saveClients();
  renderClientList();

  // Show success message
  toast(`‚úÖ ${prospect.businessName} added to Client Database!`, true);

  // Switch to clients tab
  switchTab('clients');
}

// Manual Business Entry Functions
function openAddManualBusinessModal() {
  const modal = document.getElementById('addManualBusinessModal');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');

  // Reset form
  document.getElementById('addManualBusinessForm').reset();
}

function closeAddManualBusinessModal() {
  const modal = document.getElementById('addManualBusinessModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
}

async function lookupBusinessOnGoogle() {
  const searchQuery = document.getElementById('googlePlacesLookup').value.trim();
  const statusEl = document.getElementById('lookupStatus');

  if (!searchQuery) {
    statusEl.textContent = '‚ö†Ô∏è Please enter a business name to search';
    statusEl.className = 'text-xs text-orange-600 mt-2';
    return;
  }

  statusEl.textContent = 'üîç Searching Google Places...';
  statusEl.className = 'text-xs text-blue-600 mt-2';

  try {
    const service = new google.maps.places.PlacesService(document.createElement('div'));

    const request = {
      query: searchQuery,
      fields: ['name', 'formatted_address', 'formatted_phone_number', 'website', 'types']
    };

    service.textSearch(request, (results, status) => {
      if (status === google.maps.places.PlacesServiceStatus.OK && results && results.length > 0) {
        const place = results[0];

        // Get detailed information
        service.getDetails({ placeId: place.place_id, fields: ['name', 'formatted_address', 'formatted_phone_number', 'website', 'types', 'address_components'] }, (details, detailsStatus) => {
          if (detailsStatus === google.maps.places.PlacesServiceStatus.OK) {
            // Auto-fill form fields
            document.getElementById('manualBusinessName').value = details.name || '';

            // Extract address components
            let city = '', zip = '', address = '';
            if (details.address_components) {
              for (const component of details.address_components) {
                if (component.types.includes('locality')) {
                  city = component.long_name;
                } else if (component.types.includes('postal_code')) {
                  zip = component.short_name;
                } else if (component.types.includes('street_number') || component.types.includes('route')) {
                  address += component.long_name + ' ';
                }
              }
            }

            document.getElementById('manualBusinessAddress').value = address.trim() || details.formatted_address || '';
            document.getElementById('manualBusinessTown').value = city;
            document.getElementById('manualBusinessZip').value = truncateZipTo5(zip) || '';
            document.getElementById('manualBusinessPhone').value = details.formatted_phone_number || '';
            document.getElementById('manualBusinessWebsite').value = details.website || '';

            // Guess category from types
            if (details.types && details.types.length > 0) {
              const categoryMap = {
                'restaurant': 'Restaurant',
                'food': 'Restaurant',
                'cafe': 'Cafe',
                'hair_care': 'Hair Salon',
                'beauty_salon': 'Beauty Salon',
                'car_repair': 'Auto Repair',
                'lawyer': 'Legal Services',
                'doctor': 'Medical',
                'dentist': 'Dental',
                'plumber': 'Plumbing',
                'electrician': 'Electrical',
                'real_estate_agency': 'Real Estate',
                'gym': 'Fitness'
              };

              for (const type of details.types) {
                if (categoryMap[type]) {
                  document.getElementById('manualBusinessCategory').value = categoryMap[type];
                  break;
                }
              }
            }

            statusEl.textContent = `‚úÖ Found: ${details.name}! Review and submit below.`;
            statusEl.className = 'text-xs text-green-600 mt-2 font-medium';
          }
        });
      } else {
        statusEl.textContent = '‚ùå No results found. Try a different search or fill manually.';
        statusEl.className = 'text-xs text-red-600 mt-2';
      }
    });
  } catch (error) {
    console.error('Google Places lookup error:', error);
    statusEl.textContent = '‚ùå Lookup failed. Please fill in manually.';
    statusEl.className = 'text-xs text-red-600 mt-2';
  }
}

// Handle form submission
document.getElementById('addManualBusinessForm').addEventListener('submit', function(e) {
  e.preventDefault();

  // Get form values
  const businessData = {
    id: 'manual_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
    name: document.getElementById('manualBusinessName').value.trim(),
    businessName: document.getElementById('manualBusinessName').value.trim(),
    category: normalizeCategory(document.getElementById('manualBusinessCategory').value.trim()),
    address: document.getElementById('manualBusinessAddress').value.trim(),
    town: document.getElementById('manualBusinessTown').value.trim(),
    zipCode: truncateZipTo5(document.getElementById('manualBusinessZip').value.trim()) || '',
    phone: document.getElementById('manualBusinessPhone').value.trim(),
    email: document.getElementById('manualBusinessEmail').value.trim(),
    website: document.getElementById('manualBusinessWebsite').value.trim(),
    notes: document.getElementById('manualBusinessNotes').value.trim(),
    type: 'manual',
    isEnriched: false,
    addedAt: new Date().toISOString()
  };

  // Add to manualProspects
  if (!prospectPoolState.manualProspects) {
    prospectPoolState.manualProspects = [];
  }
  prospectPoolState.manualProspects.push(businessData);

  // Save to storage and cloud
  saveManualProspects();

  // Re-render prospect pool to show new business
  renderProspectPool();

  // Show success message
  toast(`‚úÖ ${businessData.businessName} added to Prospect Pool`, true);

  // Close modal
  closeAddManualBusinessModal();
});

function renderInteractionTimeline(interactions) {
  const timeline = document.getElementById('interactionTimeline');
  if (!timeline) return;

  if (!interactions || interactions.length === 0) {
    timeline.innerHTML = '<div class="text-sm text-gray-400 italic text-center py-4">No interactions yet</div>';
    return;
  }

  // Sort interactions by date (newest first)
  const sorted = [...interactions].sort((a, b) => new Date(b.date) - new Date(a.date));

  timeline.innerHTML = sorted.map(interaction => {
    const date = new Date(interaction.date).toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', year: 'numeric'
    });

    const typeIcons = {
      call: 'üìû',
      email: '‚úâÔ∏è',
      messenger: 'üìò',
      instagram: 'üì∑',
      'in-person': 'ü§ù',
      other: 'üìù'
    };

    const icon = typeIcons[interaction.type] || 'üìù';
    const typeLabel = interaction.type.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());

    let html = `
      <div class="border-l-4 border-blue-400 pl-3 py-2">
        <div class="flex justify-between items-start mb-1">
          <div class="font-medium text-sm">${icon} ${esc(typeLabel)}</div>
          <div class="text-xs text-gray-500">${date}</div>
        </div>
        <div class="text-sm text-gray-700">${esc(interaction.notes || 'No notes')}</div>
    `;

    if (interaction.nextFollowUp) {
      const followUpDate = new Date(interaction.nextFollowUp).toLocaleDateString('en-US', {
        month: 'short', day: 'numeric', year: 'numeric'
      });
      html += `<div class="text-xs text-purple-600 mt-1">üìÖ Follow-up: ${followUpDate}</div>`;
    }

    html += `</div>`;
    return html;
  }).join('');
}

function quickAction(type) {
  if (!currentProspectDetail) return;

  const prospect = currentProspectDetail;

  switch (type) {
    case 'call':
      if (prospect.phone) {
        window.location.href = `tel:${prospect.phone}`;
      }
      break;
    case 'sms':
      if (prospect.phone) {
        const cleanPhone = prospect.phone.replace(/\D/g, ''); // Remove non-digits

        // Always use Google Voice for consistency across all devices
        navigator.clipboard.writeText(prospect.phone).then(() => {
          window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
          toast(`üìã Phone copied! Google Voice opened for: ${prospect.phone}`, true);
        }).catch(() => {
          window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
          toast(`üì± Google Voice opened. Send to: ${prospect.phone}`, true);
        });
      }
      break;
    case 'email':
      if (prospect.email) {
        const subject = encodeURIComponent(`Re: ${prospect.businessName}`);
        window.location.href = `mailto:${prospect.email}?subject=${subject}`;
      }
      break;
    case 'website':
      if (prospect.website) {
        window.open(ensureHttps(prospect.website), '_blank');
      }
      break;
    case 'facebook':
      if (prospect.facebook) {
        window.open(ensureHttps(prospect.facebook), '_blank');
      }
      break;
    case 'instagram':
      if (prospect.instagram) {
        window.open(ensureHttps(prospect.instagram), '_blank');
      }
      break;
    case 'linkedin':
      if (prospect.linkedin) {
        window.open(ensureHttps(prospect.linkedin), '_blank');
      }
      break;
    case 'twitter':
      if (prospect.twitter) {
        window.open(ensureHttps(prospect.twitter), '_blank');
      }
      break;
  }
}

// Text client via Google Voice (copies phone and opens Google Voice)
function textClientViaGoogleVoice(phone, businessName) {
  if (!phone) return;

  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

  // Copy phone to clipboard and open Google Voice
  navigator.clipboard.writeText(phone).then(() => {
    if (isMobile) {
      // Mobile: Open Google Voice in new tab (will open app if installed)
      window.open('https://voice.google.com/u/0/messages', '_blank');
    } else {
      // Desktop: Open Google Voice in new tab
      window.open('https://voice.google.com/u/0/messages', '_blank');
    }
    toast(`üìã Phone copied: ${phone}`, true);
  }).catch(() => {
    // Fallback: just open Google Voice
    window.open('https://voice.google.com/u/0/messages', '_blank');
    toast(`üì± Text ${businessName}: ${phone}`, true);
  });
}

function addNewInteraction() {
  if (!currentProspectDetail) return;

  const type = document.getElementById('newInteractionType').value;
  const date = document.getElementById('newInteractionDate').value;
  const notes = document.getElementById('newInteractionNotes').value.trim();
  const followUp = document.getElementById('newInteractionFollowUp').value;

  if (!date) {
    toast('‚ö†Ô∏è Please select a date', false);
    return;
  }

  if (!notes) {
    toast('‚ö†Ô∏è Please enter notes about the interaction', false);
    return;
  }

  const newInteraction = {
    type,
    date,
    notes,
    nextFollowUp: followUp || null
  };

  // Find the prospect in the appropriate data source and update it
  const prospectId = currentProspectDetail.id;
  const source = currentProspectDetail.source;

  if (source === 'prospect') {
    // Update in prospect pool (searches cache)
    Object.keys(placesCache.searches).forEach(cacheKey => {
      const cached = placesCache.searches[cacheKey];
      if (cached.cachedData) {
        const prospect = cached.cachedData.find(p => p.placeId === prospectId || p.id === prospectId);
        if (prospect) {
          if (!prospect.interactions) prospect.interactions = [];
          prospect.interactions.push(newInteraction);
        }
      }
    });
    idbSet('mailslot-places-cache', placesCache.searches);
  } else if (source === 'kanban') {
    // Update in kanban
    Object.keys(kanbanState.columns).forEach(columnKey => {
      const item = kanbanState.columns[columnKey].find(i => i.id === prospectId);
      if (item) {
        if (!item.interactions) item.interactions = [];
        item.interactions.push(newInteraction);
      }
    });
    saveKanban();
  } else if (source === 'client') {
    // Update in clients
    if (crmState.clients[prospectId]) {
      if (!crmState.clients[prospectId].interactions) crmState.clients[prospectId].interactions = [];
      crmState.clients[prospectId].interactions.push(newInteraction);
      saveClients();
    }
  }

  // Update the current prospect detail and re-render timeline
  if (!currentProspectDetail.interactions) currentProspectDetail.interactions = [];
  currentProspectDetail.interactions.push(newInteraction);
  renderInteractionTimeline(currentProspectDetail.interactions);

  // Clear form
  document.getElementById('newInteractionNotes').value = '';
  document.getElementById('newInteractionFollowUp').value = '';

  toast('‚úÖ Interaction logged!', true);
}


/* ========= TEMPLATE MANAGER UI FUNCTIONS ========= */

let currentEditingTemplateId = null;

function renderTemplateManager(filteredTemplates = null) {
  // Support both Dashboard and Clients tab template lists
  const prospectList = document.getElementById('prospectTemplatesList') || document.getElementById('dashboardProspectTemplatesList');
  const clientList = document.getElementById('clientTemplatesList') || document.getElementById('dashboardClientTemplatesList');
  const followupList = document.getElementById('followupTemplatesList') || document.getElementById('dashboardFollowupTemplatesList');

  const prospectCount = document.getElementById('prospectTemplateCount') || document.getElementById('dashboardProspectTemplateCount');
  const clientCount = document.getElementById('clientTemplateCount') || document.getElementById('dashboardClientTemplateCount');
  const followupCount = document.getElementById('followupTemplateCount') || document.getElementById('dashboardFollowupTemplateCount');

  // Use filtered templates if provided, otherwise get all
  let prospectTemplates, clientTemplates, followupTemplates;

  if (filteredTemplates) {
    prospectTemplates = filteredTemplates.filter(t => t.category === 'prospect');
    clientTemplates = filteredTemplates.filter(t => t.category === 'client');
    followupTemplates = filteredTemplates.filter(t => t.category === 'followup');
  } else {
    prospectTemplates = getTemplatesByCategory('prospect');
    clientTemplates = getTemplatesByCategory('client');
    followupTemplates = getTemplatesByCategory('followup');
  }

  // Update counts
  if (prospectCount) prospectCount.textContent = `(${prospectTemplates.length})`;
  if (clientCount) clientCount.textContent = `(${clientTemplates.length})`;
  if (followupCount) followupCount.textContent = `(${followupTemplates.length})`;

  // Render prospect templates
  if (prospectList) {
    prospectList.innerHTML = prospectTemplates.length === 0
      ? '<div class="text-sm text-gray-500 italic">No templates yet. Click "+ New Template" to create one.</div>'
      : prospectTemplates.map(t => renderTemplateCard(t)).join('');
  }

  // Render client templates
  if (clientList) {
    clientList.innerHTML = clientTemplates.length === 0
      ? '<div class="text-sm text-gray-500 italic">No templates yet. Click "+ New Template" to create one.</div>'
      : clientTemplates.map(t => renderTemplateCard(t)).join('');
  }

  // Render followup templates
  if (followupList) {
    followupList.innerHTML = followupTemplates.length === 0
      ? '<div class="text-sm text-gray-500 italic">No templates yet. Click "+ New Template" to create one.</div>'
      : followupTemplates.map(t => renderTemplateCard(t)).join('');
  }
}

function filterTemplates() {
  const searchInput = document.getElementById('templateSearch');
  const typeFilter = document.getElementById('templateTypeFilter');

  if (!searchInput) {
    // If search elements don't exist, just render normally
    renderTemplateManager();
    return;
  }

  const searchTerm = searchInput.value.toLowerCase().trim();
  const selectedType = typeFilter ? typeFilter.value : '';

  // Get all templates
  const allTemplates = Object.values(userTemplatesState.templates || {});

  // Filter templates
  const filtered = allTemplates.filter(template => {
    // Type filter
    if (selectedType && template.type !== selectedType) {
      return false;
    }

    // Search filter
    if (searchTerm) {
      const matchesName = template.name.toLowerCase().includes(searchTerm);
      const matchesType = template.type.toLowerCase().includes(searchTerm);
      const matchesSubject = template.subject && template.subject.toLowerCase().includes(searchTerm);
      const matchesBody = template.body.toLowerCase().includes(searchTerm);
      const matchesVariables = template.variables.some(v => v.toLowerCase().includes(searchTerm));

      return matchesName || matchesType || matchesSubject || matchesBody || matchesVariables;
    }

    return true;
  });

  // Render with filtered templates
  renderTemplateManager(filtered);
}

function renderTemplateCard(template) {
  const typeIcons = {
    email: 'üìß',
    sms: 'üì±',
    messenger: 'üìò',
    instagram: 'üì∑'
  };

  const icon = typeIcons[template.type] || 'üìù';

  // Format usage stats
  const usageCount = template.usageCount || 0;
  const lastUsed = template.lastUsed;
  let lastUsedText = '';
  if (lastUsed) {
    const daysAgo = Math.floor((Date.now() - new Date(lastUsed).getTime()) / (1000 * 60 * 60 * 24));
    lastUsedText = daysAgo === 0 ? 'Today' : daysAgo === 1 ? 'Yesterday' : `${daysAgo} days ago`;
  }

  return `
    <div class="flex items-center justify-between p-3 bg-gray-50 border rounded-lg hover:bg-gray-100 transition-colors">
      <div class="flex-1">
        <div class="flex items-center gap-2 flex-wrap">
          <span>${icon}</span>
          <span class="font-medium text-gray-900">${esc(template.name)}</span>
          ${usageCount > 0 ? `<span class="text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded">${usageCount} use${usageCount > 1 ? 's' : ''}</span>` : ''}
        </div>
        ${template.subject ? `<div class="text-xs text-gray-600 mt-1">Subject: ${esc(template.subject)}</div>` : ''}
        <div class="text-xs text-gray-500 mt-1">
          ${template.variables.length > 0 ? `Variables: ${template.variables.map(v => `{${v}}`).join(', ')}` : 'No variables'}
          ${lastUsedText ? ` ‚Ä¢ Last used: ${lastUsedText}` : ''}
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button onclick="openEditTemplateModal('${template.id}')" class="px-3 py-1.5 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700">
          Edit
        </button>
        <button onclick="confirmDeleteTemplate('${template.id}')" class="px-3 py-1.5 text-sm bg-red-50 text-red-600 border border-red-200 rounded-md hover:bg-red-100">
          Delete
        </button>
      </div>
    </div>
  `;
}

function openCreateTemplateModal() {
  currentEditingTemplateId = null;
  document.getElementById('templateModalTitle').textContent = 'Create Template';
  document.getElementById('saveTemplateBtn').textContent = 'Save Template';

  // Clear form
  document.getElementById('templateName').value = '';
  document.getElementById('templateCategory').value = '';
  document.getElementById('templateType').value = '';
  document.getElementById('templateSubject').value = '';
  document.getElementById('templateBody').value = '';
  document.getElementById('templatePreviewSection').classList.add('hidden');

  // Show modal
  document.getElementById('templateModal').style.display = 'flex';
  document.getElementById('templateModal').setAttribute('aria-hidden', 'false');
}

function openEditTemplateModal(templateId) {
  const template = userTemplatesState.templates[templateId];
  if (!template) {
    toast('‚ö†Ô∏è Template not found', false);
    return;
  }

  if (template.isDefault) {
    toast('‚ö†Ô∏è Cannot edit default templates. Use Duplicate instead.', false);
    return;
  }

  currentEditingTemplateId = templateId;
  document.getElementById('templateModalTitle').textContent = 'Edit Template';
  document.getElementById('saveTemplateBtn').textContent = 'Save Changes';

  // Populate form
  document.getElementById('templateName').value = template.name;
  document.getElementById('templateCategory').value = template.category;
  document.getElementById('templateType').value = template.type;
  document.getElementById('templateSubject').value = template.subject || '';
  document.getElementById('templateBody').value = template.body;
  document.getElementById('templatePreviewSection').classList.add('hidden');

  // Show modal
  document.getElementById('templateModal').style.display = 'flex';
  document.getElementById('templateModal').setAttribute('aria-hidden', 'false');
}

function duplicateAndEditTemplate(templateId) {
  const duplicate = duplicateTemplate(templateId);
  if (duplicate) {
    toast(`‚úÖ Template duplicated!`, true);
    renderTemplateManager();
    openEditTemplateModal(duplicate.id);
  }
}

function closeTemplateModal() {
  document.getElementById('templateModal').style.display = 'none';
  document.getElementById('templateModal').setAttribute('aria-hidden', 'true');
  currentEditingTemplateId = null;
}

function insertVariable(variableName) {
  const bodyTextarea = document.getElementById('templateBody');
  const subjectInput = document.getElementById('templateSubject');

  // Determine which field has focus or use body as default
  const activeElement = document.activeElement;
  let targetField = bodyTextarea;

  if (activeElement && activeElement.id === 'templateSubject') {
    targetField = subjectInput;
  }

  // Insert variable at cursor position
  const start = targetField.selectionStart;
  const end = targetField.selectionEnd;
  const text = targetField.value;
  const variable = `{${variableName}}`;

  targetField.value = text.substring(0, start) + variable + text.substring(end);

  // Move cursor after inserted variable
  const newCursorPos = start + variable.length;
  targetField.setSelectionRange(newCursorPos, newCursorPos);
  targetField.focus();

  // Auto-update preview
  debounceAutoPreview();
}

function showVariableMenu(event) {
  // This function can be expanded later to show a dropdown menu
  // For now, the variable buttons are always visible in the helper section
  const helperSection = event.target.closest('.space-y-4').querySelector('.bg-blue-50');
  if (helperSection) {
    helperSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
}

// Auto-preview functionality with debounce
let autoPreviewTimeout = null;
function debounceAutoPreview() {
  clearTimeout(autoPreviewTimeout);
  autoPreviewTimeout = setTimeout(() => {
    const body = document.getElementById('templateBody')?.value;
    if (body && body.length > 10) {
      updateTemplatePreview();
    }
  }, 1000); // 1 second debounce
}

// Add auto-preview on body changes
document.addEventListener('DOMContentLoaded', function() {
  const bodyField = document.getElementById('templateBody');
  const subjectField = document.getElementById('templateSubject');

  if (bodyField) {
    bodyField.addEventListener('input', debounceAutoPreview);
  }

  if (subjectField) {
    subjectField.addEventListener('input', debounceAutoPreview);
  }
});

function updateTemplatePreview() {
  const name = document.getElementById('templateName').value;
  const category = document.getElementById('templateCategory').value;
  const type = document.getElementById('templateType').value;
  const subject = document.getElementById('templateSubject').value;
  const body = document.getElementById('templateBody').value;

  if (!body) {
    toast('‚ö†Ô∏è Enter a message body first', false);
    return;
  }

  // Sample data for preview
  const sampleData = {
    businessName: 'Joe\'s Pizza',
    contactName: 'Joe Smith',
    phone: '(716) 555-1234',
    email: 'joe@joespizza.com',
    town: 'Grand Island',
    zipCode: '14072',
    campaign: 'Grand Island - January 2025',
    amount: '$500',
    date: new Date().toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' })
  };

  // Create temporary template for preview
  const tempTemplate = {
    id: 'preview',
    name,
    category,
    type,
    subject,
    body,
    variables: []
  };

  // Extract variables
  const variablePattern = /\{([^}]+)\}/g;
  const variablesSet = new Set();
  let match;
  while ((match = variablePattern.exec(subject + ' ' + body)) !== null) {
    variablesSet.add(match[1]);
  }
  tempTemplate.variables = Array.from(variablesSet);

  // Fill with sample data
  const filled = fillTemplateVariables(tempTemplate, sampleData);

  // Show preview
  const previewSection = document.getElementById('templatePreviewSection');
  const previewSubject = document.getElementById('templatePreviewSubject');
  const previewBody = document.getElementById('templatePreviewBody');

  if (filled.subject) {
    previewSubject.textContent = `Subject: ${filled.subject}`;
    previewSubject.style.display = 'block';
  } else {
    previewSubject.style.display = 'none';
  }

  previewBody.textContent = filled.body;
  previewSection.classList.remove('hidden');
}

function confirmDeleteTemplate(templateId) {
  const template = userTemplatesState.templates[templateId];
  if (!template) return;

  const confirmed = confirm(`Delete template "${template.name}"?\n\nThis action cannot be undone.`);
  if (!confirmed) return;

  const success = deleteTemplate(templateId);
  if (success) {
    toast(`‚úÖ Template deleted`, true);
    renderTemplateManager();
  }
}

// Handle template form submission
document.addEventListener('DOMContentLoaded', function() {
  const templateForm = document.getElementById('templateForm');
  if (templateForm) {
    templateForm.addEventListener('submit', function(e) {
      e.preventDefault();

      const name = document.getElementById('templateName').value.trim();
      const category = document.getElementById('templateCategory').value;
      const type = document.getElementById('templateType').value;
      const subject = document.getElementById('templateSubject').value.trim();
      const body = document.getElementById('templateBody').value.trim();

      if (!name || !category || !type || !body) {
        toast('‚ö†Ô∏è Please fill in all required fields', false);
        return;
      }

      if (currentEditingTemplateId) {
        // Update existing template
        const updated = updateTemplate(currentEditingTemplateId, {
          name,
          category,
          type,
          subject,
          body
        });

        if (updated) {
          toast('‚úÖ Template updated!', true);
          closeTemplateModal();
          renderTemplateManager();
        }
      } else {
        // Create new template
        const created = createTemplate(name, category, type, subject, body);
        if (created) {
          toast('‚úÖ Template created!', true);
          closeTemplateModal();
          renderTemplateManager();
        }
      }
    });
  }
});

async function markNotInterested() {
  if (!currentProspectDetail) return;

  const businessName = currentProspectDetail.businessName;
  const confirmed = confirm(`Are you sure you want to mark "${businessName}" as Not Interested?\n\nThis business will be permanently removed from your prospect pool and won't appear in future searches.`);

  if (!confirmed) return;

  const prospectId = currentProspectDetail.id;
  const placeId = currentProspectDetail.placeId || prospectId;

  // Add to Not Interested list
  if (!notInterestedState.placeIds) notInterestedState.placeIds = new Set();
  if (!notInterestedState.businesses) notInterestedState.businesses = {};

  notInterestedState.placeIds.add(placeId);
  notInterestedState.businesses[placeId] = {
    businessName,
    placeId: placeId,
    dateMarked: new Date().toISOString(),
    reason: 'User marked as not interested'
  };

  // Save to cloud database
  const cloudData = {
    placeIds: Array.from(notInterestedState.placeIds),
    businesses: notInterestedState.businesses
  };

  try {
    await saveToCloud('notInterested', cloudData);
  } catch (err) {
    console.error('Failed to save not interested to cloud:', err);
    // Still save to localStorage as backup
    localStorage.setItem('mailslot-not-interested', JSON.stringify(cloudData));
  }

  // Remove from prospect pool (searches cache)
  let removedCount = 0;
  Object.keys(placesCache.searches).forEach(cacheKey => {
    const cached = placesCache.searches[cacheKey];
    if (cached.cachedData) {
      const beforeLength = cached.cachedData.length;
      cached.cachedData = cached.cachedData.filter(p => {
        // Keep item unless it matches the one we want to remove
        // Match by placeId
        if (placeId && p.placeId === placeId) return false;
        // Match by id
        if (prospectId && p.id === prospectId) return false;
        // Match by business name (fallback)
        if (businessName && (p.name === businessName || p.businessName === businessName)) return false;
        // Keep all others
        return true;
      });
      removedCount += (beforeLength - cached.cachedData.length);
    }
  });
  idbSet('mailslot-places-cache', placesCache.searches);

  console.log(`Removed ${removedCount} items from prospect pool for: ${businessName}`);

  // Remove from campaign board
  const board = getCurrentCampaignBoard();
  if (board && board.columns) {
    Object.keys(board.columns).forEach(columnKey => {
      board.columns[columnKey] = board.columns[columnKey].filter(item => {
        if (placeId && item.placeId === placeId) return false;
        if (prospectId && item.id === prospectId) return false;
        if (businessName && (item.businessName === businessName || item.name === businessName)) return false;
        return true;
      });
    });
  }
  saveCampaignBoards();

  toast(`‚úÖ "${businessName}" marked as Not Interested and removed`, true);
  closeProspectDetailModal();

  // Refresh displays
  renderProspectPool();
  renderKanban();
}

// Expose functions globally
window.openProspectDetailModal = openProspectDetailModal;
window.closeProspectDetailModal = closeProspectDetailModal;
window.quickAction = quickAction;
window.addNewInteraction = addNewInteraction;
window.markNotInterested = markNotInterested;
window.markProspectNotInterested = markProspectNotInterested;

/* ========= KANBAN FUNCTIONS ========= */

// Load pipeline data - Campaign Board is now the single source of truth
async function loadKanban() {
  // Load Campaign Boards data (single source of truth)
  try {
    await loadCampaignBoards();
    console.log('‚úÖ Campaign Boards loaded');
  } catch (e) {
    console.error('Error loading campaign boards:', e);
  }

  // Migration: Check if there's legacy kanban data that needs to be migrated
  // Run if Campaign Board doesn't exist OR exists but is empty
  try {
    const currentMailerId = state.current?.Mailer_ID;
    if (currentMailerId) {
      const existingBoard = campaignBoardsState.boards[currentMailerId];
      const boardIsEmpty = !existingBoard || !existingBoard.columns ||
        !Object.values(existingBoard.columns).some(col => Array.isArray(col) && col.length > 0);

      if (boardIsEmpty) {
        // Board is empty or doesn't exist - check for legacy data to migrate
        const legacyData = await loadFromCloud('kanban');
        if (legacyData && typeof legacyData === 'object') {
          const hasLegacyData = Object.values(legacyData).some(col =>
            Array.isArray(col) && col.length > 0
          );
          if (hasLegacyData) {
            console.log('üì¶ Found legacy kanban data, migrating to Campaign Board...');
            // Pass legacy data directly to migration function
            kanbanState._legacyData = legacyData;
            await migrateToCampaignBoards();
            delete kanbanState._legacyData;
            await saveCampaignBoards();
            console.log('‚úÖ Legacy data migrated to Campaign Board');
          } else if (!existingBoard) {
            // No legacy data and no board, create empty board
            createCampaignBoard(currentMailerId, state.current?.town || currentMailerId);
            console.log('üìã Created new Campaign Board for', currentMailerId);
          }
        }
      }
    }
  } catch (e) {
    console.error('Error checking legacy data:', e);
  }

  renderKanban();
  refreshFollowUpDashboard();
  refreshContactStatusDashboard();
  refreshAnalytics();
}

// deduplicateKanbanData() removed - campaign board handles deduplication

// Quick save for drag operations - no dedup, no logging, debounced
// Now redirects to Campaign Board (single source of truth)
let kanbanSaveTimeout = null;
function saveKanbanQuick() {
  // Debounce: wait 500ms after last drag before actually saving
  if (kanbanSaveTimeout) clearTimeout(kanbanSaveTimeout);
  kanbanSaveTimeout = setTimeout(() => {
    // Save Campaign Board (single source of truth)
    saveCampaignBoards().catch(e => {
      console.warn('Quick save failed:', e);
    });
  }, 500);
}

// Legacy saveKanban - now redirects to Campaign Board (single source of truth)
async function saveKanban() {
  try {
    // Save Campaign Board (single source of truth)
    await saveCampaignBoards();
  } catch(e) {
    console.warn('Save failed:', e);
  }
}

// CLOUD PROSPECTS SYNC FUNCTIONS
// Now uses Campaign Board as single source of truth
async function saveSelectedProspectsToCloud() {
  if (cloudSyncSelection.selectedIds.size === 0) {
    toast('No prospects selected', false);
    return;
  }

  try {
    const prospectsToSync = [];
    const board = getCurrentCampaignBoard();

    if (!board) {
      toast('No campaign board found', false);
      return;
    }

    // Collect selected prospects from Campaign Board columns
    Object.keys(board.columns || {}).forEach(columnKey => {
      const items = board.columns[columnKey];

      // Safety check - ensure column is an array
      if (!Array.isArray(items)) {
        console.warn(`Column ${columnKey} is not an array:`, items);
        return;
      }

      items.forEach(item => {
        if (typeof item === 'object' && item && cloudSyncSelection.selectedIds.has(item.id)) {
          prospectsToSync.push({
            ...item,
            column: columnKey // Store which column it's in
          });
        }
      });
    });

    if (prospectsToSync.length === 0) {
      toast('Selected prospects not found', false);
      return;
    }

    // Use POST request to avoid URL length limits
    const response = await fetch(GAS_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'saveCloudProspects',
        user: ACTIVE_USER,
        prospects: prospectsToSync
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const result = await response.json();

    if (result.success) {
      toast(`‚úÖ Synced ${result.count} prospect(s) to cloud!`, true);
      cloudSyncSelection.selectedIds.clear();
      renderKanban();
    } else {
      throw new Error(result.error || 'Unknown error');
    }

  } catch (err) {
    console.error('Failed to sync prospects to cloud:', err);
    toast('Failed to sync prospects to cloud', false);
  }
}

async function loadCloudProspects() {
  try {
    const url = `${GAS_URL}?action=loadCloudProspects&user=${encodeURIComponent(ACTIVE_USER)}`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const result = await response.json();

    if (result.success && result.prospects) {
      return result.prospects;
    }

    return [];

  } catch (err) {
    console.error('Failed to load cloud prospects:', err);
    return [];
  }
}

async function deleteCloudProspect(prospectId) {
  try {
    const url = `${GAS_URL}?action=deleteCloudProspect&user=${encodeURIComponent(ACTIVE_USER)}&prospectId=${encodeURIComponent(prospectId)}`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const result = await response.json();
    return result.success;

  } catch (err) {
    console.error('Failed to delete cloud prospect:', err);
    return false;
  }
}

function toggleCloudSyncUI() {
  cloudSyncSelection.showSyncUI = !cloudSyncSelection.showSyncUI;
  if (!cloudSyncSelection.showSyncUI) {
    cloudSyncSelection.selectedIds.clear();
  }
  renderKanban();
}

function toggleProspectForSync(prospectId) {
  if (cloudSyncSelection.selectedIds.has(prospectId)) {
    cloudSyncSelection.selectedIds.delete(prospectId);
  } else {
    cloudSyncSelection.selectedIds.add(prospectId);
  }
  debouncedRenderKanban(); // Use debounced version for checkbox toggles
}

// Debounce utility to prevent excessive re-renders
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Debounced version of renderKanban for non-critical updates
const debouncedRenderKanban = debounce(() => renderKanban(), DEBOUNCE_RENDER_DELAY);

function renderKanban() {
  try { renderCampaignBoard(); }
  catch (err) { console.error('Error rendering pipeline:', err); }
}

// setupKanbanDrag() removed - campaign board has its own drag-and-drop

/* ========= CAMPAIGN BOARDS FUNCTIONS ========= */

// Column definitions for campaign boards
const campaignBoardColumns = {
  'queued': { title: '1. Queued', color: 'blue', phase: 'discovery', icon: 'üìã' },
  'attempting': { title: '2. Attempting', color: 'purple', phase: 'discovery', icon: 'üìû' },
  'negotiating': { title: '3. Negotiating', color: 'green', phase: 'sales', icon: 'üí¨' },
  'invoice-sent': { title: '4. Invoice Sent', color: 'yellow', phase: 'sales', icon: 'üìÑ' },
  'proof-approved': { title: '5. Proof Approved', color: 'orange', phase: 'sales', icon: '‚úÖ' },
  'paid-in-full': { title: '6. Paid in Full', color: 'emerald', phase: 'sales', icon: 'üí∞' }
};

// Create a new campaign board for a mailer
function createCampaignBoard(mailerId, mailerName) {
  // Try to detect primary ZIP from mailer data
  const mailer = state.mailers?.find(m => (m.Mailer_ID || m.id) === mailerId);
  const primaryZip = mailer?.zipCode || mailer?.zip || mailer?.ZIP || '';

  const board = {
    mailerId: mailerId,
    name: mailerName || `Campaign ${mailerId}`,
    createdAt: new Date().toISOString(),
    config: {
      channelPriority: ['sms', 'email', 'facebook', 'call'],
      templates: {},
      daysBetweenAttempts: 3,
      maxAttempts: 4,
      targetZips: primaryZip ? [primaryZip] : [] // Primary ZIP(s) for this campaign
    },
    columns: {
      'queued': [],
      'attempting': [],
      'negotiating': [],
      'invoice-sent': [],
      'proof-approved': [],
      'paid-in-full': []
    }
  };

  campaignBoardsState.boards[mailerId] = board;
  return board;
}

// Get or create campaign board for current mailer
function getCurrentCampaignBoard() {
  const currentMailerId = state.current?.Mailer_ID;
  if (!currentMailerId) return null;

  if (!campaignBoardsState.boards[currentMailerId]) {
    const mailerName = state.current?.town || state.current?.Mailer_ID;
    createCampaignBoard(currentMailerId, mailerName);
  }

  return campaignBoardsState.boards[currentMailerId];
}

// Enhance business with attempt tracking fields
function enhanceBusinessForCampaignBoard(business, maxAttempts = 4) {
  return {
    ...business,
    attemptTracking: business.attemptTracking || {
      currentAttempt: 0,
      maxAttempts: maxAttempts,
      attemptHistory: [],
      nextChannel: null,
      nextActionDate: null
    },
    channelStatus: business.channelStatus || {
      sms: { available: !!business.phone, sent: false, sentDate: null },
      email: { available: !!business.email, sent: false, sentDate: null },
      facebook: { available: !!business.facebook, sent: false, sentDate: null },
      instagram: { available: !!business.instagram, sent: false, sentDate: null },
      linkedin: { available: !!business.linkedin, sent: false, sentDate: null },
      call: { available: !!business.phone, sent: false, sentDate: null }
    },
    lockedChannel: business.lockedChannel || null,
    salesInfo: business.salesInfo || {
      invoiceAmount: null,
      invoiceSentDate: null,
      proofApprovedDate: null,
      paidDate: null
    }
  };
}

// Calculate next channel to use based on priority and what's been tried
function calculateNextChannel(business, channelPriority) {
  const channels = business.channelStatus || {};

  // If a channel is locked (responded), that's the only channel to use
  if (business.lockedChannel?.channel) {
    return business.lockedChannel.channel;
  }

  // Find first available channel that hasn't been sent yet
  for (const channel of channelPriority) {
    const status = channels[channel];
    if (status?.available && !status?.sent) {
      return channel;
    }
  }

  // All channels tried - cycle back to first available
  for (const channel of channelPriority) {
    if (channels[channel]?.available) {
      return channel;
    }
  }

  return null;
}

// Calculate next action date based on days between attempts
function calculateNextActionDate(business, daysBetweenAttempts = 3) {
  const history = business.attemptTracking?.attemptHistory || [];
  if (history.length === 0) {
    return new Date().toISOString().split('T')[0]; // Today
  }

  const lastAttempt = history[history.length - 1];
  const lastDate = new Date(lastAttempt.date);
  lastDate.setDate(lastDate.getDate() + daysBetweenAttempts);
  return lastDate.toISOString().split('T')[0];
}

// Mark a channel as sent for a business
function markChannelSent(businessId, channel, board) {
  const columns = board.columns;

  // Find the business in any column
  for (const colKey of Object.keys(columns)) {
    const items = columns[colKey];
    const idx = items.findIndex(item => String(item.id) === String(businessId));

    if (idx !== -1) {
      const business = items[idx];

      // Update channel status
      if (!business.channelStatus) {
        business.channelStatus = {};
      }
      if (!business.channelStatus[channel]) {
        business.channelStatus[channel] = { available: true, sent: false };
      }
      business.channelStatus[channel].sent = true;
      business.channelStatus[channel].sentDate = new Date().toISOString();

      // Update attempt tracking
      if (!business.attemptTracking) {
        business.attemptTracking = { currentAttempt: 0, maxAttempts: 4, attemptHistory: [] };
      }
      business.attemptTracking.currentAttempt++;
      business.attemptTracking.attemptHistory.push({
        date: new Date().toISOString(),
        channel: channel,
        sent: true,
        responded: false
      });

      // Calculate next action
      business.attemptTracking.nextChannel = calculateNextChannel(business, board.config.channelPriority);
      business.attemptTracking.nextActionDate = calculateNextActionDate(business, board.config.daysBetweenAttempts);

      // Move to attempting if in queued
      if (colKey === 'queued') {
        items.splice(idx, 1);
        columns['attempting'].push(business);
      }

      return business;
    }
  }

  return null;
}

// Advance attempt (when cycling through channels)
function advanceAttempt(businessId, board) {
  const business = findBusinessInBoard(businessId, board);
  if (!business) return null;

  business.attemptTracking.currentAttempt++;
  business.attemptTracking.nextChannel = calculateNextChannel(business, board.config.channelPriority);
  business.attemptTracking.nextActionDate = calculateNextActionDate(business, board.config.daysBetweenAttempts);

  return business;
}

// Get attempt progress as percentage
function getAttemptProgress(business) {
  const tracking = business.attemptTracking;
  if (!tracking) return 0;
  return Math.min(100, Math.round((tracking.currentAttempt / tracking.maxAttempts) * 100));
}

// Find business in any column of a board
function findBusinessInBoard(businessId, board) {
  for (const colKey of Object.keys(board.columns)) {
    const items = board.columns[colKey];
    const item = items.find(item => String(item.id) === String(businessId));
    if (item) return item;
  }
  return null;
}

// Move business between columns in campaign board
function moveCampaignBoardItem(businessId, fromColumn, toColumn, board) {
  const fromItems = board.columns[fromColumn];

  // Safety check: ensure destination column exists before modifying source
  if (!board.columns[toColumn]) {
    console.error(`‚ùå moveCampaignBoardItem: destination column '${toColumn}' does not exist`);
    board.columns[toColumn] = []; // Initialize if missing
  }
  const toItems = board.columns[toColumn];

  if (!fromItems) {
    console.error(`‚ùå moveCampaignBoardItem: source column '${fromColumn}' does not exist`);
    return false;
  }

  const idx = fromItems.findIndex(item => String(item.id) === String(businessId));
  if (idx === -1) return false;

  const business = fromItems[idx];
  fromItems.splice(idx, 1);

  const now = new Date().toISOString();

  // Initialize attempt tracking when entering "attempting" column
  if (toColumn === 'attempting') {
    if (!business.attemptTracking || business.attemptTracking.currentAttempt === 0) {
      // Set up channel status based on available contact info
      const channelStatus = {
        sms: { available: !!business.phone, sent: false },
        email: { available: !!business.email, sent: false },
        facebook: { available: !!business.facebook, sent: false },
        instagram: { available: !!business.instagram, sent: false },
        linkedin: { available: !!business.linkedin, sent: false },
        call: { available: !!business.phone, sent: false }
      };

      // Find first available channel based on priority
      const priority = board.config?.channelPriority || ['sms', 'email', 'facebook', 'call'];
      const nextChannel = priority.find(ch => channelStatus[ch]?.available) || null;

      business.attemptTracking = {
        currentAttempt: 1,
        maxAttempts: board.config?.maxAttempts || 4,
        attemptHistory: [],
        nextChannel: nextChannel,
        nextActionDate: now.split('T')[0]
      };
      business.channelStatus = channelStatus;
    }
  }

  // Update sales info based on destination column
  if (toColumn === 'invoice-sent' && !business.salesInfo?.invoiceSentDate) {
    business.salesInfo = business.salesInfo || {};
    business.salesInfo.invoiceSentDate = now;
  } else if (toColumn === 'proof-approved' && !business.salesInfo?.proofApprovedDate) {
    business.salesInfo = business.salesInfo || {};
    business.salesInfo.proofApprovedDate = now;
  } else if (toColumn === 'paid-in-full') {
    business.salesInfo = business.salesInfo || {};
    business.salesInfo.paidDate = now;
    // Auto-move to clients will be triggered separately
  }

  toItems.push(business);
  return true;
}

// Render campaign board (new 6-column system)
function renderCampaignBoard() {
  const board = getCurrentCampaignBoard();

  if (!board) {
    return;
  }

  const allColumnKeys = ['queued', 'attempting', 'negotiating', 'invoice-sent', 'proof-approved', 'paid-in-full'];
  const currentView = campaignBoardsState.columnView || 'discovery';
  // Discovery: cols 1-3, Sales: cols 3-6 (negotiating overlaps as it's the transition)
  const columnKeys = currentView === 'discovery'
    ? ['queued', 'attempting', 'negotiating']
    : ['negotiating', 'invoice-sent', 'proof-approved', 'paid-in-full'];

  const dailyGoalContainer = document.getElementById('dailyGoalContainer');
  const kanbanColumnsContainer = document.getElementById('salesActivityKanbanColumns');

  if (!dailyGoalContainer || !kanbanColumnsContainer) {
    console.warn('Campaign board containers not found');
    return;
  }

  // Helper to normalize ZIP to 5 digits
  const normalizeZip = (zip) => {
    if (!zip) return '';
    const zipStr = String(zip).trim();
    // Extract first 5 digits (handles both "14072" and "14072-1248" formats)
    return zipStr.split('-')[0].substring(0, 5);
  };

  // Collect ALL ZIPs across ALL columns for global filter (use allColumnKeys, not filtered columnKeys)
  const allZipsSet = new Set();
  allColumnKeys.forEach(colKey => {
    const colItems = board.columns[colKey] || [];
    colItems.forEach(item => {
      const zip = item.actualZip || item.zipCode || item.zip;
      const normalized = normalizeZip(zip);
      if (normalized) allZipsSet.add(normalized);
    });
  });
  const allZipsSorted = Array.from(allZipsSet).sort();

  // Get target ZIPs from campaign config
  const targetZips = board.config?.targetZips || [];

  // Determine which items pass the global filter
  const globalFilter = campaignBoardsState.globalZipFilter || 'target';
  const filterFunction = (item) => {
    const itemZip = normalizeZip(item.actualZip || item.zipCode || item.zip);
    if (!itemZip) return true; // Show items without ZIP

    if (globalFilter === 'all') return true;
    if (globalFilter === 'target') {
      if (targetZips.length === 0) return true; // No target set, show all
      return targetZips.includes(itemZip);
    }
    // Specific ZIP selected
    return itemZip === globalFilter;
  };

  // Build columns HTML
  const columnsHTML = columnKeys.map(colKey => {
    const colDef = campaignBoardColumns[colKey];
    const allItems = board.columns[colKey] || [];

    // Apply global ZIP filter
    const items = allItems.filter(filterFunction);

    // Phase separator styling
    const isFirstSalesPhase = colKey === 'negotiating';
    const phaseSeparator = isFirstSalesPhase ? 'border-l-4 border-l-yellow-400 pl-2' : '';

    // Column-specific empty states
    const emptyStates = {
      'queued': '<div class="text-center p-4 text-gray-400 border-2 border-dashed border-gray-200 rounded-lg"><span class="text-2xl mb-2 block">üìã</span><p class="text-xs font-medium">Ready to start outreach</p><p class="text-xs">Add from Business Pool</p></div>',
      'attempting': '<div class="text-center p-4 text-gray-400 border-2 border-dashed border-gray-200 rounded-lg"><span class="text-2xl mb-2 block">üìû</span><p class="text-xs font-medium">Active outreach</p><p class="text-xs">Shows attempt progress</p></div>',
      'negotiating': '<div class="text-center p-4 text-gray-400 border-2 border-dashed border-gray-200 rounded-lg"><span class="text-2xl mb-2 block">üí¨</span><p class="text-xs font-medium">In conversation</p><p class="text-xs">Response received</p></div>',
      'invoice-sent': '<div class="text-center p-4 text-gray-400 border-2 border-dashed border-gray-200 rounded-lg"><span class="text-2xl mb-2 block">üìÑ</span><p class="text-xs font-medium">Awaiting payment</p><p class="text-xs">Invoice delivered</p></div>',
      'proof-approved': '<div class="text-center p-4 text-gray-400 border-2 border-dashed border-gray-200 rounded-lg"><span class="text-2xl mb-2 block">‚úÖ</span><p class="text-xs font-medium">Ad approved</p><p class="text-xs">Waiting for payment</p></div>',
      'paid-in-full': '<div class="text-center p-4 text-gray-400 border-2 border-dashed border-gray-200 rounded-lg"><span class="text-2xl mb-2 block">üí∞</span><p class="text-xs font-medium">Complete!</p><p class="text-xs">Auto-moves to Clients</p></div>'
    };

    // Render cards
    const cardsHTML = items.map((item, idx) => {
      if (!item) return '';

      const leadName = item.businessName || item.name || 'Unnamed Business';
      const leadId = String(item.id || idx);
      const isDoNotContact = item.doNotContact === true;

      // Check if contacted
      const ct = item.contactTracking || {};
      const hasBeenContacted = ct.emailed || ct.texted || ct.called || ct.linkedinMessaged || ct.facebookMessaged || ct.dmed;

      // Attempt progress for "attempting" column
      let attemptHTML = '';
      if (colKey === 'attempting') {
        const channels = item.channelStatus || {};
        const history = item.attemptTracking?.attemptHistory || [];
        const contactTracking = item.contactTracking || {};

        // Find which channels were used (check both new and legacy tracking)
        const usedChannels = [];
        const channelLabels = { sms: 'üì± SMS', email: 'üìß Email', facebook: 'üìò FB Msg', instagram: 'üì∑ IG DM', linkedin: 'üíº LinkedIn', call: 'üìû Call' };

        // Check new channelStatus
        Object.entries(channels).forEach(([ch, status]) => {
          if (status?.sent) usedChannels.push({ channel: ch, label: channelLabels[ch] || ch });
        });

        // Check attemptHistory
        history.forEach(h => {
          if (h.sent && !usedChannels.find(u => u.channel === h.channel)) {
            usedChannels.push({ channel: h.channel, label: channelLabels[h.channel] || h.channel });
          }
        });

        // Check legacy contactTracking
        if (usedChannels.length === 0) {
          if (contactTracking.texted) usedChannels.push({ channel: 'sms', label: channelLabels.sms });
          if (contactTracking.emailed) usedChannels.push({ channel: 'email', label: channelLabels.email });
          if (contactTracking.called) usedChannels.push({ channel: 'call', label: channelLabels.call });
          if (contactTracking.facebookMessaged) usedChannels.push({ channel: 'facebook', label: channelLabels.facebook });
          if (contactTracking.linkedinMessaged) usedChannels.push({ channel: 'linkedin', label: channelLabels.linkedin });
          if (contactTracking.dmed) usedChannels.push({ channel: 'instagram', label: channelLabels.instagram });
        }

        // Get attempt tracking info
        const currentAttempt = item.attemptTracking?.currentAttempt || usedChannels.length || 1;
        const maxAttempts = item.attemptTracking?.maxAttempts || 4;

        if (usedChannels.length > 0) {
          // Show attempt counter AND "Contacted via" badge
          const contactedVia = usedChannels.map(u => u.label).join(', ');
          attemptHTML = `
            <div class="mt-2 pt-2 border-t border-gray-100">
              <div class="text-xs text-gray-500 text-center mb-1">Attempt ${currentAttempt} of ${maxAttempts}</div>
              <div class="bg-green-100 border border-green-300 rounded-lg px-2 py-1.5 text-center">
                <div class="text-xs text-green-800 font-medium">üì¨ Contacted via:</div>
                <div class="text-sm font-bold text-green-700">${contactedVia}</div>
              </div>
            </div>
          `;
        } else {
          // No contact recorded yet - show attempt counter and prompt
          attemptHTML = `
            <div class="mt-2 pt-2 border-t border-gray-100">
              <div class="text-xs text-gray-500 text-center mb-1">Attempt ${currentAttempt} of ${maxAttempts}</div>
              <div class="bg-yellow-50 border border-yellow-200 rounded-lg px-2 py-1.5 text-center">
                <div class="text-xs text-yellow-700">‚ö†Ô∏è No outreach recorded</div>
                <div class="text-xs text-yellow-600">Double-click to mark contact method</div>
              </div>
            </div>
          `;
        }
      }

      // Negotiating column - show which channel got a response
      let negotiatingHTML = '';
      if (colKey === 'negotiating') {
        const channels = item.channelStatus || {};
        const history = item.attemptTracking?.attemptHistory || [];
        const contactTracking = item.contactTracking || {};
        const channelLabels = { sms: 'üì± SMS', email: 'üìß Email', facebook: 'üìò FB Msg', instagram: 'üì∑ IG DM', linkedin: 'üíº LinkedIn', call: 'üìû Call' };

        // Check for explicitly set responded channel
        let respondedChannel = item.respondedChannel || item.lockedChannel?.channel;

        // If not set, find the most recent channel used
        if (!respondedChannel) {
          // Check history for responded flag
          const respondedEntry = history.find(h => h.responded);
          if (respondedEntry) {
            respondedChannel = respondedEntry.channel;
          } else {
            // Fall back to most recent sent channel
            const sentChannels = Object.entries(channels)
              .filter(([ch, status]) => status?.sent)
              .sort((a, b) => (b[1].sentDate || '').localeCompare(a[1].sentDate || ''));
            if (sentChannels.length > 0) {
              respondedChannel = sentChannels[0][0];
            }
          }
        }

        // Check legacy tracking as fallback
        if (!respondedChannel) {
          if (contactTracking.texted) respondedChannel = 'sms';
          else if (contactTracking.emailed) respondedChannel = 'email';
          else if (contactTracking.called) respondedChannel = 'call';
          else if (contactTracking.facebookMessaged) respondedChannel = 'facebook';
          else if (contactTracking.linkedinMessaged) respondedChannel = 'linkedin';
          else if (contactTracking.dmed) respondedChannel = 'instagram';
        }

        if (respondedChannel) {
          const label = channelLabels[respondedChannel] || respondedChannel;
          negotiatingHTML = `
            <div class="mt-2 pt-2 border-t border-gray-100">
              <div class="bg-blue-100 border border-blue-300 rounded-lg px-2 py-1.5 text-center">
                <div class="text-xs text-blue-800 font-medium">‚úÖ Responded via:</div>
                <div class="text-sm font-bold text-blue-700">${label}</div>
              </div>
            </div>
          `;
        } else {
          negotiatingHTML = `
            <div class="mt-2 pt-2 border-t border-gray-100">
              <div class="bg-gray-100 border border-gray-200 rounded-lg px-2 py-1.5 text-center">
                <div class="text-xs text-gray-600">üí¨ In conversation</div>
              </div>
            </div>
          `;
        }
      }

      // Sales info for sales pipeline columns
      let salesHTML = '';
      if (['invoice-sent', 'proof-approved', 'paid-in-full'].includes(colKey) && item.salesInfo) {
        const info = item.salesInfo;
        const details = [];
        if (info.invoiceAmount) details.push(`$${info.invoiceAmount}`);
        if (info.invoiceSentDate) details.push(`Sent: ${new Date(info.invoiceSentDate).toLocaleDateString()}`);
        if (info.proofApprovedDate) details.push(`Approved: ${new Date(info.proofApprovedDate).toLocaleDateString()}`);
        if (details.length > 0) {
          salesHTML = `<div class="mt-2 pt-2 border-t border-gray-100 text-xs text-gray-500">${details.join(' ‚Ä¢ ')}</div>`;
        }
      }

      // Social icons
      const socialIcons = [];
      if (item.phone) socialIcons.push(`<a href="tel:${esc(item.phone)}" onclick="event.stopPropagation()" class="px-1.5 py-0.5 bg-gray-100 rounded hover:bg-gray-200 text-sm" title="Call">üìû</a>`);
      if (item.website) socialIcons.push(`<a href="${esc(ensureHttps(item.website))}" onclick="event.stopPropagation()" target="_blank" class="px-1.5 py-0.5 bg-gray-100 rounded hover:bg-gray-200 text-sm" title="Website">üåê</a>`);
      if (item.email) socialIcons.push(`<a href="mailto:${esc(item.email)}" onclick="event.stopPropagation()" class="px-1.5 py-0.5 bg-gray-100 rounded hover:bg-gray-200 text-sm" title="Email">‚úâÔ∏è</a>`);
      if (item.facebook) socialIcons.push(`<a href="${esc(ensureHttps(item.facebook))}" onclick="event.stopPropagation()" target="_blank" class="px-1.5 py-0.5 bg-blue-50 rounded hover:bg-blue-100 text-sm" title="Facebook">üìò</a>`);

      // Checkbox for queued and attempting column selection
      const isQueuedSelected = colKey === 'queued' && campaignBoardsState.queuedSelection.has(leadId);
      const isAttemptingSelected = colKey === 'attempting' && campaignBoardsState.attemptingSelection.has(leadId);
      const isSelected = isQueuedSelected || isAttemptingSelected;
      const checkboxHtml = colKey === 'queued' ? `
        <input type="checkbox" class="queued-item-checkbox w-4 h-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500 flex-shrink-0 mt-0.5"
               data-item-id="${leadId}"
               ${isQueuedSelected ? 'checked' : ''}
               onclick="event.stopPropagation(); toggleQueuedItemSelection('${leadId}')"
               ondblclick="event.stopPropagation()">
      ` : colKey === 'attempting' ? `
        <input type="checkbox" class="attempting-item-checkbox w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500 flex-shrink-0 mt-0.5"
               data-item-id="${leadId}"
               ${isAttemptingSelected ? 'checked' : ''}
               onclick="event.stopPropagation(); toggleAttemptingItemSelection('${leadId}')"
               ondblclick="event.stopPropagation()">
      ` : '';

      // Different highlight colors: purple for queued, blue for attempting
      const selectionClass = isQueuedSelected ? 'bg-purple-50 ring-2 ring-purple-300' : isAttemptingSelected ? 'bg-blue-50 ring-2 ring-blue-300' : 'bg-white';

      return `
        <div class="kanban-item campaign-board-item text-xs p-2 ${isDoNotContact ? 'bg-red-50' : selectionClass} border rounded ${hasBeenContacted ? 'border-l-4 border-l-green-500' : 'border-l-4 border-l-gray-300'} relative ${isDoNotContact ? 'opacity-60' : ''} cursor-grab"
             style="user-select:none;-webkit-user-select:none;-webkit-touch-callout:none"
             data-item-id="${leadId}" data-column="${colKey}"
             onclick="openCampaignBoardQuickAction('${leadId}', '${colKey}')">
          ${isDoNotContact ? '<div class="absolute inset-0 flex items-center justify-center pointer-events-none z-10"><span class="text-6xl text-red-500 font-bold opacity-40">‚úï</span></div>' : ''}

          <div class="flex items-start gap-2">
            ${checkboxHtml}
            <div class="flex-1 drag-handle min-w-0">
              <div class="font-medium text-xs break-words ${isDoNotContact ? 'line-through text-gray-500' : ''}">${esc(leadName)}</div>
            </div>
          </div>

          <div class="flex items-center justify-between gap-1 mt-1.5">
            <div class="text-xs text-gray-500 font-medium">
              ${(item.zipCode || item.actualZip) ? `<span class="bg-gray-100 px-1.5 py-0.5 rounded">üìç ${esc(normalizeZip(item.zipCode || item.actualZip))}</span>` : ''}
            </div>
            <div class="flex gap-1 flex-shrink-0">
              <button onclick="event.stopPropagation(); openCampaignBoardQuickAction('${leadId}', '${colKey}')" class="text-indigo-600 hover:text-indigo-800 text-sm" title="View">üëÅ</button>
              <button onclick="event.stopPropagation(); deleteCampaignBoardItem('${leadId}', '${colKey}')" class="text-red-600 hover:text-red-800 text-sm" title="Delete">üóë</button>
            </div>
          </div>

          ${socialIcons.length > 0 ? `<div class="flex flex-wrap gap-1 items-center justify-center pt-1.5 mt-1.5 border-t border-gray-100">${socialIcons.join('')}</div>` : ''}
          ${attemptHTML}
          ${negotiatingHTML}
          ${salesHTML}
        </div>
      `;
    }).join('');

    // Show count (filtered/total if filtering is active)
    const isFiltering = globalFilter !== 'all' && (globalFilter === 'target' ? targetZips.length > 0 : true);
    const countDisplay = isFiltering && items.length !== allItems.length
      ? `${items.length}/${allItems.length}`
      : `${items.length}`;

    // All columns equal width since we only show 3-4 at a time now
    const columnWidth = 'min-width: 280px;';

    // Selection controls for queued column
    const queuedSelectionControls = colKey === 'queued' && items.length > 0 ? `
      <div class="flex items-center gap-2 mb-2 p-2 bg-gray-50 rounded-lg border border-gray-200">
        <label class="flex items-center gap-1 cursor-pointer">
          <input type="checkbox" id="queuedSelectAll" onchange="toggleQueuedSelectAll(this.checked)"
                 class="w-4 h-4 text-purple-600 rounded border-gray-300 focus:ring-purple-500"
                 ${campaignBoardsState.queuedSelection.size === items.length && items.length > 0 ? 'checked' : ''}>
          <span class="text-xs font-medium text-gray-600">Select All</span>
        </label>
        <span id="queuedSelectionCount" class="text-xs text-gray-500">(${campaignBoardsState.queuedSelection.size} selected)</span>
        <button onclick="moveQueuedSelectionToAttempting()"
                class="ml-auto px-3 py-2 text-sm font-medium rounded bg-purple-100 text-purple-700 hover:bg-purple-200 ${campaignBoardsState.queuedSelection.size === 0 ? 'opacity-50 cursor-not-allowed' : ''}"
                style="touch-action:manipulation"
                ${campaignBoardsState.queuedSelection.size === 0 ? 'disabled' : ''}>
          ‚û°Ô∏è Move to Attempting
        </button>
        <button onclick="sendQueuedSelectionToPool()"
                class="px-3 py-2 text-sm font-medium rounded bg-orange-100 text-orange-700 hover:bg-orange-200 ${campaignBoardsState.queuedSelection.size === 0 ? 'opacity-50 cursor-not-allowed' : ''}"
                style="touch-action:manipulation"
                ${campaignBoardsState.queuedSelection.size === 0 ? 'disabled' : ''}>
          ‚Ü©Ô∏è Send to Pool
        </button>
      </div>
    ` : '';

    // Selection controls for attempting column
    const attemptingSelectionControls = colKey === 'attempting' && items.length > 0 ? `
      <div class="flex items-center gap-2 mb-2 p-2 bg-gray-50 rounded-lg border border-gray-200">
        <label class="flex items-center gap-1 cursor-pointer">
          <input type="checkbox" id="attemptingSelectAll" onchange="toggleAttemptingSelectAll(this.checked)"
                 class="w-4 h-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
                 ${campaignBoardsState.attemptingSelection.size === items.length && items.length > 0 ? 'checked' : ''}>
          <span class="text-xs font-medium text-gray-600">Select All</span>
        </label>
        <span id="attemptingSelectionCount" class="text-xs text-gray-500">(${campaignBoardsState.attemptingSelection.size} selected)</span>
        <button onclick="moveAttemptingSelectionToQueued()"
                class="ml-auto px-3 py-2 text-sm font-medium rounded bg-blue-100 text-blue-700 hover:bg-blue-200 ${campaignBoardsState.attemptingSelection.size === 0 ? 'opacity-50 cursor-not-allowed' : ''}"
                style="touch-action:manipulation"
                ${campaignBoardsState.attemptingSelection.size === 0 ? 'disabled' : ''}>
          ‚¨ÖÔ∏è Move to Queued
        </button>
      </div>
    ` : '';

    const selectionControls = queuedSelectionControls || attemptingSelectionControls;

    return `
      <div class="kanban-column campaign-board-column ${phaseSeparator}" data-column="${colKey}" style="${columnWidth} flex: 1;">
        <div class="flex justify-between items-center mb-2">
          <div class="font-semibold text-sm text-${colDef.color}-600">${colDef.icon} ${colDef.title} (${countDisplay})</div>
        </div>
        ${selectionControls}
        ${items.length === 0 ? emptyStates[colKey] : ''}
        ${cardsHTML}
      </div>
    `;
  }).join('');

  // Phase headers
  const phaseHeaders = `
    <div class="flex mb-2 text-xs font-medium">
      <div class="flex-1 text-center text-blue-700 bg-blue-50 py-1 rounded-l">üìû Contact Discovery Phase</div>
      <div class="flex-1 text-center text-yellow-700 bg-yellow-50 py-1 rounded-r">üíº Sales Pipeline Phase</div>
    </div>
  `;

  // Build campaign dropdown options
  const campaignOptions = (state.mailers || []).map(m => {
    const mailerId = m.Mailer_ID || m.id;
    const name = m.Town ? `${m.Town} ${m.Mail_Date || ''}`.trim() : mailerId;
    const selected = mailerId === state.current?.Mailer_ID ? 'selected' : '';
    return `<option value="${esc(mailerId)}" ${selected}>${esc(name)}</option>`;
  }).join('');

  // Build global ZIP filter options
  const targetZipLabel = targetZips.length > 0 ? targetZips.join(', ') : 'Not set';
  const targetZipCount = targetZips.length > 0
    ? columnKeys.reduce((sum, col) => sum + (board.columns[col] || []).filter(item => {
        const z = normalizeZip(item.actualZip || item.zipCode || item.zip);
        return targetZips.includes(z);
      }).length, 0)
    : 0;
  const allItemsCount = columnKeys.reduce((sum, col) => sum + (board.columns[col] || []).length, 0);

  const zipFilterOptions = `
    <option value="target" ${globalFilter === 'target' ? 'selected' : ''}>üìç Target: ${targetZipLabel} (${targetZipCount})</option>
    <option value="all" ${globalFilter === 'all' ? 'selected' : ''}>üåç All ZIPs (${allItemsCount})</option>
    ${allZipsSorted.length > 0 ? '<option disabled>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</option>' : ''}
    ${allZipsSorted.map(zip => {
      const zipCount = columnKeys.reduce((sum, col) => sum + (board.columns[col] || []).filter(item => {
        const z = normalizeZip(item.actualZip || item.zipCode || item.zip);
        return z === zip;
      }).length, 0);
      const isTarget = targetZips.includes(zip);
      return `<option value="${zip}" ${globalFilter === zip ? 'selected' : ''}>${zip}${isTarget ? ' ‚òÖ' : ''} (${zipCount})</option>`;
    }).join('')}
  `;

  // Campaign info bar with dropdown and global ZIP filter (currentView already defined above)
  const viewToggle = `
    <div class="flex items-center gap-3 mb-3 flex-wrap">
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-600">Campaign:</label>
        <select onchange="switchCampaignFromDropdown(this.value)"
                class="px-4 py-3 text-base border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-purple-500 focus:border-purple-500">
          ${campaignOptions}
        </select>
      </div>
      <div class="flex items-center gap-2">
        <label class="text-sm font-medium text-gray-600">ZIP:</label>
        <select onchange="setGlobalZipFilter(this.value)"
                class="px-4 py-3 text-base border border-gray-300 rounded-lg bg-white focus:ring-2 focus:ring-purple-500 focus:border-purple-500">
          ${zipFilterOptions}
        </select>
      </div>
      <div class="flex rounded-lg border border-gray-300 overflow-hidden">
        <button onclick="setCampaignColumnView('discovery')"
                class="px-4 py-2 text-sm font-medium ${currentView === 'discovery' ? 'bg-purple-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'}"
                style="touch-action:manipulation">
          üìû Discovery
        </button>
        <button onclick="setCampaignColumnView('sales')"
                class="px-4 py-2 text-sm font-medium ${currentView === 'sales' ? 'bg-green-600 text-white' : 'bg-white text-gray-700 hover:bg-gray-50'}"
                style="touch-action:manipulation">
          üí∞ Sales
        </button>
      </div>
    </div>
  `;

  // Daily Goal (same as legacy)
  const dailyGoalHTML = `
    <div class="bg-gradient-to-r from-purple-50 to-blue-50 border-2 border-purple-300 rounded-lg p-4 mb-4">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
          <div class="text-2xl">üéØ</div>
          <div>
            <div class="text-sm text-gray-600 font-medium">Daily Outreach Goal</div>
            <div class="text-2xl font-bold text-purple-700">
              ${dailyGoalState.todayCount} <span class="text-gray-400">/</span> ${dailyGoalState.dailyGoal}
              <span class="text-sm text-gray-500 font-normal">contacts today</span>
            </div>
          </div>
        </div>
        <div class="flex items-center gap-3">
          <div class="text-right">
            <div class="text-xs text-gray-500 mb-1">Completion</div>
            <div class="text-lg font-bold ${dailyGoalState.todayCount >= dailyGoalState.dailyGoal ? 'text-green-600' : 'text-purple-600'}">
              ${Math.round((dailyGoalState.todayCount / dailyGoalState.dailyGoal) * 100)}%
            </div>
          </div>
          <button onclick="openDailyGoalSettings()" class="px-4 py-2 bg-purple-600 text-white text-sm rounded hover:bg-purple-700 font-medium">‚öôÔ∏è Settings</button>
        </div>
      </div>
      <div class="mt-3 w-full h-3 bg-gray-200 rounded-full overflow-hidden">
        <div class="h-full bg-gradient-to-r from-purple-500 to-blue-500 rounded-full transition-all duration-300" style="width: ${Math.min((dailyGoalState.todayCount / dailyGoalState.dailyGoal) * 100, 100)}%;"></div>
      </div>
    </div>
  `;

  // Columns wrapper (filters rendered separately for touch responsiveness)
  // Phase headers removed - the Discovery/Sales toggle makes them redundant
  const columnsWrapperHTML = `
    <div style="display: flex; gap: 0.75rem; padding-bottom: 0.5rem;">
      ${columnsHTML}
    </div>
  `;

  dailyGoalContainer.innerHTML = dailyGoalHTML;
  const filtersContainer = document.getElementById('campaignBoardFilters');
  if (filtersContainer) filtersContainer.innerHTML = viewToggle;
  kanbanColumnsContainer.innerHTML = columnsWrapperHTML;

  setupCampaignBoardDrag();
}

// Setup drag and drop for campaign board
function setupCampaignBoardDrag() {
  const items = document.querySelectorAll('.campaign-board-item');

  items.forEach(item => {
    item.setAttribute('draggable', 'true');

    item.ondragstart = function(e) {
      draggedItem = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', this.dataset.itemId);
    };

    item.ondragend = function() {
      this.classList.remove('dragging');
      draggedItem = null;
      document.querySelectorAll('.campaign-board-item.drag-over').forEach(el => el.classList.remove('drag-over'));
      document.querySelectorAll('.campaign-board-column.drag-over-column').forEach(el => el.classList.remove('drag-over-column'));
    };

    item.ondragover = function(e) {
      e.preventDefault();
      e.stopPropagation();
      if (draggedItem && draggedItem !== this) {
        document.querySelectorAll('.campaign-board-item.drag-over').forEach(el => el.classList.remove('drag-over'));
        this.classList.add('drag-over');
      }
    };

    item.ondrop = function(e) {
      e.preventDefault();
      e.stopPropagation();
      handleCampaignBoardDrop(this, e);
    };
  });

  // Column drop zones
  const columns = document.querySelectorAll('.campaign-board-column');
  columns.forEach(col => {
    col.ondragover = function(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      if (!this.classList.contains('drag-over-column')) {
        this.classList.add('drag-over-column');
      }
    };

    col.ondragleave = function(e) {
      if (e.target === this) {
        this.classList.remove('drag-over-column');
      }
    };

    col.ondrop = function(e) {
      e.preventDefault();
      handleCampaignBoardDrop(this, e, true);
    };
  });
}

// Handle campaign board drop
async function handleCampaignBoardDrop(target, e, isColumn = false) {
  document.querySelectorAll('.campaign-board-item.drag-over').forEach(el => el.classList.remove('drag-over'));
  document.querySelectorAll('.campaign-board-column.drag-over-column').forEach(el => el.classList.remove('drag-over-column'));

  if (!draggedItem) return;

  const board = getCurrentCampaignBoard();
  if (!board) return;

  const fromColumn = draggedItem.dataset.column;
  const toColumn = isColumn ? target.dataset.column : target.closest('.campaign-board-column').dataset.column;
  const itemId = draggedItem.dataset.itemId;

  if (moveCampaignBoardItem(itemId, fromColumn, toColumn, board)) {
    // Check for auto-move to clients
    if (toColumn === 'paid-in-full') {
      const business = findBusinessInBoard(itemId, board);
      if (business) {
        setTimeout(() => autoMoveToClients(itemId, board), 500);
      }
    }

    toast(`Moved to ${campaignBoardColumns[toColumn].title}`);

    // Save and re-render
    await saveCampaignBoards();
    renderCampaignBoard();
  }
}

// Open CRM contact card for campaign board item
function openCampaignBoardQuickAction(leadId, columnKey) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  // Find business in the specific column
  const items = board.columns[columnKey] || [];
  const prospect = items.find(item => {
    const itemId = item.id || item._id || item.place_id || item.businessName;
    return String(itemId) === String(leadId);
  });

  if (!prospect) {
    toast('Prospect not found', false);
    return;
  }

  // Check if this is an existing client
  const existingClient = Object.values(crmState.clients).find(c =>
    c.businessName && prospect.businessName &&
    c.businessName.toLowerCase() === (prospect.businessName || prospect.name || '').toLowerCase()
  );

  if (existingClient) {
    // Open CRM card for existing client
    openClientCrmCard(existingClient.id);
  } else {
    // Open CRM card for prospect - include columnKey for stage display
    const prospectWithStage = { ...prospect, columnKey, stage: columnKey };
    openProspectDetailModal(prospectWithStage, 'prospect');
  }
}

// Build outreach history HTML for modal
function buildOutreachHistoryHTML(prospect) {
  const tracking = prospect.attemptTracking;
  const contactTracking = prospect.contactTracking || {};
  const channelStatus = prospect.channelStatus || {};

  // Collect all outreach activity
  const activities = [];

  // From attemptTracking.attemptHistory (new system)
  if (tracking?.attemptHistory?.length > 0) {
    tracking.attemptHistory.forEach(attempt => {
      const channelIcons = { sms: 'üì±', email: 'üìß', facebook: 'üìò', instagram: 'üì∑', linkedin: 'üíº', call: 'üìû' };
      const icon = channelIcons[attempt.channel] || 'üì§';
      const date = attempt.date ? new Date(attempt.date).toLocaleDateString() : 'Unknown date';
      const responded = attempt.responded ? ' <span class="text-green-600 font-medium">‚úì Responded</span>' : '';
      activities.push({
        date: attempt.date || '',
        html: `<div class="flex items-center gap-2 text-sm"><span>${icon}</span><span class="font-medium capitalize">${attempt.channel}</span><span class="text-gray-500">- ${date}</span>${responded}</div>`
      });
    });
  }

  // From channelStatus (shows sent status)
  Object.entries(channelStatus).forEach(([channel, status]) => {
    if (status?.sent && status?.sentDate && !tracking?.attemptHistory?.some(a => a.channel === channel)) {
      const channelIcons = { sms: 'üì±', email: 'üìß', facebook: 'üìò', instagram: 'üì∑', linkedin: 'üíº', call: 'üìû' };
      const icon = channelIcons[channel] || 'üì§';
      const date = new Date(status.sentDate).toLocaleDateString();
      activities.push({
        date: status.sentDate,
        html: `<div class="flex items-center gap-2 text-sm"><span>${icon}</span><span class="font-medium capitalize">${channel}</span><span class="text-gray-500">- ${date}</span></div>`
      });
    }
  });

  // From legacy contactTracking
  const legacyChannels = [
    { key: 'emailed', icon: 'üìß', label: 'Email' },
    { key: 'texted', icon: 'üì±', label: 'SMS' },
    { key: 'called', icon: 'üìû', label: 'Call' },
    { key: 'facebookMessaged', icon: 'üìò', label: 'Facebook' },
    { key: 'linkedinMessaged', icon: 'üíº', label: 'LinkedIn' },
    { key: 'dmed', icon: 'üì∑', label: 'Instagram DM' }
  ];

  legacyChannels.forEach(({ key, icon, label }) => {
    if (contactTracking[key] && activities.length === 0) {
      activities.push({
        date: '',
        html: `<div class="flex items-center gap-2 text-sm"><span>${icon}</span><span class="font-medium">${label}</span><span class="text-green-600">‚úì Contacted</span></div>`
      });
    }
  });

  // Sort by date (newest first)
  activities.sort((a, b) => (b.date || '').localeCompare(a.date || ''));

  // Build attempt progress if tracking exists
  let progressHTML = '';
  if (tracking) {
    const current = tracking.currentAttempt || 0;
    const max = tracking.maxAttempts || 4;
    const progress = Math.min(100, Math.round((current / max) * 100));
    const nextChannel = tracking.nextChannel ? `Next: <span class="font-medium capitalize">${tracking.nextChannel}</span>` : '';

    progressHTML = `
      <div class="mb-3 p-2 bg-purple-50 rounded-lg">
        <div class="flex justify-between text-xs mb-1">
          <span>Attempt ${current} of ${max}</span>
          <span class="text-purple-600 font-medium">${progress}%</span>
        </div>
        <div class="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
          <div class="h-full bg-gradient-to-r from-purple-500 to-blue-500 rounded-full" style="width: ${progress}%"></div>
        </div>
        ${nextChannel ? `<div class="text-xs text-gray-600 mt-1">${nextChannel}</div>` : ''}
      </div>
    `;
  }

  if (activities.length === 0 && !tracking) {
    return `
      <div class="p-4 border-b">
        <div class="text-xs text-gray-600 mb-2 font-medium">üìä Outreach History</div>
        <div class="text-center py-3 text-gray-500 text-sm">
          <span class="text-xl">üì≠</span>
          <p class="mt-1">No outreach recorded yet</p>
        </div>
      </div>
    `;
  }

  return `
    <div class="p-4 border-b bg-gradient-to-r from-purple-50 to-blue-50">
      <div class="text-xs text-gray-600 mb-2 font-medium">üìä Outreach History</div>
      ${progressHTML}
      ${activities.length > 0 ? `
        <div class="space-y-2">
          ${activities.map(a => a.html).join('')}
        </div>
      ` : '<div class="text-sm text-gray-500">No outreach sent yet</div>'}
    </div>
  `;
}

// Business modal for Campaign Board items
function openCampaignBoardBusinessModal(prospect, columnKey, board) {
  const businessName = prospect.businessName || prospect.name || 'Unknown Business';
  const isDoNotContact = prospect.doNotContact === true;
  const leadId = prospect.id || prospect._id || prospect.place_id || prospect.businessName;

  // Check if this is already a client
  const isClient = prospect.source === 'client' ||
    prospect.originalClientId ||
    (prospect.businessName && Object.values(crmState.clients || {}).some(c =>
      c.businessName && c.businessName.toLowerCase() === prospect.businessName.toLowerCase()
    ));

  // Build contact info HTML
  const contactInfo = [];
  if (prospect.phone) contactInfo.push(`<div class="flex items-center gap-2"><span class="text-gray-500">üìû</span><a href="tel:${esc(prospect.phone)}" class="text-blue-600 hover:underline">${esc(prospect.phone)}</a></div>`);
  if (prospect.email) contactInfo.push(`<div class="flex items-center gap-2"><span class="text-gray-500">‚úâÔ∏è</span><a href="mailto:${esc(prospect.email)}" class="text-blue-600 hover:underline">${esc(prospect.email)}</a></div>`);
  if (prospect.website) contactInfo.push(`<div class="flex items-center gap-2"><span class="text-gray-500">üåê</span><a href="${esc(ensureHttps(prospect.website))}" target="_blank" class="text-blue-600 hover:underline">${esc(prospect.website)}</a></div>`);
  if (prospect.address) contactInfo.push(`<div class="flex items-center gap-2"><span class="text-gray-500">üìç</span><span>${esc(prospect.address)}</span></div>`);
  if (prospect.zipCode || prospect.actualZip) contactInfo.push(`<div class="flex items-center gap-2"><span class="text-gray-500">üè∑Ô∏è</span><span>ZIP: ${esc(prospect.zipCode || prospect.actualZip)}</span></div>`);
  if (prospect.category) contactInfo.push(`<div class="flex items-center gap-2"><span class="text-gray-500">üìÅ</span><span>${esc(prospect.category)}</span></div>`);

  // Build social links HTML
  const socialLinks = [];
  if (prospect.facebook) socialLinks.push(`<a href="${esc(ensureHttps(prospect.facebook))}" target="_blank" class="p-2 bg-blue-100 rounded-lg hover:bg-blue-200" title="Facebook">üìò</a>`);
  if (prospect.instagram) socialLinks.push(`<a href="${esc(ensureHttps(prospect.instagram))}" target="_blank" class="p-2 bg-pink-100 rounded-lg hover:bg-pink-200" title="Instagram">üì∑</a>`);
  if (prospect.linkedin) socialLinks.push(`<a href="${esc(ensureHttps(prospect.linkedin))}" target="_blank" class="p-2 bg-blue-100 rounded-lg hover:bg-blue-200" title="LinkedIn">üíº</a>`);

  // Build "Try Another Channel" section for Column 2 (Attempting)
  let tryAnotherChannelHTML = '';
  if (columnKey === 'attempting') {
    const channelStatus = prospect.channelStatus || {};
    const attemptHistory = prospect.attemptTracking?.attemptHistory || [];

    // Define all possible channels with their requirements and actions
    const channels = [
      { key: 'sms', label: 'SMS', icon: 'üì±', requires: 'phone', action: `sms:${prospect.phone || ''}`, color: 'green' },
      { key: 'email', label: 'Email', icon: 'üìß', requires: 'email', action: `mailto:${prospect.email || prospect.emailAddress || ''}`, color: 'blue' },
      { key: 'call', label: 'Call', icon: 'üìû', requires: 'phone', action: `tel:${prospect.phone || ''}`, color: 'yellow' },
      { key: 'facebook', label: 'Facebook', icon: 'üìò', requires: 'facebook', action: prospect.facebook ? ensureHttps(prospect.facebook) : '', color: 'blue' },
      { key: 'instagram', label: 'Instagram', icon: 'üì∑', requires: 'instagram', action: prospect.instagram ? ensureHttps(prospect.instagram) : '', color: 'pink' },
      { key: 'linkedin', label: 'LinkedIn', icon: 'üíº', requires: 'linkedin', action: prospect.linkedin ? ensureHttps(prospect.linkedin) : '', color: 'blue' }
    ];

    // Find channels that are available but not yet used
    const unusedChannels = channels.filter(ch => {
      // Check if the required contact info exists
      const hasContactInfo = ch.requires === 'phone' ? prospect.phone :
                            ch.requires === 'email' ? (prospect.email || prospect.emailAddress) :
                            prospect[ch.requires];
      if (!hasContactInfo) return false;

      // Check if already sent via this channel
      const alreadySent = channelStatus[ch.key]?.sent ||
                         attemptHistory.some(h => h.channel === ch.key && h.sent);
      return !alreadySent;
    });

    if (unusedChannels.length > 0) {
      const channelButtonsHTML = unusedChannels.map(ch => `
        <div class="flex items-center gap-2 bg-white p-2 rounded-lg border border-gray-200">
          <a href="${ch.key === 'facebook' || ch.key === 'instagram' || ch.key === 'linkedin' ? ch.action : ch.action}"
             ${ch.key === 'facebook' || ch.key === 'instagram' || ch.key === 'linkedin' ? 'target="_blank"' : ''}
             class="flex-1 px-3 py-2 bg-${ch.color}-100 hover:bg-${ch.color}-200 rounded-lg text-sm font-medium text-center">
            ${ch.icon} Open ${ch.label}
          </a>
          <button onclick="markCampaignBoardOutreach('${leadId}', '${columnKey}', '${ch.key}')"
                  class="px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm font-medium">
            ‚úì Sent
          </button>
        </div>
      `).join('');

      tryAnotherChannelHTML = `
        <div class="p-4 border-b bg-gradient-to-r from-orange-50 to-yellow-50">
          <div class="text-xs text-gray-600 mb-2 font-medium">üîÑ Try Another Channel (${unusedChannels.length} available)</div>
          <div class="space-y-2">
            ${channelButtonsHTML}
          </div>
        </div>
      `;
    }
  }

  // Column move options for Campaign Board
  const columnOptions = [
    { key: 'queued', label: '1. Queued', icon: 'üìã' },
    { key: 'attempting', label: '2. Attempting', icon: 'üìû' },
    { key: 'negotiating', label: '3. Negotiating', icon: 'üí¨' },
    { key: 'invoice-sent', label: '4. Invoice Sent', icon: 'üìÑ' },
    { key: 'proof-approved', label: '5. Proof Approved', icon: '‚úÖ' },
    { key: 'paid-in-full', label: '6. Paid in Full', icon: 'üí∞' }
  ].filter(col => col.key !== columnKey);

  const moveOptionsHTML = columnOptions.map(col =>
    `<button onclick="moveCampaignBoardItemAndRefresh('${leadId}', '${columnKey}', '${col.key}'); closeCampaignBoardModal();"
            class="px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm">
      ${col.icon} ${col.label}
    </button>`
  ).join('');

  const modalHTML = `
    <div id="campaignBoardModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onclick="if(event.target === this) closeCampaignBoardModal()">
      <div class="bg-white rounded-xl shadow-2xl max-w-md w-full mx-4 max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
        <!-- Header -->
        <div class="flex justify-between items-center p-4 border-b bg-gray-50 rounded-t-xl">
          <h3 class="font-bold text-lg">${esc(businessName)}</h3>
          <button onclick="closeCampaignBoardModal()" class="text-gray-500 hover:text-gray-700 text-2xl leading-none">&times;</button>
        </div>

        <!-- Quick Actions -->
        <div class="p-4 bg-gradient-to-r from-purple-50 to-blue-50 border-b">
          <div class="text-xs text-gray-600 mb-2 font-medium">Quick Actions</div>
          <div class="flex gap-2">
            <button onclick="toggleCampaignBoardDoNotContact('${leadId}', '${columnKey}'); closeCampaignBoardModal();"
                    class="flex-1 px-3 py-2 ${isDoNotContact ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700'} text-white text-sm rounded-lg font-medium">
              üö´ ${isDoNotContact ? 'Remove DNC' : 'Not Interested'}
            </button>
            ${isClient
              ? `<button onclick="removeCampaignBoardItem('${leadId}', '${columnKey}'); closeCampaignBoardModal();" class="flex-1 px-3 py-2 bg-green-600 text-white text-sm rounded-lg hover:bg-green-700 font-medium">
                  ‚úÖ Current Client
                </button>`
              : `<button onclick="convertCampaignBoardToClient('${leadId}', '${columnKey}'); closeCampaignBoardModal();" class="flex-1 px-3 py-2 bg-purple-600 text-white text-sm rounded-lg hover:bg-purple-700 font-medium">
                  üë§ Convert to Client
                </button>`
            }
          </div>
        </div>

        <!-- Editable Contact Info -->
        <div class="p-4 border-b">
          <div class="flex items-center justify-between mb-2">
            <div class="text-xs text-gray-600 font-medium">Contact Info</div>
            <button onclick="toggleCampaignBoardEditMode('${leadId}', '${columnKey}')" id="cbEditToggle" class="text-xs text-indigo-600 hover:text-indigo-800 font-medium">
              ‚úèÔ∏è Edit
            </button>
          </div>
          <div id="cbContactDisplay" class="space-y-2 text-sm">
            ${contactInfo.length > 0 ? contactInfo.join('') : '<div class="text-gray-400 text-sm">No contact info - click Edit to add</div>'}
          </div>
          <div id="cbContactEdit" class="hidden space-y-2">
            <div>
              <label class="text-xs text-gray-500">Phone</label>
              <input type="tel" id="cbEditPhone" value="${esc(prospect.phone || '')}" class="w-full px-2 py-1 border rounded text-sm" placeholder="Phone number">
            </div>
            <div>
              <label class="text-xs text-gray-500">Email</label>
              <input type="email" id="cbEditEmail" value="${esc(prospect.email || '')}" class="w-full px-2 py-1 border rounded text-sm" placeholder="Email address">
            </div>
            <div>
              <label class="text-xs text-gray-500">Category</label>
              <input type="text" id="cbEditCategory" value="${esc(prospect.category || '')}" class="w-full px-2 py-1 border rounded text-sm" placeholder="Business category">
            </div>
            <div class="flex gap-2 pt-2">
              <button onclick="saveCampaignBoardContactEdit('${leadId}', '${columnKey}')" class="flex-1 px-3 py-1.5 bg-green-600 text-white text-sm rounded hover:bg-green-700 font-medium">
                üíæ Save
              </button>
              <button onclick="toggleCampaignBoardEditMode('${leadId}', '${columnKey}')" class="px-3 py-1.5 bg-gray-200 text-gray-700 text-sm rounded hover:bg-gray-300">
                Cancel
              </button>
            </div>
          </div>
        </div>

        <!-- Try Another Channel (Column 2 only) -->
        ${tryAnotherChannelHTML}

        <!-- Email Reply Templates -->
        <div class="p-4 border-b bg-blue-50">
          <div class="text-xs text-gray-600 mb-2 font-medium">üìß Reply with Template</div>
          ${(prospect.email || prospect.emailAddress) ? `
            <div class="grid grid-cols-3 gap-2">
              <button onclick="openEmailWithTemplate('${esc(prospect.email || prospect.emailAddress)}', 'moreInfo', '${esc(businessName)}')"
                      class="px-2 py-2 bg-white hover:bg-blue-100 border border-blue-200 rounded-lg text-xs font-medium text-center">
                ‚ÑπÔ∏è More Info
              </button>
              <button onclick="openEmailWithTemplate('${esc(prospect.email || prospect.emailAddress)}', 'pricing', '${esc(businessName)}')"
                      class="px-2 py-2 bg-white hover:bg-blue-100 border border-blue-200 rounded-lg text-xs font-medium text-center">
                üí∞ Pricing
              </button>
              <button onclick="openEmailWithTemplate('${esc(prospect.email || prospect.emailAddress)}', 'scheduleCall', '${esc(businessName)}')"
                      class="px-2 py-2 bg-white hover:bg-blue-100 border border-blue-200 rounded-lg text-xs font-medium text-center">
                üìû Schedule
              </button>
              <button onclick="openEmailWithTemplate('${esc(prospect.email || prospect.emailAddress)}', 'followUp', '${esc(businessName)}')"
                      class="px-2 py-2 bg-white hover:bg-blue-100 border border-blue-200 rounded-lg text-xs font-medium text-center">
                üîÑ Follow Up
              </button>
              <button onclick="openEmailWithTemplate('${esc(prospect.email || prospect.emailAddress)}', 'proofReady', '${esc(businessName)}')"
                      class="px-2 py-2 bg-white hover:bg-blue-100 border border-blue-200 rounded-lg text-xs font-medium text-center">
                ‚úÖ Proof Ready
              </button>
              <button onclick="openEmailWithTemplate('${esc(prospect.email || prospect.emailAddress)}', 'invoiceSent', '${esc(businessName)}')"
                      class="px-2 py-2 bg-white hover:bg-blue-100 border border-blue-200 rounded-lg text-xs font-medium text-center">
                üìÑ Invoice
              </button>
            </div>
          ` : `
            <div class="text-center py-3 text-gray-500 text-sm">
              <span class="text-xl">üì≠</span>
              <p class="mt-1">No email on file for this business</p>
              <p class="text-xs mt-1">Add an email in Business Pool to enable templates</p>
            </div>
          `}
        </div>

        <!-- Social Links -->
        ${socialLinks.length > 0 ? `
          <div class="p-4 border-b">
            <div class="text-xs text-gray-600 mb-2 font-medium">Social Links</div>
            <div class="flex gap-2">${socialLinks.join('')}</div>
          </div>
        ` : ''}

        <!-- Outreach History -->
        ${buildOutreachHistoryHTML(prospect)}

        <!-- Mark Outreach Sent -->
        <div class="p-4 border-b">
          <div class="text-xs text-gray-600 mb-2 font-medium">üì§ Mark Outreach Sent</div>
          <div class="grid grid-cols-3 gap-2">
            <button onclick="markCampaignBoardOutreach('${leadId}', '${columnKey}', 'sms')"
                    class="px-2 py-2 bg-green-100 hover:bg-green-200 border border-green-300 rounded-lg text-xs font-medium">
              üì± SMS
            </button>
            <button onclick="markCampaignBoardOutreach('${leadId}', '${columnKey}', 'email')"
                    class="px-2 py-2 bg-blue-100 hover:bg-blue-200 border border-blue-300 rounded-lg text-xs font-medium">
              üìß Email
            </button>
            <button onclick="markCampaignBoardOutreach('${leadId}', '${columnKey}', 'call')"
                    class="px-2 py-2 bg-yellow-100 hover:bg-yellow-200 border border-yellow-300 rounded-lg text-xs font-medium">
              üìû Call
            </button>
            <button onclick="markCampaignBoardOutreach('${leadId}', '${columnKey}', 'facebook')"
                    class="px-2 py-2 bg-blue-100 hover:bg-blue-200 border border-blue-300 rounded-lg text-xs font-medium">
              üìò Facebook
            </button>
            <button onclick="markCampaignBoardOutreach('${leadId}', '${columnKey}', 'instagram')"
                    class="px-2 py-2 bg-pink-100 hover:bg-pink-200 border border-pink-300 rounded-lg text-xs font-medium">
              üì∑ Instagram
            </button>
            <button onclick="markCampaignBoardOutreach('${leadId}', '${columnKey}', 'linkedin')"
                    class="px-2 py-2 bg-blue-100 hover:bg-blue-200 border border-blue-300 rounded-lg text-xs font-medium">
              üíº LinkedIn
            </button>
          </div>
        </div>

        <!-- Move to Column -->
        <div class="p-4 border-b">
          <div class="text-xs text-gray-600 mb-2 font-medium">Move to Column</div>
          <div class="grid grid-cols-2 gap-2">
            ${moveOptionsHTML}
          </div>
        </div>

        <!-- Delete -->
        <div class="p-4">
          <button onclick="deleteCampaignBoardItem('${leadId}', '${columnKey}'); closeCampaignBoardModal();"
                  class="w-full px-3 py-2 bg-red-100 text-red-700 hover:bg-red-200 rounded-lg text-sm font-medium">
            üóëÔ∏è Remove from Board
          </button>
        </div>
      </div>
    </div>
  `;

  // Remove existing modal if any
  const existing = document.getElementById('campaignBoardModal');
  if (existing) existing.remove();

  document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function closeCampaignBoardModal() {
  const modal = document.getElementById('campaignBoardModal');
  if (modal) modal.remove();
}

// Toggle edit mode for contact info in Campaign Board modal
function toggleCampaignBoardEditMode(leadId, columnKey) {
  const displayEl = document.getElementById('cbContactDisplay');
  const editEl = document.getElementById('cbContactEdit');
  const toggleBtn = document.getElementById('cbEditToggle');

  if (displayEl && editEl) {
    const isEditing = !editEl.classList.contains('hidden');
    displayEl.classList.toggle('hidden', !isEditing);
    editEl.classList.toggle('hidden', isEditing);
    if (toggleBtn) {
      toggleBtn.textContent = isEditing ? '‚úèÔ∏è Edit' : '‚ùå Cancel';
    }
  }
}

// Save contact info edits for Campaign Board item
async function saveCampaignBoardContactEdit(leadId, columnKey) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  const items = board.columns[columnKey] || [];
  const business = items.find(item => {
    const itemId = item.id || item._id || item.place_id || item.businessName;
    return String(itemId) === String(leadId);
  });

  if (!business) {
    toast('Business not found', false);
    return;
  }

  // Get values from edit form
  const newPhone = document.getElementById('cbEditPhone')?.value.trim() || '';
  const newEmail = document.getElementById('cbEditEmail')?.value.trim() || '';
  const newCategory = document.getElementById('cbEditCategory')?.value.trim() || '';

  // Update the business object
  business.phone = newPhone;
  business.email = newEmail;
  if (newCategory) business.category = newCategory;

  // Save to cloud
  await saveCampaignBoards();

  // Close modal and re-render
  closeCampaignBoardModal();
  renderCampaignBoard();

  toast('‚úÖ Contact info updated');
  console.log(`‚úÖ Updated ${business.businessName}: phone=${newPhone}, email=${newEmail}, category=${newCategory}`);
}

// Mark outreach sent for a campaign board item
async function markCampaignBoardOutreach(leadId, columnKey, channel) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  const items = board.columns[columnKey] || [];
  const business = items.find(item => {
    const itemId = item.id || item._id || item.place_id || item.businessName;
    return String(itemId) === String(leadId);
  });

  if (!business) {
    toast('Business not found', false);
    return;
  }

  const now = new Date().toISOString();

  // Initialize tracking structures if needed
  if (!business.attemptTracking) {
    business.attemptTracking = {
      currentAttempt: 1,
      maxAttempts: board.config?.maxAttempts || 4,
      attemptHistory: [],
      nextChannel: null,
      nextActionDate: null
    };
  }

  if (!business.channelStatus) {
    business.channelStatus = {
      sms: { available: !!business.phone, sent: false },
      email: { available: !!business.email, sent: false },
      facebook: { available: !!business.facebook, sent: false },
      instagram: { available: !!business.instagram, sent: false },
      linkedin: { available: !!business.linkedin, sent: false },
      call: { available: !!business.phone, sent: false }
    };
  }

  // Record the outreach
  business.channelStatus[channel] = business.channelStatus[channel] || { available: true, sent: false };
  business.channelStatus[channel].sent = true;
  business.channelStatus[channel].sentDate = now;

  // Add to attempt history
  business.attemptTracking.attemptHistory.push({
    date: now,
    channel: channel,
    sent: true,
    responded: false
  });

  // Update attempt count if this is a new attempt cycle
  const attemptsOnThisRound = business.attemptTracking.attemptHistory.filter(h => {
    const historyDate = new Date(h.date);
    const daysSinceFirst = business.attemptTracking.attemptHistory.length > 0
      ? (historyDate - new Date(business.attemptTracking.attemptHistory[0].date)) / (1000 * 60 * 60 * 24)
      : 0;
    return daysSinceFirst < (board.config?.daysBetweenAttempts || 3);
  }).length;

  if (attemptsOnThisRound === 1) {
    business.attemptTracking.currentAttempt = Math.min(
      (business.attemptTracking.currentAttempt || 0) + 1,
      business.attemptTracking.maxAttempts
    );
  }

  // Calculate next channel
  const priority = board.config?.channelPriority || ['sms', 'email', 'facebook', 'call'];
  const nextChannel = priority.find(ch =>
    business.channelStatus[ch]?.available && !business.channelStatus[ch]?.sent
  );
  business.attemptTracking.nextChannel = nextChannel || null;

  // Move to attempting column if in queued
  if (columnKey === 'queued') {
    const queuedItems = board.columns['queued'];
    const idx = queuedItems.findIndex(item => {
      const itemId = item.id || item._id || item.place_id || item.businessName;
      return String(itemId) === String(leadId);
    });
    if (idx !== -1) {
      queuedItems.splice(idx, 1);
      board.columns['attempting'].push(business);
    }
  }

  await saveCampaignBoards();
  closeCampaignBoardModal();
  renderCampaignBoard();

  const channelNames = { sms: 'SMS', email: 'Email', call: 'Call', facebook: 'Facebook', instagram: 'Instagram', linkedin: 'LinkedIn' };
  toast(`‚úÖ ${channelNames[channel] || channel} marked as sent!`);

  // Increment daily goal counter
  incrementDailyGoal();
}

// Email reply templates for follow-up
const emailReplyTemplates = {
  moreInfo: {
    name: 'More Info',
    icon: '‚ÑπÔ∏è',
    subject: 'Re: Advertising Opportunity - More Information',
    body: `Hi [NAME],

Thank you for your interest! I'd be happy to share more details.

Our 9x12 mailer reaches [NUMBER] households in your area each month. Your ad would appear alongside other local businesses, giving you premium exposure to potential customers right in their mailboxes.

Here's what's included:
‚Ä¢ Professional ad design (we handle everything)
‚Ä¢ Distribution to targeted ZIP codes
‚Ä¢ Tracking and analytics

Would you like to schedule a quick call to discuss how this could work for your business?

Best regards`
  },
  pricing: {
    name: 'Pricing',
    icon: 'üí∞',
    subject: 'Re: Advertising Rates & Packages',
    body: `Hi [NAME],

Thanks for asking about our rates! Here's a quick overview:

[INSERT YOUR PRICING DETAILS HERE]

The great thing about our mailer is that you're sharing the cost with other local businesses, making it much more affordable than solo direct mail campaigns.

I'd love to put together a custom quote based on your goals. When would be a good time for a quick call?

Best regards`
  },
  scheduleCall: {
    name: 'Schedule Call',
    icon: 'üìû',
    subject: 'Re: Let\'s Schedule a Quick Call',
    body: `Hi [NAME],

I'd love to chat and answer any questions you have!

I'm available:
‚Ä¢ [DAY/TIME OPTION 1]
‚Ä¢ [DAY/TIME OPTION 2]
‚Ä¢ [DAY/TIME OPTION 3]

Just let me know what works best for you, or feel free to call me directly at [YOUR PHONE].

Looking forward to speaking with you!

Best regards`
  },
  followUp: {
    name: 'Follow Up',
    icon: 'üîÑ',
    subject: 'Re: Following Up - Local Advertising Opportunity',
    body: `Hi [NAME],

I wanted to follow up on my previous message about advertising in our local mailer.

I know you're busy running your business, so I'll keep this brief - we have a spot opening up in next month's edition and I thought of you.

Is this something you'd like to explore? Happy to answer any questions.

Best regards`
  },
  proofReady: {
    name: 'Proof Ready',
    icon: '‚úÖ',
    subject: 'Your Ad Proof is Ready for Review',
    body: `Hi [NAME],

Great news! Your ad proof is ready for review.

[ATTACH PROOF OR INSERT LINK]

Please take a look and let me know:
1. If everything looks good and you're ready to approve, or
2. Any changes you'd like me to make

Once approved, your ad will appear in the [MONTH] edition reaching [NUMBER] local households.

Let me know if you have any questions!

Best regards`
  },
  invoiceSent: {
    name: 'Invoice',
    icon: 'üìÑ',
    subject: 'Invoice for Your Ad in [MONTH] Mailer',
    body: `Hi [NAME],

Thank you for choosing to advertise with us! I've attached your invoice for the [MONTH] edition.

Invoice Details:
‚Ä¢ Amount: $[AMOUNT]
‚Ä¢ Due Date: [DATE]
‚Ä¢ Payment Methods: [PAYMENT OPTIONS]

Your ad is scheduled to reach [NUMBER] households in [AREA].

Please let me know if you have any questions. Looking forward to a great campaign!

Best regards`
  }
};

// Open email client with template
function openEmailWithTemplate(email, templateKey, businessName) {
  const template = emailReplyTemplates[templateKey];
  if (!template || !email) {
    toast('No email address available', false);
    return;
  }

  // Replace [NAME] placeholder with first name or business name
  let body = template.body;
  const firstName = businessName ? businessName.split(' ')[0] : 'there';
  body = body.replace(/\[NAME\]/g, firstName);

  // Encode for mailto URL
  const subject = encodeURIComponent(template.subject);
  const encodedBody = encodeURIComponent(body);

  const mailtoUrl = `mailto:${encodeURIComponent(email)}?subject=${subject}&body=${encodedBody}`;
  window.open(mailtoUrl, '_blank');

  toast(`Opening ${template.name} template in email client`);
}

async function moveCampaignBoardItemAndRefresh(leadId, fromColumn, toColumn) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  // Ensure destination column exists
  if (!board.columns[toColumn]) {
    board.columns[toColumn] = [];
  }

  const fromItems = board.columns[fromColumn] || [];
  const toItems = board.columns[toColumn];

  const getItemId = (item) => item.id || item._id || item.place_id || item.businessName;

  const idx = fromItems.findIndex(item => String(getItemId(item)) === String(leadId));
  if (idx === -1) {
    console.warn(`Item ${leadId} not found in ${fromColumn}`);
    return;
  }

  const business = fromItems[idx];
  const businessId = getItemId(business);

  // Check if item already exists in destination column (prevent duplicates)
  const existsInDest = toItems.some(item => String(getItemId(item)) === String(businessId));
  if (existsInDest) {
    console.warn(`Item ${businessId} already exists in ${toColumn}, removing from source only`);
    fromItems.splice(idx, 1);
    await saveCampaignBoards();
    renderCampaignBoard();
    toast(`Item was already in ${toColumn.replace(/-/g, ' ')}`);
    return;
  }

  // Remove from source
  fromItems.splice(idx, 1);

  // Initialize attempt tracking when entering "attempting" column
  if (toColumn === 'attempting') {
    if (!business.attemptTracking || business.attemptTracking.currentAttempt === 0) {
      const now = new Date().toISOString();
      const channelStatus = {
        sms: { available: !!business.phone, sent: false },
        email: { available: !!business.email, sent: false },
        facebook: { available: !!business.facebook, sent: false },
        instagram: { available: !!business.instagram, sent: false },
        linkedin: { available: !!business.linkedin, sent: false },
        call: { available: !!business.phone, sent: false }
      };
      const priority = board.config?.channelPriority || ['sms', 'email', 'facebook', 'call'];
      const nextChannel = priority.find(ch => channelStatus[ch]?.available) || null;

      business.attemptTracking = {
        currentAttempt: 1,
        maxAttempts: board.config?.maxAttempts || 4,
        attemptHistory: [],
        nextChannel: nextChannel,
        nextActionDate: now.split('T')[0]
      };
      business.channelStatus = channelStatus;
    }
  }

  // Update sales info for sales columns
  const now = new Date().toISOString();
  if (toColumn === 'invoice-sent' && !business.salesInfo?.invoiceSentDate) {
    business.salesInfo = business.salesInfo || {};
    business.salesInfo.invoiceSentDate = now;
  } else if (toColumn === 'proof-approved' && !business.salesInfo?.proofApprovedDate) {
    business.salesInfo = business.salesInfo || {};
    business.salesInfo.proofApprovedDate = now;
  } else if (toColumn === 'paid-in-full') {
    business.salesInfo = business.salesInfo || {};
    business.salesInfo.paidDate = now;
  }

  // Add to destination
  toItems.push(business);

  await saveCampaignBoards();
  renderCampaignBoard();
  toast(`Moved to ${toColumn.replace(/-/g, ' ')}`);
}

async function toggleCampaignBoardDoNotContact(leadId, columnKey) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  const items = board.columns[columnKey];
  const item = items.find(item => {
    const itemId = item.id || item._id || item.place_id || item.businessName;
    return String(itemId) === String(leadId);
  });

  if (item) {
    item.doNotContact = !item.doNotContact;
    await saveCampaignBoards();
    renderCampaignBoard();
    toast(item.doNotContact ? 'Marked as Do Not Contact' : 'Removed Do Not Contact flag');
  }
}

async function removeCampaignBoardItem(leadId, columnKey) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  const items = board.columns[columnKey];
  const idx = items.findIndex(item => {
    const itemId = item.id || item._id || item.place_id || item.businessName;
    return String(itemId) === String(leadId);
  });

  if (idx !== -1) {
    items.splice(idx, 1);
    await saveCampaignBoards();
    renderCampaignBoard();
    toast('Removed from campaign board');
  }
}

async function convertCampaignBoardToClient(leadId, columnKey) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  const items = board.columns[columnKey];
  const idx = items.findIndex(item => {
    const itemId = item.id || item._id || item.place_id || item.businessName;
    return String(itemId) === String(leadId);
  });

  if (idx === -1) return;

  const prospect = items[idx];

  // Create client from prospect
  const clientId = `client_${Date.now()}`;
  const newClient = {
    id: clientId,
    businessName: prospect.businessName || prospect.name,
    phone: prospect.phone || '',
    email: prospect.email || '',
    website: prospect.website || '',
    address: prospect.address || '',
    zipCode: prospect.zipCode || prospect.actualZip || '',
    category: prospect.category || '',
    facebook: prospect.facebook || '',
    instagram: prospect.instagram || '',
    linkedin: prospect.linkedin || '',
    notes: prospect.notes || '',
    createdAt: new Date().toISOString(),
    source: 'campaign-board-conversion'
  };

  // Add to clients
  if (!crmState.clients) crmState.clients = {};
  crmState.clients[clientId] = newClient;
  await saveToCloud('clients', crmState.clients);

  // Remove from campaign board
  items.splice(idx, 1);
  await saveCampaignBoards();
  renderCampaignBoard();

  toast(`${newClient.businessName} converted to client!`);
}

// Toggle selection of a single item in queued column
function toggleQueuedItemSelection(leadId) {
  if (campaignBoardsState.queuedSelection.has(leadId)) {
    campaignBoardsState.queuedSelection.delete(leadId);
  } else {
    campaignBoardsState.queuedSelection.add(leadId);
  }
  renderCampaignBoard();
}

// Toggle select all in queued column
function toggleQueuedSelectAll(checked) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  const items = board.columns['queued'] || [];

  if (checked) {
    // Select all visible items
    items.forEach(item => {
      const id = String(item.id);
      campaignBoardsState.queuedSelection.add(id);
    });
  } else {
    // Deselect all
    campaignBoardsState.queuedSelection.clear();
  }
  renderCampaignBoard();
}

// Send selected queued items back to pool
async function sendQueuedSelectionToPool() {
  const selectedIds = Array.from(campaignBoardsState.queuedSelection);
  if (selectedIds.length === 0) {
    toast('No businesses selected', false);
    return;
  }

  if (!confirm(`Send ${selectedIds.length} business${selectedIds.length > 1 ? 'es' : ''} back to the pool?`)) {
    return;
  }

  const board = getCurrentCampaignBoard();
  if (!board) return;

  const queuedItems = board.columns['queued'] || [];
  let movedCount = 0;

  // Process each selected item
  for (const leadId of selectedIds) {
    const idx = queuedItems.findIndex(item => String(item.id) === leadId);
    if (idx !== -1) {
      const item = queuedItems[idx];

      // Add to manual prospects (pool)
      // Clear contact tracking so they start fresh when re-added
      const poolItem = {
        ...item,
        id: item.id || item.placeId || `pool_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        source: 'returned-from-pipeline',
        returnedAt: new Date().toISOString(),
        contactTracking: null,  // Clear so they show as not contacted when re-added
        attemptTracking: null,  // Reset attempt tracking too
        channelStatus: null     // Reset channel status
      };

      if (!prospectPoolState.manualProspects) {
        prospectPoolState.manualProspects = [];
      }

      // Check if already in pool
      const existsInPool = prospectPoolState.manualProspects.some(p =>
        p.placeId === item.placeId || p.id === item.id
      );

      if (!existsInPool) {
        prospectPoolState.manualProspects.push(poolItem);
      }

      // Remove from queued column
      queuedItems.splice(idx, 1);
      movedCount++;
    }
  }

  // Clear selection
  campaignBoardsState.queuedSelection.clear();

  // Save changes
  await saveCampaignBoards();
  await saveToCloud('manualProspects', prospectPoolState.manualProspects);

  // Refresh UI
  renderCampaignBoard();

  toast(`‚úÖ Moved ${movedCount} business${movedCount > 1 ? 'es' : ''} back to pool`);
}

// Move selected queued items to Attempting column
async function moveQueuedSelectionToAttempting() {
  const selectedIds = Array.from(campaignBoardsState.queuedSelection);
  if (selectedIds.length === 0) {
    toast('No businesses selected', false);
    return;
  }

  const board = getCurrentCampaignBoard();
  if (!board) return;

  const queuedItems = board.columns['queued'] || [];
  if (!board.columns['attempting']) board.columns['attempting'] = [];
  const attemptingItems = board.columns['attempting'];

  let movedCount = 0;

  // Process each selected item (in reverse to avoid index shifting issues)
  const idsToMove = [...selectedIds];
  for (const leadId of idsToMove) {
    const idx = queuedItems.findIndex(item => String(item.id) === leadId);
    if (idx !== -1) {
      const item = queuedItems.splice(idx, 1)[0];

      // Initialize attempt tracking if not present
      if (!item.attemptTracking) {
        item.attemptTracking = {
          currentAttempt: 1,
          maxAttempts: 4,
          attemptHistory: []
        };
      }

      attemptingItems.push(item);
      movedCount++;
    }
  }

  // Clear selection
  campaignBoardsState.queuedSelection.clear();

  // Save changes
  await saveCampaignBoards();

  // Refresh UI
  renderCampaignBoard();

  toast(`‚úÖ Moved ${movedCount} business${movedCount > 1 ? 'es' : ''} to Attempting`);
}

// Toggle selection of a single item in attempting column
function toggleAttemptingItemSelection(leadId) {
  if (campaignBoardsState.attemptingSelection.has(leadId)) {
    campaignBoardsState.attemptingSelection.delete(leadId);
  } else {
    campaignBoardsState.attemptingSelection.add(leadId);
  }
  renderCampaignBoard();
}

// Toggle select all for attempting column
function toggleAttemptingSelectAll(checked) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  const items = board.columns['attempting'] || [];
  if (checked) {
    // Select all visible items
    items.forEach(item => {
      const id = String(item.id);
      campaignBoardsState.attemptingSelection.add(id);
    });
  } else {
    // Deselect all
    campaignBoardsState.attemptingSelection.clear();
  }
  renderCampaignBoard();
}

// Move selected attempting items back to Queued column
async function moveAttemptingSelectionToQueued() {
  const selectedIds = Array.from(campaignBoardsState.attemptingSelection);
  if (selectedIds.length === 0) {
    toast('No businesses selected', false);
    return;
  }

  const board = getCurrentCampaignBoard();
  if (!board) return;

  const attemptingItems = board.columns['attempting'] || [];
  if (!board.columns['queued']) board.columns['queued'] = [];
  const queuedItems = board.columns['queued'];

  let movedCount = 0;

  // Process each selected item
  const idsToMove = [...selectedIds];
  for (const leadId of idsToMove) {
    const idx = attemptingItems.findIndex(item => String(item.id) === leadId);
    if (idx !== -1) {
      const item = attemptingItems.splice(idx, 1)[0];
      queuedItems.push(item);
      movedCount++;
    }
  }

  // Clear selection
  campaignBoardsState.attemptingSelection.clear();

  // Save changes
  await saveCampaignBoards();

  // Refresh UI
  renderCampaignBoard();

  toast(`‚úÖ Moved ${movedCount} business${movedCount > 1 ? 'es' : ''} back to Queued`);
}

// Delete item from campaign board
async function deleteCampaignBoardItem(leadId, columnKey) {
  if (!confirm('Remove this business from the campaign board?')) return;

  const board = getCurrentCampaignBoard();
  if (!board) return;

  const items = board.columns[columnKey];
  const idx = items.findIndex(item => String(item.id) === String(leadId));

  if (idx !== -1) {
    items.splice(idx, 1);
    await saveCampaignBoards();
    renderCampaignBoard();
    toast('Removed from campaign board');
  }
}

// Set ZIP filter for campaign board column
// Legacy per-column filter (kept for backwards compatibility)
function setCampaignBoardZipFilter(columnKey, zip) {
  // Redirect to global filter
  setGlobalZipFilter(zip || 'all');
}

// Set global ZIP filter for entire Campaign Board
function setGlobalZipFilter(filter) {
  campaignBoardsState.globalZipFilter = filter || 'target';
  console.log(`üìç Global ZIP filter set: "${filter}"`);
  renderCampaignBoard();
}

// Toggle between Discovery and Sales column views
function setCampaignColumnView(view) {
  campaignBoardsState.columnView = view || 'discovery';
  console.log(`üìä Column view set: "${view}"`);
  renderCampaignBoard();
}

// Toggle between legacy kanban and campaign board
// Switch campaign from the dropdown selector
function switchCampaignFromDropdown(mailerId) {
  if (!mailerId) return;

  // Find the mailer index
  const idx = state.mailers.findIndex(m => (m.Mailer_ID || m.id) === mailerId);
  if (idx === -1) {
    toast('Campaign not found', false);
    return;
  }

  // Use pickCampaign to properly switch campaigns (this sets state.current and re-renders)
  pickCampaign({ target: { value: idx.toString() } });
  toast(`Switched to campaign`);
}

function toggleCampaignBoardView() {
  // Simply toggle the state flag
  campaignBoardsState.useLegacyKanban = !campaignBoardsState.useLegacyKanban;

  console.log('üîÑ Toggle clicked. useLegacyKanban is now:', campaignBoardsState.useLegacyKanban);

  if (campaignBoardsState.useLegacyKanban) {
    console.log('üìã Rendering Legacy Kanban...');
    renderKanban();
    toast('Switched to Classic Kanban');
  } else {
    console.log('üìä Rendering Campaign Board...');
    renderCampaignBoard();
    toast('Switched to 6-Column Campaign Board');
  }
}


// Open campaign configuration modal
function openCampaignConfigModal() {
  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign selected');
    return;
  }

  const config = board.config;
  const targetZips = config.targetZips || [];
  const channelOptions = ['sms', 'email', 'facebook', 'instagram', 'linkedin', 'call'];

  // Get all available ZIPs from the board data
  const columnKeys = ['queued', 'attempting', 'negotiating', 'invoice-sent', 'proof-approved', 'paid-in-full'];
  const availableZips = new Set();
  columnKeys.forEach(colKey => {
    const items = board.columns[colKey] || [];
    items.forEach(item => {
      const zip = item.actualZip || item.zipCode || item.zip;
      if (zip) {
        const normalized = String(zip).split('-')[0].substring(0, 5);
        if (normalized) availableZips.add(normalized);
      }
    });
  });
  const sortedAvailableZips = Array.from(availableZips).sort();

  const modalHTML = `
    <div id="campaignConfigModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onclick="if(event.target === this) closeCampaignConfigModal()">
      <div class="bg-white rounded-xl shadow-2xl p-6 max-w-md w-full mx-4 max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
        <h3 class="text-xl font-bold mb-4">‚öôÔ∏è Campaign Configuration</h3>
        <p class="text-sm text-gray-500 mb-4">Campaign: <strong>${esc(board.name)}</strong></p>

        <div class="space-y-4">
          <!-- Target ZIP Codes -->
          <div class="p-3 bg-blue-50 rounded-lg border border-blue-200">
            <label class="block text-sm font-medium text-blue-800 mb-2">üìç Target ZIP Codes</label>
            <p class="text-xs text-blue-600 mb-2">Filter the board to show only businesses in these ZIPs</p>
            <div id="targetZipsList" class="flex flex-wrap gap-2 mb-2">
              ${targetZips.length > 0 ? targetZips.map(zip => `
                <span class="inline-flex items-center gap-1 px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-sm">
                  ${zip}
                  <button onclick="removeTargetZip('${zip}')" class="text-blue-600 hover:text-blue-800 font-bold">√ó</button>
                </span>
              `).join('') : '<span class="text-xs text-gray-500">No target ZIPs set (showing all)</span>'}
            </div>
            <div class="flex gap-2">
              <select id="addTargetZipSelect" class="flex-1 px-2 py-1 text-sm border rounded-lg">
                <option value="">Add ZIP code...</option>
                ${sortedAvailableZips.filter(z => !targetZips.includes(z)).map(zip => `
                  <option value="${zip}">${zip}</option>
                `).join('')}
              </select>
              <button onclick="addTargetZipFromSelect()" class="px-3 py-1 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700">Add</button>
            </div>
            <div class="mt-2">
              <input type="text" id="manualZipInput" placeholder="Or type ZIP code" maxlength="5"
                     class="w-full px-2 py-1 text-sm border rounded-lg" onkeypress="if(event.key==='Enter') addManualTargetZip()">
            </div>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Channel Priority (drag to reorder)</label>
            <div id="channelPriorityList" class="space-y-1">
              ${config.channelPriority.map((ch, idx) => `
                <div class="flex items-center gap-2 p-2 bg-gray-50 rounded border cursor-move" data-channel="${ch}">
                  <span class="text-gray-400">‚ò∞</span>
                  <span class="flex-1">${getChannelIcon(ch)} ${ch.charAt(0).toUpperCase() + ch.slice(1)}</span>
                  <span class="text-xs text-gray-400">#${idx + 1}</span>
                </div>
              `).join('')}
            </div>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Days Between Attempts</label>
            <input type="number" id="configDaysBetween" value="${config.daysBetweenAttempts}" min="1" max="14"
                   class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500">
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Max Attempts per Business</label>
            <input type="number" id="configMaxAttempts" value="${config.maxAttempts}" min="1" max="10"
                   class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500">
          </div>
        </div>

        <div class="flex gap-3 mt-6">
          <button onclick="closeCampaignConfigModal()" class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium">Cancel</button>
          <button onclick="saveCampaignConfig()" class="flex-1 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium">Save</button>
        </div>
      </div>
    </div>
  `;

  document.body.insertAdjacentHTML('beforeend', modalHTML);

  // Setup channel reorder drag
  setupChannelPriorityDrag();
}

// Get channel icon
function getChannelIcon(channel) {
  const icons = { sms: 'üì±', email: 'üìß', facebook: 'üìò', instagram: 'üì∑', linkedin: 'üíº', call: 'üìû' };
  return icons[channel] || 'üì§';
}

// Setup drag and drop for channel priority
function setupChannelPriorityDrag() {
  const list = document.getElementById('channelPriorityList');
  if (!list) return;

  const items = list.querySelectorAll('[data-channel]');
  items.forEach(item => {
    item.setAttribute('draggable', 'true');

    item.ondragstart = function(e) {
      e.dataTransfer.setData('text/plain', this.dataset.channel);
      this.classList.add('opacity-50');
    };

    item.ondragend = function() {
      this.classList.remove('opacity-50');
    };

    item.ondragover = function(e) {
      e.preventDefault();
      this.classList.add('bg-purple-100');
    };

    item.ondragleave = function() {
      this.classList.remove('bg-purple-100');
    };

    item.ondrop = function(e) {
      e.preventDefault();
      this.classList.remove('bg-purple-100');
      const draggedChannel = e.dataTransfer.getData('text/plain');
      const targetChannel = this.dataset.channel;

      if (draggedChannel !== targetChannel) {
        // Swap positions
        const list = document.getElementById('channelPriorityList');
        const draggedEl = list.querySelector(`[data-channel="${draggedChannel}"]`);
        const targetEl = this;

        const parent = list;
        const draggedIdx = Array.from(parent.children).indexOf(draggedEl);
        const targetIdx = Array.from(parent.children).indexOf(targetEl);

        if (draggedIdx < targetIdx) {
          parent.insertBefore(draggedEl, targetEl.nextSibling);
        } else {
          parent.insertBefore(draggedEl, targetEl);
        }

        // Update numbers
        Array.from(parent.children).forEach((el, idx) => {
          const numEl = el.querySelector('.text-xs');
          if (numEl) numEl.textContent = `#${idx + 1}`;
        });
      }
    };
  });
}

// Close campaign config modal
function closeCampaignConfigModal() {
  const modal = document.getElementById('campaignConfigModal');
  if (modal) modal.remove();
}

// Add target ZIP from dropdown
function addTargetZipFromSelect() {
  const select = document.getElementById('addTargetZipSelect');
  const zip = select?.value;
  if (zip) {
    addTargetZip(zip);
    select.value = '';
  }
}

// Add target ZIP from manual input
function addManualTargetZip() {
  const input = document.getElementById('manualZipInput');
  const zip = input?.value?.trim();
  if (zip && /^\d{5}$/.test(zip)) {
    addTargetZip(zip);
    input.value = '';
  } else if (zip) {
    toast('Please enter a valid 5-digit ZIP code', false);
  }
}

// Add a target ZIP
function addTargetZip(zip) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  if (!board.config.targetZips) board.config.targetZips = [];
  if (!board.config.targetZips.includes(zip)) {
    board.config.targetZips.push(zip);
    board.config.targetZips.sort();
    // Refresh the modal to show the new ZIP
    closeCampaignConfigModal();
    openCampaignConfigModal();
    toast(`Added ${zip} to target ZIPs`);
  }
}

// Remove a target ZIP
function removeTargetZip(zip) {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  if (!board.config.targetZips) return;
  const idx = board.config.targetZips.indexOf(zip);
  if (idx !== -1) {
    board.config.targetZips.splice(idx, 1);
    // Refresh the modal
    closeCampaignConfigModal();
    openCampaignConfigModal();
    toast(`Removed ${zip} from target ZIPs`);
  }
}

// Save campaign configuration
async function saveCampaignConfig() {
  const board = getCurrentCampaignBoard();
  if (!board) return;

  // Get channel priority from DOM order
  const list = document.getElementById('channelPriorityList');
  const newPriority = Array.from(list.querySelectorAll('[data-channel]')).map(el => el.dataset.channel);

  board.config.channelPriority = newPriority;
  board.config.daysBetweenAttempts = parseInt(document.getElementById('configDaysBetween').value) || 3;
  board.config.maxAttempts = parseInt(document.getElementById('configMaxAttempts').value) || 4;

  await saveCampaignBoards();
  closeCampaignConfigModal();
  toast('Campaign configuration saved');

  // Re-render to apply changes
  if (!campaignBoardsState.useLegacyKanban) {
    renderCampaignBoard();
  }
}

// ========= LOG A REPLY MODAL =========

// Open the Log a Reply modal
function openLogReplyModal() {
  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign selected');
    return;
  }

  // Get businesses from Attempting column (Column 2) - these are the ones waiting for replies
  const attemptingItems = board.columns['attempting'] || [];

  if (attemptingItems.length === 0) {
    toast('No businesses waiting for replies');
    return;
  }

  const modalHTML = `
    <div id="logReplyModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onclick="if(event.target === this) closeLogReplyModal()">
      <div class="bg-white rounded-xl shadow-2xl p-6 max-w-md w-full mx-4" onclick="event.stopPropagation()">
        <h3 class="text-xl font-bold mb-4">üì¨ Log a Reply</h3>
        <p class="text-sm text-gray-500 mb-4">Record when a business responds to move them to Negotiating</p>

        <div class="space-y-4">
          <!-- Business Search -->
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Who replied?</label>
            <input type="text" id="logReplySearch" placeholder="Start typing business name..."
                   oninput="filterLogReplyResults(this.value)"
                   class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-green-500 focus:border-green-500">
            <div id="logReplySearchResults" class="mt-2 max-h-40 overflow-y-auto border rounded-lg hidden">
              <!-- Results will be populated here -->
            </div>
            <div id="logReplySelected" class="mt-2 hidden">
              <div class="flex items-center justify-between p-2 bg-green-100 border border-green-300 rounded-lg">
                <span id="logReplySelectedName" class="font-medium text-green-800"></span>
                <button onclick="clearLogReplySelection()" class="text-green-600 hover:text-green-800">√ó</button>
              </div>
            </div>
          </div>

          <!-- Channel Selection -->
          <div id="logReplyChannelSection" class="hidden">
            <label class="block text-sm font-medium text-gray-700 mb-2">How did they reply?</label>
            <div class="grid grid-cols-3 gap-2">
              <button onclick="selectLogReplyChannel('sms')" class="log-reply-channel px-3 py-2 bg-gray-100 hover:bg-green-100 border-2 border-gray-200 rounded-lg text-sm font-medium" data-channel="sms">
                üì± SMS
              </button>
              <button onclick="selectLogReplyChannel('email')" class="log-reply-channel px-3 py-2 bg-gray-100 hover:bg-green-100 border-2 border-gray-200 rounded-lg text-sm font-medium" data-channel="email">
                üìß Email
              </button>
              <button onclick="selectLogReplyChannel('call')" class="log-reply-channel px-3 py-2 bg-gray-100 hover:bg-green-100 border-2 border-gray-200 rounded-lg text-sm font-medium" data-channel="call">
                üìû Call
              </button>
              <button onclick="selectLogReplyChannel('facebook')" class="log-reply-channel px-3 py-2 bg-gray-100 hover:bg-green-100 border-2 border-gray-200 rounded-lg text-sm font-medium" data-channel="facebook">
                üìò Facebook
              </button>
              <button onclick="selectLogReplyChannel('instagram')" class="log-reply-channel px-3 py-2 bg-gray-100 hover:bg-green-100 border-2 border-gray-200 rounded-lg text-sm font-medium" data-channel="instagram">
                üì∑ Instagram
              </button>
              <button onclick="selectLogReplyChannel('linkedin')" class="log-reply-channel px-3 py-2 bg-gray-100 hover:bg-green-100 border-2 border-gray-200 rounded-lg text-sm font-medium" data-channel="linkedin">
                üíº LinkedIn
              </button>
            </div>
          </div>

          <!-- Submit Button -->
          <div id="logReplySubmitSection" class="hidden">
            <button onclick="submitLogReply()" class="w-full px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium text-lg">
              ‚úÖ Move to Negotiating
            </button>
          </div>
        </div>

        <div class="flex gap-3 mt-6">
          <button onclick="closeLogReplyModal()" class="flex-1 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium">Cancel</button>
        </div>
      </div>
    </div>
  `;

  // Store attempting items for search
  window._logReplyItems = attemptingItems;
  window._logReplySelectedId = null;
  window._logReplySelectedChannel = null;

  document.body.insertAdjacentHTML('beforeend', modalHTML);

  // Focus the search input
  setTimeout(() => document.getElementById('logReplySearch')?.focus(), 100);
}

// Filter search results for Log Reply
function filterLogReplyResults(query) {
  const resultsContainer = document.getElementById('logReplySearchResults');
  const items = window._logReplyItems || [];

  if (!query || query.length < 2) {
    resultsContainer.classList.add('hidden');
    return;
  }

  const queryLower = query.toLowerCase();
  const matches = items.filter(item => {
    const name = (item.businessName || item.name || '').toLowerCase();
    return name.includes(queryLower);
  }).slice(0, 10); // Limit to 10 results

  if (matches.length === 0) {
    resultsContainer.innerHTML = '<div class="p-2 text-gray-500 text-sm">No matches found</div>';
  } else {
    resultsContainer.innerHTML = matches.map(item => {
      const id = item.id || item._id || item.place_id || item.businessName;
      const name = item.businessName || item.name || 'Unknown';
      const zip = item.actualZip || item.zipCode || item.zip || '';
      return `
        <div onclick="selectLogReplyBusiness('${esc(String(id))}')"
             class="p-2 hover:bg-gray-100 cursor-pointer border-b last:border-b-0">
          <div class="font-medium text-sm">${esc(name)}</div>
          ${zip ? `<div class="text-xs text-gray-500">üìç ${esc(zip)}</div>` : ''}
        </div>
      `;
    }).join('');
  }

  resultsContainer.classList.remove('hidden');
}

// Select a business from search results
function selectLogReplyBusiness(businessId) {
  const items = window._logReplyItems || [];
  const business = items.find(item => {
    const id = item.id || item._id || item.place_id || item.businessName;
    return String(id) === String(businessId);
  });

  if (!business) return;

  window._logReplySelectedId = businessId;

  // Hide search, show selected
  document.getElementById('logReplySearchResults').classList.add('hidden');
  document.getElementById('logReplySearch').classList.add('hidden');

  const selectedDiv = document.getElementById('logReplySelected');
  document.getElementById('logReplySelectedName').textContent = business.businessName || business.name || 'Unknown';
  selectedDiv.classList.remove('hidden');

  // Show channel selection
  document.getElementById('logReplyChannelSection').classList.remove('hidden');
}

// Clear business selection
function clearLogReplySelection() {
  window._logReplySelectedId = null;
  window._logReplySelectedChannel = null;

  document.getElementById('logReplySearch').value = '';
  document.getElementById('logReplySearch').classList.remove('hidden');
  document.getElementById('logReplySelected').classList.add('hidden');
  document.getElementById('logReplyChannelSection').classList.add('hidden');
  document.getElementById('logReplySubmitSection').classList.add('hidden');

  // Reset channel buttons
  document.querySelectorAll('.log-reply-channel').forEach(btn => {
    btn.classList.remove('bg-green-200', 'border-green-500');
    btn.classList.add('bg-gray-100', 'border-gray-200');
  });

  document.getElementById('logReplySearch').focus();
}

// Select reply channel
function selectLogReplyChannel(channel) {
  window._logReplySelectedChannel = channel;

  // Update button styles
  document.querySelectorAll('.log-reply-channel').forEach(btn => {
    if (btn.dataset.channel === channel) {
      btn.classList.remove('bg-gray-100', 'border-gray-200');
      btn.classList.add('bg-green-200', 'border-green-500');
    } else {
      btn.classList.remove('bg-green-200', 'border-green-500');
      btn.classList.add('bg-gray-100', 'border-gray-200');
    }
  });

  // Show submit button
  document.getElementById('logReplySubmitSection').classList.remove('hidden');
}

// Submit the logged reply
async function submitLogReply() {
  const businessId = window._logReplySelectedId;
  const channel = window._logReplySelectedChannel;

  if (!businessId || !channel) {
    toast('Please select a business and channel', false);
    return;
  }

  const board = getCurrentCampaignBoard();
  if (!board) return;

  // Find the business in attempting column
  const attemptingItems = board.columns['attempting'] || [];
  const idx = attemptingItems.findIndex(item => {
    const id = item.id || item._id || item.place_id || item.businessName;
    return String(id) === String(businessId);
  });

  if (idx === -1) {
    toast('Business not found in Attempting column', false);
    return;
  }

  const business = attemptingItems[idx];

  // Record the response channel
  business.respondedChannel = channel;
  if (business.attemptTracking?.attemptHistory) {
    // Mark the channel as responded
    const historyEntry = business.attemptTracking.attemptHistory.find(h => h.channel === channel);
    if (historyEntry) {
      historyEntry.responded = true;
      historyEntry.respondedDate = new Date().toISOString();
    }
  }

  // Move to negotiating
  attemptingItems.splice(idx, 1);
  if (!board.columns['negotiating']) board.columns['negotiating'] = [];
  board.columns['negotiating'].push(business);

  await saveCampaignBoards();
  closeLogReplyModal();
  renderCampaignBoard();

  const name = business.businessName || business.name || 'Business';
  toast(`‚úÖ ${name} moved to Negotiating!`);
}

// Close Log Reply modal
function closeLogReplyModal() {
  const modal = document.getElementById('logReplyModal');
  if (modal) modal.remove();

  // Clean up
  delete window._logReplyItems;
  delete window._logReplySelectedId;
  delete window._logReplySelectedChannel;
}

// Data migration from legacy kanban to campaign boards
async function migrateToCampaignBoards() {
  console.log('üì• MIGRATION STARTED');
  const currentMailerId = state.current?.Mailer_ID;
  console.log('üì• Current Mailer ID:', currentMailerId);
  console.log('üì• Legacy kanban columns:', Object.keys(kanbanState.columns).map(k => `${k}: ${kanbanState.columns[k]?.length || 0}`));

  if (!currentMailerId) {
    toast('No campaign selected for migration');
    console.log('üì• MIGRATION FAILED: No campaign selected');
    return false;
  }

  // Check if already migrated
  if (campaignBoardsState.boards[currentMailerId] &&
      Object.values(campaignBoardsState.boards[currentMailerId].columns).some(col => col.length > 0)) {
    if (!confirm('This campaign already has data. Merge legacy kanban data into it?')) {
      return false;
    }
  }

  // Get or create board
  const board = getCurrentCampaignBoard();
  if (!board) return false;

  // Migration mapping:
  // prospect-list ‚Üí queued
  // to-contact ‚Üí queued or attempting (based on contact history)
  // in-progress ‚Üí attempting or negotiating (if responded)
  // committed ‚Üí negotiating

  // Use _legacyData if available (set by loadKanban migration), otherwise read from getter shim
  const legacyColumns = kanbanState._legacyData || kanbanState.columns;

  // Helper to check if business has been contacted
  const hasBeenContacted = (item) => {
    if (typeof item !== 'object') return false;
    const ct = item.contactTracking || {};
    return ct.emailed || ct.texted || ct.called || ct.linkedinMessaged || ct.facebookMessaged || ct.dmed;
  };

  // Helper to check if business exists in ANY column (prevent cross-column duplicates)
  const existsInAnyColumn = (itemId) => {
    const allColumns = ['queued', 'attempting', 'negotiating', 'invoice-sent', 'proof-approved', 'paid-in-full'];
    return allColumns.some(col => board.columns[col]?.some(b => b.id === itemId));
  };

  // Helper to get business ID consistently
  const getBusinessId = (item) => {
    return item.id || item._id || item.place_id || item.businessName;
  };

  // Migrate in reverse priority order (later stages first) so businesses end up in their most advanced stage

  // Migrate committed ‚Üí negotiating (FIRST - highest priority)
  (legacyColumns['committed'] || []).forEach(item => {
    if (!item) return;
    const itemId = getBusinessId(item);
    if (existsInAnyColumn(itemId)) return;
    const enhanced = enhanceBusinessForCampaignBoard(item, board.config.maxAttempts);
    board.columns['negotiating'].push(enhanced);
  });

  // Migrate in-progress ‚Üí attempting or negotiating
  (legacyColumns['in-progress'] || []).forEach(item => {
    if (!item) return;
    const itemId = getBusinessId(item);
    if (existsInAnyColumn(itemId)) return;
    const enhanced = enhanceBusinessForCampaignBoard(item, board.config.maxAttempts);
    // If they've responded (has notes or follow-up date), they're negotiating
    const isNegotiating = item.notes || item.followUpDate || item.lastContactResponse;
    const targetCol = isNegotiating ? 'negotiating' : 'attempting';
    board.columns[targetCol].push(enhanced);
  });

  // Migrate to-contact ‚Üí queued or attempting
  (legacyColumns['to-contact'] || []).forEach(item => {
    if (!item) return;
    const itemId = getBusinessId(item);
    if (existsInAnyColumn(itemId)) return;
    const enhanced = enhanceBusinessForCampaignBoard(item, board.config.maxAttempts);
    const targetCol = hasBeenContacted(item) ? 'attempting' : 'queued';
    board.columns[targetCol].push(enhanced);
  });

  // Migrate prospect-list ‚Üí queued (LAST - lowest priority)
  (legacyColumns['prospect-list'] || []).forEach(item => {
    if (!item) return;
    const itemId = getBusinessId(item);
    if (existsInAnyColumn(itemId)) return;
    const enhanced = enhanceBusinessForCampaignBoard(item, board.config.maxAttempts);
    board.columns['queued'].push(enhanced);
  });

  // Log final counts before saving
  console.log('üì• MIGRATION COMPLETE - Column counts:');
  Object.keys(board.columns).forEach(col => {
    console.log(`üì•   ${col}: ${board.columns[col].length} items`);
  });

  await saveCampaignBoards();
  console.log('üì• Board saved to cloud');

  const totalMigrated = Object.values(board.columns).reduce((sum, col) => sum + col.length, 0);
  console.log('üì• Total migrated:', totalMigrated);
  toast(`Migrated ${totalMigrated} businesses to Campaign Board`);

  return true;
}

// Save campaign boards to cloud with validation
async function saveCampaignBoards() {
  try {
    // Validate data before saving
    const boards = campaignBoardsState.boards;

    if (!boards || typeof boards !== 'object') {
      console.error('‚ùå Invalid boards data - skipping save');
      return;
    }

    // Guard: Don't overwrite cloud data if we haven't loaded from cloud yet
    if (!campaignBoardsState.cloudDataLoaded) {
      const totalItems = Object.values(boards).reduce((sum, b) => {
        if (!b || !b.columns) return sum;
        return sum + Object.values(b.columns).reduce((s, col) => s + (Array.isArray(col) ? col.length : 0), 0);
      }, 0);

      if (totalItems === 0) {
        console.warn('‚ö†Ô∏è Skipping save: cloud data not loaded yet and boards are empty (would overwrite cloud data)');
        return;
      }
    }

    // Clean up any null/undefined entries in columns
    Object.keys(boards).forEach(boardId => {
      const board = boards[boardId];
      if (!board || !board.columns) return;

      Object.keys(board.columns).forEach(colKey => {
        if (!Array.isArray(board.columns[colKey])) {
          board.columns[colKey] = [];
        } else {
          // Filter out null/undefined items
          board.columns[colKey] = board.columns[colKey].filter(item => item && typeof item === 'object');
        }
      });
    });

    // Log what we're saving for debugging
    const boardIds = Object.keys(boards);
    const totalItems = boardIds.reduce((sum, bid) => {
      const b = boards[bid];
      if (!b || !b.columns) return sum;
      return sum + Object.values(b.columns).reduce((s, col) => s + (Array.isArray(col) ? col.length : 0), 0);
    }, 0);
    console.log(`‚òÅÔ∏è Saving ${boardIds.length} boards (${totalItems} total items) to cloud`);

    // Create backup in IndexedDB before cloud save (for recovery)
    try {
      await idbSet('campaign-boards', JSON.parse(JSON.stringify(boards)));
    } catch (e) {
      console.warn('Could not backup to IndexedDB:', e);
    }

    await saveToCloud('campaign-boards', boards);
    console.log('‚úÖ Campaign boards saved to cloud');
  } catch (err) {
    console.error('‚ùå Failed to save campaign boards:', err);
    toast('Failed to save campaign boards', false);
  }
}

// Data recovery tool - check all storage locations and help restore lost data
window.recoverLostBusinesses = async function() {
  console.log('üîç CAMPAIGN BOARD DATA RECOVERY TOOL');
  console.log('=====================================\n');

  const recovery = {
    cloud: null,
    indexedDB: null,
    localStorage: null,
    prospectPool: []
  };

  // 1. Check cloud data
  console.log('1Ô∏è‚É£ Checking cloud storage (Supabase)...');
  try {
    const cloudData = await loadFromCloud('campaign-boards');
    if (cloudData) {
      recovery.cloud = cloudData;
      Object.keys(cloudData).forEach(boardId => {
        const board = cloudData[boardId];
        if (board?.columns) {
          console.log(`   Board "${board.name || boardId}":`);
          Object.keys(board.columns).forEach(col => {
            const count = board.columns[col]?.length || 0;
            if (count > 0) {
              console.log(`     ${col}: ${count} items`);
              board.columns[col].forEach(item => {
                console.log(`       - ${item.businessName || item.name || 'Unknown'}`);
              });
            }
          });
        }
      });
    } else {
      console.log('   ‚ùå No cloud data found');
    }
  } catch (e) {
    console.error('   ‚ùå Error loading cloud data:', e);
  }

  // 2. Check IndexedDB
  console.log('\n2Ô∏è‚É£ Checking IndexedDB...');
  try {
    const idbData = await idbGet('campaign-boards');
    if (idbData) {
      recovery.indexedDB = idbData;
      console.log('   ‚úÖ Found IndexedDB data');
      Object.keys(idbData).forEach(boardId => {
        const board = idbData[boardId];
        if (board?.columns) {
          const total = Object.values(board.columns).reduce((s, c) => s + (c?.length || 0), 0);
          console.log(`   Board "${board.name || boardId}": ${total} total items`);
        }
      });
    } else {
      console.log('   ‚ùå No IndexedDB data found');
    }
  } catch (e) {
    console.log('   ‚ùå IndexedDB not available or empty');
  }

  // 3. Check localStorage backup
  console.log('\n3Ô∏è‚É£ Checking localStorage backup...');
  try {
    const lsData = localStorage.getItem('campaign-boards-backup');
    if (lsData) {
      recovery.localStorage = JSON.parse(lsData);
      console.log('   ‚úÖ Found localStorage backup');
    } else {
      console.log('   ‚ùå No localStorage backup found');
    }
  } catch (e) {
    console.log('   ‚ùå No localStorage backup');
  }

  // 4. Check prospect pool for businesses that might need to be re-added
  console.log('\n4Ô∏è‚É£ Checking prospect pool for potential recovery...');
  if (prospectPoolState.manualProspects?.length > 0) {
    // Find prospects with contact tracking that suggests they were in the pipeline
    const contacted = prospectPoolState.manualProspects.filter(p =>
      p.contactTracking?.emailed || p.contactTracking?.texted || p.contactTracking?.called ||
      p.attemptTracking?.attemptHistory?.length > 0
    );
    recovery.prospectPool = contacted;
    console.log(`   Found ${contacted.length} prospects with contact history in pool`);
    contacted.forEach(p => {
      console.log(`     - ${p.businessName || p.name} (has contact history)`);
    });
  }

  // 5. Summary and recovery options
  console.log('\nüìä RECOVERY OPTIONS:');
  console.log('====================');

  if (recovery.indexedDB && recovery.cloud) {
    // Compare to find missing items
    const cloudItems = new Set();
    const idbItems = new Set();

    Object.values(recovery.cloud).forEach(board => {
      if (board?.columns) {
        Object.values(board.columns).forEach(col => {
          col?.forEach(item => cloudItems.add(item.id || item.businessName));
        });
      }
    });

    Object.values(recovery.indexedDB).forEach(board => {
      if (board?.columns) {
        Object.values(board.columns).forEach(col => {
          col?.forEach(item => idbItems.add(item.id || item.businessName));
        });
      }
    });

    const missingFromCloud = [...idbItems].filter(id => !cloudItems.has(id));
    if (missingFromCloud.length > 0) {
      console.log(`\n‚ö†Ô∏è ${missingFromCloud.length} items in IndexedDB but NOT in cloud!`);
      console.log('   Run: restoreFromIndexedDB() to restore these');
    }
  }

  console.log('\nüí° Available recovery commands:');
  console.log('   restoreFromIndexedDB() - Restore from local IndexedDB cache');
  console.log('   addToAttempting(businessName) - Re-add a business to Attempting column');
  console.log('\n');

  return recovery;
};

// Diagnostic: Check places cache data in cloud vs local
window.diagnosePlacesCache = async function() {
  console.log('üîç PLACES CACHE DIAGNOSTIC');
  console.log('===========================\n');

  // Check cloud
  console.log('1Ô∏è‚É£ Checking CLOUD (Supabase)...');
  try {
    const cloudData = await loadFromCloud('placesCache');
    if (cloudData) {
      const cloudSearches = Object.keys(cloudData).length;
      const cloudProspects = Object.values(cloudData).reduce((sum, cache) =>
        sum + (cache.cachedData?.length || 0), 0
      );
      console.log(`   ‚úÖ Cloud: ${cloudSearches} searches, ${cloudProspects} total prospects`);
    } else {
      console.log('   ‚ùå No cloud data found');
    }
  } catch (e) {
    console.log('   ‚ùå Cloud error:', e.message);
  }

  // Check IndexedDB
  console.log('\n2Ô∏è‚É£ Checking INDEXEDDB...');
  try {
    const idbData = await idbGet('mailslot-places-cache');
    if (idbData) {
      const idbSearches = Object.keys(idbData).length;
      const idbProspects = Object.values(idbData).reduce((sum, cache) =>
        sum + (cache.cachedData?.length || 0), 0
      );
      console.log(`   ‚úÖ IndexedDB: ${idbSearches} searches, ${idbProspects} total prospects`);
    } else {
      console.log('   ‚ùå No IndexedDB data (or IndexedDB unavailable)');
    }
  } catch (e) {
    console.log('   ‚ùå IndexedDB error:', e.message);
  }

  // Check current memory
  console.log('\n3Ô∏è‚É£ Checking CURRENT MEMORY...');
  const memSearches = Object.keys(placesCache.searches).length;
  const memProspects = Object.values(placesCache.searches).reduce((sum, cache) =>
    sum + (cache.cachedData?.length || 0), 0
  );
  console.log(`   üì¶ Memory: ${memSearches} searches, ${memProspects} total prospects`);

  // Check manual prospects
  console.log('\n4Ô∏è‚É£ Checking MANUAL PROSPECTS...');
  console.log(`   üìã Manual prospects in memory: ${prospectPoolState.manualProspects?.length || 0}`);

  console.log('\nüí° If cloud has fewer than expected, the data may have been overwritten.');
  console.log('   Check if you have a backup or can restore from another device.\n');

  return {
    cloud: await loadFromCloud('placesCache'),
    memory: placesCache.searches,
    manualProspects: prospectPoolState.manualProspects?.length || 0
  };
};

// Restore campaign boards from IndexedDB
window.restoreFromIndexedDB = async function() {
  const idbData = await idbGet('campaign-boards');
  if (!idbData) {
    console.log('‚ùå No IndexedDB data to restore from');
    return false;
  }

  console.log('üîÑ Restoring from IndexedDB...');
  campaignBoardsState.boards = idbData;
  await saveCampaignBoards();
  renderCampaignBoard();
  console.log('‚úÖ Restored from IndexedDB');
  toast('Restored campaign boards from local backup', true);
  return true;
};

// Re-add a business to the Attempting column by name
window.addToAttempting = async function(businessName) {
  // Search in prospect pool
  const prospect = prospectPoolState.manualProspects?.find(p =>
    (p.businessName || p.name || '').toLowerCase().includes(businessName.toLowerCase())
  );

  if (!prospect) {
    console.log(`‚ùå Business "${businessName}" not found in prospect pool`);
    return false;
  }

  const board = getCurrentCampaignBoard();
  if (!board) {
    console.log('‚ùå No active campaign board');
    return false;
  }

  // Check if already in board
  const allColumns = ['queued', 'attempting', 'negotiating', 'invoice-sent', 'proof-approved', 'paid-in-full'];
  for (const col of allColumns) {
    const exists = board.columns[col]?.some(item =>
      (item.businessName || item.name) === (prospect.businessName || prospect.name)
    );
    if (exists) {
      console.log(`‚ö†Ô∏è "${prospect.businessName || prospect.name}" already exists in ${col}`);
      return false;
    }
  }

  // Add to attempting column
  board.columns['attempting'].push({
    ...prospect,
    id: prospect.id || `recovered_${Date.now()}`,
    attemptTracking: prospect.attemptTracking || {
      currentAttempt: 1,
      maxAttempts: 4,
      attemptHistory: [],
      nextChannel: null,
      nextActionDate: new Date().toISOString().split('T')[0]
    }
  });

  await saveCampaignBoards();
  renderCampaignBoard();
  console.log(`‚úÖ Added "${prospect.businessName || prospect.name}" to Attempting column`);
  toast(`Recovered "${prospect.businessName || prospect.name}" to Attempting`, true);
  return true;
};

// Clean up duplicates in campaign board (for users who already migrated)
async function cleanupCampaignBoardDuplicates() {
  const board = getCurrentCampaignBoard();
  if (!board) {
    toast('No campaign board to clean');
    return;
  }

  const allColumns = ['queued', 'attempting', 'negotiating', 'invoice-sent', 'proof-approved', 'paid-in-full'];
  const seenIds = new Set();
  let duplicatesRemoved = 0;

  // Helper to get business ID consistently
  const getBusinessId = (item) => {
    return item.id || item._id || item.place_id || item.businessName;
  };

  // Process columns in priority order (later stages keep the business)
  const priorityOrder = ['paid-in-full', 'proof-approved', 'invoice-sent', 'negotiating', 'attempting', 'queued'];

  priorityOrder.forEach(colKey => {
    const column = board.columns[colKey];
    if (!column) return;

    const filtered = column.filter(item => {
      const itemId = getBusinessId(item);
      if (seenIds.has(itemId)) {
        duplicatesRemoved++;
        console.log(`üßπ Removing duplicate: ${item.businessName || item.name} from ${colKey}`);
        return false;
      }
      seenIds.add(itemId);
      return true;
    });

    board.columns[colKey] = filtered;
  });

  if (duplicatesRemoved > 0) {
    await saveCampaignBoards();
    toast(`Cleaned up ${duplicatesRemoved} duplicates`);
    renderCampaignBoard();
  } else {
    toast('No duplicates found');
  }

  console.log(`üßπ Cleanup complete: removed ${duplicatesRemoved} duplicates`);
}

// Load campaign boards from cloud with validation
async function loadCampaignBoards() {
  try {
    const data = await loadFromCloud('campaign-boards');
    if (data && typeof data === 'object') {
      // Log what we loaded from cloud for debugging cross-device sync
      const boardIds = Object.keys(data);
      console.log(`‚òÅÔ∏è Campaign boards loaded from cloud: ${boardIds.length} boards`);
      boardIds.forEach(bid => {
        const b = data[bid];
        if (b && b.columns) {
          const total = Object.values(b.columns).reduce((s, col) => s + (Array.isArray(col) ? col.length : 0), 0);
          console.log(`‚òÅÔ∏è   Board "${bid}" (${b.name || 'unnamed'}): ${total} total items`);
        }
      });

      // Validate and repair board structure
      Object.keys(data).forEach(boardId => {
        const board = data[boardId];
        if (!board) {
          delete data[boardId];
          return;
        }
        // Ensure columns object exists
        if (!board.columns || typeof board.columns !== 'object') {
          board.columns = {
            'queued': [],
            'attempting': [],
            'negotiating': [],
            'invoice-sent': [],
            'proof-approved': [],
            'paid-in-full': []
          };
        }
        // Ensure each column is an array
        const requiredColumns = ['queued', 'attempting', 'negotiating', 'invoice-sent', 'proof-approved', 'paid-in-full'];
        requiredColumns.forEach(col => {
          if (!Array.isArray(board.columns[col])) {
            board.columns[col] = [];
          }
        });
        // Ensure config exists
        if (!board.config) {
          board.config = {
            channelPriority: ['sms', 'email', 'facebook', 'call'],
            maxAttempts: 4,
            daysBetweenAttempts: 3,
            targetZips: []
          };
        }
        // Ensure targetZips exists
        if (!board.config.targetZips) {
          board.config.targetZips = [];
        }

        // Repair items in "attempting" column that have currentAttempt: 0
        const attemptingItems = board.columns['attempting'] || [];
        attemptingItems.forEach(business => {
          if (!business.attemptTracking || business.attemptTracking.currentAttempt === 0) {
            const channelStatus = {
              sms: { available: !!business.phone, sent: false },
              email: { available: !!business.email, sent: false },
              facebook: { available: !!business.facebook, sent: false },
              instagram: { available: !!business.instagram, sent: false },
              linkedin: { available: !!business.linkedin, sent: false },
              call: { available: !!business.phone, sent: false }
            };
            const priority = board.config?.channelPriority || ['sms', 'email', 'facebook', 'call'];
            const nextChannel = priority.find(ch => channelStatus[ch]?.available) || null;

            business.attemptTracking = {
              currentAttempt: 1,
              maxAttempts: board.config?.maxAttempts || 4,
              attemptHistory: [],
              nextChannel: nextChannel,
              nextActionDate: new Date().toISOString().split('T')[0]
            };
            business.channelStatus = channelStatus;
          }
        });

        // Normalize ZIP codes to 5 digits for all items in all columns
        Object.keys(board.columns).forEach(colKey => {
          board.columns[colKey] = board.columns[colKey].map(item => {
            let updated = item;
            if (item.zipCode && item.zipCode.length > 5) {
              updated = { ...updated, zipCode: truncateZipTo5(item.zipCode) };
            }
            if (item.actualZip && item.actualZip.length > 5) {
              updated = { ...updated, actualZip: truncateZipTo5(item.actualZip) };
            }
            if (item.zip && item.zip.length > 5) {
              updated = { ...updated, zip: truncateZipTo5(item.zip) };
            }
            return updated;
          });
        });

        // Normalize targetZips in config
        if (board.config.targetZips && Array.isArray(board.config.targetZips)) {
          board.config.targetZips = board.config.targetZips.map(zip =>
            zip && zip.length > 5 ? truncateZipTo5(zip) : zip
          );
        }
      });
      campaignBoardsState.boards = data;
      campaignBoardsState.cloudDataLoaded = true;
      console.log('‚úÖ Campaign boards cloud data loaded successfully');
    } else {
      console.log('‚òÅÔ∏è No campaign boards data found in cloud (new user or empty)');
      campaignBoardsState.cloudDataLoaded = true; // Cloud was checked, just empty
    }
  } catch (err) {
    console.error('‚ùå Failed to load campaign boards from cloud:', err);
    console.error('‚ùå Cross-device sync may not work until cloud connection is restored');
  }
}

// Force reload campaign boards from cloud (bypasses IndexedDB cache)
// Call from console: forceReloadCampaignBoards()
async function forceReloadCampaignBoards() {
  try {
    console.log('üîÑ Force reloading campaign boards from cloud...');

    // Direct Supabase query (bypass loadFromCloud which may use IndexedDB fallback)
    const userEmail = ACTIVE_USER || window.currentAuthUser?.email;
    if (!userEmail) {
      console.error('‚ùå No authenticated user');
      toast('Not logged in - cannot reload', false);
      return;
    }

    const { data, error } = await supabaseClient
      .from('app_data')
      .select('data')
      .eq('user_email', userEmail)
      .eq('data_type', 'campaign-boards')
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        console.log('‚òÅÔ∏è No campaign boards in cloud');
        toast('No campaign boards found in cloud', false);
        return;
      }
      throw error;
    }

    const cloudBoards = data?.data;
    if (cloudBoards && typeof cloudBoards === 'object') {
      const boardIds = Object.keys(cloudBoards);
      let totalItems = 0;
      boardIds.forEach(bid => {
        const b = cloudBoards[bid];
        if (b && b.columns) {
          const count = Object.values(b.columns).reduce((s, col) => s + (Array.isArray(col) ? col.length : 0), 0);
          totalItems += count;
          console.log(`‚òÅÔ∏è   Board "${bid}" (${b.name || 'unnamed'}): ${count} items`);
        }
      });

      campaignBoardsState.boards = cloudBoards;
      campaignBoardsState.cloudDataLoaded = true;

      // Re-render
      renderKanban();
      refreshContactStatusDashboard();
      refreshAnalytics();

      toast(`‚úÖ Reloaded ${boardIds.length} boards (${totalItems} items) from cloud`, true);
      console.log(`‚úÖ Force reload complete: ${boardIds.length} boards, ${totalItems} items`);
    } else {
      toast('No board data found in cloud', false);
    }
  } catch (err) {
    console.error('‚ùå Force reload failed:', err);
    toast('Failed to reload from cloud: ' + err.message, false);
  }
}
window.forceReloadCampaignBoards = forceReloadCampaignBoards;

// Recover campaign boards from IndexedDB cache (last resort data recovery)
// Call from console: recoverBoardsFromCache()
async function recoverBoardsFromCache() {
  try {
    console.log('üîß Attempting to recover campaign boards from IndexedDB cache...');
    const cached = await idbGet('mailslot-campaign-boards');

    if (!cached || typeof cached !== 'object') {
      console.log('‚ùå No cached campaign boards found in IndexedDB');
      toast('No cached data found in IndexedDB', false);
      return;
    }

    const boardIds = Object.keys(cached);
    let totalItems = 0;
    boardIds.forEach(bid => {
      const b = cached[bid];
      if (b && b.columns) {
        const count = Object.values(b.columns).reduce((s, col) => s + (Array.isArray(col) ? col.length : 0), 0);
        totalItems += count;
        console.log(`üîß   Cached board "${bid}" (${b.name || 'unnamed'}): ${count} items`);
        Object.keys(b.columns).forEach(col => {
          console.log(`üîß     ${col}: ${b.columns[col]?.length || 0}`);
        });
      }
    });

    if (totalItems === 0) {
      console.log('‚ùå Cached boards are empty');
      toast('Cached boards are empty - no data to recover', false);
      return;
    }

    // Restore boards from cache
    campaignBoardsState.boards = cached;
    campaignBoardsState.cloudDataLoaded = true;

    // Save recovered data back to cloud
    await saveToCloud('campaign-boards', cached);

    // Re-render
    renderKanban();
    refreshContactStatusDashboard();
    refreshAnalytics();

    toast(`‚úÖ Recovered ${totalItems} items from ${boardIds.length} boards! Saved to cloud.`, true);
    console.log(`‚úÖ Recovery complete: ${boardIds.length} boards, ${totalItems} items restored and saved to cloud`);
  } catch (err) {
    console.error('‚ùå Recovery failed:', err);
    toast('Recovery failed: ' + err.message, false);
  }
}
window.recoverBoardsFromCache = recoverBoardsFromCache;

// Debug: Show current state of boards (cloud + local)
// Call from console: debugBoardSync()
async function debugBoardSync() {
  console.log('=== CAMPAIGN BOARDS SYNC DEBUG ===');
  console.log('cloudDataLoaded:', campaignBoardsState.cloudDataLoaded);
  console.log('Current Mailer_ID:', state.current?.Mailer_ID);
  console.log('Current Town:', state.current?.Town || state.current?.town);

  // Show local state
  const localBoards = campaignBoardsState.boards;
  const localIds = Object.keys(localBoards);
  console.log(`\nLOCAL STATE: ${localIds.length} boards`);
  localIds.forEach(bid => {
    const b = localBoards[bid];
    if (b && b.columns) {
      const count = Object.values(b.columns).reduce((s, col) => s + (Array.isArray(col) ? col.length : 0), 0);
      console.log(`  "${bid}" (${b.name}): ${count} items`);
    }
  });

  // Show IndexedDB cache
  try {
    const cached = await idbGet('mailslot-campaign-boards');
    if (cached) {
      const cachedIds = Object.keys(cached);
      let totalCached = 0;
      console.log(`\nINDEXEDDB CACHE: ${cachedIds.length} boards`);
      cachedIds.forEach(bid => {
        const b = cached[bid];
        if (b && b.columns) {
          const count = Object.values(b.columns).reduce((s, col) => s + (Array.isArray(col) ? col.length : 0), 0);
          totalCached += count;
          console.log(`  "${bid}" (${b.name}): ${count} items`);
        }
      });
      console.log(`  Total cached items: ${totalCached}`);
    } else {
      console.log('\nINDEXEDDB CACHE: empty/null');
    }
  } catch (e) {
    console.log('\nINDEXEDDB CACHE: error reading -', e.message);
  }

  // Show cloud data
  try {
    const userEmail = ACTIVE_USER || window.currentAuthUser?.email;
    const { data, error } = await supabaseClient
      .from('app_data')
      .select('data')
      .eq('user_email', userEmail)
      .eq('data_type', 'campaign-boards')
      .single();

    if (error && error.code !== 'PGRST116') throw error;

    const cloudData = data?.data;
    if (cloudData) {
      const cloudIds = Object.keys(cloudData);
      let totalCloud = 0;
      console.log(`\nCLOUD (SUPABASE): ${cloudIds.length} boards`);
      cloudIds.forEach(bid => {
        const b = cloudData[bid];
        if (b && b.columns) {
          const count = Object.values(b.columns).reduce((s, col) => s + (Array.isArray(col) ? col.length : 0), 0);
          totalCloud += count;
          console.log(`  "${bid}" (${b.name}): ${count} items`);
        }
      });
      console.log(`  Total cloud items: ${totalCloud}`);
    } else {
      console.log('\nCLOUD (SUPABASE): empty/null');
    }
  } catch (e) {
    console.log('\nCLOUD (SUPABASE): error reading -', e.message);
  }

  console.log('\n=== END DEBUG ===');
}
window.debugBoardSync = debugBoardSync;

// Auto-move to clients when paid in full
async function autoMoveToClients(businessId, board) {
  const business = findBusinessInBoard(businessId, board);
  if (!business) {
    console.warn('autoMoveToClients: Business not found:', businessId);
    return;
  }

  // Build proper client object using CRM's buildClientObject
  const clientData = {
    businessName: business.businessName || business.name || '',
    category: business.category || business.types?.[0] || '',
    contactName: business.contactName || '',
    firstName: business.firstName || '',
    phone: business.phone || '',
    email: business.email || '',
    address: business.address || business.vicinity || '',
    notes: business.notes || '',
    tags: ['campaign-board', business.mailerId].filter(Boolean),
    createdDate: new Date().toISOString(),
    // Carry over sales info if available
    monthlyPrice: business.salesInfo?.invoiceAmount || 0
  };

  const client = buildClientObject(clientData);

  // Store additional business info in notes if not already there
  let additionalInfo = [];
  if (business.website) additionalInfo.push(`Website: ${business.website}`);
  if (business.facebook) additionalInfo.push(`Facebook: ${business.facebook}`);
  if (business.salesInfo?.paidDate) additionalInfo.push(`Paid: ${business.salesInfo.paidDate}`);
  if (additionalInfo.length > 0 && !client.notes) {
    client.notes = additionalInfo.join('\n');
  }

  // Add to CRM clients database (object, not array)
  crmState.clients[client.id] = client;

  // Save using proper CRM save function
  await saveClients();

  // Remove from paid-in-full column
  const paidItems = board.columns['paid-in-full'];
  const idx = paidItems.findIndex(item => String(item.id) === String(businessId));
  if (idx !== -1) {
    paidItems.splice(idx, 1);
    await saveCampaignBoards();
  }

  toast(`üéâ ${business.businessName || 'Business'} added to Clients Database!`);

  // Refresh both views
  renderCampaignBoard();
  renderClientList();
}

/* ========= TASKS FUNCTIONS ========= */

async function loadTasks() {
  try {
    // Try loading from cloud first
    const cloudData = await loadFromCloud('tasks');

    if (cloudData && Array.isArray(cloudData)) {
      tasksState.tasks = cloudData;
    } else {
      // Check localStorage as fallback
      const saved = localStorage.getItem('mailslot-tasks');
      if (saved) {
        tasksState.tasks = JSON.parse(saved);
        // Sync to cloud if we loaded from localStorage
        saveToCloud('tasks', tasksState.tasks).catch(e => console.warn('Failed to sync tasks to cloud:', e));
      } else {
        // Initialize with default tasks
        tasksState.tasks = [
          { id: 1, text: 'Call Royco Partners about Renewal', dueDate: '2025-11-20', completed: false },
          { id: 2, text: 'Follow up Capital Systems Group', dueDate: '2025-11-22', completed: false },
          { id: 3, text: 'Check Print Status: Boston Card', dueDate: '2025-11-25', completed: false },
          { id: 4, text: 'SMS Client: Stone Solutions Maine', dueDate: '2025-11-25', completed: false },
          { id: 5, text: 'Prep Renewal Pitch: Adam\'s Pizza', dueDate: '2025-11-28', completed: false },
          { id: 6, text: 'Design Ad Proof for Royco', dueDate: '2025-11-30', completed: false }
        ];
        saveTasks();
      }
    }
  } catch(e) {
    console.error('Error loading tasks:', e);
  }
  updateTasksDisplay();
}

async function saveTasks() {
  try {
    // Save to cloud and localStorage
    await saveToCloud('tasks', tasksState.tasks);
  } catch(e) {
    console.error('‚ùå Tasks save failed:', e);
    console.warn('Tasks saved to localStorage only (cloud sync failed):', e);
    // Show user-visible error
    toast('‚ö†Ô∏è Cloud sync failed - saved locally only', false);
  }
}

function updateTasksDisplay() {
  const container = document.getElementById('taskList');
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Filter: hide completed tasks that are overdue
  let visibleTasks = tasksState.tasks.filter(task => {
    if (task.completed) {
      // Parse in local timezone to avoid UTC issues
      const parts = task.dueDate.split('-');
      const dueDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
      return dueDate >= today; // Only show completed if not overdue
    }
    return true;
  });

  // Auto-sort by due date (earliest first)
  visibleTasks.sort((a, b) => {
    const dateA = new Date(a.dueDate);
    const dateB = new Date(b.dueDate);
    return dateA - dateB;
  });

  if (visibleTasks.length === 0) {
    container.innerHTML = '<p class="text-sm text-gray-500 text-center py-4">All tasks complete!</p>';
    document.getElementById('overdueText').textContent = 'All tasks complete';
    document.getElementById('overdueText').className = 'text-sm text-green-600 mb-2';
    return;
  }

  container.innerHTML = visibleTasks.map(task => {
    // Parse in local timezone to avoid UTC issues
    const parts = task.dueDate.split('-');
    const dueDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    const overdueClass = dueDate < today && !task.completed ? 'overdue' : '';
    const completedClass = task.completed ? 'completed' : '';

    return `
      <div class="task-row ${completedClass}" draggable="true" data-task-id="${task.id}" data-due-date="${task.dueDate}">
        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTaskComplete(this)" />
        <span class="task-text">${esc(task.text)}</span>
        <input type="date" class="task-date ${overdueClass}" value="${task.dueDate}" onchange="updateTaskDate(this)" />
        <div style="display: flex; gap: 0.5rem; margin-left: auto;">
          <button onclick="editTask(${task.id})" class="text-blue-600 hover:text-blue-800 text-xs" title="Edit task">
            ‚úé
          </button>
          <button onclick="deleteTask(${task.id})" class="text-red-600 hover:text-red-800 text-xs" title="Delete task">
            üóë
          </button>
        </div>
      </div>
    `;
  }).join('');
  
  // Update overdue count
  const incompleteTasks = visibleTasks.filter(t => !t.completed);
  const overdueCount = incompleteTasks.filter(t => {
    // Parse in local timezone to avoid UTC issues
    const parts = t.dueDate.split('-');
    const dueDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    return dueDate < today;
  }).length;
  
  const overdueText = document.getElementById('overdueText');
  if (overdueCount > 0) {
    overdueText.textContent = `${overdueCount} Task${overdueCount > 1 ? 's' : ''} Overdue`;
    overdueText.className = 'text-sm text-red-500 mb-2 font-bold';
  } else if (incompleteTasks.length > 0) {
    overdueText.textContent = `${incompleteTasks.length} Task${incompleteTasks.length > 1 ? 's' : ''} Pending`;
    overdueText.className = 'text-sm text-blue-600 mb-2';
  } else {
    overdueText.textContent = 'All tasks complete';
    overdueText.className = 'text-sm text-green-600 mb-2';
  }

  setupTaskDrag();

  // Also update dashboard widget
  renderDashboardTasks();
}

function setupTaskDrag() {
  const taskList = document.getElementById('taskList');

  taskList.querySelectorAll('.task-row').forEach(row => {
    row.addEventListener('dragstart', e => {
      draggedTask = row;
      row.classList.add('dragging');
    });

    row.addEventListener('dragend', e => {
      row.classList.remove('dragging');
      // Remove all drag-over indicators
      document.querySelectorAll('.task-row.drag-over').forEach(el => {
        el.classList.remove('drag-over');
      });
      draggedTask = null;
    });

    // Add dragover to show blue line indicator
    row.addEventListener('dragover', e => {
      e.preventDefault();
      if (draggedTask && draggedTask !== row) {
        // Remove previous drag-over
        document.querySelectorAll('.task-row.drag-over').forEach(el => {
          el.classList.remove('drag-over');
        });
        // Add to current target
        row.classList.add('drag-over');
      }
    });

    row.addEventListener('dragleave', e => {
      row.classList.remove('drag-over');
    });
  });

  taskList.addEventListener('dragover', e => {
    e.preventDefault();
  });

  taskList.addEventListener('drop', e => {
    e.preventDefault();

    // Remove all drag-over indicators
    document.querySelectorAll('.task-row.drag-over').forEach(el => {
      el.classList.remove('drag-over');
    });

    if (draggedTask) {
      const afterElement = getDragAfterElement(taskList, e.clientY);
      if (afterElement == null) {
        taskList.appendChild(draggedTask);
      } else {
        taskList.insertBefore(draggedTask, afterElement);
      }

      // Get the dragged task's ID and new position
      const draggedTaskId = parseInt(draggedTask.dataset.taskId);
      const draggedTaskObj = tasksState.tasks.find(t => t.id === draggedTaskId);

      // Get new order from DOM
      const newOrder = Array.from(taskList.querySelectorAll('.task-row')).map(row => {
        const taskId = parseInt(row.dataset.taskId);
        return tasksState.tasks.find(t => t.id === taskId);
      }).filter(t => t != null);

      // Check if task was moved to a different date position
      if (afterElement) {
        const targetDate = afterElement.dataset.dueDate;
        const draggedDate = draggedTask.dataset.dueDate;

        if (targetDate && draggedDate && targetDate !== draggedDate) {
          // Task dragged to a different date - update the date
          if (confirm(`Change task due date from ${draggedDate} to ${targetDate}?`)) {
            draggedTaskObj.dueDate = targetDate;
            toast('Task date updated', true);
          }
        }
      }

      tasksState.tasks = newOrder;
      saveTasks();
      updateTasksDisplay(); // Re-render to show updated date and sorting
    }
  });

  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.task-row:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
}

/* ========= SALES ACTIVITY TOGGLE ========= */
function toggleSalesActivity() {
  const kanbanColumns = document.getElementById('salesActivityKanbanColumns');
  const icon = document.getElementById('salesActivityToggleIcon');

  if (kanbanColumns.style.maxHeight && kanbanColumns.style.maxHeight !== '0px') {
    // Collapse
    kanbanColumns.style.maxHeight = '0px';
    kanbanColumns.style.marginTop = '0px';
    icon.style.transform = 'rotate(-90deg)';
    safeSetItem('salesActivityCollapsed', 'true');
  } else {
    // Expand
    kanbanColumns.style.maxHeight = kanbanColumns.scrollHeight + 'px';
    kanbanColumns.style.marginTop = '';
    icon.style.transform = 'rotate(0deg)';
    safeSetItem('salesActivityCollapsed', 'false');

    // Remove max-height after transition so content can grow dynamically
    setTimeout(() => {
      if (kanbanColumns.style.maxHeight !== '0px') {
        kanbanColumns.style.maxHeight = 'none';
      }
    }, 300);
  }
}

// Initialize sales activity state on page load
function initSalesActivityState() {
  const kanbanColumns = document.getElementById('salesActivityKanbanColumns');
  const icon = document.getElementById('salesActivityToggleIcon');
  const isCollapsed = safeGetItem('salesActivityCollapsed') === 'true';

  if (isCollapsed) {
    kanbanColumns.style.maxHeight = '0px';
    kanbanColumns.style.marginTop = '0px';
    icon.style.transform = 'rotate(-90deg)';
  } else {
    kanbanColumns.style.maxHeight = 'none';
  }
}

/* ========= TASK MANAGEMENT CRUD ========= */
function openTaskModal(taskId = null) {
  const modal = document.getElementById("taskModal");
  const title = document.getElementById("taskModalTitle");
  const textInput = document.getElementById("taskText");
  const dateInput = document.getElementById("taskDueDate");
  const idInput = document.getElementById("taskId");

  if (taskId) {
    // Edit existing task
    const task = tasksState.tasks.find(t => t.id === taskId);
    if (task) {
      title.textContent = "Edit Task";
      textInput.value = task.text;
      dateInput.value = task.dueDate;
      idInput.value = task.id;
    }
  } else {
    // New task
    title.textContent = "Add New Task";
    textInput.value = "";
    // Set default date to today
    const today = new Date().toISOString().split('T')[0];
    dateInput.value = today;
    idInput.value = "";
  }

  lastFocusedElementBeforeModal = document.activeElement;
  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
  textInput.focus();
}

function closeTaskModal() {
  const modal = document.getElementById("taskModal");
  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
  if (lastFocusedElementBeforeModal) {
    lastFocusedElementBeforeModal.focus();
    lastFocusedElementBeforeModal = null;
  }
}

function saveTaskModal() {
  const textInput = document.getElementById("taskText");
  const dateInput = document.getElementById("taskDueDate");
  const idInput = document.getElementById("taskId");

  const text = textInput.value.trim();
  const dueDate = dateInput.value;

  if (!text) {
    toast("Please enter a task description", false);
    return;
  }

  if (!dueDate) {
    toast("Please select a due date", false);
    return;
  }

  // Warn if date is in the past (but still allow it)
  const today = new Date().toISOString().split('T')[0];
  if (dueDate < today) {
    if (!confirm(`‚ö†Ô∏è Warning: This date is in the past (${dueDate}).\n\nDo you want to continue?`)) {
      return;
    }
  }

  const taskId = idInput.value;

  if (taskId) {
    // Edit existing task
    const task = tasksState.tasks.find(t => t.id == taskId);
    if (task) {
      task.text = text;
      task.dueDate = dueDate;
      toast("Task updated successfully");
    }
  } else {
    // Create new task
    const newTask = {
      id: Date.now(),
      text: text,
      dueDate: dueDate,
      completed: false
    };
    tasksState.tasks.push(newTask);
    toast("Task added successfully");
  }

  saveTasks();
  updateTasksDisplay();
  closeTaskModal();
}

function editTask(taskId) {
  openTaskModal(taskId);
}

function deleteTask(taskId) {
  const index = tasksState.tasks.findIndex(t => t.id === taskId);

  if (index === -1) {
    toast("Task not found", false);
    return;
  }

  const task = tasksState.tasks[index];
  const taskText = task.text || 'Unnamed task';

  if (!confirm(`Are you sure you want to delete this task?\n\n"${taskText}"\n\nThis action cannot be undone.`)) {
    return;
  }

  tasksState.tasks.splice(index, 1);
  saveTasks();
  updateTasksDisplay();
  toast("Task deleted successfully");
}

/* ========= LEAD/PROSPECT MANAGEMENT CRUD ========= */
// Render activity log
function renderActivityLog(activityLog = []) {
  const container = document.getElementById('leadActivityLog');
  if (!activityLog || activityLog.length === 0) {
    container.innerHTML = '<div class="text-gray-400 italic">No activity yet</div>';
    return;
  }

  container.innerHTML = activityLog.map(activity => {
    const date = new Date(activity.timestamp);
    const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    return `
      <div class="text-gray-700">
        <span class="text-gray-500">${dateStr}:</span> ${esc(activity.note)}
      </div>
    `;
  }).join('');
}

// Add activity note to current lead
function addActivityNote() {
  const noteInput = document.getElementById('leadNewActivity');
  const note = noteInput.value.trim();

  if (!note) {
    toast('Please enter a note', false);
    return;
  }

  const leadId = document.getElementById("leadId").value;
  const column = document.getElementById("leadColumn").value;

  if (!leadId) {
    toast('Please save the lead first before adding notes', false);
    return;
  }

  // Find the lead
  const items = kanbanState.columns[column] || [];
  const lead = items.find(item => typeof item === 'object' && item.id === parseFloat(leadId));

  if (!lead) {
    toast('Lead not found', false);
    return;
  }

  // Add note to activity log
  if (!lead.activityLog) {
    lead.activityLog = [];
  }

  lead.activityLog.push({
    timestamp: new Date().toISOString(),
    note: note
  });

  // Re-render activity log
  renderActivityLog(lead.activityLog);

  // Clear input
  noteInput.value = '';

  // Save changes
  saveKanban();

  toast('Note added', true);
}

// Expose functions globally
window.addActivityNote = addActivityNote;

/* ========= CONTACT LATER MODAL ========= */
function openContactLaterModal(leadId, event) {
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  const prospectingColumn = 'prospect-list';
  const items = kanbanState.columns[prospectingColumn] || [];

  // Convert leadId to number for comparison
  const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;

  const lead = items.find(item => {
    if (typeof item !== 'object' || !item) return false;
    const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
    return itemId === numericLeadId;
  });

  if (!lead) {
    console.error('Lead not found. Looking for ID:', numericLeadId, 'in items:', items);
    toast('Prospect not found', false);
    return;
  }

  // Set modal data
  document.getElementById('contactLaterBusinessName').textContent = lead.businessName;
  document.getElementById('contactLaterLeadId').value = numericLeadId;

  // Set default date to tomorrow
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  document.getElementById('contactLaterDate').value = tomorrow.toISOString().split('T')[0];

  document.getElementById('contactLaterNote').value = '';

  // Show modal
  const modal = document.getElementById('contactLaterModal');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
  document.getElementById('contactLaterDate').focus();
}

function closeContactLaterModal() {
  const modal = document.getElementById('contactLaterModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
}

function saveContactLater() {
  const leadId = parseFloat(document.getElementById('contactLaterLeadId').value);
  const followUpDate = document.getElementById('contactLaterDate').value;
  const note = document.getElementById('contactLaterNote').value.trim();

  if (!followUpDate) {
    toast('Please select a follow-up date', false);
    return;
  }

  const prospectingColumn = 'prospect-list';
  const items = kanbanState.columns[prospectingColumn] || [];
  const leadIndex = items.findIndex(item => typeof item === 'object' && item.id === leadId);

  if (leadIndex === -1) {
    toast('Prospect not found', false);
    return;
  }

  const lead = items[leadIndex];

  // Set follow-up date
  lead.followUpDate = followUpDate;

  // Add activity note if provided
  if (note) {
    if (!lead.activityLog) {
      lead.activityLog = [];
    }
    lead.activityLog.push({
      timestamp: new Date().toISOString(),
      note: `üìÖ Set follow-up for ${followUpDate}: ${note}`
    });
  } else {
    if (!lead.activityLog) {
      lead.activityLog = [];
    }
    lead.activityLog.push({
      timestamp: new Date().toISOString(),
      note: `üìÖ Set follow-up for ${followUpDate}`
    });
  }

  // Move to pool - check if already exists to avoid duplicates
  const existingIndex = prospectPoolState.manualProspects.findIndex(p =>
    p.id === lead.id ||
    (p.placeId && p.placeId === lead.placeId) ||
    (p.businessName && p.businessName.toLowerCase() === lead.businessName.toLowerCase() && p.mailerId === lead.mailerId)
  );

  if (existingIndex !== -1) {
    // Update existing prospect
    prospectPoolState.manualProspects[existingIndex] = {
      ...prospectPoolState.manualProspects[existingIndex],
      ...lead,
      movedToPoolDate: new Date().toISOString(),
      isEnriched: false // Keep standard search result styling
    };
  } else {
    // Add new prospect
    prospectPoolState.manualProspects.push({
      ...lead,
      movedToPoolDate: new Date().toISOString(),
      isEnriched: false // Keep standard search result styling
    });
  }

  // Remove from prospecting
  kanbanState.columns[prospectingColumn].splice(leadIndex, 1);

  saveManualProspects();
  saveKanban();
  renderKanban();
  closeContactLaterModal();

  toast(`üìÖ "${lead.businessName}" moved to pool. Follow up on ${followUpDate}`, true);
}

// Expose functions globally
window.openContactLaterModal = openContactLaterModal;
window.closeContactLaterModal = closeContactLaterModal;
window.saveContactLater = saveContactLater;

// Legacy kanban ZIP filter functions removed - campaign board has its own ZIP filtering

// Campaign Board window exports
window.toggleCampaignBoardView = toggleCampaignBoardView;
window.openCampaignConfigModal = openCampaignConfigModal;
window.saveCampaignConfig = saveCampaignConfig;
window.closeCampaignConfigModal = closeCampaignConfigModal;
window.migrateToCampaignBoards = migrateToCampaignBoards;
window.openCampaignBoardQuickAction = openCampaignBoardQuickAction;
window.deleteCampaignBoardItem = deleteCampaignBoardItem;
window.setCampaignBoardZipFilter = setCampaignBoardZipFilter;
window.setGlobalZipFilter = setGlobalZipFilter;
window.addTargetZipFromSelect = addTargetZipFromSelect;
window.addManualTargetZip = addManualTargetZip;
window.addTargetZip = addTargetZip;
window.removeTargetZip = removeTargetZip;
window.openLogReplyModal = openLogReplyModal;
window.filterLogReplyResults = filterLogReplyResults;
window.selectLogReplyBusiness = selectLogReplyBusiness;
window.clearLogReplySelection = clearLogReplySelection;
window.selectLogReplyChannel = selectLogReplyChannel;
window.submitLogReply = submitLogReply;
window.closeLogReplyModal = closeLogReplyModal;
window.toggleCampaignBoardEditMode = toggleCampaignBoardEditMode;
window.saveCampaignBoardContactEdit = saveCampaignBoardContactEdit;

function openLeadModal(column = null, leadId = null) {
  const modal = document.getElementById("leadModal");
  const title = document.getElementById("leadModalTitle");
  const columnInput = document.getElementById("leadColumn");
  const idInput = document.getElementById("leadId");

  if (leadId !== null && column) {
    // Edit existing lead - search campaign board
    const legacyToBoard = {
      'prospect-list': 'queued',
      'to-contact': 'attempting',
      'in-progress': 'negotiating',
      'committed': 'invoice-sent'
    };
    const boardColumn = legacyToBoard[column] || column;
    const board = getCurrentCampaignBoard();
    const items = (board && board.columns && board.columns[boardColumn]) || [];
    const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;
    const lead = items.find(item => {
      if (typeof item !== 'object') return false;
      const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
      return itemId === numericLeadId;
    });

    if (lead) {
      title.textContent = "Edit Lead";
      document.getElementById("leadBusinessName").value = lead.businessName || '';
      document.getElementById("leadContactName").value = lead.contactName || '';
      document.getElementById("leadPhone").value = lead.phone || '';
      document.getElementById("leadEmail").value = lead.email || '';
      document.getElementById("leadWebsite").value = lead.website || '';
      document.getElementById("leadFacebook").value = lead.facebook || '';
      document.getElementById("leadInstagram").value = lead.instagram || '';
      document.getElementById("leadValue").value = lead.value || '';
      document.getElementById("leadNotes").value = lead.notes || '';
      document.getElementById("leadFollowUpDate").value = lead.followUpDate || '';

      // Render activity log
      renderActivityLog(lead.activityLog || []);

      columnInput.value = column;
      idInput.value = leadId;
    }
  } else {
    // New lead
    title.textContent = "Add New Lead";
    document.getElementById("leadBusinessName").value = '';
    document.getElementById("leadContactName").value = '';
    document.getElementById("leadPhone").value = '';
    document.getElementById("leadEmail").value = '';
    document.getElementById("leadWebsite").value = '';
    document.getElementById("leadFacebook").value = '';
    document.getElementById("leadInstagram").value = '';
    document.getElementById("leadValue").value = '';
    document.getElementById("leadNotes").value = '';
    document.getElementById("leadFollowUpDate").value = '';

    // Clear activity log
    renderActivityLog([]);

    columnInput.value = column || 'prospect-list';
    idInput.value = '';
  }

  lastFocusedElementBeforeModal = document.activeElement;
  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
  document.getElementById("leadBusinessName").focus();
}

function closeLeadModal() {
  const modal = document.getElementById("leadModal");
  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
  if (lastFocusedElementBeforeModal) {
    lastFocusedElementBeforeModal.focus();
    lastFocusedElementBeforeModal = null;
  }
}

function saveLeadModal() {
  const businessName = document.getElementById("leadBusinessName").value.trim();
  const contactName = document.getElementById("leadContactName").value.trim();
  const phone = document.getElementById("leadPhone").value.trim();
  const email = document.getElementById("leadEmail").value.trim();
  const website = document.getElementById("leadWebsite").value.trim();
  const facebook = document.getElementById("leadFacebook").value.trim();
  const instagram = document.getElementById("leadInstagram").value.trim();
  const value = document.getElementById("leadValue").value.trim();
  const notes = document.getElementById("leadNotes").value.trim();
  const followUpDate = document.getElementById("leadFollowUpDate").value;
  const column = document.getElementById("leadColumn").value;
  const leadId = document.getElementById("leadId").value;

  if (!businessName) {
    toast("Please enter a business name", false);
    return;
  }

  // Get existing activity log if editing
  let activityLog = [];
  if (leadId) {
    const items = kanbanState.columns[column] || [];
    const existingLead = items.find(item => typeof item === 'object' && item.id === parseFloat(leadId));
    if (existingLead && existingLead.activityLog) {
      activityLog = existingLead.activityLog;
    }
  }

  const leadData = {
    id: leadId ? parseFloat(leadId) : Date.now() + Math.random(),
    businessName: businessName,
    contactName: contactName,
    phone: phone,
    email: email,
    website: website,
    facebook: facebook,
    instagram: instagram,
    value: value ? parseFloat(value) : 0,
    notes: notes,
    followUpDate: followUpDate,
    activityLog: activityLog,
    createdDate: new Date().toISOString()
  };

  // Map legacy column names to board columns
  const legacyToBoard = {
    'prospect-list': 'queued',
    'to-contact': 'attempting',
    'in-progress': 'negotiating',
    'committed': 'invoice-sent'
  };
  const boardColumn = legacyToBoard[column] || column;

  const board = getCurrentCampaignBoard();
  if (board && board.columns) {
    if (leadId) {
      // Edit existing lead
      const items = board.columns[boardColumn] || [];
      const index = items.findIndex(item => typeof item === 'object' && item.id === parseFloat(leadId));
      if (index !== -1) {
        items[index] = leadData;
        toast("Lead updated successfully");
      }
    } else {
      // Add new lead
      if (!board.columns[boardColumn]) {
        board.columns[boardColumn] = [];
      }
      board.columns[boardColumn].push(leadData);
      toast("Lead added successfully");
    }
  }

  saveCampaignBoards();
  renderKanban();
  closeLeadModal();
}

function editLead(column, leadId, event) {
  // Stop event propagation to prevent drag behavior
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }
  // Normalize ID type (handle both string and number)
  const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;
  openLeadModal(column, numericLeadId);
}

async function deleteLead(column, leadId, event) {
  // Stop event propagation
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  const items = kanbanState.columns[column] || [];

  // Find by ID - convert both to strings for comparison to avoid floating point precision issues
  const index = items.findIndex((item, idx) => {
    if (typeof item === 'string') return false;
    if (!item) return false;

    // Convert both IDs to strings for comparison (handles floating point precision)
    const leadIdStr = String(leadId);
    const itemIdStr = String(item.id);

    // Check if item.id matches (string comparison)
    if (item.id !== undefined && itemIdStr === leadIdStr) {
      return true;
    }

    // Fallback: check if leadId matches the array index
    return idx === leadId || String(idx) === leadIdStr;
  });

  if (index === -1) {
    toast("Lead not found", false);
    return;
  }

  const lead = items[index];
  const leadName = typeof lead === 'string' ? lead : (lead.businessName || 'Unnamed Lead');

  if (!confirm(`Are you sure you want to delete "${leadName}"?\n\nThis action cannot be undone.`)) {
    return;
  }

  if (index !== -1) {
    items.splice(index, 1);

    // Clear this prospect from selection if it was selected
    prospectingSelectionState.selectedIds.delete(leadId);

    await saveKanban(); // AWAIT to prevent race condition
    renderKanban();
    toast("Lead deleted successfully");
  }
}

// Delete lead from BOTH kanban AND pool permanently
async function deleteLeadPermanently(column, leadId, event) {
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  // Find the lead in kanban
  const items = kanbanState.columns[column] || [];
  const index = items.findIndex((item, idx) => {
    if (typeof item === 'string') return false;
    if (!item) return false;
    const leadIdStr = String(leadId);
    const itemIdStr = String(item.id);
    if (item.id !== undefined && itemIdStr === leadIdStr) return true;
    return idx === leadId || String(idx) === leadIdStr;
  });

  if (index === -1) {
    toast("Lead not found", false);
    return;
  }

  const lead = items[index];
  const leadName = typeof lead === 'string' ? lead : (lead.businessName || 'Unnamed Lead');

  if (!confirm(`Are you sure you want to permanently delete "${leadName}"?\n\nThis will remove it from the kanban AND the prospect pool.\n\nThis action cannot be undone.`)) {
    return;
  }

  // Remove from kanban
  items.splice(index, 1);

  // Clear from all selection states
  prospectingSelectionState.selectedIds.delete(String(leadId));
  toContactSelectionState.selectedIds.delete(String(leadId));
  inProgressSelectionState.selectedIds.delete(String(leadId));
  committedSelectionState.selectedIds.delete(String(leadId));

  // Also remove from prospect pool if it exists there
  if (lead && typeof lead === 'object') {
    // Remove from manualProspects by placeId or id
    if (prospectPoolState.manualProspects) {
      const poolIndex = prospectPoolState.manualProspects.findIndex(p =>
        (p.placeId && lead.placeId && p.placeId === lead.placeId) ||
        (p.id && String(p.id) === String(lead.id)) ||
        (p.businessName && lead.businessName && p.businessName.toLowerCase() === lead.businessName.toLowerCase())
      );
      if (poolIndex > -1) {
        prospectPoolState.manualProspects.splice(poolIndex, 1);
        console.log('üóëÔ∏è Also removed from prospect pool manualProspects');
      }
    }

    // Remove from rendered prospects lookup
    if (prospectPoolState.renderedProspects && lead.id) {
      delete prospectPoolState.renderedProspects[String(lead.id)];
    }
  }

  await saveKanban();
  await saveProspectPool(); // Also save prospect pool changes
  renderKanban();
  toast("Lead permanently deleted from kanban and pool");
}

async function moveProspectBackToPool(leadId, event) {
  // Stop event propagation
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  console.log('üî¥ moveProspectBackToPool called with leadId:', leadId);

  // Get direct reference to the board column array
  const board = getCurrentCampaignBoard();
  if (!board || !board.columns) {
    toast('No campaign board available', false);
    return;
  }
  if (!board.columns['queued']) {
    board.columns['queued'] = [];
  }
  const items = board.columns['queued'];

  console.log('üî¥ prospect-list has', items.length, 'items before removal');

  // Find by ID - convert both to strings for comparison to avoid floating point precision issues
  let index = items.findIndex((item, idx) => {
    if (typeof item === 'string') return false;
    if (!item) return false;

    // Convert both IDs to strings for comparison (handles floating point precision)
    const leadIdStr = String(leadId);
    const itemIdStr = String(item.id);

    // Check if item.id matches (string comparison)
    if (item.id !== undefined && itemIdStr === leadIdStr) {
      return true;
    }

    // Fallback: check if leadId matches the array index
    return idx === leadId || String(idx) === leadIdStr;
  });

  if (index === -1) {
    console.error("Prospect not found. leadId:", leadId, "type:", typeof leadId, "Available items:", items.map((item, idx) => ({idx, id: item?.id, idType: typeof item?.id, name: item?.businessName})));
    toast("Prospect not found", false);
    return;
  }

  const prospect = items[index];
  const prospectName = typeof prospect === 'string' ? prospect : (prospect.businessName || 'Unnamed Prospect');

  console.log('üî¥ Found prospect at index', index, ':', prospectName);

  // Remove from queued column
  items.splice(index, 1);

  console.log('üî¥ queued has', items.length, 'items after removal');

  // Add to manual prospects in pool ONLY if not already there
  if (!prospectPoolState.manualProspects) {
    prospectPoolState.manualProspects = [];
  }

  // Check if already exists in pool (by placeId or businessName)
  const alreadyInPool = prospectPoolState.manualProspects.some(p => {
    if (prospect.placeId && p.placeId) {
      return p.placeId === prospect.placeId;
    }
    if (prospect.businessName && p.businessName) {
      return p.businessName.toLowerCase() === prospect.businessName.toLowerCase();
    }
    return false;
  });

  // Create the prospect object to add to pool (preserving doNotContact)
  // Clear contact tracking so they start fresh when re-added
  const poolProspect = {
    ...prospect,
    isEnriched: false, // Reset styling
    enriched: false, // Reset so it can be re-enriched when added to kanban again
    doNotContact: prospect.doNotContact || false, // Explicitly preserve doNotContact
    contactTracking: null,  // Clear so they show as not contacted when re-added
    attemptTracking: null,
    channelStatus: null
  };

  if (!alreadyInPool) {
    prospectPoolState.manualProspects.push(poolProspect);
  } else {
    // Update existing entry to reset enriched flag but preserve doNotContact
    const existingIndex = prospectPoolState.manualProspects.findIndex(p => {
      if (prospect.placeId && p.placeId) return p.placeId === prospect.placeId;
      if (prospect.businessName && p.businessName) return p.businessName.toLowerCase() === prospect.businessName.toLowerCase();
      return false;
    });
    if (existingIndex !== -1) {
      prospectPoolState.manualProspects[existingIndex] = {
        ...prospectPoolState.manualProspects[existingIndex],
        ...poolProspect
      };
    }
    console.log(`üîÑ Prospect "${prospectName}" already in pool - reset for re-enrichment`);
  }

  // Also update allBusinesses if it exists (for enriched prospects view)
  if (prospectPoolState.allBusinesses) {
    const allBizIndex = prospectPoolState.allBusinesses.findIndex(b =>
      b && ((prospect.placeId && b.placeId === prospect.placeId) ||
            (prospect.businessName && b.businessName?.toLowerCase() === prospect.businessName.toLowerCase()))
    );
    if (allBizIndex !== -1) {
      prospectPoolState.allBusinesses[allBizIndex] = {
        ...prospectPoolState.allBusinesses[allBizIndex],
        doNotContact: prospect.doNotContact || false
      };
    } else {
      // Add to allBusinesses if not found
      prospectPoolState.allBusinesses.push(poolProspect);
    }
  }

  // Clear from selection if it was selected
  prospectingSelectionState.selectedIds.delete(leadId);

  console.log('üî¥ About to save kanban. Current prospect-list length:', kanbanState.columns['prospect-list']?.length);
  await saveKanban(); // Save kanban without this prospect
  console.log('üî¥ After saveKanban. prospect-list length:', kanbanState.columns['prospect-list']?.length);

  // Save pool with this prospect (triggers deduplication)
  await saveManualProspects();

  console.log('üî¥ About to renderKanban. prospect-list length:', kanbanState.columns['prospect-list']?.length);
  renderKanban();
  renderProspectPool();
  console.log('üî¥ Render complete. Move successful for:', prospectName);
  toast(`"${prospectName}" moved back to Prospect Pool`, true);
}

/* ========= DAILY GOAL TRACKING FUNCTIONS ========= */

// Increment daily outreach count (called when: button clicks, manual moves)
function incrementDailyGoal(businessName = '') {
  checkAndResetDailyGoal(); // Always check for date change first
  dailyGoalState.todayCount++;

  // Add to today's history
  const today = new Date().toDateString();
  let todayRecord = dailyGoalState.history.find(h => h.date === today);
  if (!todayRecord) {
    todayRecord = { date: today, goal: dailyGoalState.dailyGoal, actual: 0, businesses: [] };
    dailyGoalState.history.push(todayRecord);
  }
  todayRecord.actual = dailyGoalState.todayCount;
  if (businessName) {
    todayRecord.businesses.push({ name: businessName, timestamp: new Date().toISOString() });
  }

  saveDailyGoalState();
  // NOTE: Don't call renderKanban() here - let the calling function handle it
  // This prevents double-render issues and race conditions
}

// Decrement daily outreach count (called when moving back TO "To Contact")
function decrementDailyGoal(businessName = '') {
  checkAndResetDailyGoal(); // Always check for date change first

  // Don't go below 0
  if (dailyGoalState.todayCount > 0) {
    dailyGoalState.todayCount--;
  }

  // Update today's history
  const today = new Date().toDateString();
  let todayRecord = dailyGoalState.history.find(h => h.date === today);
  if (todayRecord) {
    todayRecord.actual = dailyGoalState.todayCount;
    // Remove last business entry if it exists
    if (businessName && todayRecord.businesses.length > 0) {
      todayRecord.businesses.pop();
    }
  }

  saveDailyGoalState();
}

// Check if it's a new day and reset if needed
function checkAndResetDailyGoal() {
  const today = new Date().toDateString();
  if (dailyGoalState.lastResetDate !== today) {
    // New day! Save yesterday's final count to history (if not already saved)
    if (dailyGoalState.todayCount > 0) {
      const yesterdayRecord = dailyGoalState.history.find(h => h.date === dailyGoalState.lastResetDate);
      if (yesterdayRecord) {
        yesterdayRecord.actual = dailyGoalState.todayCount;
      }
    }

    // Reset for new day
    dailyGoalState.todayCount = 0;
    dailyGoalState.lastResetDate = today;
    saveDailyGoalState();
    console.log('Daily goal reset for new day:', today);
  }
}

// Save daily goal state to localStorage
function saveDailyGoalState() {
  try {
    localStorage.setItem('dailyGoalState', JSON.stringify(dailyGoalState));
  } catch (e) {
    console.error('Failed to save daily goal state to localStorage:', e);
  }
  // Also sync to cloud for cross-device consistency
  saveToCloud('dailyGoal', dailyGoalState).catch(e => {
    console.warn('Failed to sync daily goal to cloud:', e);
  });
}

// Load daily goal state - cloud first, then localStorage
async function loadDailyGoalState() {
  try {
    // Try cloud first for cross-device sync
    const cloudData = await loadFromCloud('dailyGoal');
    if (cloudData && typeof cloudData === 'object') {
      dailyGoalState.dailyGoal = cloudData.dailyGoal || 10;
      dailyGoalState.todayCount = cloudData.todayCount || 0;
      dailyGoalState.lastResetDate = cloudData.lastResetDate || new Date().toDateString();
      dailyGoalState.history = cloudData.history || [];
      console.log('‚úÖ Loaded daily goal from cloud:', dailyGoalState.todayCount);
    } else {
      // Fallback to localStorage
      const saved = localStorage.getItem('dailyGoalState');
      if (saved) {
        const loaded = JSON.parse(saved);
        dailyGoalState.dailyGoal = loaded.dailyGoal || 10;
        dailyGoalState.todayCount = loaded.todayCount || 0;
        dailyGoalState.lastResetDate = loaded.lastResetDate || new Date().toDateString();
        dailyGoalState.history = loaded.history || [];
      }
    }
    checkAndResetDailyGoal(); // Check if we need to reset for new day
  } catch (e) {
    console.error('Failed to load daily goal state:', e);
    // Fallback to localStorage on error
    try {
      const saved = localStorage.getItem('dailyGoalState');
      if (saved) {
        const loaded = JSON.parse(saved);
        dailyGoalState.dailyGoal = loaded.dailyGoal || 10;
        dailyGoalState.todayCount = loaded.todayCount || 0;
        dailyGoalState.lastResetDate = loaded.lastResetDate || new Date().toDateString();
        dailyGoalState.history = loaded.history || [];
      }
      checkAndResetDailyGoal();
    } catch (e2) {
      console.error('localStorage fallback also failed:', e2);
    }
  }
}

// Handle "Communicating" button click
function handleCommunicating(leadId, event) {
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  // Find lead in campaign board attempting column
  const board = getCurrentCampaignBoard();
  if (!board || !board.columns) {
    toast("No campaign board available", false);
    return;
  }
  const items = board.columns['attempting'] || [];
  const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;
  const index = items.findIndex(item => {
    if (typeof item === 'string') return false;
    const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
    return itemId === numericLeadId;
  });

  if (index === -1) {
    toast("Lead not found", false);
    return;
  }

  // Move to negotiating column
  const lead = items[index];
  items.splice(index, 1);
  if (!board.columns['negotiating']) board.columns['negotiating'] = [];
  board.columns['negotiating'].push(lead);

  // Increment daily goal
  const businessName = typeof lead === 'string' ? lead : (lead.businessName || 'Unnamed Lead');
  incrementDailyGoal(businessName);

  saveCampaignBoards();
  renderKanban();
  toast(`${businessName} moved to Negotiating`);
}

// Toggle contact tracking status (emailed, dmed, texted)
// Uses Campaign Board as single source of truth
async function toggleContactTracking(leadId, method, event) {
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  // Find lead in Campaign Board (single source of truth)
  const board = getCurrentCampaignBoard();
  if (!board || !board.columns) {
    console.warn('Contact tracking: No Campaign Board found');
    return;
  }

  let foundItem = null;
  let foundColumn = null;

  for (const colKey of Object.keys(board.columns)) {
    const items = board.columns[colKey] || [];
    const item = items.find(i => i && typeof i === 'object' && String(i.id) === String(leadId));
    if (item) {
      foundItem = item;
      foundColumn = colKey;
      break;
    }
  }

  if (!foundItem) {
    console.warn('Contact tracking: Lead not found in Campaign Board', leadId);
    return;
  }

  // Initialize contactTracking if not exists
  if (!foundItem.contactTracking) {
    foundItem.contactTracking = {
      emailed: false,
      emailedDate: null,
      dmed: false,
      dmedDate: null,
      texted: false,
      textedDate: null
    };
  }

  // Toggle the method
  const wasSet = foundItem.contactTracking[method];
  foundItem.contactTracking[method] = !wasSet;
  foundItem.contactTracking[method + 'Date'] = wasSet ? null : new Date().toISOString();

  // Update last contacted date
  if (!wasSet) {
    foundItem.lastContacted = new Date().toISOString();
  }

  // Re-render immediately for UI feedback
  renderKanban();

  const methodNames = { emailed: 'Email', dmed: 'DM', texted: 'Text', linkedinMessaged: 'LinkedIn', facebookMessaged: 'Facebook', called: 'Call', visitedInPerson: 'Visit' };
  const action = wasSet ? 'unmarked' : 'marked';
  toast(`${methodNames[method]} ${action} for ${foundItem.businessName || 'business'}`);

  // Save to cloud (await to ensure it completes)
  try {
    await saveKanban();
    console.log('‚úÖ Contact tracking saved to cloud');
  } catch (err) {
    console.error('‚ùå Failed to save contact tracking:', err);
    toast('Warning: Changes may not have synced to cloud', false);
  }
}

// ============================================
// FOLLOW-UP DASHBOARD FUNCTIONS
// ============================================

// Parse a date string as LOCAL time (not UTC)
// Handles "YYYY-MM-DD" format from date inputs
function parseLocalDate(dateStr) {
  if (!dateStr) return null;
  // If it's already a Date object, use it
  if (dateStr instanceof Date) return dateStr;
  // If it's a YYYY-MM-DD string, parse as local
  if (typeof dateStr === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
    const [year, month, day] = dateStr.split('-').map(Number);
    return new Date(year, month - 1, day); // month is 0-indexed
  }
  // Otherwise use standard parsing
  return new Date(dateStr);
}

// Follow-Up Dashboard removed - stub functions to prevent errors
function refreshFollowUpDashboard() {
  // Dashboard removed - no-op
}

function renderFollowUpDashboard() {
  // Dashboard removed - no-op
}


// ============================================
// CONTACT STATUS DASHBOARD FUNCTIONS
// ============================================

// State for contact status dashboard
let contactStatusState = {
  texted: [],
  emailed: [],
  facebookMessaged: [],
  dmed: [],
  called: [],
  linkedinMessaged: [],
  currentChannel: null
};

// Refresh contact status dashboard
function refreshContactStatusDashboard() {
  // Reset state
  contactStatusState.texted = [];
  contactStatusState.emailed = [];
  contactStatusState.facebookMessaged = [];
  contactStatusState.dmed = [];
  contactStatusState.called = [];
  contactStatusState.linkedinMessaged = [];

  // Scan all Campaign Board columns (single source of truth)
  const board = getCurrentCampaignBoard();
  if (!board || !board.columns) return;

  Object.keys(board.columns).forEach(columnKey => {
    const items = board.columns[columnKey] || [];
    items.forEach(prospect => {
      if (!prospect || typeof prospect !== 'object') return;
      const ct = prospect.contactTracking || {};

      if (ct.texted) {
        contactStatusState.texted.push({ ...prospect, column: columnKey, contactDate: ct.textedDate });
      }
      if (ct.emailed) {
        contactStatusState.emailed.push({ ...prospect, column: columnKey, contactDate: ct.emailedDate });
      }
      if (ct.facebookMessaged) {
        contactStatusState.facebookMessaged.push({ ...prospect, column: columnKey, contactDate: ct.facebookMessagedDate });
      }
      if (ct.dmed) {
        contactStatusState.dmed.push({ ...prospect, column: columnKey, contactDate: ct.dmedDate });
      }
      if (ct.called) {
        contactStatusState.called.push({ ...prospect, column: columnKey, contactDate: ct.calledDate });
      }
      if (ct.linkedinMessaged) {
        contactStatusState.linkedinMessaged.push({ ...prospect, column: columnKey, contactDate: ct.linkedinMessagedDate });
      }
    });
  });

  // Sort each by most recent first
  // Sort oldest first (needs follow-up sooner)
  const sortByDate = (a, b) => {
    if (!a.contactDate) return -1; // No date = oldest
    if (!b.contactDate) return 1;
    return new Date(a.contactDate) - new Date(b.contactDate);
  };
  contactStatusState.texted.sort(sortByDate);
  contactStatusState.emailed.sort(sortByDate);
  contactStatusState.facebookMessaged.sort(sortByDate);
  contactStatusState.dmed.sort(sortByDate);
  contactStatusState.called.sort(sortByDate);
  contactStatusState.linkedinMessaged.sort(sortByDate);

  // Update counts in UI
  const textedCount = document.getElementById('textedCount');
  const emailedCount = document.getElementById('emailedCount');
  const facebookCount = document.getElementById('facebookCount');
  const instagramCount = document.getElementById('instagramCount');

  console.log('üìä Contact Status Update:', {
    texted: contactStatusState.texted.length,
    emailed: contactStatusState.emailed.length,
    facebook: contactStatusState.facebookMessaged.length,
    instagram: contactStatusState.dmed.length,
    elements: {
      textedCount: !!textedCount,
      emailedCount: !!emailedCount,
      facebookCount: !!facebookCount,
      instagramCount: !!instagramCount
    }
  });

  if (textedCount) textedCount.textContent = contactStatusState.texted.length;
  if (emailedCount) emailedCount.textContent = contactStatusState.emailed.length;
  if (facebookCount) facebookCount.textContent = contactStatusState.facebookMessaged.length;
  if (instagramCount) instagramCount.textContent = contactStatusState.dmed.length;

  // If a channel is currently shown, refresh it
  if (contactStatusState.currentChannel) {
    showContactedByChannel(contactStatusState.currentChannel);
  }
}

// Show businesses contacted by a specific channel (legacy - now shows all)
function showContactedByChannel(channelKey) {
  // Now just toggles the expanded view showing all channels
  toggleContactStatusExpanded();
}

// Calculate days ago from date
function getDaysAgo(dateStr) {
  if (!dateStr) return null;
  const date = new Date(dateStr);
  const now = new Date();
  const diffTime = now - date;
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
  if (diffDays === 0) return 'Today';
  if (diffDays === 1) return '1 day ago';
  return `${diffDays} days ago`;
}

// Render a single channel's list of businesses
function renderChannelList(listId, data, channelKey, colorClass) {
  const list = document.getElementById(listId);
  if (!list) return;

  if (data.length === 0) {
    const emptyText = {
      texted: 'No texted businesses',
      emailed: 'No emailed businesses',
      facebookMessaged: 'No FB messaged businesses',
      dmed: 'No IG DM\'d businesses'
    };
    list.innerHTML = `<p class="text-xs text-gray-400 italic">${emptyText[channelKey] || 'None'}</p>`;
    return;
  }

  // Color mapping for buttons
  const colorMap = {
    texted: 'green',
    emailed: 'blue',
    facebookMessaged: 'indigo',
    dmed: 'pink'
  };
  const btnColor = colorMap[channelKey] || 'gray';

  list.innerHTML = data.map(p => {
    const daysAgo = getDaysAgo(p.contactDate);
    const daysNum = p.contactDate ? Math.floor((new Date() - new Date(p.contactDate)) / (1000 * 60 * 60 * 24)) : 999;
    const urgencyClass = daysNum >= 7 ? 'text-red-500 font-medium' : daysNum >= 3 ? 'text-amber-500' : 'text-gray-400';

    return `
      <div class="bg-gray-50 border border-gray-100 rounded-lg p-2 text-xs mb-1">
        <div class="font-semibold text-gray-800 truncate mb-1">${esc(p.businessName || 'Unknown')}</div>
        <div class="flex items-center justify-between gap-1">
          <span class="${urgencyClass}">${daysAgo || 'No date'}</span>
          <div class="flex gap-1">
            <button onclick="followUpContact('${p.id}', '${channelKey}')"
                    class="px-2 py-0.5 bg-${btnColor}-100 text-${btnColor}-700 rounded hover:bg-${btnColor}-200 font-medium"
                    title="Follow up via ${channelKey}">
              Follow Up
            </button>
            <button onclick="removeContactTracking('${p.id}', '${channelKey}')"
                    class="px-1 py-0.5 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded"
                    title="Remove">
              ‚úï
            </button>
          </div>
        </div>
      </div>
    `;
  }).join('');
}

// Render all 4 channel columns
function renderAllContactStatusColumns() {
  renderChannelList('textedList', contactStatusState.texted, 'texted', 'green');
  renderChannelList('emailedList', contactStatusState.emailed, 'emailed', 'blue');
  renderChannelList('facebookList', contactStatusState.facebookMessaged, 'facebookMessaged', 'indigo');
  renderChannelList('instagramList', contactStatusState.dmed, 'dmed', 'pink');
}

// Toggle expanded section
function toggleContactStatusExpanded() {
  const expandedSection = document.getElementById('contactStatusExpanded');
  const toggleBtn = document.getElementById('btnContactStatusToggle');

  if (expandedSection && expandedSection.classList.contains('hidden')) {
    // Show and render all columns
    expandedSection.classList.remove('hidden');
    renderAllContactStatusColumns();
    if (toggleBtn) toggleBtn.textContent = '‚ûñ Collapse';
  } else {
    hideContactStatusExpanded();
  }
}

// Hide expanded section
function hideContactStatusExpanded() {
  const expandedSection = document.getElementById('contactStatusExpanded');
  const toggleBtn = document.getElementById('btnContactStatusToggle');

  if (expandedSection) expandedSection.classList.add('hidden');
  if (toggleBtn) toggleBtn.textContent = '‚ûï Expand';
}

// Remove contact tracking for a specific channel
async function removeContactTracking(prospectId, channelKey) {
  const result = findProspectInCampaignBoard(prospectId);
  if (!result) {
    toast('Prospect not found', false);
    return;
  }

  const prospect = result.item;
  if (!prospect.contactTracking) {
    toast('No contact tracking to remove', false);
    return;
  }

  // Map channelKey to contactTracking properties
  const trackingMap = {
    'texted': ['texted', 'textedDate'],
    'emailed': ['emailed', 'emailedDate'],
    'facebookMessaged': ['facebookMessaged', 'facebookMessagedDate'],
    'dmed': ['dmed', 'dmedDate'],
    'called': ['called', 'calledDate'],
    'linkedinMessaged': ['linkedinMessaged', 'linkedinMessagedDate']
  };

  const props = trackingMap[channelKey];
  if (props) {
    delete prospect.contactTracking[props[0]];
    delete prospect.contactTracking[props[1]];
  }

  // Save and refresh
  await saveCampaignBoards();
  refreshContactStatusDashboard();
  renderAllContactStatusColumns();
  toast(`Removed ${channelKey} tracking for ${prospect.businessName}`, true);
}

// Follow up with a business - opens channel and updates contact date
async function followUpContact(prospectId, channelKey) {
  const result = findProspectInCampaignBoard(prospectId);
  if (!result) {
    toast('Prospect not found', false);
    return;
  }
  const prospect = result.item;
  const businessName = prospect.businessName || 'Unknown';

  // Channel config
  const channelConfig = {
    texted: {
      icon: 'üì±',
      name: 'Text',
      hasContact: !!prospect.phone,
      open: () => {
        const cleanPhone = prospect.phone.replace(/\D/g, '');
        window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
      },
      dateKey: 'textedDate'
    },
    emailed: {
      icon: '‚úâÔ∏è',
      name: 'Email',
      hasContact: !!prospect.email,
      open: () => {
        let subject = localStorage.getItem('followUpSubject') || '';
        // Replace variables in subject
        if (subject) {
          subject = subject.replace(/\{BUSINESS\}/gi, businessName);
          subject = subject.replace(/\{ZIP\}/gi, prospect.zipCode || prospect.zip || '');
          subject = subject.replace(/\{CITY\}/gi, prospect.city || prospect.town || '');
        }
        const mailtoUrl = subject
          ? `mailto:${prospect.email}?subject=${encodeURIComponent(subject)}`
          : `mailto:${prospect.email}`;
        window.open(mailtoUrl, '_blank');
      },
      dateKey: 'emailedDate'
    },
    facebookMessaged: {
      icon: 'üìò',
      name: 'Facebook',
      hasContact: !!prospect.facebook,
      open: () => window.open(ensureHttps(prospect.facebook), '_blank'),
      dateKey: 'facebookMessagedDate'
    },
    dmed: {
      icon: 'üì∑',
      name: 'Instagram',
      hasContact: !!prospect.instagram,
      open: () => window.open(ensureHttps(prospect.instagram), '_blank'),
      dateKey: 'dmedDate'
    }
  };

  const config = channelConfig[channelKey];
  if (!config) {
    toast('Unknown channel', false);
    return;
  }

  if (!config.hasContact) {
    toast(`No ${config.name} contact info for ${businessName}`, false);
    return;
  }

  // Open the channel
  config.open();

  // Update the contact date
  if (!prospect.contactTracking) {
    prospect.contactTracking = {};
  }
  prospect.contactTracking[channelKey] = true;
  prospect.contactTracking[config.dateKey] = new Date().toISOString();
  prospect.lastContacted = new Date().toISOString();

  // Save and refresh
  await saveCampaignBoards();
  refreshContactStatusDashboard();
  renderAllContactStatusColumns();

  toast(`${config.icon} Following up with ${businessName}`, true);
}

// Contact a business again via the same channel (legacy - use followUpContact)
function contactAgain(prospectId, channelKey) {
  followUpContact(prospectId, channelKey);
}

// ============================================
// TEMPLATE PICKER (Consolidated Templates)
// ============================================

// Default templates (used if no saved edits)
const DEFAULT_TEMPLATES = {
  email: [
    { id: 'email_initial1', name: 'Initial Contact - Option A', subject: 'Quick question about {BUSINESS}', body: `Hi,

We send out a community postcard that reaches thousands of homes in your area.

We're filling spots for our next mailing and {BUSINESS} would be a great fit. You'd be the only one in your category on the card.

Interested in the details?

{YOUR_NAME}` },
    { id: 'email_initial2', name: 'Initial Contact - Option B', subject: 'Local advertising opportunity for {BUSINESS}', body: `Hi,

I hope this finds you well. I'm reaching out about a cost-effective advertising opportunity for {BUSINESS}.

We publish a shared mailer that goes directly to thousands of local households. Your business would be featured alongside other quality local services.

Here's what makes this different:
‚Ä¢ Direct mail to targeted local households
‚Ä¢ Professional design included
‚Ä¢ Shared cost model makes it affordable
‚Ä¢ You'd be the ONLY one in your category

Would you be interested in learning more?

{YOUR_NAME}` },
    { id: 'email_followup', name: 'Follow-up', subject: 'Following up - {BUSINESS}', body: `Hi,

Just following up on my message about the community postcard.

I know you're busy - just wanted to make sure this didn't get buried. The spot is still open if you're interested.

Worth a quick look?

{YOUR_NAME}` },
    { id: 'email5', name: 'Renewal', subject: 'Ready for the next postcard?', body: `Hi,

Hope the postcard has been working well for you!

We're putting together the next card now and wanted to reach out before offering your spot to someone else.

Want me to save your spot? Same price, same category exclusivity.

Just reply "yes" and I'll get you set up.

Thanks,
{YOUR_NAME}` },
    { id: 'email6', name: 'Sent to Print', subject: 'Postcard - Sent to Print!', body: `Hi,

Quick update - the postcard has been sent to the printer!

I'll send you another update when it's been dropped at the post office. Keep an eye out for calls once it hits mailboxes!

Thanks for advertising with us.

{YOUR_NAME}` },
    { id: 'email7', name: 'Hitting Mailboxes', subject: 'Postcard - Hitting Mailboxes Tomorrow!', body: `Hi,

Great news! The postcard was just dropped off at the post office and should hit mailboxes tomorrow.

This is when you'll start seeing results - keep an eye on your phone for new calls!

If you have any questions or want to get on the next card, just let me know.

Thanks again for advertising with us!

{YOUR_NAME}` }
  ],
  sms: [
    { id: 'sms_initial1', name: 'Initial Contact - Option A', body: `Hey! This is {YOUR_NAME}. We do a community postcard that hits thousands of homes in your area and have a spot open for your business category. Interested?` },
    { id: 'sms_initial2', name: 'Initial Contact - Option B', body: `Hi! {YOUR_NAME} here. Quick question - would {BUSINESS} be interested in being featured on a postcard that goes to every home in your area? You'd be the only one in your category. Let me know!` },
    { id: 'sms_followup', name: 'Follow-up', body: `Hey just circling back on the postcard - still have your spot if you're interested. Let me know either way!` },
    { id: 'sms3', name: 'Email Follow-up', body: `Hey it's {YOUR_NAME} - sent you an email about our community postcard. Just wanted to make sure it didn't go to spam!` },
    { id: 'sms4', name: 'Deadline Reminder', body: `Hey! Quick heads up - our postcard goes to print Friday. Still have your spot if you want it. Let me know!` },
    { id: 'sms5', name: 'Renewal', body: `Hey! Hope the postcard has been working well for you. We're putting together the next card now - want me to save your spot? Same price, same exclusivity.` },
    { id: 'sms6', name: 'Sent to Print', body: `Quick update - the postcard has been sent to print! I'll let you know when it drops. Thanks for being on the card!` },
    { id: 'sms7', name: 'Hitting Mailboxes', body: `Great news! The postcard was just dropped at the post office and should hit mailboxes tomorrow. Keep an eye out for calls! Thanks again!` }
  ],
  facebook: [
    { id: 'fb_initial1', name: 'Initial Contact - Option A', body: `Hey! We put out a community postcard that reaches thousands of homes in your area.

We're filling spots for the next one and thought {BUSINESS} would be a great fit. You'd be the only one in your category on it.

Would you want to see what it looks like?

- {YOUR_NAME}` },
    { id: 'fb_initial2', name: 'Initial Contact - Option B', body: `Hi there! üëã

I noticed {BUSINESS} and thought you might be interested in this - we're putting together a community postcard that goes to thousands of local homes.

The cool thing is you'd be the ONLY business in your category featured. No competing ads.

Would you like to see a sample?

{YOUR_NAME}` },
    { id: 'fb_followup', name: 'Follow-up', body: `Hey just bumping this up - your spot is still open on our community postcard if you're interested!

No pressure either way.` }
  ],
  instagram: [
    { id: 'ig_initial1', name: 'Initial Contact - Option A', body: `Hey! Love what you're doing with {BUSINESS}!

We do a community postcard that reaches thousands of homes in your area - thought you might be interested. You'd be the only one in your category featured.

Want to see it?` },
    { id: 'ig_initial2', name: 'Initial Contact - Option B', body: `Hi! üëã Your work looks great!

I run a community mailer that goes to thousands of local homes - {BUSINESS} would be perfect for it. You'd be the only one in your category.

Interested in seeing a sample?` },
    { id: 'ig_followup', name: 'Follow-up', body: `Hey! Just following up on my message about the postcard. Still have your spot open if you're interested!` }
  ],
  linkedin: [
    { id: 'li_initial1', name: 'Initial Contact - Option A', body: `Hi! Fellow local business owner here. I do community postcards that reach thousands of homes in your area. Would love to connect!` },
    { id: 'li_initial2', name: 'Initial Contact - Option B', body: `Hi! I help local businesses get in front of thousands of homeowners through shared direct mail. Always looking to connect with quality local businesses like {BUSINESS}.` },
    { id: 'li_followup1', name: 'After Connection', body: `Thanks for connecting!

I run a community postcard that reaches thousands of homes in your area. We're filling spots for the next mailing and I thought {BUSINESS} would be a great fit.

You'd be the only one in your category on the card - no competing ads.

Would you be interested in seeing what it looks like?

{YOUR_NAME}` },
    { id: 'li_followup2', name: 'Follow-up', body: `Hey! Just wanted to bump this - still have your spot open on the postcard if you're interested.

Happy to answer any questions. No pressure either way!` }
  ],
  call: [
    { id: 'call_initial1', name: 'Cold Call Script - Option A', body: `=== OPENER ===
Hi, is this {BUSINESS}? Great! This is {YOUR_NAME}. I do a community postcard that goes out to thousands of homes in your area - got a quick second?

=== PITCH (if they say yes) ===
Perfect. So basically, we put together a 9x12 postcard with local businesses like yours and mail it to every home in the area. You'd be the only one in your category on it, so no competition.

We handle all the design work. Sound like something you'd be interested in?

=== IF INTERESTED ===
Great! I can email you some info and a sample. What's the best email for you?

=== IF NOT INTERESTED ===
No worries at all. Mind if I ask - is it the timing or just not a fit for your business right now?` },
    { id: 'call_initial2', name: 'Cold Call Script - Option B', body: `=== OPENER ===
Hey, is this {BUSINESS}? Hi! I'm {YOUR_NAME} - I put together community postcards for local businesses. Do you have 30 seconds?

=== PITCH ===
So here's the deal - I mail a big 9x12 postcard to thousands of homes in your area. Each postcard features about 8 local businesses, and you'd be the ONLY one in your category. No competing ads.

=== CLOSE ===
I've got a spot open on the next one going out. Can I send you some info?

=== HANDLE OBJECTION ===
Totally understand. Quick question though - have you tried direct mail before, or is it more about the timing right now?` },
    { id: 'call_followup', name: 'Follow-up Call', body: `=== OPENER ===
Hi, is this {BUSINESS}? This is {YOUR_NAME} - I reached out last week about the community postcard. Just wanted to follow up real quick.

=== PITCH ===
We're putting together the next card and I still have your spot open. Any questions I can answer?` },
    { id: 'voicemail1', name: 'Voicemail', body: `Hi, this is {YOUR_NAME} calling about a local advertising opportunity. We do a community postcard that reaches thousands of homes in your area and have a spot open in your category. Give me a call back at {YOUR_PHONE} when you get a chance. Thanks!` }
  ]
};

// Template edits state (synced to cloud)
let templateEditsState = {};

// Storage key for localStorage fallback
const TEMPLATE_EDITS_STORAGE_KEY = 'mailslot-template-edits';

// Load template edits from cloud (called on app startup)
async function loadTemplateEdits() {
  try {
    // Try loading from cloud first
    const cloudData = await loadFromCloud('templateEdits');
    if (cloudData && cloudData.edits) {
      templateEditsState = cloudData.edits;
      console.log('‚úÖ Loaded template edits from cloud');
    } else {
      // Fallback to localStorage
      const saved = safeGetItem(TEMPLATE_EDITS_STORAGE_KEY);
      if (saved) {
        templateEditsState = JSON.parse(saved);
        console.log('‚úÖ Loaded template edits from localStorage');
        // Migrate to cloud
        saveTemplateEditsToCloud();
      }
    }
  } catch (e) {
    console.error('Error loading template edits:', e);
    // Try localStorage as fallback
    const saved = safeGetItem(TEMPLATE_EDITS_STORAGE_KEY);
    if (saved) {
      templateEditsState = JSON.parse(saved);
    }
  }
}

// Save template edits to cloud
async function saveTemplateEditsToCloud() {
  try {
    await saveToCloud('templateEdits', { edits: templateEditsState });
    safeSetItem(TEMPLATE_EDITS_STORAGE_KEY, JSON.stringify(templateEditsState));
    console.log('‚úÖ Saved template edits to cloud');
  } catch (e) {
    console.warn('Template edits saved to localStorage only:', e);
    safeSetItem(TEMPLATE_EDITS_STORAGE_KEY, JSON.stringify(templateEditsState));
  }
}

// Get current template edits
function getTemplateEdits() {
  return templateEditsState;
}

// Get variable values for template replacement
function getTemplateVariables() {
  // Load salesToolkitSettings from localStorage if not loaded
  const savedSettings = localStorage.getItem('salesToolkitSettings');
  const settings = savedSettings ? JSON.parse(savedSettings) : {};

  // Get current prospect data
  const prospect = currentProspectDetail || {};

  // Get current campaign/mailer data
  const campaign = state.current || {};

  return {
    // Business info (from current prospect)
    BUSINESS: prospect.businessName || prospect.name || '',
    ZIP: prospect.zipCode || prospect.zip || campaign.ZIP || '',
    CITY: prospect.city || prospect.town || campaign.Town || '',
    CATEGORY: prospect.category || prospect.types?.[0] || '',

    // User info (from salesToolkitSettings)
    YOUR_NAME: settings.yourName || '',
    YOUR_PHONE: settings.yourPhone || '',
    YOUR_EMAIL: settings.yourEmail || '',
    YOUR_COMPANY: settings.yourCompany || '',

    // Campaign info
    MAILER_DATE: campaign.Mailer_Date || '',
    DEADLINE: campaign.Deadline || '',
    SPOT_PRICE: settings.spotPrice || '$399',
    HOMES_REACHED: settings.homesReached || '5,000'
  };
}

// Save a single template edit
async function saveTemplateEdit(channelKey, templateId, edits) {
  try {
    if (!templateEditsState[channelKey]) {
      templateEditsState[channelKey] = {};
    }
    templateEditsState[channelKey][templateId] = edits;
    await saveTemplateEditsToCloud();
    return true;
  } catch (e) {
    console.error('Error saving template edit:', e);
    return false;
  }
}

// Reset a template to default
async function resetTemplateEdit(channelKey, templateId) {
  try {
    if (templateEditsState[channelKey] && templateEditsState[channelKey][templateId]) {
      delete templateEditsState[channelKey][templateId];
      if (Object.keys(templateEditsState[channelKey]).length === 0) {
        delete templateEditsState[channelKey];
      }
      await saveTemplateEditsToCloud();
    }
    return true;
  } catch (e) {
    console.error('Error resetting template:', e);
    return false;
  }
}

// Get merged templates (defaults + user edits)
function getTemplates(channelKey) {
  const defaults = DEFAULT_TEMPLATES[channelKey] || [];
  const userEdits = templateEditsState[channelKey] || {};

  return defaults.map(template => {
    const userEdit = userEdits[template.id];
    if (userEdit) {
      return {
        ...template,
        subject: userEdit.subject !== undefined ? userEdit.subject : template.subject,
        body: userEdit.body !== undefined ? userEdit.body : template.body,
        isEdited: true
      };
    }
    return { ...template, isEdited: false };
  });
}

// Check if a template has been edited
function isTemplateEdited(channelKey, templateId) {
  const userEdits = templateEditsState[channelKey] || {};
  return !!userEdits[templateId];
}

// Open template picker in a separate window (can be dragged to another screen)
function openTemplatePicker() {
  // Check if window already exists and is open
  if (window.templateWindow && !window.templateWindow.closed) {
    window.templateWindow.focus();
    return;
  }

  // Open new window
  const width = 850;
  const height = 700;
  const left = window.screenX + 100;
  const top = window.screenY + 50;

  window.templateWindow = window.open('', 'TemplatePickerWindow',
    `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`);

  if (!window.templateWindow) {
    toast('Popup blocked! Please allow popups for this site.', false);
    return;
  }

  // Build the complete HTML for the new window
  const channels = [
    { key: 'email', icon: '‚úâÔ∏è', name: 'Email' },
    { key: 'sms', icon: 'üì±', name: 'Text/SMS' },
    { key: 'facebook', icon: 'üìò', name: 'Facebook' },
    { key: 'instagram', icon: 'üì∑', name: 'Instagram' },
    { key: 'linkedin', icon: 'üíº', name: 'LinkedIn' },
    { key: 'call', icon: 'üìû', name: 'Call Scripts' }
  ];

  const tabsHtml = channels.map((ch, i) => `
    <button onclick="showTemplateChannel('${ch.key}')"
            id="templateTab_${ch.key}"
            class="px-3 py-2 text-sm font-medium whitespace-nowrap ${i === 0 ? 'border-b-2 border-purple-600 text-purple-600' : 'text-gray-500 hover:text-gray-700'}">
      ${ch.icon} ${ch.name}
    </button>
  `).join('');

  // Serialize DEFAULT_TEMPLATES for the new window
  const templatesJson = JSON.stringify(DEFAULT_TEMPLATES);

  const html = `<!DOCTYPE html>
<html>
<head>
  <title>Message Templates - 9x12 Pro</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
  </style>
</head>
<body class="bg-gray-100">
  <div class="flex h-screen">
    <!-- Main Content -->
    <div class="flex flex-col flex-1 min-w-0">
      <div class="p-4 bg-white border-b shadow-sm">
        <div class="flex items-center justify-between">
          <h1 class="text-xl font-bold text-gray-900">üìã Message Templates</h1>
          <span id="syncStatus" class="text-xs px-2 py-1 rounded"></span>
        </div>
        <p class="text-xs text-gray-500 mt-1">Copy a template, then Follow Up on a business in the main app</p>
        <div id="selectedSubjectBar" class="mt-2 p-2 bg-green-50 border border-green-200 rounded text-xs hidden">
          <span class="text-green-700 font-medium">üìß Follow Up Subject:</span>
          <span id="selectedSubjectText" class="text-green-900 font-semibold ml-1"></span>
          <button onclick="clearFollowUpSubject()" class="ml-2 text-green-600 hover:text-green-800 underline">Clear</button>
        </div>
      </div>

      <!-- Channel Tabs -->
      <div class="flex bg-white border-b overflow-x-auto px-2">
        ${tabsHtml}
      </div>

      <!-- Template Content -->
      <div id="templateContent" class="flex-1 overflow-y-auto p-4">
        Loading...
      </div>

      <div class="p-3 border-t bg-gray-50 text-xs text-gray-500 text-center">
        Click <strong>Copy</strong> to copy template. Use <strong>Edit</strong> to customize - changes sync with main app.
      </div>
    </div>

    <!-- Variables Sidebar -->
    <div class="w-56 bg-white border-l shadow-lg flex flex-col">
      <div class="p-3 bg-purple-50 border-b">
        <h2 class="font-bold text-purple-800 text-sm">üìù Available Variables</h2>
        <p class="text-xs text-purple-600 mt-1">Click to copy, then paste in template</p>
      </div>
      <div class="flex-1 overflow-y-auto p-3 space-y-3">
        <!-- Business Info -->
        <div>
          <div class="text-xs font-semibold text-gray-500 uppercase mb-2">Business Info</div>
          <div class="space-y-1">
            <button onclick="copyVariable('{BUSINESS}')" class="w-full text-left px-2 py-1.5 bg-gray-50 hover:bg-purple-100 rounded text-xs group">
              <code class="font-mono text-purple-700">{BUSINESS}</code>
              <div class="text-gray-500 group-hover:text-gray-700">Business name</div>
            </button>
            <button onclick="copyVariable('{ZIP}')" class="w-full text-left px-2 py-1.5 bg-gray-50 hover:bg-purple-100 rounded text-xs group">
              <code class="font-mono text-purple-700">{ZIP}</code>
              <div class="text-gray-500 group-hover:text-gray-700">ZIP code</div>
            </button>
            <button onclick="copyVariable('{CITY}')" class="w-full text-left px-2 py-1.5 bg-gray-50 hover:bg-purple-100 rounded text-xs group">
              <code class="font-mono text-purple-700">{CITY}</code>
              <div class="text-gray-500 group-hover:text-gray-700">City/Town name</div>
            </button>
            <button onclick="copyVariable('{CATEGORY}')" class="w-full text-left px-2 py-1.5 bg-gray-50 hover:bg-purple-100 rounded text-xs group">
              <code class="font-mono text-purple-700">{CATEGORY}</code>
              <div class="text-gray-500 group-hover:text-gray-700">Business category</div>
            </button>
          </div>
        </div>

        <!-- Your Info - Editable -->
        <div>
          <div class="text-xs font-semibold text-gray-500 uppercase mb-2">Your Info (edit below)</div>
          <div class="space-y-2">
            <div>
              <label class="text-xs text-gray-500 block mb-0.5">{YOUR_NAME}</label>
              <input type="text" id="myInfoName" placeholder="Your name"
                     onchange="saveMyInfo()"
                     class="w-full px-2 py-1 text-xs border rounded focus:ring-1 focus:ring-purple-500 focus:border-purple-500">
            </div>
            <div>
              <label class="text-xs text-gray-500 block mb-0.5">{YOUR_PHONE}</label>
              <input type="tel" id="myInfoPhone" placeholder="Your phone"
                     onchange="saveMyInfo()"
                     class="w-full px-2 py-1 text-xs border rounded focus:ring-1 focus:ring-purple-500 focus:border-purple-500">
            </div>
            <div>
              <label class="text-xs text-gray-500 block mb-0.5">{YOUR_EMAIL}</label>
              <input type="email" id="myInfoEmail" placeholder="Your email"
                     onchange="saveMyInfo()"
                     class="w-full px-2 py-1 text-xs border rounded focus:ring-1 focus:ring-purple-500 focus:border-purple-500">
            </div>
          </div>
        </div>

        <!-- Campaign Info -->
        <div>
          <div class="text-xs font-semibold text-gray-500 uppercase mb-2">Campaign Info</div>
          <div class="space-y-1">
            <button onclick="copyVariable('{MAILER_DATE}')" class="w-full text-left px-2 py-1.5 bg-gray-50 hover:bg-purple-100 rounded text-xs group">
              <code class="font-mono text-purple-700">{MAILER_DATE}</code>
              <div class="text-gray-500 group-hover:text-gray-700">Mail date</div>
            </button>
            <button onclick="copyVariable('{DEADLINE}')" class="w-full text-left px-2 py-1.5 bg-gray-50 hover:bg-purple-100 rounded text-xs group">
              <code class="font-mono text-purple-700">{DEADLINE}</code>
              <div class="text-gray-500 group-hover:text-gray-700">Signup deadline</div>
            </button>
          </div>
        </div>
      </div>
      <div class="p-2 border-t bg-gray-50 text-center">
        <span class="text-xs text-gray-400">Variables auto-fill when sending</span>
      </div>
    </div>
  </div>

  <script>
    // Template data from main app
    const DEFAULT_TEMPLATES = ${templatesJson};

    function esc(str) {
      if (!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    const LOCAL_STORAGE_KEY = 'mailslot-template-edits';
    const MY_INFO_KEY = 'salesToolkitSettings';

    // Load and display My Info on startup
    function loadMyInfo() {
      try {
        const saved = localStorage.getItem(MY_INFO_KEY);
        if (saved) {
          const info = JSON.parse(saved);
          const nameEl = document.getElementById('myInfoName');
          const phoneEl = document.getElementById('myInfoPhone');
          const emailEl = document.getElementById('myInfoEmail');
          if (nameEl) nameEl.value = info.yourName || '';
          if (phoneEl) phoneEl.value = info.yourPhone || '';
          if (emailEl) emailEl.value = info.yourEmail || '';
        }
      } catch (e) { console.warn('Error loading My Info:', e); }
    }

    // Save My Info to localStorage (syncs with main app)
    function saveMyInfo() {
      try {
        const existing = JSON.parse(localStorage.getItem(MY_INFO_KEY) || '{}');
        const updated = {
          ...existing,
          yourName: document.getElementById('myInfoName')?.value || '',
          yourPhone: document.getElementById('myInfoPhone')?.value || '',
          yourEmail: document.getElementById('myInfoEmail')?.value || ''
        };
        localStorage.setItem(MY_INFO_KEY, JSON.stringify(updated));
        showToast('Saved!');
      } catch (e) { console.warn('Error saving My Info:', e); }
    }

    // Set subject line for Follow Up emails
    function setFollowUpSubject(channelKey, templateId) {
      const templates = getTemplates(channelKey);
      const template = templates.find(t => t.id === templateId);
      if (!template || !template.subject) {
        showToast('No subject found');
        return;
      }
      const subject = template.subject;
      localStorage.setItem('followUpSubject', subject);
      updateSelectedSubjectDisplay();
      showToast('‚úì Subject set!');
      // Also notify main app if available
      try {
        if (window.opener && !window.opener.closed) {
          window.opener.localStorage.setItem('followUpSubject', subject);
        }
      } catch (e) { /* ignore */ }
    }

    // Clear follow up subject
    function clearFollowUpSubject() {
      localStorage.removeItem('followUpSubject');
      updateSelectedSubjectDisplay();
      showToast('Subject cleared');
      try {
        if (window.opener && !window.opener.closed) {
          window.opener.localStorage.removeItem('followUpSubject');
        }
      } catch (e) { /* ignore */ }
    }

    // Update the selected subject display bar
    function updateSelectedSubjectDisplay() {
      const bar = document.getElementById('selectedSubjectBar');
      const text = document.getElementById('selectedSubjectText');
      const subject = localStorage.getItem('followUpSubject');
      if (subject && bar && text) {
        text.textContent = subject;
        bar.classList.remove('hidden');
      } else if (bar) {
        bar.classList.add('hidden');
      }
    }

    // Get template edits - try main app first, fall back to localStorage
    function getTemplateEditsFromMain() {
      // Try main app first (for cloud sync)
      try {
        if (window.opener && !window.opener.closed && window.opener.getTemplateEdits) {
          return window.opener.getTemplateEdits();
        }
      } catch (e) { console.warn('Cannot access main app:', e); }

      // Fall back to localStorage
      try {
        const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
        return saved ? JSON.parse(saved) : {};
      } catch (e) { return {}; }
    }

    // Save template edit - try main app first, fall back to localStorage
    async function saveTemplateViaMain(channelKey, templateId, edits) {
      console.log('saveTemplateViaMain called:', channelKey, templateId);

      // Try main app first (for cloud sync)
      try {
        console.log('Checking window.opener:', !!window.opener, window.opener ? !window.opener.closed : 'N/A');
        if (window.opener && !window.opener.closed) {
          console.log('Has saveTemplateEdit?', typeof window.opener.saveTemplateEdit);
          if (window.opener.saveTemplateEdit) {
            console.log('Calling saveTemplateEdit...');
            const result = await window.opener.saveTemplateEdit(channelKey, templateId, edits);
            console.log('saveTemplateEdit result:', result);
            if (result) return true;
          }
        }
      } catch (e) {
        console.warn('Cannot save via main app:', e.message, e);
      }

      // Fall back to localStorage
      console.log('Falling back to localStorage...');
      try {
        const allEdits = getTemplateEditsFromMain();
        if (!allEdits[channelKey]) allEdits[channelKey] = {};
        allEdits[channelKey][templateId] = edits;
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(allEdits));
        console.log('Saved to localStorage successfully');
        return true;
      } catch (e) {
        console.error('Failed to save to localStorage:', e);
        return false;
      }
    }

    // Reset template - try main app first, fall back to localStorage
    async function resetTemplateViaMain(channelKey, templateId) {
      // Try main app first (for cloud sync)
      try {
        if (window.opener && !window.opener.closed && window.opener.resetTemplateEdit) {
          const result = await window.opener.resetTemplateEdit(channelKey, templateId);
          if (result) return true;
        }
      } catch (e) { console.warn('Cannot reset via main app:', e); }

      // Fall back to localStorage
      try {
        const allEdits = getTemplateEditsFromMain();
        if (allEdits[channelKey] && allEdits[channelKey][templateId]) {
          delete allEdits[channelKey][templateId];
          if (Object.keys(allEdits[channelKey]).length === 0) delete allEdits[channelKey];
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(allEdits));
        }
        return true;
      } catch (e) {
        console.error('Failed to reset in localStorage:', e);
        return false;
      }
    }

    function getTemplates(channelKey) {
      const defaults = DEFAULT_TEMPLATES[channelKey] || [];
      const allEdits = getTemplateEditsFromMain();
      const userEdits = allEdits[channelKey] || {};
      return defaults.map(template => {
        const userEdit = userEdits[template.id];
        if (userEdit) {
          return {
            ...template,
            subject: userEdit.subject !== undefined ? userEdit.subject : template.subject,
            body: userEdit.body !== undefined ? userEdit.body : template.body,
            isEdited: true
          };
        }
        return { ...template, isEdited: false };
      });
    }

    function showTemplateChannel(channelKey) {
      document.querySelectorAll('[id^="templateTab_"]').forEach(tab => {
        tab.classList.remove('border-b-2', 'border-purple-600', 'text-purple-600');
        tab.classList.add('text-gray-500');
      });
      const activeTab = document.getElementById('templateTab_' + channelKey);
      if (activeTab) {
        activeTab.classList.add('border-b-2', 'border-purple-600', 'text-purple-600');
        activeTab.classList.remove('text-gray-500');
      }
      document.getElementById('templateContent').innerHTML = renderTemplateList(channelKey);
    }

    function renderTemplateList(channelKey) {
      const templates = getTemplates(channelKey);
      if (templates.length === 0) return '<p class="text-gray-500 italic">No templates available</p>';

      return templates.map(t => \`
        <div class="bg-white border border-gray-200 rounded-lg p-3 mb-3 shadow-sm" id="template_\${t.id}">
          <div class="flex items-center justify-between mb-2">
            <div class="flex items-center gap-2">
              <span class="font-semibold text-gray-800">\${esc(t.name)}</span>
              \${t.isEdited ? '<span class="text-xs bg-yellow-100 text-yellow-700 px-2 py-0.5 rounded">Edited</span>' : ''}
            </div>
            <div class="flex items-center gap-2">
              \${t.isEdited ? \`<button onclick="resetTemplate('\${channelKey}', '\${t.id}')" class="px-2 py-1 text-gray-500 hover:text-gray-700 text-sm" title="Reset to default">‚Ü∫ Reset</button>\` : ''}
              <button onclick="editTemplate('\${channelKey}', '\${t.id}')" class="px-2 py-1 text-blue-600 hover:text-blue-800 text-sm font-medium">‚úèÔ∏è Edit</button>
              <button onclick="copyTemplate('\${channelKey}', '\${t.id}')" class="px-3 py-1 bg-purple-600 text-white text-sm rounded hover:bg-purple-700 font-medium">Copy</button>
            </div>
          </div>
          \${t.subject ? \`
            <div class="mb-2 bg-blue-50 px-2 py-1.5 rounded border border-blue-200">
              <div class="flex items-center justify-between mb-0.5">
                <span class="text-xs text-blue-600 font-medium">Subject Line:</span>
                <button onclick="setFollowUpSubject('\${channelKey}', '\${t.id}')"
                        class="px-2 py-0.5 bg-green-600 text-white text-xs rounded hover:bg-green-700">
                  ‚úì Use for Follow Up
                </button>
              </div>
              <div class="text-sm text-blue-900 font-semibold select-all cursor-text">\${esc(t.subject)}</div>
            </div>
          \` : ''}
          <pre class="text-xs text-gray-600 whitespace-pre-wrap font-sans bg-gray-50 p-2 rounded border max-h-32 overflow-y-auto">\${esc(t.body)}</pre>
        </div>
      \`).join('');
    }

    function copyTemplate(channelKey, templateId) {
      const templates = getTemplates(channelKey);
      const template = templates.find(t => t.id === templateId);
      if (!template) { alert('Template not found'); return; }

      // Get variable values from main app
      let variables = {};
      try {
        if (window.opener && !window.opener.closed && window.opener.getTemplateVariables) {
          variables = window.opener.getTemplateVariables();
        }
      } catch (e) { console.warn('Cannot get variables from main app:', e); }

      // Copy only the body (not the subject)
      let text = template.body;

      // Replace variables in body
      Object.entries(variables).forEach(([key, value]) => {
        if (value) {
          text = text.replace(new RegExp('\\\\{' + key + '\\\\}', 'gi'), value);
        }
      });

      navigator.clipboard.writeText(text).then(() => {
        const hasUnfilled = text.match(/\\{[A-Z_]+\\}/);
        if (hasUnfilled) {
          showToast('üìã Copied! (Some variables need filling)');
        } else {
          showToast('üìã Copied!');
        }
      }).catch(() => { alert('Failed to copy'); });
    }

    function editTemplate(channelKey, templateId) {
      const templates = getTemplates(channelKey);
      const template = templates.find(t => t.id === templateId);
      if (!template) { alert('Template not found'); return; }

      const hasSubject = template.subject !== undefined;

      const modal = document.createElement('div');
      modal.id = 'editModal';
      modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50';
      modal.onclick = (e) => { if (e.target === modal) modal.remove(); };

      modal.innerHTML = \`
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-3xl mx-4 max-h-[85vh] flex flex-col">
          <div class="p-4 border-b flex items-center justify-between">
            <h3 class="text-lg font-bold text-gray-900">‚úèÔ∏è Edit: \${esc(template.name)}</h3>
            <button onclick="document.getElementById('editModal').remove()" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
          </div>
          <div class="flex-1 flex overflow-hidden">
            <!-- Editor Section -->
            <div class="flex-1 overflow-y-auto p-4 space-y-4">
              \${hasSubject ? \`<div><label class="block text-sm font-medium text-gray-700 mb-1">Subject Line</label><input type="text" id="editSubject" value="\${esc(template.subject)}" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500"></div>\` : ''}
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Message Body</label>
                <textarea id="editBody" rows="14" class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm font-mono focus:ring-2 focus:ring-purple-500 focus:border-purple-500">\${esc(template.body)}</textarea>
              </div>
            </div>
            <!-- Variables Panel -->
            <div class="w-48 bg-purple-50 border-l overflow-y-auto">
              <div class="p-2 bg-purple-100 border-b sticky top-0">
                <div class="font-bold text-purple-800 text-xs">üìù Insert Variable</div>
                <div class="text-xs text-purple-600">Click to insert at cursor</div>
              </div>
              <div class="p-2 space-y-2">
                <div class="text-xs font-semibold text-gray-500 uppercase">Business</div>
                <button onclick="insertVariable('{BUSINESS}')" class="w-full text-left px-2 py-1 bg-white hover:bg-purple-200 rounded text-xs border border-purple-200"><code class="text-purple-700">{BUSINESS}</code></button>
                <button onclick="insertVariable('{ZIP}')" class="w-full text-left px-2 py-1 bg-white hover:bg-purple-200 rounded text-xs border border-purple-200"><code class="text-purple-700">{ZIP}</code></button>
                <button onclick="insertVariable('{CITY}')" class="w-full text-left px-2 py-1 bg-white hover:bg-purple-200 rounded text-xs border border-purple-200"><code class="text-purple-700">{CITY}</code></button>
                <button onclick="insertVariable('{CATEGORY}')" class="w-full text-left px-2 py-1 bg-white hover:bg-purple-200 rounded text-xs border border-purple-200"><code class="text-purple-700">{CATEGORY}</code></button>
                <div class="text-xs font-semibold text-gray-500 uppercase mt-3">Your Info</div>
                <button onclick="insertVariable('{YOUR_NAME}')" class="w-full text-left px-2 py-1 bg-white hover:bg-purple-200 rounded text-xs border border-purple-200"><code class="text-purple-700">{YOUR_NAME}</code></button>
                <button onclick="insertVariable('{YOUR_PHONE}')" class="w-full text-left px-2 py-1 bg-white hover:bg-purple-200 rounded text-xs border border-purple-200"><code class="text-purple-700">{YOUR_PHONE}</code></button>
                <button onclick="insertVariable('{YOUR_EMAIL}')" class="w-full text-left px-2 py-1 bg-white hover:bg-purple-200 rounded text-xs border border-purple-200"><code class="text-purple-700">{YOUR_EMAIL}</code></button>
                <div class="text-xs font-semibold text-gray-500 uppercase mt-3">Campaign</div>
                <button onclick="insertVariable('{MAILER_DATE}')" class="w-full text-left px-2 py-1 bg-white hover:bg-purple-200 rounded text-xs border border-purple-200"><code class="text-purple-700">{MAILER_DATE}</code></button>
                <button onclick="insertVariable('{DEADLINE}')" class="w-full text-left px-2 py-1 bg-white hover:bg-purple-200 rounded text-xs border border-purple-200"><code class="text-purple-700">{DEADLINE}</code></button>
              </div>
            </div>
          </div>
          <div class="p-4 border-t flex items-center justify-between bg-gray-50">
            <button onclick="document.getElementById('editModal').remove()" class="px-4 py-2 text-gray-600 hover:text-gray-800">Cancel</button>
            <button onclick="saveEdit('\${channelKey}', '\${templateId}', \${hasSubject})" class="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium">Save Changes</button>
          </div>
        </div>
      \`;
      document.body.appendChild(modal);
    }

    // Insert variable at cursor position in textarea
    function insertVariable(variable) {
      const textarea = document.getElementById('editBody');
      if (!textarea) return;

      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const text = textarea.value;

      textarea.value = text.substring(0, start) + variable + text.substring(end);
      textarea.focus();
      textarea.selectionStart = textarea.selectionEnd = start + variable.length;
      showToast('Inserted: ' + variable);
    }

    async function saveEdit(channelKey, templateId, hasSubject) {
      const bodyEl = document.getElementById('editBody');
      const subjectEl = document.getElementById('editSubject');

      if (!bodyEl) {
        alert('Error: Could not find message body field');
        console.error('editBody element not found');
        return;
      }

      const edits = { body: bodyEl.value };
      if (hasSubject && subjectEl) {
        edits.subject = subjectEl.value;
      }

      showToast('üíæ Saving...');
      const success = await saveTemplateViaMain(channelKey, templateId, edits);
      if (success) {
        const isConnected = checkMainAppConnection();
        showToast(isConnected ? '‚úÖ Saved to cloud!' : '‚úÖ Saved locally!');
        document.getElementById('editModal').remove();
        showTemplateChannel(channelKey);
      } else {
        alert('Failed to save');
      }
    }

    async function resetTemplate(channelKey, templateId) {
      if (!confirm('Reset this template to default?')) return;
      showToast('üíæ Resetting...');
      const success = await resetTemplateViaMain(channelKey, templateId);
      if (success) {
        const isConnected = checkMainAppConnection();
        showToast(isConnected ? '‚úÖ Reset (cloud)' : '‚úÖ Reset (local)');
        showTemplateChannel(channelKey);
      } else {
        alert('Failed to reset');
      }
    }

    function copyVariable(variable) {
      navigator.clipboard.writeText(variable).then(() => {
        showToast('üìã Copied: ' + variable);
      }).catch(() => {
        alert('Failed to copy');
      });
    }

    function showToast(msg) {
      const existing = document.getElementById('toast');
      if (existing) existing.remove();

      const toast = document.createElement('div');
      toast.id = 'toast';
      toast.className = 'fixed bottom-4 left-1/2 -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg text-sm';
      toast.textContent = msg;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 2000);
    }

    // Check connection to main app
    function checkMainAppConnection() {
      const statusEl = document.getElementById('syncStatus');
      try {
        if (window.opener && !window.opener.closed && window.opener.getTemplateEdits) {
          statusEl.textContent = '‚òÅÔ∏è Cloud Synced';
          statusEl.className = 'text-xs px-2 py-1 rounded bg-green-100 text-green-700';
          return true;
        }
      } catch (e) {}
      statusEl.textContent = 'üíæ Local Mode';
      statusEl.className = 'text-xs px-2 py-1 rounded bg-blue-100 text-blue-700';
      statusEl.title = 'Changes save locally. Open main app to sync to cloud.';
      return false;
    }

    // Initialize
    checkMainAppConnection();
    loadMyInfo();
    updateSelectedSubjectDisplay();
    showTemplateChannel('email');

    // Re-check connection periodically
    setInterval(checkMainAppConnection, 5000);
  </script>
</body>
</html>`;

  window.templateWindow.document.write(html);
  window.templateWindow.document.close();
}

// Show templates for a specific channel
function showTemplateChannel(channelKey) {
  // Update tabs
  document.querySelectorAll('[id^="templateTab_"]').forEach(tab => {
    tab.classList.remove('border-b-2', 'border-purple-600', 'text-purple-600');
    tab.classList.add('text-gray-500');
  });
  const activeTab = document.getElementById(`templateTab_${channelKey}`);
  if (activeTab) {
    activeTab.classList.add('border-b-2', 'border-purple-600', 'text-purple-600');
    activeTab.classList.remove('text-gray-500');
  }

  // Update content
  const content = document.getElementById('templateContent');
  if (content) {
    content.innerHTML = renderTemplateList(channelKey);
  }
}

// Render template list for a channel
function renderTemplateList(channelKey) {
  const templates = getTemplates(channelKey);
  if (templates.length === 0) {
    return '<p class="text-gray-500 italic">No templates available</p>';
  }

  return templates.map(t => `
    <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 mb-3" id="template_${t.id}">
      <div class="flex items-center justify-between mb-2">
        <div class="flex items-center gap-2">
          <span class="font-semibold text-gray-800">${esc(t.name)}</span>
          ${t.isEdited ? '<span class="text-xs bg-yellow-100 text-yellow-700 px-2 py-0.5 rounded">Edited</span>' : ''}
        </div>
        <div class="flex items-center gap-2">
          ${t.isEdited ? `
            <button onclick="resetTemplate('${channelKey}', '${t.id}')"
                    class="px-2 py-1 text-gray-500 hover:text-gray-700 text-sm" title="Reset to default">
              ‚Ü∫ Reset
            </button>
          ` : ''}
          <button onclick="editTemplate('${channelKey}', '${t.id}')"
                  class="px-2 py-1 text-blue-600 hover:text-blue-800 text-sm font-medium">
            ‚úèÔ∏è Edit
          </button>
          <button onclick="copyTemplate('${channelKey}', '${t.id}')"
                  class="px-3 py-1 bg-purple-600 text-white text-sm rounded hover:bg-purple-700 font-medium">
            Copy
          </button>
        </div>
      </div>
      ${t.subject ? `<div class="text-xs text-gray-500 mb-1"><strong>Subject:</strong> ${esc(t.subject)}</div>` : ''}
      <pre class="text-xs text-gray-600 whitespace-pre-wrap font-sans bg-white p-2 rounded border max-h-32 overflow-y-auto">${esc(t.body)}</pre>
    </div>
  `).join('');
}

// Copy template to clipboard
function copyTemplate(channelKey, templateId) {
  const templates = getTemplates(channelKey);
  const template = templates.find(t => t.id === templateId);
  if (!template) {
    toast('Template not found', false);
    return;
  }

  let text = template.body;
  if (template.subject) {
    text = `Subject: ${template.subject}\n\n${template.body}`;
  }

  navigator.clipboard.writeText(text).then(() => {
    toast(`üìã "${template.name}" copied to clipboard!`, true);
  }).catch(() => {
    toast('Failed to copy', false);
  });
}

// Edit template - opens editing modal
function editTemplate(channelKey, templateId) {
  const templates = getTemplates(channelKey);
  const template = templates.find(t => t.id === templateId);
  if (!template) {
    toast('Template not found', false);
    return;
  }

  // Create edit modal
  const editModal = document.createElement('div');
  editModal.id = 'templateEditModal';
  editModal.className = 'fixed inset-0 bg-black/60 flex items-center justify-center z-[60]';
  editModal.onclick = (e) => { if (e.target === editModal) editModal.remove(); };

  const hasSubject = template.subject !== undefined;

  editModal.innerHTML = `
    <div class="bg-white rounded-xl shadow-2xl w-full max-w-xl mx-4 max-h-[80vh] flex flex-col">
      <div class="p-4 border-b flex items-center justify-between">
        <h3 class="text-lg font-bold text-gray-900">‚úèÔ∏è Edit Template: ${esc(template.name)}</h3>
        <button onclick="document.getElementById('templateEditModal').remove()" class="text-gray-400 hover:text-gray-600 text-2xl">&times;</button>
      </div>

      <div class="flex-1 overflow-y-auto p-4 space-y-4">
        ${hasSubject ? `
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Subject Line</label>
            <input type="text" id="editTemplateSubject" value="${esc(template.subject)}"
                   class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500">
          </div>
        ` : ''}
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Message Body</label>
          <textarea id="editTemplateBody" rows="12"
                    class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500 text-sm font-mono">${esc(template.body)}</textarea>
        </div>
        <div class="text-xs text-gray-500">
          <strong>Available placeholders:</strong> {BUSINESS}, {YOUR_NAME}, {YOUR_PHONE}
        </div>
      </div>

      <div class="p-4 border-t flex items-center justify-between bg-gray-50">
        <button onclick="document.getElementById('templateEditModal').remove()"
                class="px-4 py-2 text-gray-600 hover:text-gray-800">
          Cancel
        </button>
        <button onclick="saveMainAppTemplateEdit('${channelKey}', '${templateId}', ${hasSubject})"
                class="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium">
          Save Changes
        </button>
      </div>
    </div>
  `;

  document.body.appendChild(editModal);

  // Focus the body textarea
  setTimeout(() => {
    const bodyInput = document.getElementById('editTemplateBody');
    if (bodyInput) bodyInput.focus();
  }, 100);
}

// Save template edit from main app's modal (different from cloud saveTemplateEdit)
function saveMainAppTemplateEdit(channelKey, templateId, hasSubject) {
  const bodyInput = document.getElementById('editTemplateBody');
  const subjectInput = document.getElementById('editTemplateSubject');

  if (!bodyInput) {
    toast('Error: Could not find template body', false);
    return;
  }

  const edits = {
    body: bodyInput.value
  };

  if (hasSubject && subjectInput) {
    edits.subject = subjectInput.value;
  }

  if (saveUserTemplate(channelKey, templateId, edits)) {
    toast('‚úÖ Template saved!', true);
    // Close edit modal
    document.getElementById('templateEditModal')?.remove();
    // Refresh the template list
    const content = document.getElementById('templateContent');
    if (content) {
      content.innerHTML = renderTemplateList(channelKey);
    }
  } else {
    toast('Failed to save template', false);
  }
}

// Reset template to default
function resetTemplate(channelKey, templateId) {
  if (!confirm('Reset this template to default? Your edits will be lost.')) {
    return;
  }

  if (resetUserTemplate(channelKey, templateId)) {
    toast('‚úÖ Template reset to default', true);
    // Refresh the template list
    const content = document.getElementById('templateContent');
    if (content) {
      content.innerHTML = renderTemplateList(channelKey);
    }
  } else {
    toast('Failed to reset template', false);
  }
}

// ============================================
// ANALYTICS DASHBOARD FUNCTIONS
// ============================================

// Analytics state
let analyticsState = {
  totalOutreach: 0,
  totalResponses: 0,
  totalInterested: 0,
  totalClients: 0,
  channelStats: {},
  timeRange: 30
};

// Refresh analytics dashboard
function refreshAnalytics() {
  const timeRangeSelect = document.getElementById('analyticsTimeRange');
  const days = timeRangeSelect?.value === 'all' ? null : parseInt(timeRangeSelect?.value || 30);
  analyticsState.timeRange = days;

  const cutoffDate = days ? new Date(Date.now() - days * 24 * 60 * 60 * 1000) : null;

  // Reset counts
  analyticsState.totalOutreach = 0;
  analyticsState.totalResponses = 0;
  analyticsState.totalInterested = 0;
  analyticsState.channelStats = {
    texted: { count: 0, responses: 0, label: 'üì± Text', color: 'green' },
    emailed: { count: 0, responses: 0, label: '‚úâÔ∏è Email', color: 'blue' },
    facebookMessaged: { count: 0, responses: 0, label: 'üìò Facebook', color: 'indigo' },
    dmed: { count: 0, responses: 0, label: 'üì∑ Instagram', color: 'pink' },
    called: { count: 0, responses: 0, label: 'üìû Call', color: 'orange' }
  };

  // Count clients created in time range
  analyticsState.totalClients = Object.values(crmState.clients || {}).filter(c => {
    if (!cutoffDate) return true;
    const created = c.createdAt ? new Date(c.createdAt) : null;
    return created && created >= cutoffDate;
  }).length;

  // Scan all Campaign Board columns (single source of truth)
  const board = getCurrentCampaignBoard();
  if (board && board.columns) {
    // Columns that indicate the prospect has responded/shown interest
    const respondedColumns = ['negotiating', 'invoice-sent', 'proof-approved', 'paid-in-full'];

    Object.keys(board.columns).forEach(columnKey => {
      const items = board.columns[columnKey] || [];
      const isRespondedColumn = respondedColumns.includes(columnKey);

      items.forEach(prospect => {
        if (!prospect || typeof prospect !== 'object') return;
        const ct = prospect.contactTracking || {};

        // Track if this prospect has been counted for response (avoid double-counting)
        let prospectCounted = false;

        // Check each channel
        Object.keys(analyticsState.channelStats).forEach(channel => {
          if (ct[channel]) {
            const contactDate = ct[channel + 'Date'] ? new Date(ct[channel + 'Date']) : null;
            // Include if: no date filter, OR contact has no date (legacy), OR date is within range
            if (!cutoffDate || !contactDate || contactDate >= cutoffDate) {
              analyticsState.channelStats[channel].count++;
              analyticsState.totalOutreach++;

              // Count as responded if: explicit responded flag OR in a responded column
              if ((ct.responded || isRespondedColumn) && !prospectCounted) {
                analyticsState.channelStats[channel].responses++;
                analyticsState.totalResponses++;
                prospectCounted = true;
              }
            }
          }
        });

        // Count interested: explicit responseType OR in negotiating/beyond columns
        if (ct.responseType === 'Interested' || isRespondedColumn) {
          const responseDate = ct.respondedDate ? new Date(ct.respondedDate) : null;
          // Include if: no date filter, OR no date recorded (legacy), OR date is within range
          if (!cutoffDate || !responseDate || responseDate >= cutoffDate) {
            analyticsState.totalInterested++;
          }
        }
      });
    });
  }

  // Update UI
  renderAnalytics();
}

// Render analytics UI
function renderAnalytics() {
  // Key metrics
  const totalOutreachEl = document.getElementById('analyticsTotalOutreach');
  const responseRateEl = document.getElementById('analyticsResponseRate');
  const interestedEl = document.getElementById('analyticsInterested');
  const conversionRateEl = document.getElementById('analyticsConversionRate');
  const newClientsEl = document.getElementById('analyticsNewClients');

  if (totalOutreachEl) totalOutreachEl.textContent = analyticsState.totalOutreach;

  const responseRate = analyticsState.totalOutreach > 0
    ? Math.round((analyticsState.totalResponses / analyticsState.totalOutreach) * 100)
    : 0;
  if (responseRateEl) responseRateEl.textContent = responseRate + '%';

  if (interestedEl) interestedEl.textContent = analyticsState.totalInterested;

  const conversionRate = analyticsState.totalOutreach > 0
    ? Math.round((analyticsState.totalClients / analyticsState.totalOutreach) * 100)
    : 0;
  if (conversionRateEl) conversionRateEl.textContent = conversionRate + '%';

  if (newClientsEl) newClientsEl.textContent = analyticsState.totalClients;

  // Channel bars
  const channelBars = document.getElementById('analyticsChannelBars');
  if (channelBars) {
    const maxCount = Math.max(...Object.values(analyticsState.channelStats).map(s => s.count), 1);

    channelBars.innerHTML = Object.entries(analyticsState.channelStats)
      .sort((a, b) => b[1].count - a[1].count)
      .map(([key, stats]) => {
        const width = Math.round((stats.count / maxCount) * 100);
        const responseRate = stats.count > 0 ? Math.round((stats.responses / stats.count) * 100) : 0;
        return `
          <div class="flex items-center gap-3">
            <div class="w-24 text-sm font-medium text-gray-700">${stats.label}</div>
            <div class="flex-1 bg-gray-100 rounded-full h-4 overflow-hidden">
              <div class="bg-${stats.color}-500 h-full rounded-full transition-all" style="width: ${width}%"></div>
            </div>
            <div class="w-20 text-right text-sm">
              <span class="font-bold text-gray-700">${stats.count}</span>
              <span class="text-gray-400 text-xs">(${responseRate}%)</span>
            </div>
          </div>
        `;
      }).join('');
  }
}

// Export analytics as CSV
function exportAnalytics() {
  const timeRange = analyticsState.timeRange ? `Last ${analyticsState.timeRange} days` : 'All time';
  const date = new Date().toISOString().split('T')[0];

  let csv = `9x12 Pro Analytics Export\n`;
  csv += `Generated: ${date}\n`;
  csv += `Time Range: ${timeRange}\n\n`;

  csv += `Key Metrics\n`;
  csv += `Total Outreach,${analyticsState.totalOutreach}\n`;
  csv += `Total Responses,${analyticsState.totalResponses}\n`;
  csv += `Response Rate,${analyticsState.totalOutreach > 0 ? Math.round((analyticsState.totalResponses / analyticsState.totalOutreach) * 100) : 0}%\n`;
  csv += `Interested,${analyticsState.totalInterested}\n`;
  csv += `New Clients,${analyticsState.totalClients}\n\n`;

  csv += `Channel Performance\n`;
  csv += `Channel,Outreach,Responses,Response Rate\n`;
  Object.entries(analyticsState.channelStats).forEach(([key, stats]) => {
    const rate = stats.count > 0 ? Math.round((stats.responses / stats.count) * 100) : 0;
    csv += `${stats.label.replace(/[üì±‚úâÔ∏èüìòüì∑üìû]/g, '').trim()},${stats.count},${stats.responses},${rate}%\n`;
  });

  // Download
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `9x12-analytics-${date}.csv`;
  a.click();
  URL.revokeObjectURL(url);
  toast('üì• Analytics exported!', true);
}

// Quick action: call a number
function quickCall(phone) {
  window.open(`tel:${phone}`, '_blank');
}

// Quick action: email a prospect
function quickEmail(prospectId) {
  // Find prospect in Campaign Board
  const result = findProspectInCampaignBoard(prospectId);
  if (result && result.item.email) {
    window.open(`mailto:${result.item.email}`, '_blank');
  }
}

// Scroll to prospect in kanban
function scrollToProspect(prospectId, columnKey) {
  // Find the card element and scroll to it
  const card = document.querySelector(`[data-lead-id="${prospectId}"]`);
  if (card) {
    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
    card.classList.add('ring-4', 'ring-yellow-400');
    setTimeout(() => card.classList.remove('ring-4', 'ring-yellow-400'), 2000);
  }
}


// Toggle Do Not Contact status on a lead (keeps card visible but marked)
async function toggleDoNotContact(leadId, columnKey, event) {
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  // Find lead in Campaign Board
  const result = findProspectInCampaignBoard(leadId);
  let foundItem = result?.item || null;
  let foundColumn = result?.column || columnKey;

  if (!foundItem) {
    // Check prospect pool
    if (prospectPoolState.allBusinesses) {
      const poolBiz = prospectPoolState.allBusinesses.find(b =>
        b && (String(b.placeId) === String(leadId) || String(b.id) === String(leadId))
      );
      if (poolBiz) {
        poolBiz.doNotContact = !poolBiz.doNotContact;
        renderProspectPool();
        toast(poolBiz.doNotContact ? 'üö´ Marked as Do Not Contact' : '‚úì Removed Do Not Contact', true);
        return;
      }
    }
    console.warn('toggleDoNotContact: Lead not found', leadId);
    return;
  }

  // Toggle the doNotContact flag
  foundItem.doNotContact = !foundItem.doNotContact;
  const businessName = foundItem.businessName || foundItem.name || 'Business';

  // Save to cloud
  try {
    await saveCampaignBoards();
  } catch (err) {
    console.error('Failed to save after toggle:', err);
  }

  // Re-render
  renderKanban();

  toast(foundItem.doNotContact ? `üö´ "${businessName}" marked as Do Not Contact` : `‚úì "${businessName}" removed from Do Not Contact`, true);
}

window.toggleDoNotContact = toggleDoNotContact;

// Toggle Do Not Contact for prospects in the pool
async function togglePoolDoNotContact(prospectId) {
  let found = false;
  let newValue = false;
  const idStr = String(prospectId);

  // Helper to match prospect by ID (check multiple possible ID properties)
  const matchesId = (b) => {
    if (!b) return false;
    return String(b.placeId) === idStr ||
           String(b.id) === idStr ||
           String(b.businessId) === idStr ||
           String(b.yelpId) === idStr;
  };

  // Check allBusinesses (enriched prospects)
  if (prospectPoolState.allBusinesses) {
    const biz = prospectPoolState.allBusinesses.find(matchesId);
    if (biz) {
      biz.doNotContact = !biz.doNotContact;
      newValue = biz.doNotContact;
      found = true;
    }
  }

  // Check manualProspects (prospects moved back from kanban)
  if (prospectPoolState.manualProspects) {
    const manualBiz = prospectPoolState.manualProspects.find(matchesId);
    if (manualBiz) {
      manualBiz.doNotContact = found ? newValue : !manualBiz.doNotContact;
      if (!found) newValue = manualBiz.doNotContact;
      found = true;
    }
  }

  // Check categories (raw prospects from search)
  if (prospectPoolState.categories) {
    for (const categoryKey of Object.keys(prospectPoolState.categories)) {
      const businesses = prospectPoolState.categories[categoryKey].businesses || [];
      const biz = businesses.find(matchesId);
      if (biz) {
        biz.doNotContact = found ? newValue : !biz.doNotContact;
        if (!found) newValue = biz.doNotContact;
        found = true;
      }
    }
  }

  // Check placesCache.searches (where search results are stored)
  // Check both cachedData (new format) and businesses (old Yelp format)
  if (placesCache && placesCache.searches) {
    for (const cacheKey of Object.keys(placesCache.searches)) {
      const cached = placesCache.searches[cacheKey];
      // Check cachedData (current format)
      if (cached && cached.cachedData) {
        const biz = cached.cachedData.find(matchesId);
        if (biz) {
          biz.doNotContact = found ? newValue : !biz.doNotContact;
          if (!found) newValue = biz.doNotContact;
          found = true;
        }
      }
      // Also check businesses (old Yelp format)
      if (cached && cached.businesses) {
        const biz = cached.businesses.find(matchesId);
        if (biz) {
          biz.doNotContact = found ? newValue : !biz.doNotContact;
          if (!found) newValue = biz.doNotContact;
          found = true;
        }
      }
    }
  }

  // Check renderedProspects - this is populated during rendering and contains
  // references to the actual prospect objects being displayed
  if (!found && prospectPoolState.renderedProspects && prospectPoolState.renderedProspects[prospectId]) {
    const prospect = prospectPoolState.renderedProspects[prospectId];
    prospect.doNotContact = !prospect.doNotContact;
    newValue = prospect.doNotContact;
    found = true;
    console.log('togglePoolDoNotContact: Found prospect in renderedProspects', prospectId);
  } else if (prospectPoolState.renderedProspects && prospectPoolState.renderedProspects[prospectId]) {
    // Also update renderedProspects lookup (used during rendering)
    prospectPoolState.renderedProspects[prospectId].doNotContact = newValue;
  }

  if (found) {
    // Save pool state
    try {
      const poolData = {
        allBusinesses: prospectPoolState.allBusinesses || [],
        categories: prospectPoolState.categories || {},
        manualProspects: prospectPoolState.manualProspects || []
      };
      await saveToCloud('prospectPool', poolData);
      // Also save manualProspects separately
      await saveManualProspects();
      // Save places cache to persist the DNC status
      if (typeof savePlacesCache === 'function') {
        savePlacesCache();
      }
    } catch (err) {
      console.error('Failed to save pool do not contact:', err);
    }

    renderProspectPool();
    toast(newValue ? 'üö´ Marked as Do Not Contact' : '‚úì Removed Do Not Contact', true);
  } else {
    console.warn('togglePoolDoNotContact: Prospect not found', prospectId);
    toast('Prospect not found', false);
  }
}

window.togglePoolDoNotContact = togglePoolDoNotContact;

// Handle "Not Interested" button click
function handleNotInterested(leadId, event) {
  if (event) {
    event.stopPropagation();
    event.preventDefault();
  }

  // Find lead in to-contact column - use string comparison for floating point IDs
  const items = kanbanState.columns['to-contact'] || [];
  const index = items.findIndex((item, idx) => {
    if (typeof item === 'string') return false;
    if (!item) return false;

    // Convert both IDs to strings for comparison (handles floating point precision)
    const leadIdStr = String(leadId);
    const itemIdStr = String(item.id);

    // Check if item.id matches (string comparison)
    if (item.id !== undefined && itemIdStr === leadIdStr) {
      return true;
    }

    // Fallback: check if leadId matches the array index
    return idx === leadId || String(idx) === leadIdStr;
  });

  if (index === -1) {
    toast("Lead not found", false);
    return;
  }

  const lead = items[index];
  const businessName = typeof lead === 'string' ? lead : (lead.businessName || 'Unnamed Lead');

  if (!confirm(`Mark "${businessName}" as Not Interested?\n\nThis will remove them from your pipeline.`)) {
    return;
  }

  // Remove from kanban
  items.splice(index, 1);

  // Add to not interested list (if it's an object with placeId)
  if (typeof lead === 'object' && lead.placeId) {
    addToNotInterestedList(lead);
  }

  // Increment daily goal
  incrementDailyGoal(businessName);

  saveKanban();
  renderKanban();
  toast(`${businessName} marked as not interested`);
}

// Reset daily goal count to 0
function resetDailyGoal() {
  if (!confirm('Reset today\'s outreach count to 0?\n\nThis will clear your progress for today but keep your goal and history.')) {
    return;
  }

  dailyGoalState.todayCount = 0;

  // Update today's history record if it exists
  const today = new Date().toDateString();
  let todayRecord = dailyGoalState.history.find(h => h.date === today);
  if (todayRecord) {
    todayRecord.actual = 0;
    todayRecord.businesses = [];
  }

  saveDailyGoalState();
  renderKanban();
  toast('Daily count reset to 0');
}

// Open daily goal settings modal
function openDailyGoalSettings() {
  const modal = document.getElementById('dailyGoalSettingsModal');
  if (!modal) return;

  // Pre-fill current goal
  const input = document.getElementById('dailyGoalInput');
  if (input) {
    input.value = dailyGoalState.dailyGoal;
  }

  lastFocusedElementBeforeModal = document.activeElement;
  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);

  // Focus on input
  if (input) input.focus();
}

function closeDailyGoalSettings() {
  const modal = document.getElementById('dailyGoalSettingsModal');
  if (!modal) return;

  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus();

  if (lastFocusedElementBeforeModal) {
    lastFocusedElementBeforeModal.focus();
  }
}

function saveDailyGoalFromModal() {
  const input = document.getElementById('dailyGoalInput');
  if (!input) return;

  const goalNumber = parseInt(input.value);
  if (isNaN(goalNumber) || goalNumber < 1) {
    toast("Please enter a valid number (minimum 1)", false);
    return;
  }

  dailyGoalState.dailyGoal = goalNumber;
  saveDailyGoalState();
  renderKanban();
  closeDailyGoalSettings();
  toast(`Daily goal updated to ${goalNumber} contacts`, true);
}

function resetDailyGoalFromModal() {
  if (!confirm("Are you sure you want to reset today's count to 0?")) {
    return;
  }

  dailyGoalState.todayCount = 0;
  dailyGoalState.todayDate = new Date().toISOString().split('T')[0];
  saveDailyGoalState();
  renderKanban();
  toast('Daily count reset to 0', true);
  // Don't close modal - user might want to adjust goal too
}

/* ========= NEW POSTCARD CREATION WORKFLOW ========= */
function openNewPostcardModal() {
  const modal = document.getElementById("newPostcardModal");

  // Populate town dropdown with unique towns from existing postcards
  const towns = [...new Set(state.mailers.map(m => m.Town))].sort();
  const townSelect = document.getElementById("newPostcardTownSelect");
  townSelect.innerHTML = '<option value="">‚Äî Select existing town ‚Äî</option>' +
    towns.map(town => `<option value="${esc(town)}">${esc(town)}</option>`).join('');

  // Populate year dropdown (current year and next 2 years)
  const currentYear = new Date().getFullYear();
  const yearSelect = document.getElementById("newPostcardYear");
  yearSelect.innerHTML = [currentYear, currentYear + 1, currentYear + 2]
    .map(year => `<option value="${year}">${year}</option>`).join('');

  // Set default month to next month
  const nextMonth = new Date();
  nextMonth.setMonth(nextMonth.getMonth() + 1);
  document.getElementById("newPostcardMonth").value = String(nextMonth.getMonth() + 1).padStart(2, '0');

  // Populate copy source dropdown
  const copySelect = document.getElementById("copySourcePostcard");
  copySelect.innerHTML = '<option value="">‚Äî Select postcard ‚Äî</option>' +
    state.mailers.map((m, i) => `<option value="${i}">${esc(m.Town)} ‚Äî ${esc(m.Mail_Date)}</option>`).join('');

  // Reset form
  document.querySelector('input[name="townOption"][value="existing"]').checked = true;
  document.getElementById("newPostcardTownInput").disabled = true;
  document.getElementById("copyFromPrevious").checked = false;
  document.getElementById("copyOptions").classList.add('hidden');
  document.getElementById("advertiserChecklistContainer").classList.add('hidden');

  lastFocusedElementBeforeModal = document.activeElement;
  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
}

function closeNewPostcardModal() {
  const modal = document.getElementById("newPostcardModal");
  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
  if (lastFocusedElementBeforeModal) {
    lastFocusedElementBeforeModal.focus();
    lastFocusedElementBeforeModal = null;
  }
}

/* ========= DUPLICATE POSTCARD MODAL ========= */
function openDuplicatePostcardModal() {
  const modal = document.getElementById("duplicatePostcardModal");

  // Populate source postcard dropdown
  const sourceSelect = document.getElementById("duplicateSourcePostcard");
  sourceSelect.innerHTML = '<option value="">‚Äî Select postcard ‚Äî</option>' +
    state.mailers.map((m, i) => {
      let displayDate = m.Mail_Date || "";
      if (/^\d{4}-\d{2}-\d{2}/.test(displayDate)) {
        const [year, month] = displayDate.split('-');
        const monthNames = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        displayDate = `${monthNames[parseInt(month)]} ${year}`;
      }
      const sizeLabel = m.Postcard_Size ? ` (${m.Postcard_Size})` : '';
      return `<option value="${i}">${esc(m.Town)} ‚Äî ${esc(displayDate)}${sizeLabel}</option>`;
    }).join('');

  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
}

function closeDuplicatePostcardModal() {
  const modal = document.getElementById("duplicatePostcardModal");
  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
}

async function createDuplicatePostcard() {
  const sourceIndex = document.getElementById("duplicateSourcePostcard").value;
  if (!sourceIndex) {
    toast("Please select a postcard to duplicate", false);
    return;
  }

  const sourcePostcard = state.mailers[parseInt(sourceIndex)];
  const newTown = document.getElementById("duplicateTown").value.trim();
  const newMonth = document.getElementById("duplicateMonth").value;
  const newYear = document.getElementById("duplicateYear").value;
  const newSize = document.getElementById("duplicateSize").value;

  // Must change at least one thing
  const isSameTown = !newTown || newTown === sourcePostcard.Town;
  const isSameMonth = !newMonth || !newYear;
  const isSameSize = !newSize || newSize === sourcePostcard.Postcard_Size;

  if (isSameTown && isSameMonth && isSameSize) {
    toast("You must change at least one: town, month/year, or size", false);
    return;
  }

  const btn = document.getElementById('btnCreateDuplicate');
  const originalText = btn.innerHTML;
  btn.disabled = true;
  btn.innerHTML = '‚è≥ Duplicating...';

  try {
    // Determine new values
    const finalTown = newTown || sourcePostcard.Town;
    const sourceDate = new Date(sourcePostcard.Mail_Date);
    const finalMonth = newMonth ? newMonth.padStart(2, '0') : String(sourceDate.getMonth() + 1).padStart(2, '0');
    const finalYear = newYear || sourceDate.getFullYear();
    const finalSize = newSize || sourcePostcard.Postcard_Size || '9x12';

    const mailDate = `${finalYear}-${finalMonth}-01`;
    const mailerId = `${finalTown.replace(/\s+/g, '-')}-${finalMonth}-${finalYear}`;

    // Check for duplicates
    const duplicate = state.mailers.find(m => m.Mailer_ID === mailerId);
    if (duplicate) {
      toast("A postcard with this combination already exists!", false);
      btn.disabled = false;
      btn.innerHTML = originalText;
      return;
    }

    // Create new postcard object
    const newPostcard = {
      Mailer_ID: mailerId,
      Town: finalTown,
      Mail_Date: mailDate,
      In_Homes_Date: sourcePostcard.In_Homes_Date, // Can be edited later
      Payment_Status: "Active",
      Postcard_Size: finalSize,
      availability: {},
      Postcard_BG: document.getElementById("duplicateCopyColors").checked ? sourcePostcard.Postcard_BG : "#000000",
      Banner_BG: document.getElementById("duplicateCopyColors").checked ? sourcePostcard.Banner_BG : "#000000"
    };

    // Initialize all spots as available
    for (let i = 1; i <= 18; i++) {
      newPostcard.availability[`Spot_${i}`] = "Available";
    }

    // Copy advertisers if checked
    if (document.getElementById("duplicateCopyAdvertisers").checked) {
      for (let i = 1; i <= 18; i++) {
        const spotKey = `Spot_${i}`;
        // Check both availability object and direct spot properties (Supabase format)
        const raw = (sourcePostcard.availability && sourcePostcard.availability[spotKey]) || sourcePostcard[spotKey] || "Available";
        if (!/^available$/i.test(raw)) {
          // Has an advertiser - copy as Reserved
          const match = String(raw).match(/^(.+?)\s*:\s*(.*)$/);
          if (match) {
            const name = match[2].trim();
            if (name) {
              newPostcard.availability[spotKey] = `Reserved: ${name}`;
            }
          }
        }
      }
    }

    // Copy expenses if checked
    if (document.getElementById("duplicateCopyExpenses").checked && productionState.expenses[sourcePostcard.Mailer_ID]) {
      const sourceExpenses = productionState.expenses[sourcePostcard.Mailer_ID];
      productionState.expenses[mailerId] = {
        printing: sourceExpenses.printing || 0,
        postage: sourceExpenses.postage || 0,
        design: sourceExpenses.design || 0,
        misc: sourceExpenses.misc || 0
      };
      await saveExpenses();
    }

    // Copy pricing if checked
    if (document.getElementById("duplicateCopyPricing").checked && productionState.pricing[sourcePostcard.Mailer_ID]) {
      const sourcePricing = productionState.pricing[sourcePostcard.Mailer_ID];
      productionState.pricing[mailerId] = {
        singleAd: sourcePricing.singleAd || 0,
        doubleAd: sourcePricing.doubleAd || 0,
        bannerAd: sourcePricing.bannerAd || 0,
        homeCount: sourcePricing.homeCount || 0
      };
      await savePricing();
    }

    // Add to state
    state.mailers.push(newPostcard);

    // Sort mailers
    state.mailers = state.mailers.sort((a, b) => {
      const dateA = a.Mail_Date || '';
      const dateB = b.Mail_Date || '';
      if (dateA !== dateB) {
        return dateB.localeCompare(dateA);
      }
      const townA = (a.Town || '').toLowerCase();
      const townB = (b.Town || '').toLowerCase();
      return townA.localeCompare(townB);
    });

    // Repopulate selectors
    populateTownAndMonthSelectors();

    // Select new postcard
    const newIndex = state.mailers.findIndex(m => m.Mailer_ID === mailerId);
    pickCampaign({ target: { value: newIndex.toString() } });
    switchTab('manager');

    // Save to Supabase
    try {
      const { error } = await supabaseClient
        .from('postcards')
        .insert({
          user_email: ACTIVE_USER,
          mailer_id: newPostcard.Mailer_ID,
          town: newPostcard.Town,
          mail_date: newPostcard.Mail_Date,
          in_homes_date: newPostcard.In_Homes_Date,
          payment_status: newPostcard.Payment_Status,
          postcard_size: newPostcard.Postcard_Size || '9x12',
          address_count: newPostcard.Address_Count || 0,
          postcard_bg: newPostcard.Postcard_BG,
          banner_bg: newPostcard.Banner_BG,
          spot_1: newPostcard.availability.Spot_1 || 'Available',
          spot_2: newPostcard.availability.Spot_2 || 'Available',
          spot_3: newPostcard.availability.Spot_3 || 'Available',
          spot_4: newPostcard.availability.Spot_4 || 'Available',
          spot_5: newPostcard.availability.Spot_5 || 'Available',
          spot_6: newPostcard.availability.Spot_6 || 'Available',
          spot_7: newPostcard.availability.Spot_7 || 'Available',
          spot_8: newPostcard.availability.Spot_8 || 'Available',
          spot_9: newPostcard.availability.Spot_9 || 'Available',
          spot_10: newPostcard.availability.Spot_10 || 'Available',
          spot_11: newPostcard.availability.Spot_11 || 'Available',
          spot_12: newPostcard.availability.Spot_12 || 'Available',
          spot_13: newPostcard.availability.Spot_13 || 'Available',
          spot_14: newPostcard.availability.Spot_14 || 'Available',
          spot_15: newPostcard.availability.Spot_15 || 'Available',
          spot_16: newPostcard.availability.Spot_16 || 'Available',
          spot_17: newPostcard.availability.Spot_17 || 'Available',
          spot_18: newPostcard.availability.Spot_18 || 'Available'
        });

      if (error) throw error;

    } catch (cloudErr) {
      console.error("Failed to save duplicated postcard to cloud:", cloudErr);
      toast("‚ö†Ô∏è Postcard duplicated locally. Will sync on next spot edit.", false);
    }

    closeDuplicatePostcardModal();
    toast(`‚úÖ Duplicated postcard: ${finalTown} ‚Äî ${finalMonth}/${finalYear}`);

  } catch (error) {
    console.error('Error duplicating postcard:', error);
    toast('Failed to duplicate postcard', false);
    btn.disabled = false;
    btn.innerHTML = originalText;
  }
}

/* ========= PRICING MODAL ========= */
async function loadPricing() {
  try {
    const cloudData = await loadFromCloud('pricing');
    if (cloudData) {
      // Ensure all pricing values are numbers, not strings
      productionState.pricing = {};
      Object.keys(cloudData).forEach(mailerId => {
        const pricing = cloudData[mailerId];
        productionState.pricing[mailerId] = {
          singleAd: parseFloat(pricing.singleAd) || 0,
          doubleAd: parseFloat(pricing.doubleAd) || 0,
          bannerAd: parseFloat(pricing.bannerAd) || 0,
          homeCount: parseInt(pricing.homeCount) || 0
        };
      });
    }
  } catch (e) {
    // Silently handle error - pricing table may not exist yet in Supabase
    // This is expected on first use before running migration
    console.log('Pricing not available yet (this is normal on first use)');
  }
}

async function savePricing() {
  try {
    await saveToCloud('pricing', productionState.pricing);
    await saveToCloud('revenueGoals', productionState.revenueGoals);
  } catch (e) {
    console.warn('Pricing saved locally only (cloud sync failed):', e);
  }
}

async function loadRevenueGoals() {
  try {
    const cloudData = await loadFromCloud('revenueGoals');
    if (cloudData) {
      productionState.revenueGoals = cloudData;
    }
  } catch (e) {
    console.log('Revenue goals not available');
  }
}

/* ========= SPOT PRICING (PER-SPOT CUSTOM PRICES) ========= */

// Helper function to normalize pricing keys (ALL UPPERCASE for consistency)
// This fixes case mismatch between old data and new data
function normalizePriceKey(mailerId, spotNum = null) {
  const base = String(mailerId).toUpperCase();
  return spotNum ? `${base}-SPOT_${spotNum}`.toUpperCase() : base;
}

async function loadSpotPricing() {
  try {
    const cloudData = await loadFromCloud('spotPricing');
    console.log('üí∞ [LOAD SPOT PRICING] Cloud data received:', cloudData ? 'YES' : 'NO');
    if (cloudData) {
      const keys = Object.keys(cloudData);
      console.log('üí∞ [LOAD SPOT PRICING] Found', keys.length, 'entries in cloud data');
      console.log('üí∞ [LOAD SPOT PRICING] Sample keys (raw):', keys.slice(0, 3));

      // Clean and normalize: only load valid spot pricing (numeric values with SPOT_ in key)
      // This filters out any Set Pricing data that got mixed in
      productionState.spotPricing = {};
      let skippedCount = 0;

      Object.keys(cloudData).forEach(key => {
        const value = cloudData[key];
        const normalizedKey = key.toUpperCase();

        // Skip if value is an object (Set Pricing data) or not a valid number
        if (typeof value === 'object') {
          console.log('üí∞ [LOAD SPOT PRICING] ‚ö†Ô∏è Skipping invalid entry (object):', key);
          skippedCount++;
          return;
        }

        const numValue = parseFloat(value);
        if (isNaN(numValue)) {
          console.log('üí∞ [LOAD SPOT PRICING] ‚ö†Ô∏è Skipping invalid entry (not a number):', key, '=', value);
          skippedCount++;
          return;
        }

        // Only load entries that look like spot pricing (contain SPOT_) or are explicitly 0
        if (normalizedKey.includes('SPOT_') || numValue === 0) {
          productionState.spotPricing[normalizedKey] = numValue;
          if (normalizedKey !== key) {
            console.log('üí∞ [LOAD SPOT PRICING] Normalized key:', key, '‚Üí', normalizedKey);
          }
        } else {
          console.log('üí∞ [LOAD SPOT PRICING] ‚ö†Ô∏è Skipping non-spot entry:', key, '=', value);
          skippedCount++;
        }
      });

      console.log('üí∞ [LOAD SPOT PRICING] ‚úÖ Loaded', Object.keys(productionState.spotPricing).length, 'valid spot prices');
      if (skippedCount > 0) {
        console.log('üí∞ [LOAD SPOT PRICING] ‚ö†Ô∏è Skipped', skippedCount, 'invalid entries');
      }
      console.log('üí∞ [LOAD SPOT PRICING] Sample loaded keys:', Object.keys(productionState.spotPricing).slice(0, 5));
    } else {
      console.log('üí∞ [LOAD SPOT PRICING] No cloud data found, starting fresh');
    }
  } catch (e) {
    console.log('üí∞ [LOAD SPOT PRICING] Error:', e.message);
  }
}

async function saveSpotPricing() {
  try {
    // FILTER OUT campaign-level pricing objects before saving
    // Only save individual spot prices (numbers with SPOT_ in key)
    const cleanedSpotPricing = {};
    Object.keys(productionState.spotPricing).forEach(key => {
      const value = productionState.spotPricing[key];
      // Only save if value is a number AND key contains SPOT_
      if (typeof value === 'number' && !isNaN(value) && key.toUpperCase().includes('SPOT_')) {
        cleanedSpotPricing[key.toUpperCase()] = value;
      } else if (typeof value === 'object') {
        console.log('üíæ [SAVE SPOT PRICING] ‚ö†Ô∏è Filtering out campaign-level pricing:', key);
      }
    });

    const keys = Object.keys(cleanedSpotPricing);
    console.log('üíæ [SAVE SPOT PRICING] Saving', keys.length, 'spot prices to cloud');
    console.log('üíæ [SAVE SPOT PRICING] Sample keys:', keys.slice(0, 3));
    console.log('üíæ [SAVE SPOT PRICING] Sample values:', keys.slice(0, 3).map(k => `${k}: ${cleanedSpotPricing[k]}`));
    console.log('üíæ [SAVE SPOT PRICING] Full data being saved:', JSON.stringify(cleanedSpotPricing).substring(0, 200) + '...');

    await saveToCloud('spotPricing', cleanedSpotPricing);

    console.log('üíæ [SAVE SPOT PRICING] ‚úÖ Successfully saved to cloud');

    // Update productionState to match cleaned data
    productionState.spotPricing = cleanedSpotPricing;

    // Also save to localStorage as backup (cleaned version only)
    safeSetItem('mailslot-pricing', JSON.stringify(cleanedSpotPricing));
  } catch (e) {
    console.error('üíæ [SAVE SPOT PRICING] ‚ùå Failed to save:', e);
  }
}

// Sync top pricing inputs to bottom calculator price fields
function syncPricingToCalculator() {
  const singlePrice = parseFloat(document.getElementById("pricingSingleAd").value) || 0;
  const doublePrice = parseFloat(document.getElementById("pricingDoubleAd").value) || 0;
  const bannerPrice = parseFloat(document.getElementById("pricingBannerAd").value) || 0;

  document.getElementById("goalSinglePrice").value = singlePrice;
  document.getElementById("goalDoublePrice").value = doublePrice;
  document.getElementById("goalBannerPrice").value = bannerPrice;

  updateRevenueGoalCalculator();
}

function updateRevenueGoalCalculator() {
  const singleCount = parseFloat(document.getElementById("goalSingleCount").value) || 0;
  const singlePrice = parseFloat(document.getElementById("goalSinglePrice").value) || 0;
  const doubleCount = parseFloat(document.getElementById("goalDoubleCount").value) || 0;
  const doublePrice = parseFloat(document.getElementById("goalDoublePrice").value) || 0;
  const bannerCount = parseFloat(document.getElementById("goalBannerCount").value) || 0;
  const bannerPrice = parseFloat(document.getElementById("goalBannerPrice").value) || 0;

  const singleTotal = singleCount * singlePrice;
  const doubleTotal = doubleCount * doublePrice;
  const bannerTotal = bannerCount * bannerPrice;
  const total = singleTotal + doubleTotal + bannerTotal;

  document.getElementById("goalSingleTotal").textContent = formatCurrency(singleTotal);
  document.getElementById("goalDoubleTotal").textContent = formatCurrency(doubleTotal);
  document.getElementById("goalBannerTotal").textContent = formatCurrency(bannerTotal);
  document.getElementById("goalTotalRevenue").textContent = formatCurrency(total);

  // Calculate expenses and profit
  if (state.current) {
    const mailerId = state.current.Mailer_ID;
    const expenses = productionState.expenses[mailerId] || { printing: 0, postage: 0, design: 0, misc: 0 };
    const totalExpenses = (expenses.printing || 0) + (expenses.postage || 0) + (expenses.design || 0) + (expenses.misc || 0);
    const profit = total - totalExpenses;

    document.getElementById("goalTotalExpenses").textContent = formatCurrency(totalExpenses);
    document.getElementById("goalProfit").textContent = formatCurrency(profit);

    // Color profit based on positive/negative
    const profitElement = document.getElementById("goalProfit");
    if (profit >= 0) {
      profitElement.className = "text-lg font-bold text-blue-700";
    } else {
      profitElement.className = "text-lg font-bold text-red-700";
    }
  }
}

function openPricingModal() {
  if (!state.current) {
    toast('Please select a postcard first', false);
    return;
  }

  const modal = document.getElementById("pricingModal");
  const mailerId = state.current.Mailer_ID;

  // Load existing pricing for this postcard
  const pricing = productionState.pricing[mailerId] || { singleAd: 0, doubleAd: 0, bannerAd: 0, homeCount: 0 };

  document.getElementById("pricingHomeCount").value = pricing.homeCount || '';
  document.getElementById("pricingSingleAd").value = pricing.singleAd || '';
  document.getElementById("pricingDoubleAd").value = pricing.doubleAd || '';
  document.getElementById("pricingBannerAd").value = pricing.bannerAd || '';

  // Load existing revenue goal for this postcard
  const revenueGoal = productionState.revenueGoals[mailerId] || {
    singleCount: 0, singlePrice: pricing.singleAd || 0,
    doubleCount: 0, doublePrice: pricing.doubleAd || 0,
    bannerCount: 0, bannerPrice: pricing.bannerAd || 0
  };

  document.getElementById("goalSingleCount").value = revenueGoal.singleCount || '';
  document.getElementById("goalSinglePrice").value = revenueGoal.singlePrice || pricing.singleAd || '';
  document.getElementById("goalDoubleCount").value = revenueGoal.doubleCount || '';
  document.getElementById("goalDoublePrice").value = revenueGoal.doublePrice || pricing.doubleAd || '';
  document.getElementById("goalBannerCount").value = revenueGoal.bannerCount || '';
  document.getElementById("goalBannerPrice").value = revenueGoal.bannerPrice || pricing.bannerAd || '';

  updateRevenueGoalCalculator();

  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
}

function closePricingModal() {
  const modal = document.getElementById("pricingModal");
  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
}

async function savePricingModal() {
  if (!state.current) return;

  const mailerId = state.current.Mailer_ID;
  const homeCount = parseInt(document.getElementById("pricingHomeCount").value) || 0;
  const singleAd = parseFloat(document.getElementById("pricingSingleAd").value) || 0;
  const doubleAd = parseFloat(document.getElementById("pricingDoubleAd").value) || 0;
  const bannerAd = parseFloat(document.getElementById("pricingBannerAd").value) || 0;

  productionState.pricing[mailerId] = { singleAd, doubleAd, bannerAd, homeCount };

  // Also update the postcard's address_count in Supabase
  if (homeCount > 0) {
    try {
      await supabaseClient
        .from('postcards')
        .update({ address_count: homeCount })
        .eq('user_email', ACTIVE_USER)
        .eq('mailer_id', mailerId);

      // Update local state too
      state.current.Address_Count = homeCount;
    } catch (err) {
      console.warn('Failed to update address_count in postcards:', err);
    }
  }

  // Save revenue goal
  const singleCount = parseFloat(document.getElementById("goalSingleCount").value) || 0;
  const singlePrice = parseFloat(document.getElementById("goalSinglePrice").value) || 0;
  const doubleCount = parseFloat(document.getElementById("goalDoubleCount").value) || 0;
  const doublePrice = parseFloat(document.getElementById("goalDoublePrice").value) || 0;
  const bannerCount = parseFloat(document.getElementById("goalBannerCount").value) || 0;
  const bannerPrice = parseFloat(document.getElementById("goalBannerPrice").value) || 0;

  const total = (singleCount * singlePrice) + (doubleCount * doublePrice) + (bannerCount * bannerPrice);

  productionState.revenueGoals[mailerId] = {
    singleCount, singlePrice,
    doubleCount, doublePrice,
    bannerCount, bannerPrice,
    total
  };

  await savePricing();

  closePricingModal();
  toast('Pricing and revenue goal saved');

  // Refresh financials display
  updateFinancialDashboard();
  renderCardsInProgress();
}

function openEditDetailsModal() {
  if (!state.current) {
    toast('Please select a postcard first', false);
    return;
  }

  const modal = document.getElementById("editDetailsModal");
  const inHomesDate = state.current.In_Homes_Date;

  if (inHomesDate) {
    // Parse date string without timezone conversion
    // If already in YYYY-MM-DD format, use it directly
    if (/^\d{4}-\d{2}-\d{2}/.test(inHomesDate)) {
      document.getElementById("editInHomesDate").value = inHomesDate.substring(0, 10);
    } else {
      // Fallback: parse as local date
      const dateObj = new Date(inHomesDate);
      const yyyy = dateObj.getFullYear();
      const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
      const dd = String(dateObj.getDate()).padStart(2, '0');
      document.getElementById("editInHomesDate").value = `${yyyy}-${mm}-${dd}`;
    }
  } else {
    document.getElementById("editInHomesDate").value = '';
  }

  // Load households reached - check both Address_Count and pricing data
  const mailerId = state.current.Mailer_ID;
  const pricing = productionState.pricing[mailerId] || {};
  const householdsReached = state.current.Address_Count || pricing.homeCount || '';
  document.getElementById("editHouseholdsReached").value = householdsReached;

  // Load ZIP code
  document.getElementById("editZipCode").value = state.current.Zip_Code || '';

  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
}

function closeEditDetailsModal() {
  const modal = document.getElementById("editDetailsModal");
  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
}

async function saveEditDetailsModal() {
  if (!state.current) return;

  const inHomesDateValue = document.getElementById("editInHomesDate").value;
  const householdsReachedValue = parseInt(document.getElementById("editHouseholdsReached").value) || 0;
  const zipCodeValue = document.getElementById("editZipCode").value.trim();
  const mailerId = state.current.Mailer_ID;

  // Build update object
  const updates = {};
  if (inHomesDateValue) {
    updates.in_homes_date = inHomesDateValue;
    state.current.In_Homes_Date = inHomesDateValue;
  }
  if (householdsReachedValue > 0) {
    updates.address_count = householdsReachedValue;
    state.current.Address_Count = householdsReachedValue;

    // Also update productionState.pricing so it syncs to cloud
    if (!productionState.pricing[mailerId]) {
      productionState.pricing[mailerId] = { singleAd: 0, doubleAd: 0, bannerAd: 0, homeCount: 0 };
    }
    productionState.pricing[mailerId].homeCount = householdsReachedValue;
  }
  if (zipCodeValue !== (state.current.Zip_Code || '')) {
    updates.zip_code = zipCodeValue;
    state.current.Zip_Code = zipCodeValue;
  }

  if (Object.keys(updates).length === 0) {
    toast('No changes to save');
    closeEditDetailsModal();
    return;
  }

  try {
    // Update postcards table
    const { error } = await supabaseClient
      .from('postcards')
      .update(updates)
      .eq('user_email', ACTIVE_USER)
      .eq('mailer_id', mailerId);

    if (error) throw error;

    // If households was updated, also save pricing data to cloud
    if (householdsReachedValue > 0) {
      await savePricing();
    }

    toast('‚úÖ Postcard details updated successfully');
    closeEditDetailsModal();

    // Refresh display
    renderCardsInProgress();
  } catch (err) {
    console.error('Error updating postcard details:', err);
    toast('‚ùå Failed to update postcard details', false);
  }
}

function toggleTownInput() {
  const isNew = document.querySelector('input[name="townOption"][value="new"]').checked;
  document.getElementById("newPostcardTownSelect").disabled = isNew;
  document.getElementById("newPostcardTownInput").disabled = !isNew;
}

function toggleCopyOptions() {
  const checked = document.getElementById("copyFromPrevious").checked;
  document.getElementById("copyOptions").classList.toggle('hidden', !checked);
  if (!checked) {
    document.getElementById("advertiserChecklistContainer").classList.add('hidden');
  }
}

function loadAdvertisersForCopy() {
  const sourceIndex = document.getElementById("copySourcePostcard").value;
  if (!sourceIndex) {
    document.getElementById("advertiserChecklistContainer").classList.add('hidden');
    return;
  }

  const sourcePostcard = state.mailers[sourceIndex];
  if (!sourcePostcard) return;

  // Extract advertisers from the source postcard
  const advertisers = [];
  for (let i = 1; i <= 18; i++) {
    const spotKey = `Spot_${i}`;
    const raw = (sourcePostcard.availability || {})[spotKey] || "Available";
    if (!/^available$/i.test(raw)) {
      const match = String(raw).match(/^(.+?)\s*:\s*(.*)$/);
      if (match) {
        const status = match[1].trim();
        const name = match[2].trim();
        if (name) {
          // Check if this advertiser is already in the list (merged spots)
          const existing = advertisers.find(a => a.name.toLowerCase() === name.toLowerCase());
          if (existing) {
            existing.spots.push(i);
          } else {
            advertisers.push({ name, status, spots: [i] });
          }
        }
      }
    }
  }

  // Render checklist
  const checklist = document.getElementById("advertiserChecklist");
  if (advertisers.length === 0) {
    checklist.innerHTML = '<p class="text-sm text-gray-500">No advertisers found in this postcard.</p>';
    document.getElementById("advertiserChecklistContainer").classList.remove('hidden');
    return;
  }

  checklist.innerHTML = advertisers.map((adv, idx) => {
    const spotText = adv.spots.length > 1 ? `Spots ${adv.spots.join(', ')}` : `Spot ${adv.spots[0]}`;
    return `
      <label class="flex items-start gap-2 p-2 hover:bg-gray-50 rounded cursor-pointer">
        <input type="checkbox" value="${idx}" checked class="mt-0.5" />
        <div class="flex-1">
          <div class="font-medium text-sm">${esc(adv.name)}</div>
          <div class="text-xs text-gray-600">${spotText} ‚Ä¢ Status: ${esc(adv.status)}</div>
        </div>
      </label>
    `;
  }).join('');

  document.getElementById("advertiserChecklistContainer").classList.remove('hidden');
}

async function createNewPostcard() {
  // Check subscription limits for free tier
  const campaignCheck = canCreateCampaign();
  if (!campaignCheck.allowed) {
    showUpgradePrompt(campaignCheck.message);
    return;
  }

  // Get form values
  const isNewTown = document.querySelector('input[name="townOption"][value="new"]').checked;
  const town = isNewTown ?
    document.getElementById("newPostcardTownInput").value.trim() :
    document.getElementById("newPostcardTownSelect").value;

  const month = document.getElementById("newPostcardMonth").value;
  const year = document.getElementById("newPostcardYear").value;
  const inHomesDate = document.getElementById("newPostcardInHomesDate").value;
  const postcardSize = document.getElementById("newPostcardSize").value;

  // Validation
  if (!town) {
    toast("Please select or enter a town name", false);
    return;
  }

  if (!inHomesDate) {
    toast("Please select an in-homes date", false);
    return;
  }

  // Show loading state
  const btn = document.getElementById('btnCreatePostcard');
  const originalText = btn.innerHTML;
  btn.disabled = true;
  btn.innerHTML = '‚è≥ Creating...';

  try {

    // Build mail date - store in ISO format (YYYY-MM-DD) to avoid timezone issues
    const mailDate = `${year}-${month.padStart(2, '0')}-01`;  // e.g., "2025-12-01"

    // Build display name for duplicate check
    const monthNames = ["", "January", "February", "March", "April", "May", "June",
                        "July", "August", "September", "October", "November", "December"];
    const displayDate = `${monthNames[parseInt(month)]} ${year}`;

    // Check for duplicates using town and month/year
    const duplicate = state.mailers.find(m => {
      const mDate = new Date(m.Mail_Date);
      return m.Town.toLowerCase() === town.toLowerCase() &&
             mDate.getMonth() + 1 === parseInt(month) &&
             mDate.getFullYear() === parseInt(year);
    });
    if (duplicate) {
      toast("A postcard for this town and date already exists!", false);
      btn.disabled = false;
      btn.innerHTML = originalText;
      return;
    }

    // Create new postcard object
    const newPostcard = {
      Mailer_ID: `${town.replace(/\s+/g, '-')}-${month.padStart(2, '0')}-${year}`,
      Town: town,
      Mail_Date: mailDate,  // Store as "12/1/2025" format
      In_Homes_Date: inHomesDate,
      Payment_Status: "Active",  // Set to Active by default
      Postcard_Size: postcardSize,  // Store size (9x12)
      Address_Count: 0,  // Set via Campaign Manager ‚Üí Set Ad Price
      availability: {},
      Postcard_BG: "#000000",
      Banner_BG: "#000000"  // Black background (will display white text via useLightTextOn)
    };

    // Initialize all spots as available
    for (let i = 1; i <= 18; i++) {
      newPostcard.availability[`Spot_${i}`] = "Available";
    }

    // Handle copy from previous
    if (document.getElementById("copyFromPrevious").checked) {
      const sourceIndex = document.getElementById("copySourcePostcard").value;
      if (sourceIndex) {
        const sourcePostcard = state.mailers[sourceIndex];
        const checklist = document.getElementById("advertiserChecklist");
        const checkedBoxes = checklist.querySelectorAll('input[type="checkbox"]:checked');

        // Collect selected advertisers
        const advertisers = [];
        for (let i = 1; i <= 18; i++) {
          const spotKey = `Spot_${i}`;
          const raw = (sourcePostcard.availability || {})[spotKey] || "Available";
          if (!/^available$/i.test(raw)) {
            const match = String(raw).match(/^(.+?)\s*:\s*(.*)$/);
            if (match) {
              const name = match[2].trim();
              if (name) {
                const existing = advertisers.find(a => a.name.toLowerCase() === name.toLowerCase());
                if (existing) {
                  existing.spots.push(i);
                } else {
                  advertisers.push({ name, spots: [i] });
                }
              }
            }
          }
        }

        // Apply selected advertisers to new postcard with "Reserved" status
        checkedBoxes.forEach(checkbox => {
          const idx = parseInt(checkbox.value);
          const adv = advertisers[idx];
          if (adv) {
            adv.spots.forEach(spotNum => {
              newPostcard.availability[`Spot_${spotNum}`] = `Reserved:${adv.name}`;
            });
          }
        });
      }
    }

    // Handle copy expenses from previous
    if (document.getElementById("copyExpensesFromPrevious").checked) {
      const sourceIndex = document.getElementById("copySourcePostcard").value;
      if (sourceIndex) {
        const sourcePostcard = state.mailers[sourceIndex];
        const sourceMailerId = sourcePostcard.Mailer_ID;

        // Check if source postcard has expenses
        if (productionState.expenses[sourceMailerId]) {
          const sourceExpenses = productionState.expenses[sourceMailerId];

          // Copy expenses to new postcard
          productionState.expenses[newPostcard.Mailer_ID] = {
            printing: sourceExpenses.printing || 0,
            postage: sourceExpenses.postage || 0,
            design: sourceExpenses.design || 0,
            misc: sourceExpenses.misc || 0
          };

          // Save expenses to cloud
          await saveExpenses();

          console.log(`‚úÖ Copied expenses from ${sourceMailerId} to ${newPostcard.Mailer_ID}`);
        }
      }
    }

    // Add the new postcard to state.mailers
    state.mailers.push(newPostcard);

    // Sort mailers by date (newest first), then by town (alphabetically)
    state.mailers = state.mailers.sort((a, b) => {
      const dateA = a.Mail_Date || '';
      const dateB = b.Mail_Date || '';
      if (dateA !== dateB) {
        return dateB.localeCompare(dateA); // Reverse order for descending
      }
      const townA = (a.Town || '').toLowerCase();
      const townB = (b.Town || '').toLowerCase();
      return townA.localeCompare(townB);
    });

    // Find the index of the newly created postcard after sorting
    const newIndex = state.mailers.findIndex(m => m.Mailer_ID === newPostcard.Mailer_ID);

    // Update the dropdown selectors
    const selManager = document.getElementById("postcardSelect");

    const selectHtml = '<option value="">‚Äî Select ‚Äî</option>' +
      state.mailers.map((m,i)=>{
        // Format date display
        let displayDate = m.Mail_Date || "";
        if (/^\d{4}-\d{2}-\d{2}/.test(displayDate)) {
          const [year, month] = displayDate.split('-');
          const monthNames = ["", "January", "February", "March", "April", "May", "June",
                              "July", "August", "September", "October", "November", "December"];
          displayDate = `${monthNames[parseInt(month)]} ${year}`;
        }
        // Add size indicator to label
        const sizeLabel = m.Postcard_Size ? ` (${m.Postcard_Size})` : '';
        return `<option value="${i}">${esc(m.Town)} ‚Äî ${esc(displayDate)}${sizeLabel}</option>`;
      }).join("");

    if (selManager) {
      selManager.innerHTML = selectHtml;
      selManager.value = newIndex.toString();
    }

    // Repopulate town and month selectors and set to new postcard
    populateTownAndMonthSelectors();
    const townSelect = document.getElementById("headerTownSelect");
    const monthSelect = document.getElementById("headerMonthSelect");
    if (townSelect && newPostcard.Town) {
      townSelect.value = newPostcard.Town;
      onTownChanged(); // Populate month dropdown for this town
      if (monthSelect && newPostcard.Mail_Date) monthSelect.value = newPostcard.Mail_Date;
    }

    // Save to cloud immediately with retry logic for mobile
    btn.innerHTML = '‚òÅÔ∏è Saving to cloud...';

    let cloudSaveSuccess = false;
    let retryCount = 0;
    const maxRetries = 2;

    while (!cloudSaveSuccess && retryCount <= maxRetries) {
      try {
        console.log(`üíæ Attempting cloud save (attempt ${retryCount + 1}/${maxRetries + 1})...`);

        // Insert into Supabase with snake_case column names
        const { data, error } = await supabaseClient
          .from('postcards')
          .insert({
            user_email: ACTIVE_USER,
            mailer_id: newPostcard.Mailer_ID,
            town: newPostcard.Town,
            mail_date: newPostcard.Mail_Date,
            in_homes_date: newPostcard.In_Homes_Date,
            payment_status: newPostcard.Payment_Status,
            postcard_size: newPostcard.Postcard_Size || '9x12',
            address_count: newPostcard.Address_Count || 0,
            postcard_bg: newPostcard.Postcard_BG,
            banner_bg: newPostcard.Banner_BG,
            spot_1: newPostcard.availability.Spot_1 || 'Available',
            spot_2: newPostcard.availability.Spot_2 || 'Available',
            spot_3: newPostcard.availability.Spot_3 || 'Available',
            spot_4: newPostcard.availability.Spot_4 || 'Available',
            spot_5: newPostcard.availability.Spot_5 || 'Available',
            spot_6: newPostcard.availability.Spot_6 || 'Available',
            spot_7: newPostcard.availability.Spot_7 || 'Available',
            spot_8: newPostcard.availability.Spot_8 || 'Available',
            spot_9: newPostcard.availability.Spot_9 || 'Available',
            spot_10: newPostcard.availability.Spot_10 || 'Available',
            spot_11: newPostcard.availability.Spot_11 || 'Available',
            spot_12: newPostcard.availability.Spot_12 || 'Available',
            spot_13: newPostcard.availability.Spot_13 || 'Available',
            spot_14: newPostcard.availability.Spot_14 || 'Available',
            spot_15: newPostcard.availability.Spot_15 || 'Available',
            spot_16: newPostcard.availability.Spot_16 || 'Available',
            spot_17: newPostcard.availability.Spot_17 || 'Available',
            spot_18: newPostcard.availability.Spot_18 || 'Available'
          });

        if (error) {
          console.error(`‚ùå Cloud save attempt ${retryCount + 1} failed:`, error);
          throw error;
        }

        console.log('‚úÖ Cloud save successful!', data);
        cloudSaveSuccess = true;
        toast("‚úÖ Postcard created and saved to cloud!", true);

        // Track Getting Started progress - campaign created
        markGettingStartedComplete('create_campaign');

      } catch (cloudErr) {
        retryCount++;
        console.error(`Failed to save to cloud (attempt ${retryCount}/${maxRetries + 1}):`, cloudErr);

        if (retryCount > maxRetries) {
          // Final failure after all retries
          toast("‚ö†Ô∏è Cloud save failed after retries. Postcard created locally. Will sync on next edit.", false);
        } else {
          // Wait before retry
          btn.innerHTML = `‚òÅÔ∏è Retrying... (${retryCount}/${maxRetries + 1})`;
          await new Promise(resolve => setTimeout(resolve, 1500));
        }
      }
    }

    // Switch to the new postcard
    pickCampaign({ target: { value: newIndex.toString() } });

    // Reset button
    btn.disabled = false;
    btn.innerHTML = originalText;

    closeNewPostcardModal();

  } catch (err) {
    console.error("Failed to create postcard:", err);
    toast("‚ö†Ô∏è Error creating postcard: " + err.message, false);

    // Reset button
    btn.disabled = false;
    btn.innerHTML = originalText;
  }
}

/* ========= RENEWAL AUTOMATION ========= */

function checkRenewals() {
  // Render to both the old location (if exists) and the dashboard widget
  const renewalContainer = document.getElementById('renewalList');
  const dashboardRenewalContainer = document.getElementById('dashboardRenewalList');

  if (!state.current) {
    const noCardMsg = `<p class="text-sm text-gray-500 text-center py-2">Select a campaign to check renewals</p>`;
    if (renewalContainer) renewalContainer.innerHTML = noCardMsg;
    if (dashboardRenewalContainer) dashboardRenewalContainer.innerHTML = noCardMsg;
    return;
  }

  const mailDate = new Date(state.current.Mail_Date);
  const today = new Date();
  const daysSinceDrop = Math.floor((today - mailDate) / (1000 * 60 * 60 * 24));

  if (daysSinceDrop >= 30) {
    const clients = Object.values(crmState.clients).filter(c =>
      c.history.some(h => h.campaign.includes(state.current.Town))
    );

    const renewalHTML = clients.length > 0 ? clients.map(c => `
      <div class="p-3 border rounded-lg bg-white flex items-center justify-between">
        <div>
          <div class="font-semibold text-sm">${esc(c.businessName)}</div>
          <div class="text-xs text-gray-500">Ready for renewal outreach</div>
        </div>
        <button onclick="openEmailRenewal('${c.id}')" class="text-xs px-3 py-1.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
          Email
        </button>
      </div>
    `).join('') : `<p class="text-sm text-gray-500 text-center py-2">No clients due for renewal from this campaign</p>`;

    if (renewalContainer) renewalContainer.innerHTML = renewalHTML;
    if (dashboardRenewalContainer) dashboardRenewalContainer.innerHTML = renewalHTML;
  } else {
    const pendingMsg = `<p class="text-sm text-gray-500 text-center py-2">No renewals due yet (${30 - daysSinceDrop} days remaining)</p>`;
    if (renewalContainer) renewalContainer.innerHTML = pendingMsg;
    if (dashboardRenewalContainer) dashboardRenewalContainer.innerHTML = pendingMsg;
  }
}

function openEmailRenewal(clientId) {
  const client = crmState.clients[clientId];
  if (!client) return;
  
  openEmailModal();
  document.getElementById('emailTemplate').value = 'renewal';
  loadEmailTemplate();
  document.getElementById('emailTo').value = client.contact.email;
  
  // Replace placeholders
  let subject = document.getElementById('emailSubject').value;
  let body = document.getElementById('emailBody').value;
  subject = subject.replace('{businessName}', client.businessName);
  body = body.replace('{contactName}', client.contact.name || 'there');
  body = body.replace('{campaign}', state.current ? `${state.current.Town} ${state.current.Mail_Date}` : 'our campaign');
  
  document.getElementById('emailSubject').value = subject;
  document.getElementById('emailBody').value = body;
}

// Delete the current postcard
async function deleteCurrentPostcard() {
  if (!state.current) {
    toast('No postcard selected', false);
    return;
  }

  const postcard = state.current;
  const confirmMsg = `Are you sure you want to delete the postcard for ${postcard.Town} ‚Äî ${postcard.Mail_Date}?\n\nThis action cannot be undone.`;

  if (!confirm(confirmMsg)) return;

  try {
    // Delete from Supabase
    const { error } = await supabaseClient
      .from('postcards')
      .delete()
      .eq('user_email', ACTIVE_USER)
      .eq('mailer_id', postcard.Mailer_ID);

    if (error) throw error;

    // Remove from state
    const currentIndex = state.mailers.findIndex(m => m.Mailer_ID === postcard.Mailer_ID);
    if (currentIndex !== -1) {
      state.mailers.splice(currentIndex, 1);
    }

    // Clear current selection
    state.current = null;
    state.availability = {};
    state.initial = {};
    state.merged.clear();
    state.selected.clear();
    state.dirty = false;

    // Refresh dropdowns
    populateTownAndMonthSelectors();

    // Select first postcard if available
    if (state.mailers.length > 0) {
      pickCampaign({ target: { value: '0' } });
    } else {
      renderAll();
    }

    toast(`‚úÖ Postcard for ${postcard.Town} deleted successfully`, true);

  } catch (err) {
    console.error('Error deleting postcard:', err);
    toast('Failed to delete postcard', false);
  }
}

/* ========= PERSISTED COLORS ========= */
const POSTCARD_BG_KEY = "mailslot-postcard-bg";
const BANNER_BG_KEY = "mailslot-banner-bg";

function loadPostcardBg() {
  try {
    const v = localStorage.getItem(POSTCARD_BG_KEY) || "#000000";
    return v;
  } catch (_) { return "#000000"; }
}

function loadBannerBg() {
  try {
    const v = localStorage.getItem(BANNER_BG_KEY) || "#000000";
    return v;
  } catch (_) { return "#000000"; }
}

function savePostcardBg(hex) {
  try { localStorage.setItem(POSTCARD_BG_KEY, hex); } catch(_) {}
}

function saveBannerBg(hex) {
  try { localStorage.setItem(BANNER_BG_KEY, hex); } catch(_) {}
}

function applyStagedColors() {
  document.querySelectorAll('.postcard').forEach(el => {
    el.style.backgroundColor = stagedColors.Postcard_BG;
    const border = shadeBlend(stagedColors.Postcard_BG, -0.15) || '#e5e7eb';
    el.style.borderColor = border;
  });
  document.querySelectorAll('.banner').forEach(b => {
    b.style.backgroundColor = stagedColors.Banner_BG;
    const border = shadeBlend(stagedColors.Banner_BG, -0.12) || '#e5e7eb';
    b.style.borderColor = border;
    b.style.color = useLightTextOn(stagedColors.Banner_BG) ? '#fff' : '#0f172a';
  });
  const previewPostcard = document.getElementById('previewPostcard');
  const previewBanner = document.getElementById('previewBanner');
  if (previewPostcard) previewPostcard.style.backgroundColor = stagedColors.Postcard_BG;
  if (previewBanner) {
    previewBanner.style.backgroundColor = stagedColors.Banner_BG;
    previewBanner.style.color = useLightTextOn(stagedColors.Banner_BG) ? '#fff' : '#0f172a';
  }
}

function shadeBlend(hex, percent) {
  try {
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16), g = parseInt(h.substring(2,4),16), b = parseInt(h.substring(4,6),16);
    const t = percent < 0 ? 0 : 255;
    const p = Math.abs(percent);
    const R = Math.round((t - r) * p) + r;
    const G = Math.round((t - g) * p) + g;
    const B = Math.round((t - b) * p) + b;
    return '#' + [R,G,B].map(x => x.toString(16).padStart(2,'0')).join('');
  } catch (e) { return null; }
}

function linearize(v){ return v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4); }
function useLightTextOn(hex){ try{ const h = hex.replace('#',''); const r=parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16); const L = 0.2126*linearize(r/255)+0.7152*linearize(g/255)+0.0722*linearize(b/255); return L < 0.45; }catch(e){ return true; } }

/* ========= FILTER BAR INITIALIZATION ========= */
// FilterBar removed - using built-in search in Prospect Pool instead
// Auto-enrichment is now automatic, no checkbox needed

/* ========= SELECT ALL CATEGORIES ========= */
// Simple global function called from HTML onclick
window.selectAllCategoriesHandler = function() {
  const checkbox = document.getElementById('selectAllCategories');
  if (!checkbox) {
    console.error('Select All checkbox not found');
    return;
  }

  const categoryCheckboxes = document.querySelectorAll('.category-checkbox');
  console.log('selectAllCategoriesHandler:', checkbox.checked, 'categories:', categoryCheckboxes.length);

  if (categoryCheckboxes.length === 0) {
    toast('No categories available', false);
    return;
  }

  categoryCheckboxes.forEach(cb => {
    cb.checked = checkbox.checked;
  });

  toast(checkbox.checked ? `Selected all ${categoryCheckboxes.length} categories` : 'Cleared all categories', true);
};

/* ========= INIT ========= */
document.addEventListener("DOMContentLoaded", () => {
  console.log('üîß DOMContentLoaded fired');

  // Display version in header
  const versionEl = document.getElementById('appVersionDisplay');
  if (versionEl && window.APP_CONFIG?.app?.version) {
    versionEl.textContent = window.APP_CONFIG.app.version;
  }

  // Initialize offline support (event listeners, sync queue)
  try {
    initOfflineSupport();
    console.log('üîß initOfflineSupport done');
  } catch(e) {
    console.error('‚ùå initOfflineSupport error:', e);
  }

  try {
    const saved = JSON.parse(safeGetItem("mailslot-sort") || "{}");
    sortOrder = saved.order || [...CANONICAL_STATUSES];
    visibleStatuses = saved.visible || [...CANONICAL_STATUSES];
  } catch(_) {}

  try {
    updateColorMappings();
    renderLegend();
    console.log('üîß Color mappings done');
  } catch(e) {
    console.error('‚ùå Color/legend error:', e);
  }

  try {
    stagedColors.Postcard_BG = loadPostcardBg();
    stagedColors.Banner_BG = loadBannerBg();
    document.getElementById('pickerPostcard').value = stagedColors.Postcard_BG;
    document.getElementById('pickerBanner').value = stagedColors.Banner_BG;
    applyStagedColors();
    console.log('üîß Staged colors done');
  } catch(e) {
    console.error('‚ùå Staged colors error:', e);
  }

  // Daily goal state will be loaded in loadAllData() after auth is ready

  // Wait for auth to complete before loading user data
  console.log('‚è≥ Waiting for authentication before loading data...');
  let authWaitCount = 0;
  var waitForAuth = setInterval(function() {
    authWaitCount++;
    if (window.authReady && ACTIVE_USER) {
      clearInterval(waitForAuth);
      console.log('‚úÖ Auth ready, loading user data for:', ACTIVE_USER);
      loadAllData();
    } else if (authWaitCount > 100) { // 10 second timeout
      clearInterval(waitForAuth);
      console.warn('‚ö†Ô∏è Auth timeout - authReady:', window.authReady, 'ACTIVE_USER:', ACTIVE_USER);
      // Try to proceed anyway if we have a user
      if (ACTIVE_USER || window.currentAuthUser?.email) {
        ACTIVE_USER = ACTIVE_USER || window.currentAuthUser?.email;
        console.log('üîÑ Proceeding with user:', ACTIVE_USER);
        loadAllData();
      } else {
        console.error('‚ùå No authenticated user after timeout');
        hideLoadingOverlay();
        toast('Authentication timeout. Please refresh the page.', false);
      }
    }
  }, 100);
});

// Separate function for loading all data (called after auth is ready)
async function loadAllData() {
  // Migrate localStorage to IndexedDB (one-time, runs in background)
  migrateLocalStorageToIDB().catch(e => console.warn('IndexedDB migration skipped:', e));

  // Load all state from cloud (with IndexedDB fallback)
  Promise.allSettled([
    loadExpenses(),
    loadPricing(),
    loadRevenueGoals(),
    loadSpotPricing(),
    loadClients(),
    loadKanban(),
    loadTasks(),
    loadNotInterestedList(),
    loadManualProspects(),
    loadBusinessCategories(),
    loadUserTemplates(),
    loadDailyGoalState(),
    loadTemplateEdits(),
    loadOutreachTemplatesFromCloud(),
    loadOutreachNotesFromCloud()
  ]).then(results => {
    const succeeded = results.filter(r => r.status === 'fulfilled').length;
    const failed = results.filter(r => r.status === 'rejected').length;

    if (failed > 0) {
      console.warn(`‚ö†Ô∏è ${succeeded} data types loaded, ${failed} failed (using localStorage cache)`);
      const failedTypes = results
        .map((r, i) => r.status === 'rejected' ? ['expenses', 'pricing', 'revenueGoals', 'spotPricing', 'clients', 'kanban', 'tasks', 'notInterested', 'manualProspects', 'businessCategories', 'userTemplates', 'dailyGoal', 'templateEdits'][i] : null)
        .filter(t => t !== null);
      console.warn('Failed types:', failedTypes.join(', '));

      // Show user notification about partial cloud sync failure
      toast(`‚ö†Ô∏è ${failed} data type(s) loaded from local cache (cloud unavailable)`, false);
    }

    // Load campaigns AFTER expenses and pricing are loaded so financial dashboard shows correct data
    console.log('‚úÖ Pricing data loaded. Loading campaigns...');
    loadCampaigns();

    // Load Getting Started progress after all other data is loaded
    loadGettingStartedProgress();

    // Re-render Close Deals if that tab is active (kanban data now loaded)
    const activeTab = localStorage.getItem('9x12_active_tab');
    if (activeTab === 'outreach') {
      renderCloseDealsProspects();
    }
  });

  // Load API quota (local only)
  loadApiQuota();

  // Load enrichment quota counter
  loadEnrichmentQuota();

  // Load Getting Started checklist progress (loaded after campaigns)
  // Will be called after data loads

  // Load prospect cache from cloud with merge
  loadPlacesCache().then(() => {
    renderProspectPool(); // Re-render to show loaded prospects
    updateCacheStatus(); // Update dashboard cache display

    // Save to cloud to ensure computer's data is uploaded
    savePlacesCache();
  }).catch(e => {
    console.error('Failed to load prospect cache:', e);
  });

  // Auto-sync prospect cache every 2 minutes to keep devices in sync
  setInterval(async () => {
    console.log('üîÑ Auto-syncing prospect cache from cloud...');
    try {
      const cloudData = await loadFromCloud('placesCache');

      if (cloudData && Object.keys(cloudData).length > 0) {
        // Merge cloud data with local
        const currentLocal = { ...placesCache.searches };
        let newEntriesCount = 0;

        Object.keys(cloudData).forEach(cacheKey => {
          const cloud = cloudData[cacheKey];
          const local = currentLocal[cacheKey];

          if (!local) {
            // New entry from cloud - add it
            placesCache.searches[cacheKey] = cloud;
            newEntriesCount++;
          } else if (cloud.lastFetched && local.lastFetched) {
            // Both exist - keep newer one
            const cloudDate = new Date(cloud.lastFetched);
            const localDate = new Date(local.lastFetched);
            if (cloudDate > localDate) {
              placesCache.searches[cacheKey] = cloud;
              newEntriesCount++;
            }
          }
        });

        if (newEntriesCount > 0) {
          console.log(`‚úÖ Auto-sync: Found ${newEntriesCount} new/updated searches from cloud`);

          // Save merged data locally
          idbSet('mailslot-places-cache', placesCache.searches);

          // Refresh prospect pool if user is viewing it
          const prospectTab = document.querySelector('.tab-pane[data-content="prospects"]');
          const isViewingProspects = prospectTab && !prospectTab.classList.contains('hidden');

          if (isViewingProspects) {
            console.log('üì• User is viewing Prospect Pool - refreshing...');
            renderProspectPool();
            showInfo(`üì• Synced ${newEntriesCount} new searches from cloud`);
          } else {
            console.log('üì• User not viewing Prospect Pool - data synced silently');
          }
        } else {
          console.log('‚úÖ Auto-sync: Prospect cache is up to date');
        }
      }
    } catch(e) {
      console.error('Auto-sync failed:', e);
    }
  }, 2 * 60 * 1000); // Every 2 minutes

  // Load spot pricing from localStorage as fallback (cloud load happens earlier)
  // This will be used if cloud sync fails or for migration
  try {
    const savedPricing = safeGetItem('mailslot-pricing');
    if (savedPricing && Object.keys(productionState.spotPricing).length === 0) {
      const rawPricing = JSON.parse(savedPricing);

      // FILTER: Only load valid spot prices (numbers with SPOT_ in key)
      // Prevents corrupted campaign-level pricing from localStorage
      productionState.spotPricing = {};
      Object.keys(rawPricing).forEach(key => {
        const value = rawPricing[key];
        if (typeof value === 'number' && !isNaN(value) && key.toUpperCase().includes('SPOT_')) {
          productionState.spotPricing[key.toUpperCase()] = value;
        }
      });

      console.log('üí∞ [LOCALSTORAGE MIGRATION] Loaded', Object.keys(productionState.spotPricing).length, 'valid spot prices from localStorage');

      // Migrate cleaned data to cloud
      if (Object.keys(productionState.spotPricing).length > 0) {
        saveSpotPricing();
      }
    }
  } catch(e) {}
  // Don't call updateAutoSaveStatus() on page load - only show after actual saves
  updateQuickApiUsage(); // Initialize API usage display in prospecting section

  // Initialize sales activity collapse state
  initSalesActivityState();

  // Restore last active tab, or default to dashboard
  const lastTab = localStorage.getItem('9x12_active_tab') || 'dashboard';
  switchTab(lastTab);

  // If starting on dashboard, refresh it after data loads
  if (lastTab === 'dashboard') {
    setTimeout(() => refreshDashboard(), 1000);
  }

  window.addEventListener('resize', () => renderLegend());
  bindUI();

  // Ensure critical functions are globally accessible
  window.openExpenseModal = openExpenseModal;
  window.openReportsModal = openReportsModal;
  window.openEmailModal = openEmailModal;
  window.manualSaveNow = manualSaveNow;
  window.pickCampaign = pickCampaign;
  // toggleCustomCategory removed - categories now populated dynamically
  window.toggleBulkCustomCategory = toggleBulkCustomCategory;
  window.importClientsCSV = importClientsCSV;
  window.openAutoPopulateModal = openAutoPopulateModal;
  window.runBulkAutoPopulate = runBulkAutoPopulate;
  window.openProspectsResultsModal = openProspectsResultsModal;
  window.closeProspectsResultsModal = closeProspectsResultsModal;
  window.toggleProspectSelection = toggleProspectSelection;
  window.markNotInterested = markNotInterested;
  window.addSelectedProspects = addSelectedProspects;
  window.editLead = editLead;
  window.deleteLead = deleteLead;
  window.moveProspectBackToPool = moveProspectBackToPool;
  window.openLeadModal = openLeadModal;
  window.saveLeadModal = saveLeadModal;
  window.toggleCloudSyncUI = toggleCloudSyncUI;
  window.toggleProspectForSync = toggleProspectForSync;
  window.saveSelectedProspectsToCloud = saveSelectedProspectsToCloud;
  window.closeLeadModal = closeLeadModal;
  window.togglePoolProspect = togglePoolProspect;
  window.selectCategoryProspects = selectCategoryProspects;
  window.addFromProspectPool = addFromProspectPool;
  window.clearProspectPool = clearProspectPool;
  window.renderProspectPool = renderProspectPool;
  window.switchTab = switchTab;
  window.deleteCurrentPostcard = deleteCurrentPostcard;
}

function bindUI(){
  const btn = (id, handler) => {
    const el = document.getElementById(id);
    if (el) el.onclick = handler;
  };

  btn("btnCancelEdit", closeEditModal);
  btn("btnApplyEdit", applyEditModal);
  btn("btnCancelPostcard", closePostcardModal);
  btn("btnApplyPostcard", applyPostcardModal);
  btn("btnAdjustPostcard", openPostcardModal);
  btn("btnCancelEditStatus", closeEditStatusModal);
  btn("btnSaveEditStatus", saveEditStatusModal);

  // Duplicate modal
  btn("btnCancelDuplicate", closeDuplicatePostcardModal);
  btn("btnCreateDuplicate", createDuplicatePostcard);

  // Pricing modal
  btn("btnCancelPricing", closePricingModal);
  btn("btnSavePricing", savePricingModal);

  // Sync top pricing inputs to bottom calculator
  ["pricingSingleAd", "pricingDoubleAd", "pricingBannerAd"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', syncPricingToCalculator);
  });

  // Expense modal
  btn("btnCancelExpense", closeExpenseModal);
  btn("btnSaveExpense", saveExpenseModal);
  ["expensePrinting", "expensePostage", "expenseDesign", "expenseMisc"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', updateExpenseTotal);
  });
  
  // Client modal
  document.getElementById('btnCancelClient').onclick = closeClientModal;
  document.getElementById('btnSaveClient').onclick = saveClientModal;
  document.getElementById('btnDeleteClient').onclick = deleteClientModal;
  
  // Email modal
  document.getElementById('btnCancelEmail').onclick = closeEmailModal;
  document.getElementById('btnSendEmail').onclick = sendEmail;
  
  // Reports modal
  document.getElementById('btnCloseReports').onclick = closeReportsModal;

  // Task modal
  document.getElementById('btnCancelTask').onclick = closeTaskModal;
  document.getElementById('btnSaveTask').onclick = saveTaskModal;

  // Lead modal
  document.getElementById('btnCancelLead').onclick = closeLeadModal;
  document.getElementById('btnSaveLead').onclick = saveLeadModal;

  // Contact Later modal
  document.getElementById('btnCancelContactLater').onclick = closeContactLaterModal;
  document.getElementById('btnSaveContactLater').onclick = saveContactLater;

  // Auto-populate modal
  document.getElementById('btnCancelAutoPopulate').onclick = closeAutoPopulateModal;
  document.getElementById('btnRunAutoPopulate').onclick = runAutoPopulate;

  // Financial transaction modals
  document.getElementById('btnCancelAddTransaction').onclick = closeAddTransactionModal;
  document.getElementById('btnSaveAddTransaction').onclick = saveAddTransaction;
  document.getElementById('btnCancelEditTransaction').onclick = closeEditTransactionModal;
  document.getElementById('btnSaveEditTransaction').onclick = saveEditTransaction;

  // New Postcard modal
  document.getElementById('btnCancelNewPostcard').onclick = closeNewPostcardModal;
  document.getElementById('btnCreatePostcard').onclick = createNewPostcard;
  
  document.getElementById("pickerPostcard").addEventListener('input', (e)=> { stagedColors.Postcard_BG = e.target.value; previewPostcardModal(); });
  document.getElementById("pickerBanner").addEventListener('input', (e)=> { stagedColors.Banner_BG = e.target.value; previewPostcardModal(); });
 
  const commitBtn = document.getElementById("btnSaveCommit");
  if (commitBtn) {
    commitBtn.onclick = function() {
      return saveToSheet();
    };
  } else {
    // btnSaveCommit is optional - only used in sheet mode
  }
 
  window.addEventListener('beforeunload', (e) => {
    if (state.dirty) {
      // Attempt to auto-save before leaving
      performAutoSave();

      // Still show warning in case save isn't complete
      e.preventDefault();
      e.returnValue = 'You have unsaved changes. We are attempting to save them now.';
    }
  });
  
  document.addEventListener('click', (e)=> {
    if (e.target.matches('.sort-up') || e.target.matches('.sort-down')) handleSortUpDown(e);
  });
  
  // Tab navigation is handled by onclick handlers on individual buttons
  const navTabs = document.getElementById("mainNavigation");
  if (navTabs) {
    navTabs.addEventListener('click', (e) => {
        const target = e.target.closest('.tab-btn');
        if (!target) return;
        const tabName = target.dataset.tab;
        switchTab(tabName);
    });
  }

  // Don't call switchTab here - it's already restored at line 6730
}

function switchTab(tabName) {
    // Auto-save before switching tabs if there are unsaved changes
    if (state.dirty) {
        performAutoSave(); // Immediate save on tab switch
    }

    // Save current tab to remember it on refresh
    localStorage.setItem('9x12_active_tab', tabName);

    // Remove active state from all nav buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.classList.remove('bg-white', 'shadow-md');
    });

    // Add active state to current tab button
    const activeBtn = document.querySelector(`.tab-btn[data-tab="${tabName}"]`);
    if (activeBtn) {
        activeBtn.classList.add('active', 'bg-white', 'shadow-md');
    }

    document.querySelectorAll('.tab-pane').forEach(pane => {
        pane.classList.add('hidden');
        pane.classList.remove('active-pane');
    });
    const activePane = document.querySelector(`.tab-pane[data-content="${tabName}"]`);
    if (activePane) {
        activePane.classList.remove('hidden');
        activePane.classList.add('active-pane');
    }

    const legendArea = document.getElementById("legendArea");
    if (legendArea) show(legendArea, tabName === 'manager');

    // Show/hide postcard selector - only visible on Postcards & Activation tab
    const selectorContainer = document.getElementById("postcardSelectorContainer");
    if (selectorContainer) {
        if (tabName === 'manager') {
            selectorContainer.classList.remove('hidden');
        } else {
            selectorContainer.classList.add('hidden');
        }
    }

    // Update breadcrumb active state
    updateBreadcrumbHighlight(tabName);

    // Refresh dashboard when switching to it
    if (tabName === 'dashboard') {
        setTimeout(() => {
            refreshDashboard();
            initializeDashboardTemplatesState();
            // Load financial data for dashboard widget if not loaded
            if (!financialState.loaded) {
                loadFinancialData();
            }
        }, 100);
    }

    // Render template manager when clients tab is opened
    if (tabName === 'clients') {
        setTimeout(() => renderTemplateManager(), 100);
    }

    if (tabName === 'manager') {
        renderAll();
    } else if (tabName === 'pipeline') {
        renderCardsInProgress();
        renderGettingStartedChecklist();
        renderContractsExpiring();
        // Populate bulk send templates
        setTimeout(() => populateBulkSendTemplates(), 100);
    } else if (tabName === 'clients') {
        renderClientList();
    } else if (tabName === 'admin' || tabName === 'reports') {
        // Load financial data when Financials/Reports tab is opened
        if (!financialState.loaded) {
            loadFinancialData();
        } else {
            renderFinancialRegister();
        }
    } else if (tabName === 'prospects' || tabName === 'lead-generation') {
        renderProspectPool();
    } else if (tabName === 'outreach') {
        // Render Outreach Worksheet table
        renderOutreachTable();
    }
}

/**
 * Switch between Dashboard sub-tabs (Overview, Tasks, Reports, Templates, Renewals)
 */
function switchDashboardTab(subTabName) {
    // Remove active state from all dashboard sub-tab buttons
    document.querySelectorAll('.dashboard-tab-btn').forEach(btn => {
        btn.classList.remove('active', 'bg-white', 'shadow-md');
    });

    // Add active state to selected dashboard sub-tab button
    const activeBtn = document.querySelector(`.dashboard-tab-btn[data-dashboard-tab="${subTabName}"]`);
    if (activeBtn) {
        activeBtn.classList.add('active', 'bg-white', 'shadow-md');
    }

    // Hide all dashboard sub-panes
    document.querySelectorAll('.dashboard-sub-pane').forEach(pane => {
        pane.classList.add('hidden');
    });

    // Show selected dashboard sub-pane
    const activePane = document.getElementById(`dashboard-${subTabName}`);
    if (activePane) {
        activePane.classList.remove('hidden');
    }

    // Handle specific tab loading logic
    if (subTabName === 'reports') {
        // Load financial data
        if (!financialState.loaded) {
            loadFinancialData();
        } else {
            renderFinancialRegister();
        }
    } else if (subTabName === 'templates') {
        // Render templates
        setTimeout(() => renderTemplateManager(), 100);
    } else if (subTabName === 'renewals') {
        // Render contract renewals
        renderContractsExpiring();
    }
}

/* ========= TEMPLATE MANAGEMENT FUNCTIONS ========= */

// Alias for backward compatibility - now uses consolidated renderTemplateManager
function renderDashboardTemplates() {
    renderTemplateManager();
}

// Toggle dashboard templates section visibility
function toggleDashboardTemplates() {
    const content = document.getElementById('dashboardTemplatesContent');
    const icon = document.getElementById('dashboardTemplatesToggleIcon');

    if (content && icon) {
        if (content.classList.contains('hidden')) {
            content.classList.remove('hidden');
            icon.textContent = '‚ñº';
            icon.style.transform = 'rotate(0deg)';
            // Save preference
            safeSetItem('dashboardTemplatesExpanded', 'true');
        } else {
            content.classList.add('hidden');
            icon.textContent = '‚ñ∂';
            icon.style.transform = 'rotate(0deg)';
            // Save preference
            safeSetItem('dashboardTemplatesExpanded', 'false');
        }
    }
}

// Initialize dashboard templates collapsed state on load
function initializeDashboardTemplatesState() {
    const expanded = safeGetItem('dashboardTemplatesExpanded');
    const content = document.getElementById('dashboardTemplatesContent');
    const icon = document.getElementById('dashboardTemplatesToggleIcon');

    // Default to collapsed (hidden)
    if (content && icon) {
        if (expanded === 'true') {
            content.classList.remove('hidden');
            icon.textContent = '‚ñº';
        } else {
            content.classList.add('hidden');
            icon.textContent = '‚ñ∂';
        }
    }
}

/* ========= QUICK SEND FUNCTIONS ========= */

function populateBulkSendTemplates() {
    const templates = Object.values(userTemplatesState.templates || {});

    // Populate bulk send template selector
    const bulkSelector = document.getElementById('bulkSendTemplateSelector');
    if (bulkSelector) {
        bulkSelector.innerHTML = '<option value="">‚Äî Choose a template ‚Äî</option>' +
            templates.map(t => `<option value="${t.id}">[${t.type.toUpperCase()}] ${t.name}</option>`).join('');

        // Add event listener for template preview
        bulkSelector.onchange = function() {
            const previewDiv = document.getElementById('bulkSendPreview');
            const previewText = document.getElementById('bulkSendPreviewText');

            if (this.value && previewDiv && previewText) {
                const template = userTemplatesState.templates[this.value];
                if (template) {
                    previewText.textContent = template.body;
                    previewDiv.classList.remove('hidden');
                } else {
                    previewDiv.classList.add('hidden');
                }
            } else if (previewDiv) {
                previewDiv.classList.add('hidden');
            }
        };
    }
}


function bulkSendSMS() {
    const templateSelector = document.getElementById('bulkSendTemplateSelector');
    if (!templateSelector || !templateSelector.value) {
        toast('‚ö†Ô∏è Please select a template first', false);
        return;
    }

    const templateId = templateSelector.value;
    const template = userTemplatesState.templates[templateId];

    if (!template) {
        toast('‚ö†Ô∏è Template not found', false);
        return;
    }

    if (template.type !== 'sms') {
        toast('‚ö†Ô∏è Please select an SMS template', false);
        return;
    }

    const selectedCount = toContactSelectionState.selectedIds.size;

    if (confirm(`Send SMS to ${selectedCount} selected prospect${selectedCount > 1 ? 's' : ''}?\n\nThis will open your SMS app for each contact with a delay between each.`)) {
        const board = getCurrentCampaignBoard();
        const toContactColumn = (board && board.columns) ? (board.columns['queued'] || []) : [];
        const selectedIds = Array.from(toContactSelectionState.selectedIds);

        let successCount = 0;
        let currentIndex = 0;

        // Process SMS sequentially with delay
        const processNextSMS = () => {
            if (currentIndex >= selectedIds.length) {
                // All done - show final toast
                toast(`‚úÖ Opened SMS for ${successCount} of ${selectedCount} prospect${successCount > 1 ? 's' : ''}`, true);

                // Track template usage
                if (template) {
                    template.lastUsed = new Date().toISOString();
                    template.usageCount = (template.usageCount || 0) + successCount;
                    saveUserTemplates();
                }

                // Clear selections
                toContactSelectionState.selectedIds.clear();
                updateBulkSendSection();
                renderKanban();
                return;
            }

            const leadId = selectedIds[currentIndex];
            const prospect = toContactColumn.find(item => String(item.id || item) === String(leadId));

            if (prospect && typeof prospect === 'object' && prospect.phone) {
                // Fill template variables
                const filled = fillTemplateVariables(template, prospect);
                const message = filled.body;

                // Show progress toast
                toast(`üì± Opening Google Voice ${currentIndex + 1} of ${selectedCount}: ${prospect.businessName}`, true);

                // Copy message and open Google Voice
                const cleanPhone = prospect.phone.replace(/\D/g, '');
                navigator.clipboard.writeText(message).catch(() => {});
                window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
                successCount++;
            } else if (prospect && !prospect.phone) {
                toast(`‚ö†Ô∏è Skipping ${prospect.businessName} - no phone number`, false);
            }

            currentIndex++;

            // Wait 3 seconds before next to allow Google Voice to load
            setTimeout(processNextSMS, 3000);
        };

        // Start processing
        processNextSMS();
    }
}

function bulkSendEmail() {
    const templateSelector = document.getElementById('bulkSendTemplateSelector');
    if (!templateSelector || !templateSelector.value) {
        toast('‚ö†Ô∏è Please select a template first', false);
        return;
    }

    const templateId = templateSelector.value;
    const template = userTemplatesState.templates[templateId];

    if (!template) {
        toast('‚ö†Ô∏è Template not found', false);
        return;
    }

    if (template.type !== 'email') {
        toast('‚ö†Ô∏è Please select an Email template', false);
        return;
    }

    const selectedCount = toContactSelectionState.selectedIds.size;

    if (confirm(`Send Email to ${selectedCount} selected prospect${selectedCount > 1 ? 's' : ''}?\n\nYou'll be prompted before each email.`)) {
        const board = getCurrentCampaignBoard();
        const toContactColumn = (board && board.columns) ? (board.columns['queued'] || []) : [];
        const selectedIds = Array.from(toContactSelectionState.selectedIds);

        console.log('üîµ Bulk Email - Selected IDs:', selectedIds);
        console.log('üîµ Bulk Email - To Contact Column:', toContactColumn.map(item => ({ id: item.id, name: item.businessName })));

        let successCount = 0;
        let currentIndex = 0;

        // Process emails sequentially with user confirmation AFTER opening email
        const processNextEmail = () => {
            if (currentIndex >= selectedIds.length) {
                // All done - show final toast
                toast(`‚úÖ Sent to ${successCount} of ${selectedCount} prospect${successCount > 1 ? 's' : ''}`, true);

                // Track template usage
                if (template) {
                    template.lastUsed = new Date().toISOString();
                    template.usageCount = (template.usageCount || 0) + successCount;
                    saveUserTemplates();
                }

                // Clear selections
                toContactSelectionState.selectedIds.clear();
                updateBulkSendSection();
                renderKanban();
                return;
            }

            const leadId = selectedIds[currentIndex];
            const prospect = toContactColumn.find(item => String(item.id || item) === String(leadId));

            console.log('üîµ Looking for leadId:', leadId, 'Found:', prospect ? prospect.businessName : 'NOT FOUND');

            if (prospect && typeof prospect === 'object' && prospect.email) {
                // Fill template variables
                const filled = fillTemplateVariables(template, prospect);
                const subject = filled.subject;
                const body = filled.body;

                // Open email window FIRST (while in user gesture context)
                window.open(`mailto:${prospect.email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`, '_blank');
                successCount++;
                console.log('‚úÖ Opened email for:', prospect.businessName);

                currentIndex++;

                // THEN ask if they want to continue to next (after they send this one)
                if (currentIndex < selectedIds.length) {
                    setTimeout(() => {
                        const continueNext = confirm(`Email opened for ${prospect.businessName}\n\nEmail ${currentIndex} of ${selectedCount} sent.\n\nClick OK to continue to next email, or Cancel to stop.`);
                        if (continueNext) {
                            processNextEmail();
                        } else {
                            toast(`‚úÖ Sent to ${successCount} of ${selectedCount} prospect${successCount > 1 ? 's' : ''}`, true);
                            toContactSelectionState.selectedIds.clear();
                            updateBulkSendSection();
                            renderKanban();
                        }
                    }, 500); // Short delay to let email client open
                } else {
                    // Last email - finish up
                    processNextEmail();
                }
            } else if (prospect && !prospect.email) {
                console.warn('‚ö†Ô∏è No email for:', prospect.businessName);
                alert(`‚ö†Ô∏è ${prospect.businessName} has no email address. Skipping.`);
                currentIndex++;
                processNextEmail();
            } else {
                currentIndex++;
                processNextEmail();
            }
        };

        // Start processing
        processNextEmail();
    }
}

function bulkSendGoogleVoice() {
    const templateSelector = document.getElementById('bulkSendTemplateSelector');
    if (!templateSelector || !templateSelector.value) {
        toast('‚ö†Ô∏è Please select a template first', false);
        return;
    }

    const templateId = templateSelector.value;
    const template = userTemplatesState.templates[templateId];

    if (!template) {
        toast('‚ö†Ô∏è Template not found', false);
        return;
    }

    if (template.type !== 'sms') {
        toast('‚ö†Ô∏è Please select an SMS template (Google Voice uses SMS format)', false);
        return;
    }

    const selectedCount = toContactSelectionState.selectedIds.size;

    if (confirm(`Send via Google Voice to ${selectedCount} selected prospect${selectedCount > 1 ? 's' : ''}?\n\nThis will:\n1. Copy each message to your clipboard\n2. Open Google Voice for each contact with a delay\n3. You can paste (Ctrl+V) the message and send`)) {
        const board = getCurrentCampaignBoard();
        const toContactColumn = (board && board.columns) ? (board.columns['queued'] || []) : [];
        const selectedIds = Array.from(toContactSelectionState.selectedIds);

        let successCount = 0;
        let currentIndex = 0;

        // Process Google Voice messages sequentially with delay
        const processNextGoogleVoice = () => {
            if (currentIndex >= selectedIds.length) {
                // All done - show final toast
                toast(`‚úÖ Opened Google Voice for ${successCount} of ${selectedCount} prospect${successCount > 1 ? 's' : ''}`, true);

                // Track template usage
                if (template) {
                    template.lastUsed = new Date().toISOString();
                    template.usageCount = (template.usageCount || 0) + successCount;
                    saveUserTemplates();
                }

                // Clear selections
                toContactSelectionState.selectedIds.clear();
                updateBulkSendSection();
                renderKanban();
                return;
            }

            const leadId = selectedIds[currentIndex];
            const prospect = toContactColumn.find(item => String(item.id || item) === String(leadId));

            if (prospect && typeof prospect === 'object' && prospect.phone) {
                // Fill template variables
                const filled = fillTemplateVariables(template, prospect);
                const message = filled.body;

                // Google Voice web URL - opens to messages with phone number
                const cleanPhone = prospect.phone.replace(/\D/g, ''); // Remove non-digits
                const formattedPhone = cleanPhone.length === 10 ? `+1${cleanPhone}` : `+${cleanPhone}`;
                const googleVoiceUrl = `https://voice.google.com/u/0/messages?itemId=${formattedPhone}`;

                // Copy message to clipboard so user can easily paste
                navigator.clipboard.writeText(message).then(() => {
                    toast(`üì± Opening Google Voice ${currentIndex + 1} of ${selectedCount}: ${prospect.businessName} (message copied!)`, true);
                }).catch(err => {
                    console.warn('Could not copy to clipboard:', err);
                    toast(`üì± Opening Google Voice ${currentIndex + 1} of ${selectedCount}: ${prospect.businessName}`, true);
                });

                window.open(googleVoiceUrl, '_blank');
                successCount++;
            } else if (prospect && !prospect.phone) {
                toast(`‚ö†Ô∏è Skipping ${prospect.businessName} - no phone number`, false);
            }

            currentIndex++;

            // Wait 3 seconds for Google Voice (slightly longer to allow clipboard and page load)
            setTimeout(processNextGoogleVoice, 3000);
        };

        // Start processing
        processNextGoogleVoice();
    }
}

// Bulk open LinkedIn profiles and copy message to clipboard
function bulkOpenLinkedIn() {
    const templateSelector = document.getElementById('bulkSendTemplateSelector');
    if (!templateSelector || !templateSelector.value) {
        toast('‚ö†Ô∏è Please select a template first', false);
        return;
    }

    const templateId = templateSelector.value;
    const template = userTemplatesState.templates[templateId];

    if (!template) {
        toast('‚ö†Ô∏è Template not found', false);
        return;
    }

    const selectedCount = toContactSelectionState.selectedIds.size;
    const board = getCurrentCampaignBoard();
    const toContactColumn = (board && board.columns) ? (board.columns['queued'] || []) : [];
    const selectedIds = Array.from(toContactSelectionState.selectedIds);

    // Count how many have LinkedIn URLs
    let linkedInCount = 0;
    selectedIds.forEach(leadId => {
        const prospect = toContactColumn.find(item => String(item.id || item) === String(leadId));
        if (prospect && typeof prospect === 'object' && prospect.linkedin) {
            linkedInCount++;
        }
    });

    if (linkedInCount === 0) {
        toast('‚ö†Ô∏è None of the selected prospects have LinkedIn URLs', false);
        return;
    }

    if (confirm(`Open LinkedIn for ${linkedInCount} prospect${linkedInCount > 1 ? 's' : ''} (of ${selectedCount} selected)?\n\nThis will:\n1. Copy the message to your clipboard\n2. Open their LinkedIn profile\n3. You can paste the message to send`)) {
        let successCount = 0;
        let currentIndex = 0;

        const processNextLinkedIn = () => {
            if (currentIndex >= selectedIds.length) {
                toast(`‚úÖ Opened LinkedIn for ${successCount} prospect${successCount > 1 ? 's' : ''}`, true);

                if (template) {
                    template.lastUsed = new Date().toISOString();
                    template.usageCount = (template.usageCount || 0) + successCount;
                    saveUserTemplates();
                }

                toContactSelectionState.selectedIds.clear();
                updateBulkSendSection();
                renderKanban();
                return;
            }

            const leadId = selectedIds[currentIndex];
            const prospect = toContactColumn.find(item => String(item.id || item) === String(leadId));

            if (prospect && typeof prospect === 'object' && prospect.linkedin) {
                const filled = fillTemplateVariables(template, prospect);
                const message = template.type === 'email' ? filled.body : (filled.body || template.body);

                navigator.clipboard.writeText(message).then(() => {
                    toast(`üíº Opening LinkedIn ${successCount + 1} of ${linkedInCount}: ${prospect.businessName} (message copied!)`, true);
                }).catch(err => {
                    console.warn('Could not copy to clipboard:', err);
                    toast(`üíº Opening LinkedIn ${successCount + 1} of ${linkedInCount}: ${prospect.businessName}`, true);
                });

                window.open(prospect.linkedin, '_blank');
                successCount++;

                // Track the interaction
                if (!prospect.contactTracking) {
                    prospect.contactTracking = {};
                }
                prospect.contactTracking.linkedinMessaged = true;
                prospect.contactTracking.linkedinMessagedDate = new Date().toISOString();
            }

            currentIndex++;
            setTimeout(processNextLinkedIn, 3000);
        };

        processNextLinkedIn();
    }
}

// Bulk open Facebook pages and copy message to clipboard
function bulkOpenFacebook() {
    const templateSelector = document.getElementById('bulkSendTemplateSelector');
    if (!templateSelector || !templateSelector.value) {
        toast('‚ö†Ô∏è Please select a template first', false);
        return;
    }

    const templateId = templateSelector.value;
    const template = userTemplatesState.templates[templateId];

    if (!template) {
        toast('‚ö†Ô∏è Template not found', false);
        return;
    }

    const selectedCount = toContactSelectionState.selectedIds.size;
    const board = getCurrentCampaignBoard();
    const toContactColumn = (board && board.columns) ? (board.columns['queued'] || []) : [];
    const selectedIds = Array.from(toContactSelectionState.selectedIds);

    // Count how many have Facebook URLs
    let facebookCount = 0;
    selectedIds.forEach(leadId => {
        const prospect = toContactColumn.find(item => String(item.id || item) === String(leadId));
        if (prospect && typeof prospect === 'object' && prospect.facebook) {
            facebookCount++;
        }
    });

    if (facebookCount === 0) {
        toast('‚ö†Ô∏è None of the selected prospects have Facebook URLs', false);
        return;
    }

    if (confirm(`Open Facebook for ${facebookCount} prospect${facebookCount > 1 ? 's' : ''} (of ${selectedCount} selected)?\n\nThis will:\n1. Copy the message to your clipboard\n2. Open their Facebook page\n3. You can paste the message to send`)) {
        let successCount = 0;
        let currentIndex = 0;

        const processNextFacebook = () => {
            if (currentIndex >= selectedIds.length) {
                toast(`‚úÖ Opened Facebook for ${successCount} prospect${successCount > 1 ? 's' : ''}`, true);

                if (template) {
                    template.lastUsed = new Date().toISOString();
                    template.usageCount = (template.usageCount || 0) + successCount;
                    saveUserTemplates();
                }

                toContactSelectionState.selectedIds.clear();
                updateBulkSendSection();
                renderKanban();
                return;
            }

            const leadId = selectedIds[currentIndex];
            const prospect = toContactColumn.find(item => String(item.id || item) === String(leadId));

            if (prospect && typeof prospect === 'object' && prospect.facebook) {
                const filled = fillTemplateVariables(template, prospect);
                const message = template.type === 'email' ? filled.body : (filled.body || template.body);

                navigator.clipboard.writeText(message).then(() => {
                    toast(`üìò Opening Facebook ${successCount + 1} of ${facebookCount}: ${prospect.businessName} (message copied!)`, true);
                }).catch(err => {
                    console.warn('Could not copy to clipboard:', err);
                    toast(`üìò Opening Facebook ${successCount + 1} of ${facebookCount}: ${prospect.businessName}`, true);
                });

                window.open(prospect.facebook, '_blank');
                successCount++;

                // Track the interaction
                if (!prospect.contactTracking) {
                    prospect.contactTracking = {};
                }
                prospect.contactTracking.facebookMessaged = true;
                prospect.contactTracking.facebookMessagedDate = new Date().toISOString();
            }

            currentIndex++;
            setTimeout(processNextFacebook, 3000);
        };

        processNextFacebook();
    }
}

/* ========= LOAD CAMPAIGNS ========= */
async function loadCampaigns(restoreMailerId = null) {
  try {
    console.log('üì• LOADING FROM SUPABASE for user:', ACTIVE_USER, 'restoreMailerId:', restoreMailerId);

    const { data, error } = await supabaseClient
      .from('postcards')
      .select('*')
      .eq('user_email', ACTIVE_USER)
      .order('mail_date', { ascending: false });

    if (error) throw error;

    console.log('üì• SUPABASE LOAD SUCCESS:', data?.length, 'postcards loaded');
    if (data && data.length > 0) {
      console.log('üì• First postcard sample:', data[0]);
    }

    // Transform Supabase column names to match app expectations
    const mailers = (data || []).map(postcard => ({
      Mailer_ID: postcard.mailer_id,
      Town: postcard.town,
      Mail_Date: postcard.mail_date,
      In_Homes_Date: postcard.in_homes_date,
      Payment_Status: postcard.payment_status,
      Postcard_Size: postcard.postcard_size || '9x12',
      Address_Count: postcard.address_count || 0,
      Zip_Code: postcard.zip_code || '',
      Postcard_BG: postcard.postcard_bg,
      Banner_BG: postcard.banner_bg,
      Spot_1: postcard.spot_1,
      Spot_2: postcard.spot_2,
      Spot_3: postcard.spot_3,
      Spot_4: postcard.spot_4,
      Spot_5: postcard.spot_5,
      Spot_6: postcard.spot_6,
      Spot_7: postcard.spot_7,
      Spot_8: postcard.spot_8,
      Spot_9: postcard.spot_9,
      Spot_10: postcard.spot_10,
      Spot_11: postcard.spot_11,
      Spot_12: postcard.spot_12,
      Spot_13: postcard.spot_13,
      Spot_14: postcard.spot_14,
      Spot_15: postcard.spot_15,
      Spot_16: postcard.spot_16,
      Spot_17: postcard.spot_17,
      Spot_18: postcard.spot_18
    }));

    onCampaignsLoaded(mailers, restoreMailerId);
  } catch (err) {
    console.error('Failed to load campaigns from Supabase:', err);
    toast("‚ö†Ô∏è Failed to load campaigns. Please refresh.", false);
    hideLoadingOverlay(); // Still hide overlay on error

    // Still initialize UI even if campaigns fail to load
    onCampaignsLoaded([], restoreMailerId);
  }
}

function jsonpLoad(url, cb){
  const cbName = "cb_" + Math.random().toString(36).slice(2);
  window[cbName] = (data) => { try{ cb(data); } finally { delete window[cbName]; s.remove(); } };
  const s = document.createElement("script");
  s.src = url + (url.includes("?") ? "&" : "?") + "callback=" + cbName;
  s.async = true;
  s.onerror = () => toast("Load failed", false);
  document.head.appendChild(s);
}

function onCampaignsLoaded(res, restoreMailerId = null){
  // Backend returns array directly, not wrapped in {mailers: []}
  let mailers = Array.isArray(res) ? res : (res && res.mailers) ? res.mailers : [];

  // Sort by date (newest first), then by town (alphabetically)
  mailers = mailers.sort((a, b) => {
    // Compare dates in descending order (newest first)
    const dateA = a.Mail_Date || '';
    const dateB = b.Mail_Date || '';
    if (dateA !== dateB) {
      return dateB.localeCompare(dateA); // Reverse order for descending
    }
    // If dates are the same, sort by town alphabetically
    const townA = (a.Town || '').toLowerCase();
    const townB = (b.Town || '').toLowerCase();
    return townA.localeCompare(townB);
  });

  state.mailers = mailers;
  const selectHtml = '<option value="">‚Äî Select ‚Äî</option>' +
    mailers.map((m,i)=>{
      // Format date: handle both formatted strings and date objects
      let displayDate = m.Mail_Date || "";

      // Check if it's already in "Month Year" format (like "December 2025")
      const isMonthYearFormat = displayDate && /^[A-Za-z]+ \d{4}$/.test(displayDate);

      if (!isMonthYearFormat && displayDate) {
        // Parse and format the date (handle ISO format YYYY-MM-DD)
        try {
          // If it's ISO format (YYYY-MM-DD), parse it without timezone issues
          if (/^\d{4}-\d{2}-\d{2}/.test(displayDate)) {
            const [year, month] = displayDate.split('-');
            const monthNames = ["", "January", "February", "March", "April", "May", "June",
                                "July", "August", "September", "October", "November", "December"];
            displayDate = `${monthNames[parseInt(month)]} ${year}`;
          } else {
            const date = new Date(displayDate);
            if (!isNaN(date.getTime())) {
              displayDate = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            }
          }
        } catch (e) {
          // Keep original if parsing fails
        }
      }

      const sizeLabel = m.Postcard_Size ? ` (${m.Postcard_Size})` : '';
      return `<option value="${i}">${esc(m.Town)} ‚Äî ${displayDate}${sizeLabel}</option>`;
    }).join("");
  const selManager = document.getElementById("postcardSelect");

  if (selManager) {
    selManager.innerHTML = selectHtml;
    selManager.onchange = pickCampaign;
  }

  // Populate town and month dropdowns
  populateTownAndMonthSelectors();

  renderAll();

  // Determine which postcard to select
  let selectedIndex = -1;

  // If restoring a specific campaign, find it by Mailer_ID
  let mailerIdToRestore = restoreMailerId;

  // If no restoreMailerId provided, check localStorage (for page refresh)
  if (!mailerIdToRestore) {
    const savedMailerId = safeGetItem('mailslot-selectedMailerId');
    if (savedMailerId) {
      mailerIdToRestore = savedMailerId;
      console.log('üìÇ Found saved campaign in localStorage:', savedMailerId);
    }
  }

  if (mailerIdToRestore) {
    console.log('üîç Looking for mailer_id:', mailerIdToRestore, 'type:', typeof mailerIdToRestore);
    console.log('üîç Available mailer_ids:', mailers.map(m => ({id: m.Mailer_ID, type: typeof m.Mailer_ID, town: m.Town})));

    // Try both strict and loose comparison in case of type mismatch
    selectedIndex = mailers.findIndex(m => m.Mailer_ID === mailerIdToRestore || m.Mailer_ID == mailerIdToRestore);

    if (selectedIndex !== -1) {
      console.log('üìå Restoring campaign:', mailers[selectedIndex].Town, mailers[selectedIndex].Mail_Date);
    } else {
      console.warn('‚ö†Ô∏è Could not find campaign with mailer_id:', mailerIdToRestore);
    }
  }

  // If not found or no restore ID, auto-select the most recent postcard (last in array)
  if (selectedIndex === -1 && mailers.length > 0) {
    selectedIndex = mailers.length - 1;
  }

  if (selectedIndex !== -1) {
    if (selManager) selManager.value = selectedIndex.toString();

    // Set town and month selectors to match the selected postcard
    const selected = mailers[selectedIndex];
    const townSelect = document.getElementById("headerTownSelect");
    const monthSelect = document.getElementById("headerMonthSelect");
    if (townSelect && selected.Town) {
      townSelect.value = selected.Town;
      populateMonthsForTown(selected.Town); // Populate month dropdown without triggering events
      if (monthSelect && selected.Mail_Date) monthSelect.value = selected.Mail_Date;
    }

    pickCampaign({ target: { value: selectedIndex.toString() } });
  }

  // Render cards in progress on dashboard
  renderCardsInProgress();

  // Refresh dashboard stats after mailers are loaded
  refreshDashboard();

  // Hide loading overlay - app is now ready
  hideLoadingOverlay();
}

// Populate town selector from available mailers
function populateTownAndMonthSelectors() {
  const townSelect = document.getElementById("headerTownSelect");

  if (!townSelect) return;

  // Get unique towns (sorted alphabetically)
  const towns = [...new Set(state.mailers.map(m => m.Town))].sort();

  // Populate town dropdown
  townSelect.innerHTML = '<option value="">‚Äî Select Town ‚Äî</option>' +
    towns.map(town => `<option value="${esc(town)}">${esc(town)}</option>`).join('');

  // Month dropdown will be populated when town is selected
  const monthSelect = document.getElementById("headerMonthSelect");
  if (monthSelect) {
    monthSelect.innerHTML = '<option value="">‚Äî Select Town First ‚Äî</option>';
    monthSelect.disabled = true;
  }
}

// When town changes, populate month dropdown with only months for that town
function onTownChanged() {
  // Prevent circular updates when syncing dropdowns programmatically
  if (state.updatingSelectors) return;

  const townSelect = document.getElementById("headerTownSelect");
  const monthSelect = document.getElementById("headerMonthSelect");

  if (!townSelect || !monthSelect) return;

  const selectedTown = townSelect.value;

  if (!selectedTown) {
    // No town selected, disable month dropdown
    monthSelect.innerHTML = '<option value="">‚Äî Select Town First ‚Äî</option>';
    monthSelect.disabled = true;
    return;
  }

  // Filter mailers for this town only
  const townMailers = state.mailers.filter(m => m.Town === selectedTown);

  if (townMailers.length === 0) {
    monthSelect.innerHTML = '<option value="">‚Äî No cards for this town ‚Äî</option>';
    monthSelect.disabled = true;
    return;
  }

  // Get months for this town (sorted by date descending - newest first)
  const monthDates = townMailers.map(m => m.Mail_Date).sort((a, b) => b.localeCompare(a));

  // Enable and populate month dropdown
  monthSelect.disabled = false;
  monthSelect.innerHTML = '<option value="">‚Äî Select Month ‚Äî</option>' +
    monthDates.map(date => {
      // Find the mailer for this date to get its size
      const mailer = townMailers.find(m => m.Mail_Date === date);
      let displayDate = date;
      if (/^\d{4}-\d{2}-\d{2}/.test(date)) {
        const [year, month] = date.split('-');
        const monthNames = ["", "January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
        displayDate = `${monthNames[parseInt(month)]} ${year}`;
      }
      // Add size indicator to label
      const sizeLabel = mailer?.Postcard_Size ? ` (${mailer.Postcard_Size})` : '';
      return `<option value="${esc(date)}">${esc(displayDate)}${sizeLabel}</option>`;
    }).join('');

  // If there's only one month for this town, auto-select it
  if (monthDates.length === 1) {
    monthSelect.value = monthDates[0];
    updatePostcardFromSelectors();
  } else {
    // Town changed but no month auto-selected - refresh prospect pool to show prospects for this town
    renderProspectPool();
  }
}

// Update selected postcard when town or month selector changes
function updatePostcardFromSelectors() {
  // Prevent circular updates when syncing dropdowns programmatically
  if (state.updatingSelectors) return;

  const townSelect = document.getElementById("headerTownSelect");
  const monthSelect = document.getElementById("headerMonthSelect");

  if (!townSelect || !monthSelect) return;

  const selectedTown = townSelect.value;
  const selectedMonth = monthSelect.value;

  // If either is not selected, don't do anything
  if (!selectedTown || !selectedMonth) {
    return;
  }

  // Find the postcard that matches both town and month
  const matchingIndex = state.mailers.findIndex(m =>
    m.Town === selectedTown && m.Mail_Date === selectedMonth
  );

  if (matchingIndex !== -1) {
    // Update the manager selector if it exists
    const selManager = document.getElementById("postcardSelect");
    if (selManager) selManager.value = matchingIndex.toString();

    // Select this postcard
    pickCampaign({ target: { value: matchingIndex.toString() } });
  } else {
    toast('No postcard found for this town and month combination', false);
  }
}

/* ========= LEGEND & SORT ========= */
function renderLegend(){
  const grid = document.getElementById("legendGrid");
  if (!grid) return; // Legend moved to Edit Status modal
  grid.innerHTML = "";
  const visibleSorted = sortOrder.filter(st => visibleStatuses.includes(st));
  visibleSorted.forEach(st => {
    const item = document.createElement("div");
    item.className = "legend-item";
    const dot = document.createElement("span");
    dot.className = `legend-dot`;
    dot.style.backgroundColor = STATUS_HEX[st] || GRADIENT_HEX[0];
    const txt = document.createElement("span");
    txt.textContent = st;
    item.appendChild(dot);
    item.appendChild(txt);
    grid.appendChild(item);
  });
  requestAnimationFrame(() => {
    const children = Array.from(grid.children);
    let totalW = 0;
    children.forEach((c) => {
      const r = c.getBoundingClientRect();
      totalW += Math.ceil(r.width);
    });
    const gap = 8 * (children.length - 1);
    const needed = totalW + gap;
    const available = grid.clientWidth;
    if (needed <= available) {
      grid.style.flexWrap = 'nowrap';
    } else {
      grid.style.flexWrap = 'wrap';
    }
  });
}

/* ========= PICK CAMPAIGN ========= */
function pickCampaign(e){
  const i = e.target.value;
  if (!state.mailers[i]) {
    state.current = null;
    state.availability = {};
    state.initial = {};
    state.merged.clear();
    state.selected.clear();
    state.dirty = false;
    renderAll();
    updateFinancialDashboard();
    // Clear localStorage selection
    safeRemoveItem('mailslot-selectedMailerId');
    return;
  }
  const m = state.mailers[i];
  state.current = m;

  // Cross-device sync: Check if board exists and has data
  // If board is empty, try reloading from cloud (handles race conditions and stale IndexedDB)
  const boardCheck = campaignBoardsState.boards[m.Mailer_ID];
  const boardHasData = boardCheck && boardCheck.columns &&
    Object.values(boardCheck.columns).some(col => Array.isArray(col) && col.length > 0);

  if (!boardHasData) {
    console.log(`‚òÅÔ∏è Board for "${m.Town}" (${m.Mailer_ID}) is empty - attempting cloud reload...`);
    // Async reload - re-render when done
    loadCampaignBoards().then(() => {
      const reloaded = campaignBoardsState.boards[m.Mailer_ID];
      const reloadedHasData = reloaded && reloaded.columns &&
        Object.values(reloaded.columns).some(col => Array.isArray(col) && col.length > 0);
      if (reloadedHasData) {
        console.log(`‚úÖ Cloud reload found data for "${m.Town}" - re-rendering`);
        renderKanban();
        refreshContactStatusDashboard();
        refreshAnalytics();
      } else {
        console.log(`‚òÅÔ∏è Cloud reload: no data found for "${m.Town}" (${m.Mailer_ID})`);
        console.log(`‚òÅÔ∏è Available board keys:`, Object.keys(campaignBoardsState.boards));
      }
    }).catch(err => {
      console.error('‚òÅÔ∏è Cloud reload failed:', err);
    });
  }

  // Immediately re-render kanban and dashboards now that we have a Mailer_ID
  renderKanban();
  refreshFollowUpDashboard();
  refreshContactStatusDashboard();
  refreshAnalytics();

  // Save selected campaign to localStorage for page refresh persistence
  if (m.Mailer_ID) {
    safeSetItem('mailslot-selectedMailerId', m.Mailer_ID);
  }
  state.availability = {};
  state.initial = {};
  state.merged.clear();
  state.selected.clear();
  state.dirty = false;
  updateToolbar();

  console.log('üìã LOADING POSTCARD:', {
    Mailer_ID: m.Mailer_ID,
    Town: m.Town,
    Mail_Date: m.Mail_Date,
    spots_sample: {
      Spot_1: m.Spot_1,
      Spot_2: m.Spot_2,
      Spot_3: m.Spot_3
    }
  });

  for (let s=1; s<=18; s++){
    // Get spot data directly from mailer object (comes from sheet columns Spot_1, Spot_2, etc.)
    const raw = m[`Spot_${s}`] || "Available";
    if (/^available$/i.test(raw)) {
      state.availability[`Spot_${s}`] = { name:"", status:"Available" };
      state.initial[`Spot_${s}`] = "";
    } else {
      const m2 = String(raw).match(/^(.+?)\s*:\s*(.*)$/);
      let long = "Proof In Progress", name = "";
      if (m2) { long = m2[1].trim(); name = (m2[2]||"").trim(); }
      state.availability[`Spot_${s}`] = { name, status:long };
      state.initial[`Spot_${s}`] = `${long}:${name}`;
    }
  }

  // Load ad images from cloud storage
  loadAdImagesFromCloud(m.Mailer_ID).then(() => {
    // Re-render after images are loaded
    renderAll();
    // Re-render kanban to switch to Campaign Board now that we have a Mailer_ID
    renderKanban();
  });

  // Load colors: use postcard data if available, otherwise fall back to localStorage
  if (m.Postcard_BG) {
    stagedColors.Postcard_BG = m.Postcard_BG;
    savePostcardBg(m.Postcard_BG);
  } else {
    // Fall back to localStorage
    stagedColors.Postcard_BG = loadPostcardBg();
    m.Postcard_BG = stagedColors.Postcard_BG; // Update postcard data with loaded color
  }
  document.getElementById('pickerPostcard').value = stagedColors.Postcard_BG;

  if (m.Banner_BG) {
    stagedColors.Banner_BG = m.Banner_BG;
    saveBannerBg(m.Banner_BG);
  } else {
    // Fall back to localStorage
    stagedColors.Banner_BG = loadBannerBg();
    m.Banner_BG = stagedColors.Banner_BG; // Update postcard data with loaded color
  }
  document.getElementById('pickerBanner').value = stagedColors.Banner_BG;

  applyStagedColors();
  
  PAIRS.forEach(([a,b])=>{
    const A = (state.availability[`Spot_${a}`].name||"").toLowerCase().trim().replace(/\s+/g,' ');
    const B = (state.availability[`Spot_${b}`].name||"").toLowerCase().trim().replace(/\s+/g,' ');
    if (A && A===B) state.merged.add(keyPair(a,b));
    else state.merged.delete(keyPair(a,b));
  });
  
  show(document.getElementById("legendArea"), true);
  renderAll();
  updateFinancialDashboard();
  checkRenewals();

  // Sync all dropdowns
  const selManager = document.getElementById("postcardSelect");
  const townSelect = document.getElementById("headerTownSelect");
  const monthSelect = document.getElementById("headerMonthSelect");

  if (selManager) selManager.value = i;

  // Update town and month selectors to match current postcard
  // Set flag to prevent circular updates/infinite recursion
  state.updatingSelectors = true;
  try {
    if (townSelect && m.Town) {
      townSelect.value = m.Town;
      // Manually populate month dropdown without triggering events
      populateMonthsForTown(m.Town);
      if (monthSelect && m.Mail_Date) monthSelect.value = m.Mail_Date;
    }
  } finally {
    // Always clear the flag, even if there's an error
    state.updatingSelectors = false;
  }
}

// Helper function to populate months without triggering onchange events
function populateMonthsForTown(town) {
  const monthSelect = document.getElementById("headerMonthSelect");
  if (!monthSelect) return;

  const townMailers = state.mailers.filter(m => m.Town === town);

  if (townMailers.length === 0) {
    monthSelect.innerHTML = '<option value="">‚Äî No cards for this town ‚Äî</option>';
    monthSelect.disabled = true;
    return;
  }

  // Get months for this town (sorted by date descending - newest first)
  const monthDates = townMailers.map(m => m.Mail_Date).sort((a, b) => b.localeCompare(a));

  // Enable and populate month dropdown
  monthSelect.disabled = false;
  monthSelect.innerHTML = '<option value="">‚Äî Select Month ‚Äî</option>' +
    monthDates.map(date => {
      // Find the mailer for this date to get its size
      const mailer = townMailers.find(m => m.Mail_Date === date);
      let displayDate = date;
      if (/^\d{4}-\d{2}-\d{2}/.test(date)) {
        const [year, month] = date.split('-');
        const monthNames = ["", "January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
        displayDate = `${monthNames[parseInt(month)]} ${year}`;
      }
      // Add size indicator to label
      const sizeLabel = mailer?.Postcard_Size ? ` (${mailer.Postcard_Size})` : '';
      return `<option value="${esc(date)}">${esc(displayDate)}${sizeLabel}</option>`;
    }).join('');
}

/* ========= RENDERING ========= */
function renderAll(){
  renderFront();
  renderBack();
  updateToolbar();

  // Apply size-specific CSS class to postcard containers
  const frontPostcard = document.getElementById("frontPostcard");
  const backPostcard = document.getElementById("backPostcard");

  if (frontPostcard && backPostcard) {
    // Remove existing size classes
    frontPostcard.classList.remove('size-9x12', 'size-6x12');
    backPostcard.classList.remove('size-9x12', 'size-6x12');

    // Apply appropriate size class based on Postcard_Size
    const size = state.current?.Postcard_Size || '9x12';
    const sizeClass = size === '6.5x12' ? 'size-6x12' : 'size-9x12';

    frontPostcard.classList.add(sizeClass);
    backPostcard.classList.add(sizeClass);
  }
}

// ========== GETTING STARTED CHECKLIST ==========
// Persistent tracking of completed getting started items
const gettingStartedState = {
  completed: {} // Will be loaded from cloud storage
};

// Load getting started progress from cloud
async function loadGettingStartedProgress() {
  try {
    const cloudData = await loadFromCloud('gettingStartedProgress');
    if (cloudData && cloudData.completed) {
      gettingStartedState.completed = cloudData.completed;
    }
    // Also check localStorage as fallback
    const localData = localStorage.getItem('gettingStartedProgress');
    if (localData) {
      const parsed = JSON.parse(localData);
      // Merge with cloud data (prefer cloud but use local as backup)
      if (parsed && parsed.completed) {
        gettingStartedState.completed = { ...parsed.completed, ...gettingStartedState.completed };
      }
    }
  } catch (e) {
    console.warn('Failed to load getting started progress:', e);
  }
  // Don't render here - let the tab switch handle it after all data is loaded
}

// Mark a getting started item as complete
async function markGettingStartedComplete(itemId) {
  if (gettingStartedState.completed[itemId]) return; // Already completed

  gettingStartedState.completed[itemId] = true;
  console.log(`‚úÖ Getting Started: Completed "${itemId}"`);

  // Save to localStorage immediately
  localStorage.setItem('gettingStartedProgress', JSON.stringify({ completed: gettingStartedState.completed }));

  // Save to cloud (non-blocking)
  saveToCloud('gettingStartedProgress', { completed: gettingStartedState.completed }).catch(e => {
    console.warn('Failed to save getting started progress to cloud:', e);
  });

  // Update the checklist UI
  renderGettingStartedChecklist();
}

function renderGettingStartedChecklist() {
  // Check if user has dismissed it
  if (localStorage.getItem('gettingStartedDismissed') === 'true') {
    const widget = document.getElementById('gettingStartedWidget');
    if (widget) widget.style.display = 'none';
    return;
  }

  const checklist = [
    {
      id: 'create_campaign',
      label: 'Create your first campaign',
      check: () => gettingStartedState.completed['create_campaign'] || (state.mailers && state.mailers.length > 0),
      action: () => switchTab('manager')
    },
    {
      id: 'generate_prospects',
      label: 'Generate prospects with Prospect Generator',
      check: () => gettingStartedState.completed['generate_prospects'] || (placesCache.searches && Object.keys(placesCache.searches).length > 0),
      action: () => switchTab('lead-generation')
    },
    {
      id: 'review_prospects',
      label: 'Review & select prospects from Prospect Pool',
      check: () => gettingStartedState.completed['review_prospects'] ||
        (kanbanState.columns && kanbanState.columns['prospect-list'] && kanbanState.columns['prospect-list'].length > 0),
      action: () => switchTab('clients')
    },
    {
      id: 'add_to_pipeline',
      label: 'Add prospects to your sales pipeline',
      check: () => gettingStartedState.completed['add_to_pipeline'] ||
        (kanbanState.columns && (
          (kanbanState.columns['to-contact'] || []).length > 0 ||
          (kanbanState.columns['in-progress'] || []).length > 0 ||
          (kanbanState.columns['committed'] || []).length > 0
        )),
      action: () => switchTab('pipeline')
    },
    {
      id: 'mark_reserved',
      label: 'Mark your first spot as "Reserved" or "Paid"',
      check: () => {
        if (gettingStartedState.completed['mark_reserved']) return true;
        if (!state.current) return false;
        // Check availability object or direct Spot_N properties
        const availability = state.current.availability || {};
        for (let i = 1; i <= 18; i++) {
          const spotStatus = availability[`Spot_${i}`] || state.current[`Spot_${i}`] || "Available";
          if (typeof spotStatus === 'string') {
            const statusLower = spotStatus.toLowerCase();
            if (statusLower !== "available" && !statusLower.startsWith("available")) {
              return true;
            }
          }
        }
        return false;
      },
      action: () => switchTab('manager')
    }
  ];

  let completed = 0;
  const html = checklist.map(item => {
    const isComplete = item.check();
    if (isComplete) completed++;

    return `
      <div class="flex items-center gap-3 p-3 bg-white rounded-lg border ${isComplete ? 'border-green-300' : 'border-gray-200'} transition-all">
        <div class="flex-shrink-0">
          ${isComplete
            ? '<svg class="w-6 h-6 text-green-600" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>'
            : '<svg class="w-6 h-6 text-gray-300" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>'
          }
        </div>
        <span class="flex-1 text-sm font-medium ${isComplete ? 'text-green-800 line-through' : 'text-gray-700'}">${item.label}</span>
        ${!isComplete ? `<button onclick="event.stopPropagation(); (${item.action.toString()})()" class="px-3 py-1 text-xs font-bold text-indigo-600 hover:bg-indigo-50 rounded transition">Go ‚Üí</button>` : ''}
      </div>
    `;
  }).join('');

  const container = document.getElementById('checklistItems');
  if (container) {
    container.innerHTML = html;
  }

  const progress = document.getElementById('checklistProgress');
  if (progress) {
    progress.textContent = `${completed} of ${checklist.length} complete`;
  }

  // Hide widget if all complete
  if (completed === checklist.length) {
    setTimeout(() => {
      const widget = document.getElementById('gettingStartedWidget');
      if (widget) {
        widget.style.transition = 'opacity 0.5s';
        widget.style.opacity = '0';
        setTimeout(() => {
          widget.style.display = 'none';
        }, 500);
      }
    }, 2000);
  }
}

function dismissGettingStarted() {
  localStorage.setItem('gettingStartedDismissed', 'true');
  const widget = document.getElementById('gettingStartedWidget');
  if (widget) {
    widget.style.transition = 'opacity 0.3s';
    widget.style.opacity = '0';
    setTimeout(() => {
      widget.style.display = 'none';
    }, 300);
  }
}

// ========== DASHBOARD STATS ==========
function renderDashboardStats() {
  // Count unique prospects using deduplication (same logic as renderProspectPool)
  const seenPlaceIds = new Set();
  const seenNames = new Set();

  // Helper to normalize name for dedup
  const normalizeName = (name) => {
    if (!name) return '';
    // First, truncate at common separators (‚Ä¢, |, -, :) to get core business name
    let coreName = name.split(/[‚Ä¢|:\-‚Äì‚Äî]/)[0];
    return coreName.toLowerCase()
      .replace(/['''`¬¥]/g, '')  // Remove all apostrophe variations
      .replace(/&/g, 'and')
      .replace(/[^\w\s]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
  };

  let prospectsCount = 0;

  // Count from manual prospects (enriched)
  if (prospectPoolState && prospectPoolState.manualProspects) {
    prospectPoolState.manualProspects.forEach(p => {
      const name = p.name || p.businessName || p.title || '';
      const normalizedName = normalizeName(name);
      if (p.placeId && !seenPlaceIds.has(p.placeId)) {
        seenPlaceIds.add(p.placeId);
        if (normalizedName) seenNames.add(normalizedName);
        prospectsCount++;
      } else if (!p.placeId && normalizedName && !seenNames.has(normalizedName)) {
        seenNames.add(normalizedName);
        prospectsCount++;
      }
    });
  }

  // Count from places cache (search results) - skip duplicates
  if (placesCache && placesCache.searches) {
    Object.values(placesCache.searches).forEach(cached => {
      if (cached.cachedData && Array.isArray(cached.cachedData)) {
        cached.cachedData.forEach(p => {
          const name = p.name || p.businessName || p.title || '';
          const normalizedName = normalizeName(name);
          if (p.placeId && !seenPlaceIds.has(p.placeId)) {
            // Also check if name already seen (catches duplicates with different placeIds)
            if (!normalizedName || !seenNames.has(normalizedName)) {
              seenPlaceIds.add(p.placeId);
              if (normalizedName) seenNames.add(normalizedName);
              prospectsCount++;
            }
          } else if (!p.placeId && normalizedName && !seenNames.has(normalizedName)) {
            seenNames.add(normalizedName);
            prospectsCount++;
          }
        });
      }
    });
  }

  const statsProspects = document.getElementById('statsProspects');
  if (statsProspects) statsProspects.textContent = prospectsCount;

  // Count active leads in pipeline from Campaign Boards (attempting, negotiating, invoice-sent, proof-approved)
  let leadsCount = 0;
  if (campaignBoardsState && campaignBoardsState.boards) {
    Object.values(campaignBoardsState.boards).forEach(board => {
      if (board && board.columns) {
        leadsCount += (board.columns['attempting'] || []).length;
        leadsCount += (board.columns['negotiating'] || []).length;
        leadsCount += (board.columns['invoice-sent'] || []).length;
        leadsCount += (board.columns['proof-approved'] || []).length;
      }
    });
  }
  const statsLeads = document.getElementById('statsLeads');
  if (statsLeads) statsLeads.textContent = leadsCount;

  // Count total campaigns (all postcards)
  let campaignsCount = 0;
  if (state && state.mailers && Array.isArray(state.mailers)) {
    campaignsCount = state.mailers.length;
  }
  const statsCampaigns = document.getElementById('statsCampaigns');
  if (statsCampaigns) statsCampaigns.textContent = campaignsCount;

  // Count clients (all CRM clients)
  let clientsCount = 0;
  if (crmState && crmState.clients) {
    clientsCount = Object.keys(crmState.clients).length;
  }
  const statsClients = document.getElementById('statsClients');
  if (statsClients) statsClients.textContent = clientsCount;
}

// ========== DASHBOARD TASKS WIDGET ==========
function renderDashboardTasks() {
  const container = document.getElementById('dashboardTaskList');
  const statusEl = document.getElementById('dashboardTaskStatus');
  if (!container) return;

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Filter: hide completed tasks that are overdue
  let visibleTasks = (tasksState.tasks || []).filter(task => {
    if (task.completed) {
      const parts = task.dueDate.split('-');
      const dueDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
      return dueDate >= today;
    }
    return true;
  });

  // Sort by due date and limit to 5
  visibleTasks.sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
  const displayTasks = visibleTasks.slice(0, 5);

  // Update status text
  const incompleteTasks = visibleTasks.filter(t => !t.completed);
  const overdueCount = incompleteTasks.filter(t => {
    const parts = t.dueDate.split('-');
    const dueDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    return dueDate < today;
  }).length;

  if (statusEl) {
    if (overdueCount > 0) {
      statusEl.textContent = `${overdueCount} overdue, ${incompleteTasks.length} total`;
      statusEl.className = 'text-sm text-red-500 font-medium';
    } else if (incompleteTasks.length > 0) {
      statusEl.textContent = `${incompleteTasks.length} pending`;
      statusEl.className = 'text-sm text-gray-500';
    } else {
      statusEl.textContent = 'All complete!';
      statusEl.className = 'text-sm text-green-600';
    }
  }

  if (displayTasks.length === 0) {
    container.innerHTML = '<p class="text-sm text-gray-500 text-center py-4">No tasks. Add one to get started!</p>';
    return;
  }

  container.innerHTML = displayTasks.map(task => {
    const parts = task.dueDate.split('-');
    const dueDate = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
    const isOverdue = dueDate < today && !task.completed;
    const dateStr = dueDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

    return `
      <div class="flex items-center gap-3 p-2 rounded-lg ${task.completed ? 'bg-gray-50 opacity-60' : isOverdue ? 'bg-red-50' : 'bg-gray-50'} hover:bg-gray-100 transition-colors">
        <input type="checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTaskComplete(this)" data-task-id="${task.id}" class="w-4 h-4 rounded border-gray-300 text-green-600 focus:ring-green-500" />
        <span class="flex-1 text-sm ${task.completed ? 'line-through text-gray-400' : 'text-gray-700'} truncate">${esc(task.text)}</span>
        <span class="text-xs ${isOverdue ? 'text-red-600 font-bold' : 'text-gray-400'} whitespace-nowrap">${dateStr}</span>
      </div>
    `;
  }).join('');
}

// ========== DASHBOARD FINANCIAL SUMMARY WIDGET ==========
function renderDashboardFinancials() {
  if (!financialState.loaded || !financialState.transactions) return;

  const now = new Date();
  const currentMonth = now.getMonth();
  const currentYear = now.getFullYear();

  let monthRevenue = 0, monthExpenses = 0;
  let allRevenue = 0, allExpenses = 0;

  financialState.transactions.forEach(trans => {
    const amount = parseFloat(trans.amount) || 0;
    const transDate = new Date(trans.date);

    // All time totals
    if (trans.type === 'revenue') {
      allRevenue += amount;
      if (transDate.getMonth() === currentMonth && transDate.getFullYear() === currentYear) {
        monthRevenue += amount;
      }
    } else if (trans.type === 'cogs' || trans.type === 'operating' || trans.type === 'owner_draw') {
      allExpenses += Math.abs(amount);
      if (transDate.getMonth() === currentMonth && transDate.getFullYear() === currentYear) {
        monthExpenses += Math.abs(amount);
      }
    }
  });

  const monthProfit = monthRevenue - monthExpenses;
  const allProfit = allRevenue - allExpenses;

  // Update DOM elements
  const formatMoney = (val) => '$' + Math.abs(val).toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });

  const updateEl = (id, val, isProfit = false) => {
    const el = document.getElementById(id);
    if (el) {
      el.textContent = (isProfit && val < 0 ? '-' : '') + formatMoney(val);
      if (isProfit) {
        el.className = el.className.replace(/text-(green|red|blue)-600/g, '') + (val >= 0 ? ' text-blue-600' : ' text-red-600');
      }
    }
  };

  updateEl('dashboardRevenueMonth', monthRevenue);
  updateEl('dashboardExpensesMonth', monthExpenses);
  updateEl('dashboardProfitMonth', monthProfit, true);
  updateEl('dashboardRevenueAll', allRevenue);
  updateEl('dashboardExpensesAll', allExpenses);
  updateEl('dashboardProfitAll', allProfit, true);
}

// Refresh all dashboard widgets
function refreshDashboard() {
  renderDashboardStats();
  renderGettingStartedChecklist();
  renderContractsExpiring();
  renderDashboardTasks();
  renderDashboardFinancials();
  checkRenewals(); // Update renewal widget on dashboard
}

// ========== CONTRACTS EXPIRING WIDGET ==========
function renderContractsExpiring() {
  const container = document.getElementById('contractsExpiringList');
  if (!container) return;

  // Check if crmState exists and has clients
  if (!crmState || !crmState.clients) {
    container.innerHTML = `
      <div class="text-center py-6 text-gray-500">
        <p class="text-sm">Loading clients...</p>
      </div>
    `;
    return;
  }

  // Get all clients with active contracts
  const allClients = Object.values(crmState.clients);
  const clientsWithContracts = allClients.filter(client => {
    return client.contractEnabled && client.contractStartDate && client.contractLength;
  });

  // Calculate expiration dates and filter for next 90 days
  const now = new Date();
  const ninetyDaysFromNow = new Date(now.getTime() + (90 * 24 * 60 * 60 * 1000));

  const expiringContracts = clientsWithContracts
    .map(client => {
      const startDate = new Date(client.contractStartDate);
      const endDate = new Date(startDate);
      endDate.setMonth(endDate.getMonth() + parseInt(client.contractLength));

      const daysUntilExpiry = Math.ceil((endDate - now) / (1000 * 60 * 60 * 24));

      return {
        client,
        endDate,
        daysUntilExpiry
      };
    })
    .filter(item => item.daysUntilExpiry >= 0 && item.daysUntilExpiry <= 90)
    .sort((a, b) => a.daysUntilExpiry - b.daysUntilExpiry);

  if (expiringContracts.length === 0) {
    container.innerHTML = `
      <div class="text-center py-6 text-gray-500">
        <svg class="w-12 h-12 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>
        <p class="text-sm font-medium">No contracts expiring soon</p>
        <p class="text-xs text-gray-400 mt-1">You're all set for the next 90 days!</p>
      </div>
    `;
    return;
  }

  const html = expiringContracts.slice(0, 5).map(item => {
    const urgency = item.daysUntilExpiry <= 7 ? 'urgent' : item.daysUntilExpiry <= 30 ? 'warning' : 'normal';
    const colorClass = urgency === 'urgent' ? 'border-red-300 bg-red-50' : urgency === 'warning' ? 'border-amber-300 bg-amber-50' : 'border-gray-200 bg-white';
    const textColor = urgency === 'urgent' ? 'text-red-700' : urgency === 'warning' ? 'text-amber-700' : 'text-gray-700';

    return `
      <div class="flex items-center justify-between p-3 border rounded-lg ${colorClass} transition-all hover:shadow-md">
        <div class="flex-1">
          <p class="font-bold text-sm ${textColor}">${item.client.name}</p>
          <p class="text-xs text-gray-600">Expires ${item.endDate.toLocaleDateString()}</p>
        </div>
        <div class="text-right">
          <p class="text-lg font-black ${textColor}">${item.daysUntilExpiry}</p>
          <p class="text-xs text-gray-500">${item.daysUntilExpiry === 1 ? 'day' : 'days'}</p>
        </div>
      </div>
    `;
  }).join('');

  container.innerHTML = html;

  if (expiringContracts.length > 5) {
    container.innerHTML += `
      <div class="text-center pt-2">
        <button onclick="switchTab('clients')" class="text-sm text-indigo-600 hover:text-indigo-800 font-semibold">
          View all ${expiringContracts.length} contracts ‚Üí
        </button>
      </div>
    `;
  }
}

function renderCardsInProgress() {
  const container = document.getElementById('cardsInProgressSection');
  if (!container) {
    console.warn('cardsInProgressSection container not found');
    return;
  }

  console.log('Rendering cards in progress. Total mailers:', state.mailers.length);


  // Filter postcards that are "in progress" (not fully sold - includes 0 spots sold)
  const inProgressCards = state.mailers.filter(campaign => {
    const financials = calculateFinancials(campaign.Mailer_ID, campaign);
    if (!financials) {
      console.log('No financials for', campaign.Town, campaign.Mail_Date);
      return false;
    }
    const spotsSold = financials.metrics.spotsSold;
    const totalSpots = financials.metrics.effectiveTotalSpots;
    console.log(`${campaign.Town}: ${spotsSold}/${totalSpots} spots`);
    return spotsSold >= 0 && spotsSold < totalSpots;
  });

  console.log('Cards in progress:', inProgressCards.length);

  if (inProgressCards.length === 0) {
    container.innerHTML = '';
    return;
  }

  // Sort by date (soonest/earliest date first)
  inProgressCards.sort((a, b) => {
    const dateA = a.Mail_Date || '';
    const dateB = b.Mail_Date || '';
    return dateA.localeCompare(dateB); // Ascending order (earliest first)
  });

  // Build HTML
  let html = `
    <div class="mb-4">
      <h4 class="text-lg font-bold text-gray-800">You have ${inProgressCards.length} Card${inProgressCards.length !== 1 ? 's' : ''} in Progress</h4>
    </div>
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
  `;

  inProgressCards.forEach(campaign => {
    const financials = calculateFinancials(campaign.Mailer_ID, campaign);
    if (!financials) return;

    const spotsSold = financials.metrics.spotsSold;
    const totalSpots = financials.metrics.effectiveTotalSpots;
    const percent = Math.round(financials.metrics.progressPercent);

    // Extract month name from Mail_Date
    let monthName = campaign.Mail_Date;
    try {
      if (/^\d{4}-\d{2}-\d{2}/.test(campaign.Mail_Date)) {
        const month = parseInt(campaign.Mail_Date.split('-')[1]);
        const monthNames = ["", "January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
        monthName = monthNames[month] || campaign.Mail_Date;
      }
    } catch (e) {
      // Keep original if parsing fails
    }

    html += `
      <div class="bg-white rounded-xl cursor-pointer hover:shadow-xl transition-all duration-200 border border-gray-200 p-5"
           onclick="openPostcardCard('${campaign.Town.replace(/'/g, "\\'")}', '${campaign.Mail_Date}')"
           style="box-shadow: 0 2px 8px rgba(0,0,0,0.06);">
        <div class="text-sm font-bold text-blue-700 uppercase tracking-wide mb-1">${campaign.Town}</div>
        <div class="text-xs text-gray-500 mb-3">${monthName}</div>
        <div class="text-2xl font-bold text-gray-900 mb-1">${spotsSold}<span class="text-gray-400">/${totalSpots}</span></div>
        <div class="text-xs text-gray-500 mb-3">${percent}% complete</div>
        <div class="w-full h-1.5 bg-gray-100 rounded-full overflow-hidden">
          <div class="h-full bg-gradient-to-r from-blue-500 to-blue-400 rounded-full transition-all duration-300" style="width: ${percent}%;"></div>
        </div>
      </div>
    `;
  });

  html += '</div>';
  container.innerHTML = html;
}

function openPostcardCard(town, mailDate) {
  // Set the selectors to the correct town and month
  const townSelect = document.getElementById("headerTownSelect");
  const monthSelect = document.getElementById("headerMonthSelect");

  if (townSelect && monthSelect) {
    townSelect.value = town;
    monthSelect.value = mailDate;
  }

  // Switch to the manager (Postcards & Activation) tab
  switchTab('manager');

  // Update the postcard view
  updatePostcardFromSelectors();
}

function renderFront(){
  const grid = document.getElementById("frontGrid");
  grid.innerHTML = "";
  if (!state.current) {
    renderPlaceholderFront(grid);
    return;
  }
  renderRow(grid,1,4);
  const banner = document.createElement("div");
  banner.className = "card col-span-4 banner";
  const town = state.current?.Town || "";
  const md = state.current?.Mail_Date || "";

  // Extract month name from mail date (e.g., "2025-12-01" -> "December")
  // Parse ISO format without timezone issues
  let monthName = "";
  if (md) {
    try {
      if (/^\d{4}-\d{2}-\d{2}/.test(md)) {
        // ISO format: extract month directly from string to avoid timezone issues
        const month = parseInt(md.split('-')[1]);
        const monthNames = ["", "January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
        monthName = monthNames[month] || "";
      } else {
        const date = new Date(md);
        monthName = date.toLocaleString('en-US', { month: 'long' });
      }
    } catch (e) {
      monthName = "";
    }
  }

  // Show just town and month (e.g., "KENMORE ‚Äî December")
  const fullText = monthName ? `${town.toUpperCase()} ‚Äî ${monthName.toUpperCase()}` : town.toUpperCase();
  const span = document.createElement('span');
  span.className = 'banner-text';
  span.textContent = fullText;
  span.setAttribute('aria-label', fullText);
  span.setAttribute('title', fullText); // Tooltip for overflow text

  // Apply banner colors directly
  banner.style.backgroundColor = stagedColors.Banner_BG || '#000000';
  banner.style.color = useLightTextOn(stagedColors.Banner_BG || '#000000') ? '#ffffff' : '#0f172a';
  const border = shadeBlend(stagedColors.Banner_BG || '#000000', -0.12) || '#e5e7eb';
  banner.style.borderColor = border;

  banner.appendChild(span);
  grid.appendChild(banner);
  renderRow(grid,5,8);
}

function renderBack(){
  const grid = document.getElementById("backGrid");
  grid.innerHTML = "";
  if (!state.current) {
    renderPlaceholderBack(grid);
    return;
  }
  renderRow(grid,9,12);
  // Check if spots 13-14 are merged OR both selected
  const bothSelected = state.selected.has(13) && state.selected.has(14);
  if (state.merged.has(keyPair(13,14)) || bothSelected) {
    const A = state.availability["Spot_13"], B = state.availability["Spot_14"];
    const name = A.name || B.name || "Merged Banner";
    const st = A.name ? A.status : (B.name ? B.status : "Available");
    const mergedEl = cardButtonSafe({label:"Spots 13‚Äì14", name, status:st, span4:true, selected:isSel([13,14]), spots:[13,14]});
    mergedEl.addEventListener("click", ()=>toggle([13,14],"back"));
    grid.appendChild(mergedEl);
  } else {
    const sp13 = cardButtonSafe({label:"Spot 13", name:(state.availability["Spot_13"]?.name || "Available"), status: (state.availability["Spot_13"]?.status || "Available"), span2:true, selected: state.selected.has(13), spots:[13]});
    sp13.addEventListener("click", ()=>toggle([13],"back"));
    grid.appendChild(sp13);
    const sp14 = cardButtonSafe({label:"Spot 14", name:(state.availability["Spot_14"]?.name || "Available"), status: (state.availability["Spot_14"]?.status || "Available"), span2:true, selected: state.selected.has(14), spots:[14]});
    sp14.addEventListener("click", ()=>toggle([14],"back"));
    grid.appendChild(sp14);
  }
  renderRow(grid,15,18,"back");
}

function renderRow(grid, a, b, side="front"){
  for (let i=a; i<=b; i+=2){
    // Check if spots are merged OR both selected
    const bothSelected = state.selected.has(i) && state.selected.has(i+1);
    if (state.merged.has(keyPair(i,i+1)) || bothSelected){
      const A = state.availability[`Spot_${i}`], B = state.availability[`Spot_${i+1}`];
      const name = A.name || B.name || "Merged Ad";
      const st = A.name ? A.status : (B.name ? B.status : "Available");
      const btn = cardButtonSafe({label:`Spots ${i}-${i+1}`, name, status:st, span2:true, selected:isSel([i,i+1]), spots:[i,i+1]});
      btn.addEventListener("click", ()=>toggle([i,i+1], side));
      grid.appendChild(btn);
    } else {
      grid.appendChild(single(i,false,side));
      grid.appendChild(single(i+1,false,side));
    }
  }
}

function single(i, span2=false, side="front"){
  const s = state.availability[`Spot_${i}`] || { name:"", status:"Available" };
  const btn = cardButtonSafe({label:`Spot ${i}`, name:(s.name || "Available"), status:s.status, span2, selected:state.selected.has(i), spots:[i]});
  btn.addEventListener("click", ()=>toggle([i], side));
  return btn;
}

function createTextNodeTag(tagName, text, className) {
  const el = document.createElement(tagName);
  if (className) el.className = className;
  el.textContent = text;
  return el;
}

function cardButtonSafe({label,name,status,selected=false,span2=false,span4=false,spots=[]}){
  const el = document.createElement("button");
  el.type = "button";
  const span = span4 ? "col-span-4" : (span2 ? "col-span-2" : "");
  const longStatus = normalizeStatusLong(status);
  el.className = `card ${span} ${selected ? "selected" : ""}`;
  el.style.backgroundColor = STATUS_HEX[longStatus] || GRADIENT_HEX[0];
  el.style.borderColor = shadeBlend(STATUS_HEX[longStatus] || GRADIENT_HEX[0], -0.2) || '#f59e0b';
  el.style.color = useLightTextOn(STATUS_HEX[longStatus] || GRADIENT_HEX[0]) ? 'white' : '#0f172a';
  el.setAttribute("aria-pressed", selected ? "true" : "false");
  el.tabIndex = 0;
  const match = label.match(/\d+/);
  if (match) el.dataset.spot = match[0];
  
  const labelEl = createTextNodeTag('div', label, 'spot-label');
  const nameEl = createTextNodeTag('div', name);
  const badge = createTextNodeTag('div', longStatus, 'status-badge');
  badge.style.backgroundColor = shadeBlend(STATUS_HEX[longStatus] || GRADIENT_HEX[0], 0.1) || 'rgba(255,255,255,.96)';
  
  el.appendChild(labelEl);
  el.appendChild(nameEl);
  el.appendChild(badge);
  
  // Add price badge if spot is sold and has a price
  if (state.current && spots.length > 0 && longStatus !== "Available") {
    const spotNum = spots[0];
    const priceKey = normalizePriceKey(state.current.Mailer_ID, spotNum);
    const customSpotPrice = productionState.spotPricing[priceKey];
    const pricing = productionState.pricing[state.current.Mailer_ID];

    // Use same 3-step pricing logic as calculateFinancials
    let price;
    if (customSpotPrice !== undefined && customSpotPrice !== null && customSpotPrice > 0) {
      // 1. Custom spot price (manually set)
      price = parseFloat(customSpotPrice);
    } else if (pricing) {
      // 2. Set Pricing (singleAd/doubleAd/bannerAd)
      const isMerged = spots.length > 1;
      if (isMerged) {
        price = parseFloat(pricing.doubleAd) || DEFAULT_SPOT_PRICE;
      } else {
        price = parseFloat(pricing.singleAd) || DEFAULT_SPOT_PRICE;
      }
    } else {
      // 3. Fallback default
      price = DEFAULT_SPOT_PRICE;
    }

    const priceBadge = createTextNodeTag('div', formatCurrency(price), 'price-badge');
    el.appendChild(priceBadge);

    // Add camera icon badge if this spot has an ad image
    const spotKey = `Spot_${spotNum}`;
    if (state.availability[spotKey]?.adImage) {
      const cameraBadge = createTextNodeTag('div', 'üì∑', 'camera-badge');
      cameraBadge.style.cssText = 'position: absolute; top: 6px; right: 8px; font-size: 0.9rem; background: rgba(59, 130, 246, 0.9); color: white; padding: 2px 6px; border-radius: 4px; font-weight: bold;';
      cameraBadge.title = 'Has ad image';
      el.appendChild(cameraBadge);
    }
  }
  
  // Add ad image if it exists (for non-Available spots)
  if (longStatus !== "Available" && spots.length > 0) {
    const spotNum = spots[0];
    const spotKey = `Spot_${spotNum}`;
    const adImage = state.availability[spotKey]?.adImage;

    if (adImage) {
      const imgContainer = document.createElement('div');
      imgContainer.className = 'ad-image-preview';
      imgContainer.style.cssText = 'position: absolute; top: 35px; left: 8px; right: 8px; bottom: 35px; background-size: cover; background-position: center; background-repeat: no-repeat; border-radius: 6px; opacity: 0.9;';
      imgContainer.style.backgroundImage = `url(${adImage})`;
      imgContainer.title = 'Click to view full size';
      imgContainer.onclick = (e) => {
        e.stopPropagation();
        viewAdImage(adImage, name);
      };
      el.appendChild(imgContainer);
    }
  }

  // Add overlay edit button if selected
  // When multiple spots are selected, only show button on the first (lowest numbered) spot
  if (selected) {
    const showButton = state.selected.size === 1 ||
                      (spots.length > 0 && spots[0] === Math.min(...Array.from(state.selected)));

    if (showButton) {
      const overlay = document.createElement('div');
      overlay.className = 'card-edit-overlay';
      const editBtn = document.createElement('button');
      // Show "EDIT SPOT" (singular) when multiple spots selected, "Edit Spot" otherwise
      editBtn.textContent = state.selected.size > 1 ? '‚úé EDIT SPOT' : '‚úé Edit Spot';
      editBtn.onclick = (e) => {
        e.stopPropagation();
        openEditModal();
      };
      overlay.appendChild(editBtn);
      el.appendChild(overlay);
    }
  }
  
  el.addEventListener('keydown', (e) => {
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      el.click();
    }
  });
  return el;
}

function normalizeStatusLong(s) {
  if (!s) return "Available";
  const up = String(s).trim();
  const map = {
    "RESERVED": "Reserved",
    "INVOICE": "Invoice Sent",
    "DEPOSIT": "Deposit Paid",
    "PROOF": "Proof In Progress",
    "APPROVED": "Ad Approved",
    "PAID": "Paid in Full",
    "AVAIL": "Available"
  };
  if (map[up.toUpperCase()]) return map[up.toUpperCase()];
  for (const k of CANONICAL_STATUSES) {
    if (k.toLowerCase() === up.toLowerCase()) return k;
  }
  return up;
}

function renderPlaceholderFront(grid){
  for (let i=1;i<=4;i++){
    const el = createPlaceholderCard(`Spot ${i}`);
    grid.appendChild(el);
  }
  const banner = document.createElement("div");
  banner.className = "card col-span-4 banner placeholder";
  banner.innerHTML = '<div class="banner-text" aria-label="TOWN ‚Äî MONTH" title="TOWN ‚Äî MONTH">TOWN ‚Äî MONTH</div>';
  banner.style.backgroundColor = '#000000';
  banner.style.color = '#ffffff';
  banner.style.borderColor = '#000000';
  grid.appendChild(banner);
  for (let i=5;i<=8;i++){
    const el = createPlaceholderCard(`Spot ${i}`);
    grid.appendChild(el);
  }
}

function renderPlaceholderBack(grid){
  for (let i=9;i<=12;i++){
    const el = createPlaceholderCard(`Spot ${i}`);
    grid.appendChild(el);
  }
  const p13 = createPlaceholderCard('Spot 13');
  p13.classList.add('col-span-2');
  grid.appendChild(p13);
  const p14 = createPlaceholderCard('Spot 14');
  p14.classList.add('col-span-2');
  grid.appendChild(p14);
  for (let i=15;i<=18;i++){
    const el = createPlaceholderCard(`Spot ${i}`);
    grid.appendChild(el);
  }
}

function createPlaceholderCard(label, hidden=false, isSpan2=false){
  const el = document.createElement("div");
  el.className = "card placeholder";
  if (isSpan2) el.classList.add('col-span-2');
  el.style.justifyContent = "center";
  if (hidden){
    el.style.visibility = 'hidden';
  } else {
    const lbl = document.createElement("div");
    lbl.textContent = label;
    el.appendChild(lbl);
  }
  return el;
}

/* ========= SELECTION / TOOLBAR ========= */
function toggle(spots, sideHint="front"){
  spots.forEach(n => { state.selected.has(n) ? state.selected.delete(n) : state.selected.add(n); });
  if (state.selected.size > 2){
    const last = spots[spots.length-1];
    const others = [...state.selected].filter(x => x !== last);
    const mate = others.find(o => isValidPair(o,last));
    state.selected.clear();
    if (mate){ state.selected.add(mate); state.selected.add(last); }
    else { state.selected.add(last); toast("Pick a valid pair", false); }
  }
  if (state.selected.size === 2){
    const [a,b] = [...state.selected].sort((x,y)=>x-y);
    if (!isValidPair(a,b)){
      const last = spots[spots.length-1];
      state.selected.clear();
      state.selected.add(last);
      toast("Pick a valid pair", false);
    }
  }
  renderAll();
}

function isSel(arr){ return arr.every(n => state.selected.has(n)); }

function updateToolbar(){
  const saveBtn = document.getElementById("btnSaveCommit");
  if (saveBtn) {
    if (state.dirty){
      saveBtn.disabled = false;
      saveBtn.classList.remove("opacity-50","cursor-not-allowed");
    } else {
      saveBtn.disabled = true;
      saveBtn.classList.add("opacity-50","cursor-not-allowed");
    }
  }
}

/* ========= MODAL & APPLY ========= */
function openEditModal(){
  if (!state.selected.size) return;

  lastFocusedElementBeforeModal = document.activeElement;
  const sel = [...state.selected].sort((a,b)=>a-b);

  // Populate client dropdown
  populateClientDropdown();

  // Get pricing for this postcard (new system)
  const mailerId = state.current.Mailer_ID;
  const pricing = productionState.pricing[mailerId] || null;

  if (sel.length === 1){
    const s = state.availability[`Spot_${sel[0]}`] || {name:"", status:"Available"};
    document.getElementById("editName").value = s.name || "";
    document.getElementById("editStatus").value = toShortKey(s.status);

    // Use new pricing system or fall back to old spot pricing
    const priceKey = normalizePriceKey(mailerId, sel[0]);
    const oldPrice = productionState.spotPricing[priceKey];
    if (oldPrice) {
      document.getElementById("editPrice").value = oldPrice;
    } else if (pricing && pricing.singleAd) {
      document.getElementById("editPrice").value = pricing.singleAd;
    } else {
      document.getElementById("editPrice").value = ""; // Empty instead of $500 default
    }
  } else {
    const [a,b] = sel;
    const A = state.availability[`Spot_${a}`] || {name:"", status:"Available"}, B = state.availability[`Spot_${b}`] || {name:"", status:"Available"};
    const nm = (A.name && B.name && A.name.toLowerCase()===B.name.toLowerCase()) ? A.name : (A.name || B.name || "");
    const st = nm ? (A.status!=="Available" ? A.status : (B.status!=="Available"?B.status:"Proof In Progress")) : "Available";
    document.getElementById("editName").value = nm;
    document.getElementById("editStatus").value = toShortKey(st);

    // Use new pricing system for double ad or fall back to old spot pricing
    const priceKey = normalizePriceKey(mailerId, a);
    const oldPrice = productionState.spotPricing[priceKey];
    if (oldPrice) {
      document.getElementById("editPrice").value = oldPrice;
    } else if (pricing && pricing.doubleAd) {
      document.getElementById("editPrice").value = pricing.doubleAd;
    } else {
      document.getElementById("editPrice").value = ""; // Empty instead of $500 default
    }
  }

  // Show/hide image preview based on whether spot has an ad image
  const firstSpot = sel[0];
  const spotKey = `Spot_${firstSpot}`;
  const adImage = state.availability[spotKey]?.adImage;

  const imagePreview = document.getElementById('editImagePreview');
  const imageThumb = document.getElementById('editImageThumb');
  const uploadBtn = document.getElementById('btnUploadAdImage');
  const removeBtn = document.getElementById('btnRemoveAdImage');

  if (adImage) {
    // Show preview and remove button
    imageThumb.src = adImage;
    imagePreview.classList.remove('hidden');
    uploadBtn.textContent = 'üì∑ Change Ad Image';
    removeBtn.classList.remove('hidden');
  } else {
    // Hide preview and remove button
    imagePreview.classList.add('hidden');
    uploadBtn.textContent = 'üì∑ Upload Ad Image';
    removeBtn.classList.add('hidden');
  }

  const modal = document.getElementById("editModal");
  modal.style.display = "flex";
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);
  document.getElementById("editName").focus();
}

// New function to handle save from BusinessModal
async function applyEditModalWithData(data, selectedSpots) {
  const name = String(data.name || "").replace(/\s+/g,' ').trim();
  const short = data.status;
  let long = toLongLabel(short);
  const price = parseFloat(data.price) || DEFAULT_SPOT_PRICE;
  const selectedClientId = data.linkedClientId;

  // Auto-change status from Available to Reserved when name is entered
  if (name && long === "Available") {
    long = "Reserved";
  }

  const sel = selectedSpots.sort((a,b)=>a-b);

  sel.forEach(spotNum => {
    state.availability[`Spot_${spotNum}`] = { name, status: long };

    // Store price in new pricing system
    const mailerId = state.current.Mailer_ID;
    const priceKey = normalizePriceKey(mailerId, spotNum);
    productionState.spotPricing[priceKey] = price;

    // Link to client if selected
    if (selectedClientId) {
      state.availability[`Spot_${spotNum}`].linkedClientId = selectedClientId;
    }
  });

  await triggerSave();
  renderGrid();
}

function trapModalFocus(modalEl) {
  const dialog = modalEl.querySelector('.modal');
  if (!dialog) return;
  const focusable = dialog.querySelectorAll('a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])');
  if (focusable.length === 0) return;
  const first = focusable[0], last = focusable[focusable.length - 1];
  function onKey(e) {
    if (e.key === 'Escape') {
      if (modalEl.id === 'editModal') closeEditModal();
      else if (modalEl.id === 'postcardModal') closePostcardModal();
      else if (modalEl.id === 'sortModal') closeSortModal();
      else if (modalEl.id === 'expenseModal') closeExpenseModal();
      else if (modalEl.id === 'clientModal') closeClientModal();
      else if (modalEl.id === 'emailModal') closeEmailModal();
      else if (modalEl.id === 'reportsModal') closeReportsModal();
      return;
    }
    if (e.key === 'Tab') {
      if (e.shiftKey && document.activeElement === first) {
        e.preventDefault(); last.focus();
      } else if (!e.shiftKey && document.activeElement === last) {
        e.preventDefault(); first.focus();
      }
    }
  }
  modalEl.__trap = onKey;
  modalEl.addEventListener('keydown', onKey);
}

function releaseModalFocus(modalEl) {
  if (!modalEl) return;
  if (modalEl.__trap) {
    modalEl.removeEventListener('keydown', modalEl.__trap);
    delete modalEl.__trap;
  }
}

function closeEditModal(){
  const modal = document.getElementById("editModal");
  modal.style.display = "none";
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
  if (lastFocusedElementBeforeModal && typeof lastFocusedElementBeforeModal.focus === 'function') {
    lastFocusedElementBeforeModal.focus();
  }
}

async function applyEditModal(){
  const nameRaw = document.getElementById("editName").value;
  const name = String(nameRaw || "").replace(/\s+/g,' ').trim();
  const short = document.getElementById("editStatus").value;
  let long = toLongLabel(short);
  const price = parseFloat(document.getElementById("editPrice").value) || DEFAULT_SPOT_PRICE;
  const selectedClientId = document.getElementById('editClient').value;

  // Auto-change status from Available to Reserved when name is entered
  if (name && long === "Available") {
    long = "Reserved";
  }

  const sel = [...state.selected].sort((a,b)=>a-b);

  sel.forEach(spotNum => {
    const priceKey = normalizePriceKey(state.current.Mailer_ID, spotNum);
    productionState.spotPricing[priceKey] = price;
  });

  // Save spot pricing to cloud (also saves to localStorage as backup)
  await saveSpotPricing();
  
  if (sel.length === 2){
    const [a,b] = sel;
    if (name){
      state.merged.add(keyPair(a,b));
      state.availability[`Spot_${a}`] = { name, status: long };
      state.availability[`Spot_${b}`] = { name, status: long };
    } else {
      state.merged.delete(keyPair(a,b));
      state.availability[`Spot_${a}`] = { name:"", status:"Available" };
      state.availability[`Spot_${b}`] = { name:"", status:"Available" };
    }
  } else if (sel.length === 1){
    const a = sel[0];
    const m = mateOf(a);
    if (name){
      state.availability[`Spot_${a}`] = { name, status: long };
      if (m && state.merged.has(keyPair(a,m))){
        state.merged.delete(keyPair(a,m));
        state.availability[`Spot_${m}`] = { name:"", status:"Available" };
      }
    } else {
      state.availability[`Spot_${a}`] = { name:"", status:"Available" };
      if (m && state.merged.has(keyPair(a,m))){
        state.merged.delete(keyPair(a,m));
        state.availability[`Spot_${m}`] = { name:"", status:"Available" };
      }
    }
  }
  
  // Link client if selected and status is Paid in Full
  if (selectedClientId && state.current && name && long === "Paid in Full") {
    const spotNum = sel[0];
    linkClientToSpot(
      selectedClientId,
      spotNum,
      `${state.current.Town} ‚Äî ${state.current.Mail_Date}`,
      price,
      long
    );
    renderClientList();
  }

  state.dirty = true;

  // Clear selection immediately after save
  state.selected.clear();

  closeEditModal();
  renderAll();
  updateFinancialDashboard();

  // Save immediately to database (no delay)
  saveToSheet();
}

// Upload Ad Image for a spot
function uploadAdImage(spotNum) {
  // Create file input
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.style.display = 'none';

  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      toast('‚ö†Ô∏è Image too large. Please use an image under 5MB.', false);
      return;
    }

    // Show loading toast
    toast('üì§ Uploading image...', true);

    try {
      // Convert to base64 for storage
      const reader = new FileReader();
      reader.onload = async (event) => {
        const base64Image = event.target.result;

        // Store in state.availability
        const spotKey = `Spot_${spotNum}`;
        if (!state.availability[spotKey]) {
          state.availability[spotKey] = { name: "", status: "Available" };
        }
        state.availability[spotKey].adImage = base64Image;

        // Save ad images to cloud separately (they don't go in spot columns)
        await saveAdImagesToCloud();

        // Re-render to show image
        renderAll();
        toast('‚úÖ Ad image uploaded successfully!', true);
      };

      reader.onerror = () => {
        toast('‚ùå Failed to read image file', false);
      };

      reader.readAsDataURL(file);
    } catch (error) {
      console.error('Error uploading ad image:', error);
      toast('‚ùå Failed to upload image', false);
    }
  };

  // Trigger file picker
  document.body.appendChild(input);
  input.click();
  document.body.removeChild(input);
}

// Save ad images to cloud storage
async function saveAdImagesToCloud() {
  if (!state.current) return;

  const adImages = {};
  const mailerId = state.current.Mailer_ID;

  // Collect all ad images for this campaign
  for (let i = 1; i <= 18; i++) {
    const spotKey = `Spot_${i}`;
    const adImage = state.availability[spotKey]?.adImage;
    if (adImage) {
      adImages[spotKey] = adImage;
    }
  }

  // Save to cloud with mailer-specific key
  const storageKey = `adImages_${mailerId}`;
  try {
    await saveToCloud(storageKey, adImages);
    console.log(`‚úÖ Saved ${Object.keys(adImages).length} ad images for ${mailerId}`);
  } catch (error) {
    console.error('Failed to save ad images to cloud:', error);
    toast('‚ö†Ô∏è Ad image saved locally but cloud sync failed', false);
  }
}

// Load ad images from cloud storage
async function loadAdImagesFromCloud(mailerId) {
  if (!mailerId) return;

  const storageKey = `adImages_${mailerId}`;
  try {
    const adImages = await loadFromCloud(storageKey);
    if (adImages && typeof adImages === 'object') {
      // Restore ad images to state.availability
      Object.keys(adImages).forEach(spotKey => {
        if (!state.availability[spotKey]) {
          state.availability[spotKey] = { name: "", status: "Available" };
        }
        state.availability[spotKey].adImage = adImages[spotKey];
      });
      console.log(`‚úÖ Loaded ${Object.keys(adImages).length} ad images for ${mailerId}`);
    }
  } catch (error) {
    console.log(`‚ÑπÔ∏è No ad images found for ${mailerId} (this is normal for campaigns without ads)`);
  }
}

// Remove ad image from a spot
async function removeAdImage(spotNum) {
  const spotKey = `Spot_${spotNum}`;
  const businessName = state.availability[spotKey]?.name || `Spot ${spotNum}`;

  if (!confirm(`Remove ad image for "${businessName}"?`)) {
    return;
  }

  // Remove from state
  if (state.availability[spotKey]) {
    delete state.availability[spotKey].adImage;
  }

  // Save to cloud
  toast('üóëÔ∏è Removing ad image...', true);
  await saveAdImagesToCloud();

  // Re-render to show change
  renderAll();
  toast('‚úÖ Ad image removed', true);
}

// Upload ad image from the Edit Modal
function uploadAdImageFromModal() {
  const sel = [...state.selected].sort((a,b)=>a-b);
  if (!sel.length) return;

  const spotNum = sel[0];

  // Create file input
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'image/*';
  input.style.display = 'none';

  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      toast('‚ö†Ô∏è Image too large. Please use an image under 5MB.', false);
      return;
    }

    // Show loading toast
    toast('üì§ Uploading image...', true);

    try {
      // Convert to base64 for storage
      const reader = new FileReader();
      reader.onload = async (event) => {
        const base64Image = event.target.result;

        // Store in state.availability
        const spotKey = `Spot_${spotNum}`;
        if (!state.availability[spotKey]) {
          state.availability[spotKey] = { name: "", status: "Available" };
        }
        state.availability[spotKey].adImage = base64Image;

        // Update modal preview
        const imagePreview = document.getElementById('editImagePreview');
        const imageThumb = document.getElementById('editImageThumb');
        const uploadBtn = document.getElementById('btnUploadAdImage');
        const removeBtn = document.getElementById('btnRemoveAdImage');

        imageThumb.src = base64Image;
        imagePreview.classList.remove('hidden');
        uploadBtn.textContent = 'üì∑ Change Ad Image';
        removeBtn.classList.remove('hidden');

        // Save ad images to cloud separately (they don't go in spot columns)
        await saveAdImagesToCloud();

        // Re-render cards to show image
        renderAll();
        toast('‚úÖ Ad image uploaded successfully!', true);
      };

      reader.onerror = () => {
        toast('‚ùå Failed to read image file', false);
      };

      reader.readAsDataURL(file);
    } catch (error) {
      console.error('Error uploading ad image:', error);
      toast('‚ùå Failed to upload image', false);
    }
  };

  // Trigger file picker
  document.body.appendChild(input);
  input.click();
  document.body.removeChild(input);
}

// Remove ad image from the Edit Modal
async function removeAdImageFromModal() {
  const sel = [...state.selected].sort((a,b)=>a-b);
  if (!sel.length) return;

  const spotNum = sel[0];
  const spotKey = `Spot_${spotNum}`;
  const businessName = state.availability[spotKey]?.name || `Spot ${spotNum}`;

  if (!confirm(`Remove ad image for "${businessName}"?`)) {
    return;
  }

  // Remove from state
  if (state.availability[spotKey]) {
    delete state.availability[spotKey].adImage;
  }

  // Update modal UI
  const imagePreview = document.getElementById('editImagePreview');
  const uploadBtn = document.getElementById('btnUploadAdImage');
  const removeBtn = document.getElementById('btnRemoveAdImage');

  imagePreview.classList.add('hidden');
  uploadBtn.textContent = 'üì∑ Upload Ad Image';
  removeBtn.classList.add('hidden');

  // Save to cloud
  toast('üóëÔ∏è Removing ad image...', true);
  await saveAdImagesToCloud();

  // Re-render to show change
  renderAll();
  toast('‚úÖ Ad image removed', true);
}

// View full-size ad image
function viewAdImage(imageUrl, businessName = '') {
  const modal = document.createElement('div');
  modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px;';

  const header = document.createElement('div');
  header.style.cssText = 'color: white; font-size: 18px; font-weight: bold; margin-bottom: 15px; text-align: center;';
  header.textContent = businessName ? `${businessName} - Ad Preview` : 'Ad Preview';

  const img = document.createElement('img');
  img.src = imageUrl;
  img.style.cssText = 'max-width: 90%; max-height: 80vh; object-fit: contain; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);';

  const closeBtn = document.createElement('button');
  closeBtn.textContent = '‚úï Close';
  closeBtn.style.cssText = 'margin-top: 15px; padding: 10px 24px; background: white; color: black; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 14px;';
  closeBtn.onclick = () => document.body.removeChild(modal);

  modal.appendChild(header);
  modal.appendChild(img);
  modal.appendChild(closeBtn);

  modal.onclick = (e) => {
    if (e.target === modal) {
      document.body.removeChild(modal);
    }
  };

  document.body.appendChild(modal);

  // Close on Escape key
  const escHandler = (e) => {
    if (e.key === 'Escape') {
      if (document.body.contains(modal)) {
        document.body.removeChild(modal);
      }
      document.removeEventListener('keydown', escHandler);
    }
  };
  document.addEventListener('keydown', escHandler);
}

function toShortKey(longLabel){
  switch(longLabel){
    case "Reserved": return "RESERVED";
    case "Invoice Sent": return "INVOICE";
    case "Deposit Paid": return "DEPOSIT";
    case "Proof In Progress": return "PROOF";
    case "Ad Approved": return "APPROVED";
    case "Paid in Full": return "PAID";
    case "Available": return "AVAIL";
  }
  return String(longLabel || "").toUpperCase();
}

function toLongLabel(shortKey){
  switch(shortKey){
    case "RESERVED": return "Reserved";
    case "INVOICE": return "Invoice Sent";
    case "DEPOSIT": return "Deposit Paid";
    case "PROOF": return "Proof In Progress";
    case "APPROVED": return "Ad Approved";
    case "PAID": return "Paid in Full";
    default: return "Available";
  }
}

/* ========= POSTCARD MODAL ========= */
function openPostcardModal(){ 
  const modal = document.getElementById("postcardModal");
  modal.style.display='flex'; 
  modal.setAttribute('aria-hidden','false'); 
  trapModalFocus(modal); 
  previewPostcardModal(); 
}

function closePostcardModal(){ 
  const modal = document.getElementById("postcardModal");
  modal.style.display = 'none'; 
  modal.setAttribute('aria-hidden','true'); 
  releaseModalFocus(modal); 
}

function previewPostcardModal(){
  const previewPostcard = document.getElementById('previewPostcard');
  const previewBanner = document.getElementById('previewBanner');
  previewPostcard.style.backgroundColor = stagedColors.Postcard_BG || '#000';
  previewBanner.style.backgroundColor = stagedColors.Banner_BG || '#000000';
  previewBanner.style.color = useLightTextOn(stagedColors.Banner_BG || '#000000')? '#fff' : '#0f172a';
}

function applyPostcardModal(){
  stagedColors.Postcard_BG = document.getElementById('pickerPostcard').value;
  stagedColors.Banner_BG = document.getElementById('pickerBanner').value;
  savePostcardBg(stagedColors.Postcard_BG);
  saveBannerBg(stagedColors.Banner_BG);

  // Also save to current postcard data so colors persist when switching postcards
  if (state.current) {
    // Find the index of current postcard in mailers array
    const currentIndex = state.mailers.findIndex(m => m === state.current || m?.Mailer_ID === state.current?.Mailer_ID);
    if (currentIndex !== -1) {
      state.mailers[currentIndex].Postcard_BG = stagedColors.Postcard_BG;
      state.mailers[currentIndex].Banner_BG = stagedColors.Banner_BG;
    }
    // Also update the current object directly
    state.current.Postcard_BG = stagedColors.Postcard_BG;
    state.current.Banner_BG = stagedColors.Banner_BG;
  }

  applyStagedColors();
  closePostcardModal();
  state.dirty = true;
  updateToolbar();
  // Save immediately to database
  saveToSheet();
}

/* ========= SORT MODAL ========= */
function openEditStatusModal() {
  const modal = document.getElementById("editStatusModal");
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
  trapModalFocus(modal);

  // Populate legend in modal
  const legendGrid = document.getElementById("editStatusLegendGrid");
  legendGrid.innerHTML = "";
  const visibleSorted = sortOrder.filter(st => visibleStatuses.includes(st));
  visibleSorted.forEach(st => {
    const item = document.createElement("div");
    item.className = "flex items-center gap-2";
    const dot = document.createElement("span");
    dot.className = "w-3 h-3 rounded-full";
    dot.style.backgroundColor = STATUS_HEX[st] || GRADIENT_HEX[0];
    const txt = document.createElement("span");
    txt.textContent = st;
    item.appendChild(dot);
    item.appendChild(txt);
    legendGrid.appendChild(item);
  });

  // Build sort list
  buildSortList();
  updateSortPreview();
}

function closeEditStatusModal() {
  const modal = document.getElementById("editStatusModal");
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
  releaseModalFocus(modal);
}

function saveEditStatusModal() {
  saveSortOrderFromModal();
  closeEditStatusModal();
}

function openSortModal(){
  const modal = document.getElementById("sortModal");
  modal.style.display='flex';
  modal.setAttribute('aria-hidden','false');
  trapModalFocus(modal);
  buildSortList();
  updateSortPreview();
}

function closeSortModal(){
  const modal = document.getElementById("sortModal");
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden','true');
  releaseModalFocus(modal);
  renderLegend();
}

function buildSortList(){
  const container = document.getElementById("sortListContainer"); 
  container.innerHTML = ''; 
  sortOrder.forEach((s, idx)=>{
    const row = document.createElement('div'); 
    row.className='sort-row'; 
    row.dataset.idx = idx;
    const left = document.createElement('div'); 
    left.style.display='flex'; 
    left.style.alignItems='center'; 
    left.style.gap='8px';
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = visibleStatuses.includes(s);
    checkbox.dataset.status = s;
    checkbox.style.marginRight = '8px';
    const dot = document.createElement('span'); 
    dot.style.width='14px'; 
    dot.style.height='14px'; 
    dot.style.borderRadius='9999px'; 
    dot.style.background = STATUS_HEX[s] || '#ddd';
    const label = document.createElement('div'); 
    label.textContent = s; 
    label.style.fontWeight='700';
    left.appendChild(checkbox);
    left.appendChild(dot); 
    left.appendChild(label);
    const right = document.createElement('div'); 
    right.style.display='flex'; 
    right.style.gap='6px';
    const up = document.createElement('button'); 
    up.className='sort-up'; 
    up.textContent='‚ñ≤'; 
    up.dataset.idx = idx; 
    up.title='Move up';
    const down = document.createElement('button'); 
    down.className='sort-down'; 
    down.textContent='‚ñº'; 
    down.dataset.idx = idx; 
    down.title='Move down';
    right.appendChild(up); 
    right.appendChild(down);
    row.appendChild(left); 
    row.appendChild(right);
    row.draggable = true;
    row.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', idx); row.style.opacity='0.6'; });
    row.addEventListener('dragend', e => { row.style.opacity=''; });
    row.addEventListener('dragover', e => { e.preventDefault(); row.style.background = '#f3f4f6'; });
    row.addEventListener('dragleave', e => { row.style.background = '#fff'; });
    row.addEventListener('drop', e => {
      e.preventDefault(); 
      row.style.background = '#fff';
      const from = Number(e.dataTransfer.getData('text/plain')); 
      const to = Number(row.dataset.idx);
      if (from === to) return;
      const copy = sortOrder.slice(); 
      const [item] = copy.splice(from,1); 
      copy.splice(to,0,item); 
      sortOrder = copy; 
      buildSortList(); 
      updateSortPreview();
    });
    container.appendChild(row);
  });
}

function handleSortUpDown(e){
  const el = e.target; 
  const idx = Number(el.dataset.idx);
  if (isNaN(idx)) return;
  if (el.classList.contains('sort-up')){ 
    if (idx>0){ 
      [sortOrder[idx-1], sortOrder[idx]] = [sortOrder[idx], sortOrder[idx-1]]; 
      buildSortList(); 
      updateSortPreview(); 
    } 
  }
  else if (el.classList.contains('sort-down')){ 
    if (idx < sortOrder.length-1){ 
      [sortOrder[idx+1], sortOrder[idx]] = [sortOrder[idx], sortOrder[idx+1]]; 
      buildSortList(); 
      updateSortPreview(); 
    } 
  }
}

function updateSortPreview(){
  const colors = GRADIENT_HEX;
  const grad = colors.map((c,i)=> `${c} ${i/(colors.length-1)*100}%`).join(',');
  document.getElementById('sortPreview').style.background = `linear-gradient(90deg, ${grad})`;
}

function saveSortOrderFromModal(){
  const checkboxes = document.querySelectorAll('#sortListContainer input[type="checkbox"]');
  visibleStatuses = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.dataset.status);
  safeSetItem('mailslot-sort', JSON.stringify({order: sortOrder, visible: visibleStatuses}));
  updateColorMappings();
  toast('Legend order and visibility saved');
  closeSortModal();
  renderAll();
}

/* ========= SAVE ========= */
function computeUpdates(){
  let n=0;
  for (let i=1;i<=18;i++){
    const key=`Spot_${i}`;
    const cur = state.availability[key] || {name:"", status:"Available"};
    const human = cur.name ? `${cur.status}: ${cur.name}` : ""; // FIX: Added space after colon to match save format
    if ((state.initial[key]||"") !== human) n++;
  }
  return n;
}

function buildAvailabilityPayload(){
  const out = {};
  for (let i=1;i<=18;i++){
    const key=`Spot_${i}`;
    const cur=state.availability[key] || {name:"", status:"Available"};
    const human = cur.name ? `${cur.status}: ${cur.name}` : "Available";
    const initial = state.initial[key] || "";
    const humanCompare = cur.name ? `${cur.status}: ${cur.name}` : ""; // FIX: Added space after colon to match output format
    if (initial !== humanCompare) {
      out[key] = cur.name ? `${cur.status}: ${cur.name}` : "Available";
    }
  }
  state.merged.forEach(pair => {
    const parts = pair.split("-").map(n => Number(n));
    if (parts.length !== 2) return;
    const a = parts[0], b = parts[1];
    const A = state.availability[`Spot_${a}`] || {name:"", status:"Available"};
    const B = state.availability[`Spot_${b}`] || {name:"", status:"Available"};
    const preferredName = (A.name || B.name || "").replace(/\s+/g,' ').trim();
    const preferredStatus = (A.name ? A.status : (B.name ? B.status : "Available"));
    const human = preferredName ? `${preferredStatus}: ${preferredName}` : "Available";
    out[`Spot_${a}`] = human;
    out[`Spot_${b}`] = human;
  });
  return out;
}

/* ========= AUTO-SAVE SYSTEM ========= */

function updateAutoSaveStatus() {
  try {
    const statusDiv = document.getElementById('autoSaveStatus');
    const iconSpan = document.getElementById('autoSaveIcon');
    const textSpan = document.getElementById('autoSaveText');
    const saveBtn = document.getElementById('btnManualSave');

    if (!statusDiv) return;

  // Clear any hide timeout and show the status
  if (window.autoSaveHideTimeout) {
    clearTimeout(window.autoSaveHideTimeout);
  }
  statusDiv.style.display = 'flex';
  statusDiv.style.opacity = '1';

  // Determine status
  if (autoSaveState.saving) {
    // Currently saving
    statusDiv.className = 'flex items-center gap-1 px-2 py-1 rounded-md text-xs font-medium bg-blue-50 border border-blue-300 text-blue-700';
    iconSpan.textContent = '‚òÅÔ∏è';
    textSpan.textContent = 'Saving...';
    saveBtn.classList.add('hidden');
  } else if (state.dirty) {
    // Has unsaved changes - hide status, show manual save button
    statusDiv.style.display = 'none';
    saveBtn.classList.remove('hidden');
  } else {
    // All saved
    statusDiv.className = 'flex items-center gap-1 px-2 py-1 rounded-md text-xs font-medium bg-green-50 border border-green-300 text-green-700';
    iconSpan.textContent = '‚úì';

    if (autoSaveState.lastSaveTime) {
      const relativeTime = getRelativeTime(autoSaveState.lastSaveTime);
      textSpan.textContent = relativeTime;
    } else {
      textSpan.textContent = 'Saved';
    }

    saveBtn.classList.add('hidden');

    // Auto-hide after 10 seconds (increased from 4s for better visibility)
    if (window.autoSaveHideTimeout) {
      clearTimeout(window.autoSaveHideTimeout);
    }
    statusDiv.style.opacity = '1';
    statusDiv.style.transition = 'opacity 0.3s';

    window.autoSaveHideTimeout = setTimeout(() => {
      statusDiv.style.opacity = '0';
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 300);
    }, 10000);
  }
  } catch(e) {
    console.error('Error in updateAutoSaveStatus:', e);
  }
}

function getRelativeTime(timestamp) {
  const now = Date.now();
  const diff = now - timestamp;
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  if (seconds < 10) return 'just now';
  if (seconds < 60) return `${seconds} sec ago`;
  if (minutes === 1) return '1 min ago';
  if (minutes < 60) return `${minutes} min ago`;
  if (hours === 1) return '1 hour ago';
  if (hours < 24) return `${hours} hours ago`;
  if (days === 1) return '1 day ago';
  return `${days} days ago`;
}

function scheduleAutoSave() {
  try {
    // Clear existing timer
    if (autoSaveState.timer) {
      clearTimeout(autoSaveState.timer);
    }

    // Don't schedule if no changes
    if (!state.dirty) {
      updateAutoSaveStatus();
      return;
    }

    // Schedule auto-save for 15 seconds from now
    autoSaveState.timer = setTimeout(() => {
      performAutoSave();
    }, 15000); // 15 seconds

    updateAutoSaveStatus();
  } catch(e) {
    console.error('Error in scheduleAutoSave:', e);
  }
}

function performAutoSave() {
  try {
    console.log('üîÑ performAutoSave triggered');
    if (!state.dirty) {
      console.log('üîÑ performAutoSave: nothing to save');
      return;
    }

    // Call saveToSheet to save to Supabase
    console.log('üîÑ performAutoSave: calling saveToSheet');
    saveToSheet();

  } catch(e) {
    console.error('Error in performAutoSave:', e);
  }
}

  /* OLD CODE BELOW - DISABLED
  if (autoSaveState.saving) {
    // Already saving - reschedule for after current save completes
    return;
  }
  if (!state.current) return;

  const availabilityDiffs = buildAvailabilityPayload();
  if (Object.keys(availabilityDiffs).length === 0) {
    state.dirty = false;
    updateAutoSaveStatus();
    return;
  }

  autoSaveState.saving = true;
  updateAutoSaveStatus();

  const payload = {
    user: ACTIVE_USER,
    Mailer_ID: state.current.Mailer_ID,
    availability: availabilityDiffs,
    Postcard_BG: stagedColors.Postcard_BG || null,
    Banner_BG: stagedColors.Banner_BG || null
  };

  // Use GET request instead of POST to avoid 403 errors
  const payloadJson = encodeURIComponent(JSON.stringify(payload));
  const url = `${GAS_URL}?action=saveSpots&data=${payloadJson}`;

  fetch(url)
    .then(response => response.json())
    .then(result => {
      if (result.error) {
        throw new Error(result.error);
      }

      autoSaveState.saving = false;
      autoSaveState.lastSaveTime = Date.now();
      state.dirty = false;
      updateToolbar();
      updateAutoSaveStatus();

      // Clear spot selection after successful save
      state.selected.clear();
      renderAll();

      // Start interval to update "saved X min ago" text
      if (!autoSaveState.updateInterval) {
        autoSaveState.updateInterval = setInterval(() => {
          if (!state.dirty && autoSaveState.lastSaveTime) {
            updateAutoSaveStatus();
          }
        }, 30000); // Update every 30 seconds
      }

      toast('‚úì Auto-saved to cloud', true);
    })
    .catch(err => {
      console.error('Auto-save failed:', err);
      autoSaveState.saving = false;
      toast('Auto-save failed - saved locally only', false);
    });
  } catch(e) {
    console.error('Error in performAutoSave:', e);
    autoSaveState.saving = false;
    toast('Auto-save failed', false);
  }
}
*/

function manualSaveNow() {
  if (!state.dirty) {
    toast('No changes to save', false);
    return;
  }

  // Cancel any pending auto-save
  if (autoSaveState.timer) {
    clearTimeout(autoSaveState.timer);
    autoSaveState.timer = null;
  }

  performAutoSave();
}

async function saveToSheet(){
  console.log('üöÄ saveToSheet() CALLED!', {
    hasCurrent: !!state.current,
    isDirty: state.dirty,
    currentMailerId: state.current?.Mailer_ID
  });

  if (!state.current) {
    console.log('‚ùå Exiting: No current postcard');
    return;
  }

  if (!state.dirty) {
    console.log('‚ùå Exiting: Not dirty');
    toast("No changes to save");
    return;
  }

  const availabilityDiffs = buildAvailabilityPayload();
  console.log('üìù Availability diffs:', availabilityDiffs, 'Count:', Object.keys(availabilityDiffs).length);

  if (Object.keys(availabilityDiffs).length === 0) {
    console.log('‚ùå Exiting: No availability diffs');
    toast("No changes to save");
    state.dirty = false;
    updateToolbar();
    return;
  }

  const updates = computeUpdates();
  console.log('üìä Computed updates count:', updates);

  // If no actual changes (updates = 0), don't save
  if (updates === 0) {
    console.log('‚ùå Exiting: No changes to save (spots haven\'t changed from initial values)');
    toast("No changes to save");
    state.dirty = false;
    updateToolbar();
    return;
  }

  const payload = {
    User: ACTIVE_USER,  // Use uppercase User to match backend
    Mailer_ID: state.current.Mailer_ID,
    Town: state.current.Town,
    Mail_Date: state.current.Mail_Date,
    In_Homes_Date: state.current.In_Homes_Date,
    availability: availabilityDiffs,
    Postcard_BG: stagedColors.Postcard_BG || state.current.Postcard_BG || '#000000',
    Banner_BG: stagedColors.Banner_BG || state.current.Banner_BG || '#000000'
  };

  try {
    toast(`‚òÅÔ∏è Saving ${updates} change${updates===1?"":"s"}...`, false);

    // Build Supabase update object with snake_case column names
    const updateData = {
      postcard_bg: stagedColors.Postcard_BG || state.current.Postcard_BG || '#000000',
      banner_bg: stagedColors.Banner_BG || state.current.Banner_BG || '#000000'
    };

    // Add spot updates
    Object.keys(availabilityDiffs).forEach(spotKey => {
      const spotNumber = spotKey.replace('Spot_', '');
      updateData[`spot_${spotNumber}`] = availabilityDiffs[spotKey];
    });

    const { error, data: resultData } = await supabaseClient
      .from('postcards')
      .update(updateData)
      .eq('mailer_id', state.current.Mailer_ID)
      .eq('user_email', ACTIVE_USER)
      .select();

    if (error) throw error;

    toast(`‚úÖ Saved ${updates} change${updates===1?"":"s"} to cloud!`, true);
    state.dirty = false;
    autoSaveState.lastSaveTime = Date.now();
    updateToolbar();
    updateAutoSaveStatus();

    // Check if any spot was marked as Reserved or Paid (for Getting Started checklist)
    const hasReservedOrPaid = Object.values(availabilityDiffs).some(status => {
      const statusLower = status.toLowerCase();
      return statusLower.includes('reserved') ||
             statusLower.includes('deposit paid') ||
             statusLower.includes('paid in full') ||
             statusLower.includes('invoice sent') ||
             statusLower.includes('ad approved');
    });
    if (hasReservedOrPaid) {
      markGettingStartedComplete('mark_reserved');
    }

    // Reload campaigns to get fresh data, preserving current selection
    const currentMailerId = state.current?.Mailer_ID;
    console.log('üíæ Saving complete. Will restore mailer_id:', currentMailerId, 'type:', typeof currentMailerId);
    setTimeout(() => loadCampaigns(currentMailerId), 500);

  } catch (err) {
    console.error("Failed to save to cloud:", err);
    toast("‚ö†Ô∏è Failed to save to cloud. Please try again.", false);
  }
}

// ===================================================================
// FINANCIALS SYSTEM
// ===================================================================

// Financial data state
const financialState = {
  transactions: [], // Array of transaction objects
  loaded: false
};

// Category definitions for auto-categorization and reporting
const FINANCIAL_CATEGORIES = {
  // Revenue
  'Card Payment': { type: 'revenue', category: 'Sales Revenue', subcategory: 'Card Payments' },
  'Sales': { type: 'revenue', category: 'Sales Revenue', subcategory: 'General Sales' },

  // Cost of Goods Sold (COGS)
  'USPS': { type: 'cogs', category: 'COGS', subcategory: 'Postage & Shipping' },
  'Postage': { type: 'cogs', category: 'COGS', subcategory: 'Postage & Shipping' },
  'Printing': { type: 'cogs', category: 'COGS', subcategory: 'Printing' },

  // Operating Expenses
  'Square': { type: 'operating', category: 'Operating Expenses', subcategory: 'Software & Services' },
  'Software': { type: 'operating', category: 'Operating Expenses', subcategory: 'Software & Services' },
  'Bank Fee': { type: 'operating', category: 'Operating Expenses', subcategory: 'Bank Fees' },
  'Fee': { type: 'operating', category: 'Operating Expenses', subcategory: 'Bank Fees' },

  // Owner Draw
  'Transfer': { type: 'owner_draw', category: 'Owner Draw', subcategory: 'Withdrawals' },
  'Withdrawal': { type: 'owner_draw', category: 'Owner Draw', subcategory: 'Withdrawals' }
};

// Auto-categorize a transaction based on description
function autoCategorizeTransaction(description, activityType, amount) {
  const desc = description.toUpperCase();
  const isPositive = amount > 0;

  // Revenue - Sales activity
  if (activityType === 'Sales' && isPositive) {
    return { type: 'revenue', category: 'Sales Revenue', subcategory: 'Card Payments' };
  }

  // COGS - Postage & Shipping
  if (desc.includes('USPS') || desc.includes('POSTAGE') || desc.includes('EVERY DOOR')) {
    return { type: 'cogs', category: 'COGS', subcategory: 'Postage & Shipping' };
  }

  // COGS - Printing
  if (desc.includes('4 OVER') || desc.includes('PRINTING')) {
    return { type: 'cogs', category: 'COGS', subcategory: 'Printing' };
  }

  // Operating Expenses - Software & Services
  if (desc.includes('SQUARE') || desc.includes('HOSTINGER') || desc.includes('XERO') ||
      desc.includes('SITEGROUND') || desc.includes('OPENAI') || desc.includes('CHATGPT') ||
      desc.includes('XAI') || desc.includes('HEYGEN') || desc.includes('ZEROBOUNCE')) {
    return { type: 'operating', category: 'Operating Expenses', subcategory: 'Software & Services' };
  }

  // Operating Expenses - Marketing/Advertising
  if (desc.includes('STRUC MARKE') || desc.includes('MARKETING') || desc.includes('ADVERTISING')) {
    return { type: 'operating', category: 'Operating Expenses', subcategory: 'Marketing' };
  }

  // Operating Expenses - General
  if (desc.includes('AMAZON') || activityType === 'Card spend') {
    return { type: 'operating', category: 'Operating Expenses', subcategory: 'General Expenses' };
  }

  // Owner equity - Transfers in
  if (activityType === 'Transfer in') {
    return { type: 'revenue', category: 'Owner Contribution', subcategory: 'Capital Injection' };
  }

  // Default uncategorized
  return { type: 'uncategorized', category: 'Uncategorized', subcategory: '' };
}

// Load financial data from Supabase
async function loadFinancialData() {
  try {
    const { data, error } = await supabaseClient
      .from('app_data')
      .select('data')
      .eq('user_email', ACTIVE_USER)
      .eq('data_type', 'financialTransactions')
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        // No data yet - this is fine
        financialState.transactions = [];
        financialState.loaded = true;
        renderDashboardFinancials();
        return;
      }
      throw error;
    }

    financialState.transactions = data.data || [];
    financialState.loaded = true;

    // Render the register
    renderFinancialRegister();

  } catch (err) {
    console.error('Error loading financial data:', err);
    toast('‚ö†Ô∏è Failed to load financial data', false);
    financialState.transactions = [];
    financialState.loaded = true;
  }
}

// Save financial data to Supabase
async function saveFinancialData() {
  try {
    // Upsert to app_data table
    const { error } = await supabaseClient
      .from('app_data')
      .upsert({
        user_email: ACTIVE_USER,
        data_type: 'financialTransactions',
        data: financialState.transactions
      }, {
        onConflict: 'user_email,data_type'
      });

    if (error) throw error;

  } catch (err) {
    console.error('Error saving financial data:', err);
    toast('‚ö†Ô∏è Failed to save financial data', false);
    throw err;
  }
}

// Calculate financial summaries
function calculateFinancialSummaries(transactions) {
  let totalRevenue = 0;
  let totalExpenses = 0;
  let currentBalance = 0;

  let revenueCount = 0;
  let expenseCount = 0;

  transactions.forEach(trans => {
    const amount = parseFloat(trans.amount) || 0;

    if (trans.type === 'revenue') {
      totalRevenue += amount;
      revenueCount++;
    } else if (trans.type === 'cogs' || trans.type === 'operating' || trans.type === 'owner_draw') {
      totalExpenses += Math.abs(amount);
      expenseCount++;
    }

    // Track balance - we'll use the latest (most recent) transaction's balance
    const transBalance = parseFloat(trans.balance) || 0;
    if (!currentBalance || transBalance > 0) {
      currentBalance = transBalance;
    }
  });

  // Since transactions are sorted newest first, get the balance from the first transaction (most recent)
  if (transactions.length > 0) {
    currentBalance = parseFloat(transactions[0].balance) || 0;
  }

  const netIncome = totalRevenue - totalExpenses;

  return { totalRevenue, totalExpenses, netIncome, currentBalance };
}

// Filter transactions based on period and category
function filterTransactions(transactions, periodFilter, categoryFilter) {
  let filtered = [...transactions];

  // Period filter
  if (periodFilter !== 'all') {
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth();

    filtered = filtered.filter(trans => {
      const transDate = new Date(trans.date);
      const transYear = transDate.getFullYear();
      const transMonth = transDate.getMonth();

      if (periodFilter === 'current-year') {
        return transYear === currentYear;
      } else if (periodFilter === 'current-month') {
        return transYear === currentYear && transMonth === currentMonth;
      } else if (periodFilter === 'last-month') {
        const lastMonth = currentMonth === 0 ? 11 : currentMonth - 1;
        const lastMonthYear = currentMonth === 0 ? currentYear - 1 : currentYear;
        return transYear === lastMonthYear && transMonth === lastMonth;
      } else if (periodFilter === 'q1') {
        return transYear === currentYear && transMonth >= 0 && transMonth <= 2;
      } else if (periodFilter === 'q2') {
        return transYear === currentYear && transMonth >= 3 && transMonth <= 5;
      } else if (periodFilter === 'q3') {
        return transYear === currentYear && transMonth >= 6 && transMonth <= 8;
      } else if (periodFilter === 'q4') {
        return transYear === currentYear && transMonth >= 9 && transMonth <= 11;
      }

      return true;
    });
  }

  // Category filter
  if (categoryFilter !== 'all') {
    filtered = filtered.filter(trans => trans.type === categoryFilter);
  }

  return filtered;
}

// Render the financial register
function renderFinancialRegister() {
  const tbody = document.getElementById('financialRegisterBody');
  if (!tbody) return;

  if (!financialState.loaded) {
    tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-gray-500">Loading transactions...</td></tr>';
    return;
  }

  // Get filter values
  const periodFilterEl = document.getElementById('financialPeriodFilter');
  const periodFilter = periodFilterEl?.value || 'current-year';
  const categoryFilter = document.getElementById('financialCategoryFilter')?.value || 'all';

  // Filter transactions
  const filteredTransactions = filterTransactions(financialState.transactions, periodFilter, categoryFilter);

  // Sort by date descending (newest first)
  const sortedTransactions = [...filteredTransactions].sort((a, b) => {
    return new Date(b.date) - new Date(a.date);
  });

  // Calculate summaries
  const summaries = calculateFinancialSummaries(sortedTransactions);

  // Update summary cards
  document.getElementById('totalRevenue').textContent = `$${summaries.totalRevenue.toFixed(2)}`;
  document.getElementById('totalExpenses').textContent = `$${summaries.totalExpenses.toFixed(2)}`;
  document.getElementById('netIncome').textContent = `$${summaries.netIncome.toFixed(2)}`;
  document.getElementById('currentBalance').textContent = `$${summaries.currentBalance.toFixed(2)}`;

  // Also update dashboard widget
  renderDashboardFinancials();

  // Render transactions
  if (sortedTransactions.length === 0) {
    tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-gray-500">No transactions found</td></tr>';
    return;
  }

  tbody.innerHTML = sortedTransactions.map(trans => {
    const amount = parseFloat(trans.amount) || 0;
    const amountClass = amount >= 0 ? 'text-green-600 font-semibold' : 'text-red-600 font-semibold';
    const amountDisplay = amount >= 0 ? `+$${amount.toFixed(2)}` : `-$${Math.abs(amount).toFixed(2)}`;

    return `
      <tr class="border-b hover:bg-gray-50">
        <td class="py-2 px-3 text-sm">${trans.date}</td>
        <td class="py-2 px-3 text-sm">${trans.description}</td>
        <td class="py-2 px-3 text-sm">
          <span class="px-2 py-1 rounded text-xs font-medium ${getCategoryBadgeClass(trans.type)}">
            ${trans.category}
          </span>
        </td>
        <td class="py-2 px-3 text-sm ${amountClass}">${amountDisplay}</td>
        <td class="py-2 px-3 text-sm font-medium">$${(parseFloat(trans.balance) || 0).toFixed(2)}</td>
        <td class="py-2 px-3 text-sm text-gray-600">${trans.notes || ''}</td>
        <td class="py-2 px-3 text-sm">
          <button onclick="editTransaction('${trans.id}')" class="text-blue-600 hover:underline text-xs mr-2">Edit</button>
          <button onclick="deleteTransaction('${trans.id}')" class="text-red-600 hover:underline text-xs">Delete</button>
        </td>
      </tr>
    `;
  }).join('');
}

// Get badge class for category type
function getCategoryBadgeClass(type) {
  switch (type) {
    case 'revenue':
      return 'bg-green-100 text-green-800';
    case 'cogs':
      return 'bg-blue-100 text-blue-800';
    case 'operating':
      return 'bg-orange-100 text-orange-800';
    case 'owner_draw':
      return 'bg-purple-100 text-purple-800';
    default:
      return 'bg-gray-100 text-gray-800';
  }
}

// Show add transaction modal
function showAddTransactionModal() {
  // Reset form
  document.getElementById('txnDate').value = new Date().toISOString().split('T')[0];
  document.getElementById('txnType').value = '';
  document.getElementById('txnDescription').value = '';
  document.getElementById('txnAmount').value = '';
  document.getElementById('txnCategory').value = '';
  document.getElementById('txnNotes').value = '';

  // Show modal
  const modal = document.getElementById('addTransactionModal');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
}

// Close add transaction modal
function closeAddTransactionModal() {
  const modal = document.getElementById('addTransactionModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
}

// Save add transaction
async function saveAddTransaction() {
  try {
    const date = document.getElementById('txnDate').value;
    const type = document.getElementById('txnType').value;
    const description = document.getElementById('txnDescription').value;
    const amount = parseFloat(document.getElementById('txnAmount').value);
    const notes = document.getElementById('txnNotes').value;

    // Validate
    if (!date || !type || !description || isNaN(amount)) {
      toast('‚ö†Ô∏è Please fill in all required fields', false);
      return;
    }

    // Adjust amount for expenses (make negative)
    const adjustedAmount = (type === 'revenue') ? Math.abs(amount) : -Math.abs(amount);

    // Convert type to activityType for categorization
    let activityType = 'Manual Entry';
    if (type === 'revenue') activityType = 'Sales';
    else if (type === 'cogs') activityType = 'Card spend';
    else if (type === 'operating') activityType = 'Card spend';
    else if (type === 'owner_draw') activityType = 'Transfer out';

    // Auto-categorize based on description, activityType, and amount
    const categorization = autoCategorizeTransaction(description, activityType, adjustedAmount);

    // Calculate new balance (last transaction balance + this amount)
    const lastBalance = financialState.transactions.length > 0
      ? parseFloat(financialState.transactions[0].balance) || 0
      : 0;
    const newBalance = lastBalance + adjustedAmount;

    // Create transaction
    const transaction = {
      id: `manual-${Date.now()}`,
      date: date,
      description: description,
      activityType: activityType,
      amount: adjustedAmount,
      balance: newBalance,
      type: categorization.type,
      category: categorization.category,
      subcategory: categorization.subcategory,
      notes: notes
    };

    // Add to array (at beginning since it's new)
    financialState.transactions.unshift(transaction);

    // Recalculate balances for all transactions
    recalculateBalances();

    // Save to cloud
    await saveFinancialData();

    // Re-render
    renderFinancialRegister();

    // Close modal
    closeAddTransactionModal();

    toast('‚úÖ Transaction added', true);
  } catch (err) {
    console.error('Error adding transaction:', err);
    toast('‚ö†Ô∏è Failed to add transaction', false);
  }
}

// Recalculate balances for all transactions
function recalculateBalances() {
  // Sort transactions by date (oldest first)
  const sorted = [...financialState.transactions].sort((a, b) => {
    return new Date(a.date) - new Date(b.date);
  });

  // Calculate running balance
  let runningBalance = 0;
  sorted.forEach(trans => {
    runningBalance += parseFloat(trans.amount) || 0;
    trans.balance = runningBalance;
  });

  // Update financialState with sorted and balanced transactions
  financialState.transactions = sorted;
}

// Edit transaction
function editTransaction(id) {
  const transaction = financialState.transactions.find(t => t.id === id);
  if (!transaction) {
    toast('‚ö†Ô∏è Transaction not found', false);
    return;
  }

  // Fill form with transaction data
  document.getElementById('editTxnDate').value = transaction.date;
  document.getElementById('editTxnType').value = transaction.type;
  document.getElementById('editTxnDescription').value = transaction.description;
  document.getElementById('editTxnAmount').value = Math.abs(parseFloat(transaction.amount));
  document.getElementById('editTxnCategory').value = transaction.category;
  document.getElementById('editTxnNotes').value = transaction.notes || '';
  document.getElementById('editTxnId').value = id;

  // Show modal
  const modal = document.getElementById('editTransactionModal');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
}

// Close edit transaction modal
function closeEditTransactionModal() {
  const modal = document.getElementById('editTransactionModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
}

// Save edit transaction
async function saveEditTransaction() {
  try {
    const id = document.getElementById('editTxnId').value;
    const date = document.getElementById('editTxnDate').value;
    const type = document.getElementById('editTxnType').value;
    const description = document.getElementById('editTxnDescription').value;
    const amount = parseFloat(document.getElementById('editTxnAmount').value);
    const notes = document.getElementById('editTxnNotes').value;

    // Validate
    if (!date || !type || !description || isNaN(amount)) {
      toast('‚ö†Ô∏è Please fill in all required fields', false);
      return;
    }

    // Find and update transaction
    const transaction = financialState.transactions.find(t => t.id === id);
    if (!transaction) {
      toast('‚ö†Ô∏è Transaction not found', false);
      return;
    }

    // Adjust amount for expenses (make negative)
    const adjustedAmount = (type === 'revenue') ? Math.abs(amount) : -Math.abs(amount);

    // Convert type to activityType for categorization
    let activityType = 'Manual Entry';
    if (type === 'revenue') activityType = 'Sales';
    else if (type === 'cogs') activityType = 'Card spend';
    else if (type === 'operating') activityType = 'Card spend';
    else if (type === 'owner_draw') activityType = 'Transfer out';

    // Auto-categorize based on description, activityType, and amount
    const categorization = autoCategorizeTransaction(description, activityType, adjustedAmount);

    // Update transaction
    transaction.date = date;
    transaction.description = description;
    transaction.activityType = activityType;
    transaction.type = categorization.type;
    transaction.amount = adjustedAmount;
    transaction.category = categorization.category;
    transaction.subcategory = categorization.subcategory;
    transaction.notes = notes;

    // Recalculate all balances
    recalculateBalances();

    // Save to cloud
    await saveFinancialData();

    // Re-render
    renderFinancialRegister();

    // Close modal
    closeEditTransactionModal();

    toast('‚úÖ Transaction updated', true);
  } catch (err) {
    console.error('Error updating transaction:', err);
    toast('‚ö†Ô∏è Failed to update transaction', false);
  }
}

// Delete transaction
async function deleteTransaction(id) {
  if (!confirm('Are you sure you want to delete this transaction?')) {
    return;
  }

  try {
    // Remove from array
    financialState.transactions = financialState.transactions.filter(t => t.id !== id);

    // Save to cloud
    await saveFinancialData();

    // Re-render
    renderFinancialRegister();

    toast('‚úÖ Transaction deleted', true);
  } catch (err) {
    console.error('Error deleting transaction:', err);
    toast('‚ö†Ô∏è Failed to delete transaction', false);
  }
}

// Export financial data to CSV
function exportFinancialCSV() {
  const periodFilter = document.getElementById('financialPeriodFilter')?.value || 'all';
  const categoryFilter = document.getElementById('financialCategoryFilter')?.value || 'all';

  const filteredTransactions = filterTransactions(financialState.transactions, periodFilter, categoryFilter);

  if (filteredTransactions.length === 0) {
    toast('‚ö†Ô∏è No transactions to export', false);
    return;
  }

  // Build CSV
  const headers = ['Date', 'Description', 'Category', 'Subcategory', 'Amount', 'Balance', 'Notes'];
  const rows = filteredTransactions.map(trans => [
    trans.date,
    trans.description,
    trans.category,
    trans.subcategory || '',
    trans.amount,
    trans.balance,
    trans.notes || ''
  ]);

  const csv = [headers, ...rows].map(row =>
    row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
  ).join('\n');

  // Download
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `9x12Pro_Financials_${new Date().toISOString().slice(0, 10)}.csv`;
  a.click();
  URL.revokeObjectURL(url);

  toast('‚úÖ Exported to CSV', true);
}

// Show Profit & Loss report
function showProfitLossReport() {
  // Set default period
  document.getElementById('plReportPeriod').value = 'current-year';

  // Generate report
  generatePLReport();

  // Show modal
  const modal = document.getElementById('plReportModal');
  modal.style.display = 'flex';
  modal.setAttribute('aria-hidden', 'false');
}

// Close P&L Report modal
function closePLReportModal() {
  const modal = document.getElementById('plReportModal');
  modal.style.display = 'none';
  modal.setAttribute('aria-hidden', 'true');
}

// Generate P&L Report
function generatePLReport() {
  const periodFilter = document.getElementById('plReportPeriod')?.value || 'current-year';
  const filteredTransactions = filterTransactions(financialState.transactions, periodFilter, 'all');

  // Calculate totals by category
  let totalRevenue = 0;
  let totalCOGS = 0;
  let totalOperating = 0;
  let totalOwnerDraw = 0;

  const revenueItems = [];
  const cogsItems = [];
  const operatingItems = [];
  const ownerDrawItems = [];

  filteredTransactions.forEach(trans => {
    const amount = Math.abs(parseFloat(trans.amount) || 0);
    const item = {
      date: trans.date,
      description: trans.description,
      amount: amount
    };

    if (trans.type === 'revenue') {
      totalRevenue += amount;
      revenueItems.push(item);
    } else if (trans.type === 'cogs') {
      totalCOGS += amount;
      cogsItems.push(item);
    } else if (trans.type === 'operating') {
      totalOperating += amount;
      operatingItems.push(item);
    } else if (trans.type === 'owner_draw') {
      totalOwnerDraw += amount;
      ownerDrawItems.push(item);
    }
  });

  const grossProfit = totalRevenue - totalCOGS;
  const operatingIncome = grossProfit - totalOperating;
  const netIncome = operatingIncome - totalOwnerDraw;

  // Get period label
  const periodLabel = getPeriodLabel(periodFilter);

  // Build report HTML
  const reportHTML = `
    <div class="p-6">
      <div class="text-center mb-6">
        <h2 class="text-2xl font-bold">9x12 PRO</h2>
        <h3 class="text-lg font-semibold mt-2">Profit & Loss Statement</h3>
        <p class="text-sm text-gray-600 mt-1">${periodLabel}</p>
      </div>

      <!-- Revenue Section -->
      <div class="mb-6">
        <div class="bg-green-50 px-4 py-2 font-semibold text-green-900 border-b-2 border-green-600">
          REVENUE
        </div>
        <div class="pl-6 py-2">
          <div class="flex justify-between items-center">
            <span>Sales Revenue</span>
            <span class="font-mono">$${totalRevenue.toFixed(2)}</span>
          </div>
        </div>
        <div class="bg-green-100 px-4 py-2 flex justify-between font-semibold text-green-900">
          <span>Total Revenue</span>
          <span class="font-mono">$${totalRevenue.toFixed(2)}</span>
        </div>
      </div>

      <!-- Cost of Goods Sold Section -->
      <div class="mb-6">
        <div class="bg-blue-50 px-4 py-2 font-semibold text-blue-900 border-b-2 border-blue-600">
          COST OF GOODS SOLD
        </div>
        <div class="pl-6 py-2">
          <div class="flex justify-between items-center">
            <span>Direct Costs</span>
            <span class="font-mono">$${totalCOGS.toFixed(2)}</span>
          </div>
        </div>
        <div class="bg-blue-100 px-4 py-2 flex justify-between font-semibold text-blue-900">
          <span>Total COGS</span>
          <span class="font-mono">$${totalCOGS.toFixed(2)}</span>
        </div>
      </div>

      <!-- Gross Profit -->
      <div class="mb-6 bg-gray-100 px-4 py-3 flex justify-between font-bold text-lg">
        <span>GROSS PROFIT</span>
        <span class="font-mono ${grossProfit >= 0 ? 'text-green-600' : 'text-red-600'}">$${grossProfit.toFixed(2)}</span>
      </div>

      <!-- Operating Expenses Section -->
      <div class="mb-6">
        <div class="bg-orange-50 px-4 py-2 font-semibold text-orange-900 border-b-2 border-orange-600">
          OPERATING EXPENSES
        </div>
        <div class="pl-6 py-2">
          <div class="flex justify-between items-center">
            <span>General & Administrative</span>
            <span class="font-mono">$${totalOperating.toFixed(2)}</span>
          </div>
        </div>
        <div class="bg-orange-100 px-4 py-2 flex justify-between font-semibold text-orange-900">
          <span>Total Operating Expenses</span>
          <span class="font-mono">$${totalOperating.toFixed(2)}</span>
        </div>
      </div>

      <!-- Operating Income -->
      <div class="mb-6 bg-gray-100 px-4 py-3 flex justify-between font-bold text-lg">
        <span>OPERATING INCOME</span>
        <span class="font-mono ${operatingIncome >= 0 ? 'text-green-600' : 'text-red-600'}">$${operatingIncome.toFixed(2)}</span>
      </div>

      <!-- Owner Draws -->
      ${totalOwnerDraw > 0 ? `
      <div class="mb-6">
        <div class="bg-purple-50 px-4 py-2 font-semibold text-purple-900 border-b-2 border-purple-600">
          OWNER DISTRIBUTIONS
        </div>
        <div class="pl-6 py-2">
          <div class="flex justify-between items-center">
            <span>Owner Draws</span>
            <span class="font-mono">$${totalOwnerDraw.toFixed(2)}</span>
          </div>
        </div>
      </div>
      ` : ''}

      <!-- Net Income -->
      <div class="bg-gradient-to-r from-gray-700 to-gray-800 text-white px-4 py-4 flex justify-between font-bold text-xl rounded-lg">
        <span>NET INCOME</span>
        <span class="font-mono ${netIncome >= 0 ? 'text-green-300' : 'text-red-300'}">$${netIncome.toFixed(2)}</span>
      </div>

      <!-- Summary Stats -->
      <div class="mt-6 grid grid-cols-3 gap-4 text-center">
        <div class="bg-green-50 p-3 rounded-lg">
          <div class="text-xs text-gray-600">Gross Margin</div>
          <div class="text-lg font-bold text-green-600">${totalRevenue > 0 ? ((grossProfit / totalRevenue) * 100).toFixed(1) : '0.0'}%</div>
        </div>
        <div class="bg-blue-50 p-3 rounded-lg">
          <div class="text-xs text-gray-600">Operating Margin</div>
          <div class="text-lg font-bold text-blue-600">${totalRevenue > 0 ? ((operatingIncome / totalRevenue) * 100).toFixed(1) : '0.0'}%</div>
        </div>
        <div class="bg-purple-50 p-3 rounded-lg">
          <div class="text-xs text-gray-600">Net Margin</div>
          <div class="text-lg font-bold text-purple-600">${totalRevenue > 0 ? ((netIncome / totalRevenue) * 100).toFixed(1) : '0.0'}%</div>
        </div>
      </div>

      <div class="mt-6 text-xs text-gray-500 text-center">
        Generated on ${new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })} at ${new Date().toLocaleTimeString('en-US')}
      </div>
    </div>
  `;

  document.getElementById('plReportContent').innerHTML = reportHTML;
}

// Get period label for P&L report
function getPeriodLabel(periodFilter) {
  const now = new Date();
  const year = now.getFullYear();

  switch (periodFilter) {
    case 'current-year':
      return `For the Year Ending December 31, ${year}`;
    case 'q1':
      return `Q1 ${year} (January - March)`;
    case 'q2':
      return `Q2 ${year} (April - June)`;
    case 'q3':
      return `Q3 ${year} (July - September)`;
    case 'q4':
      return `Q4 ${year} (October - December)`;
    case 'current-month':
      return `For ${now.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`;
    case 'last-month':
      const lastMonth = new Date(year, now.getMonth() - 1, 1);
      return `For ${lastMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`;
    case 'all':
      return 'All Time (Inception to Date)';
    default:
      return periodFilter;
  }
}

// Export P&L Report as PDF (placeholder - would need library)
function exportPLReportPDF() {
  toast('üí° PDF export coming soon! For now, use Print (Ctrl+P) to save as PDF', false);
}

// Import Square statement data
async function importSquareStatements() {
  // Confirm with user - this will replace ALL existing transactions
  if (!confirm('‚ö†Ô∏è This will REPLACE all existing financial data with 96 transactions from Square statements (April-October 2025).\n\nThis action cannot be undone.\n\nContinue?')) {
    return;
  }

  try {
    console.log('üì• Importing Square statement data...');
    toast('üì• Importing Square data...', true);

    // All transactions from April-October 2025
    const rawTransactions = [
      // April 2025
      { date: '2025-04-03', description: 'Card payment', activityType: 'Sales', amount: 242.45, balance: 242.45 },
      { date: '2025-04-04', description: '2 Activities', activityType: 'Sales', amount: 1358.80, balance: 1601.25 },
      { date: '2025-04-05', description: 'Hostinger Hostinger.c', activityType: 'Card spend', amount: -22.34, balance: 1578.91 },
      { date: '2025-04-08', description: 'Hostinger Hostinger.c', activityType: 'Card spend', amount: -52.07, balance: 1526.84 },
      { date: '2025-04-08', description: '2 Activities', activityType: 'Sales', amount: 727.65, balance: 2254.49 },
      { date: '2025-04-13', description: 'Amazon', activityType: 'Card spend', amount: -40.30, balance: 2214.19 },
      { date: '2025-04-17', description: 'Card payment', activityType: 'Sales', amount: 242.45, balance: 2456.64 },
      { date: '2025-04-21', description: 'Amazon', activityType: 'Card spend', amount: -68.04, balance: 2388.60 },
      { date: '2025-04-21', description: 'Card payment', activityType: 'Sales', amount: 242.45, balance: 2631.05 },
      { date: '2025-04-22', description: 'Xero Us Inv', activityType: 'Card spend', amount: -2.00, balance: 2629.05 },
      { date: '2025-04-22', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 3114.25 },
      { date: '2025-04-22', description: 'Struc Marke', activityType: 'Card spend', amount: -2030.68, balance: 1083.57 },
      { date: '2025-04-23', description: 'Card payment', activityType: 'Sales', amount: 442.72, balance: 1526.29 },
      { date: '2025-04-24', description: 'Card payment', activityType: 'Sales', amount: 291.00, balance: 1817.29 },
      { date: '2025-04-28', description: 'Card payment', activityType: 'Sales', amount: 970.70, balance: 2787.99 },
      { date: '2025-04-29', description: 'USPS', activityType: 'Card spend', amount: -3.43, balance: 2784.56 },

      // May 2025
      { date: '2025-05-01', description: 'Openai Chatgpt Subscr', activityType: 'Card spend', amount: -21.75, balance: 2762.81 },
      { date: '2025-05-03', description: 'Usps.com Every Door Dt', activityType: 'Card spend', amount: -1023.35, balance: 1739.46 },
      { date: '2025-05-04', description: 'USPS', activityType: 'Card spend', amount: -1098.50, balance: 640.96 },
      { date: '2025-05-05', description: 'Amazon', activityType: 'Card spend', amount: -74.98, balance: 565.98 },
      { date: '2025-05-07', description: 'Xai Llc', activityType: 'Card spend', amount: -30.00, balance: 535.98 },
      { date: '2025-05-14', description: 'Card payment', activityType: 'Sales', amount: 483.20, balance: 1019.18 },
      { date: '2025-05-15', description: '3 Activities', activityType: 'Sales', amount: 1237.12, balance: 2256.30 },
      { date: '2025-05-16', description: 'Square Paid Services', activityType: 'Card spend', amount: -11.93, balance: 2244.37 },
      { date: '2025-05-19', description: 'Xero Us Inv', activityType: 'Card spend', amount: -2.00, balance: 2242.37 },
      { date: '2025-05-20', description: '2 Activities', activityType: 'Sales', amount: 970.40, balance: 3212.77 },
      { date: '2025-05-22', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 3697.97 },
      { date: '2025-05-26', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 4377.37 },
      { date: '2025-05-29', description: '4 Over International', activityType: 'Card spend', amount: -1363.63, balance: 3013.74 },

      // June 2025
      { date: '2025-06-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 2991.99 },
      { date: '2025-06-04', description: 'Siteground Hosting', activityType: 'Card spend', amount: -35.88, balance: 2956.11 },
      { date: '2025-06-06', description: 'Usps.com Every Door Dt', activityType: 'Card spend', amount: -1098.50, balance: 1857.61 },
      { date: '2025-06-07', description: 'Xai Llc', activityType: 'Card spend', amount: -30.00, balance: 1827.61 },
      { date: '2025-06-07', description: 'USPS', activityType: 'Card spend', amount: -1023.35, balance: 804.26 },
      { date: '2025-06-11', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 1289.46 },
      { date: '2025-06-16', description: 'Card payment', activityType: 'Sales', amount: 388.10, balance: 1677.56 },
      { date: '2025-06-19', description: 'Xero Us Inv', activityType: 'Card spend', amount: -2.00, balance: 1675.56 },
      { date: '2025-06-20', description: 'Heygen Technology Inc.', activityType: 'Card spend', amount: -20.30, balance: 1655.26 },
      { date: '2025-06-25', description: 'Card payment', activityType: 'Sales', amount: 291.00, balance: 1946.26 },
      { date: '2025-06-26', description: '4 Over International', activityType: 'Card spend', amount: -1322.50, balance: 623.76 },
      { date: '2025-06-29', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 1108.96 },

      // July 2025
      { date: '2025-07-01', description: 'Usps.com Every Door Dt', activityType: 'Card spend', amount: -992.13, balance: 116.83 },
      { date: '2025-07-01', description: '2 Activities', activityType: 'Sales', amount: 1164.60, balance: 1281.43 },
      { date: '2025-07-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 1259.68 },
      { date: '2025-07-02', description: 'USPS', activityType: 'Card spend', amount: -983.43, balance: 276.25 },
      { date: '2025-07-07', description: 'Xai Llc', activityType: 'Card spend', amount: -30.00, balance: 246.25 },
      { date: '2025-07-09', description: 'Zerobounce.com', activityType: 'Card spend', amount: -16.20, balance: 230.05 },
      { date: '2025-07-14', description: 'Card payment', activityType: 'Sales', amount: 266.72, balance: 496.77 },
      { date: '2025-07-15', description: 'Card payment', activityType: 'Sales', amount: 192.93, balance: 689.70 },
      { date: '2025-07-16', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 1174.90 },
      { date: '2025-07-17', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 1854.30 },
      { date: '2025-07-18', description: 'USPS', activityType: 'Card spend', amount: -279.60, balance: 1574.70 },
      { date: '2025-07-18', description: 'Card payment', activityType: 'Sales', amount: 315.27, balance: 1889.97 },
      { date: '2025-07-19', description: 'Xero Us Inv', activityType: 'Card spend', amount: -15.48, balance: 1874.49 },
      { date: '2025-07-19', description: 'USPS', activityType: 'Card spend', amount: -297.39, balance: 1577.10 },
      { date: '2025-07-20', description: 'Heygen Technology Inc.', activityType: 'Card spend', amount: -29.00, balance: 1548.10 },
      { date: '2025-07-22', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 1984.75 },
      { date: '2025-07-29', description: '4 Over International', activityType: 'Card spend', amount: -1378.66, balance: 606.09 },

      // August 2025
      { date: '2025-08-01', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 1091.29 },
      { date: '2025-08-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 1069.54 },
      { date: '2025-08-02', description: 'Card payment', activityType: 'Sales', amount: 339.55, balance: 1409.09 },
      { date: '2025-08-05', description: 'Transfer in', activityType: 'Transfer in', amount: 1000.00, balance: 2409.09 },
      { date: '2025-08-05', description: 'USPS', activityType: 'Card spend', amount: -1205.36, balance: 1203.73 },
      { date: '2025-08-06', description: 'USPS', activityType: 'Card spend', amount: -1125.09, balance: 78.64 },
      { date: '2025-08-07', description: 'Xai Llc', activityType: 'Card spend', amount: -30.00, balance: 48.64 },
      { date: '2025-08-07', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 728.04 },
      { date: '2025-08-09', description: 'Zerobounce.net Saas', activityType: 'Card spend', amount: -18.00, balance: 710.04 },
      { date: '2025-08-20', description: 'Heygen Technology Inc.', activityType: 'Card spend', amount: -29.00, balance: 681.04 },
      { date: '2025-08-21', description: 'Card payment', activityType: 'Sales', amount: 266.72, balance: 947.76 },
      { date: '2025-08-22', description: 'Card payment', activityType: 'Sales', amount: 873.60, balance: 1821.36 },
      { date: '2025-08-25', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 2258.01 },
      { date: '2025-08-27', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 2694.66 },
      { date: '2025-08-29', description: '4 Over International', activityType: 'Card spend', amount: -1378.01, balance: 1316.65 },

      // September 2025
      { date: '2025-09-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 1294.90 },
      { date: '2025-09-03', description: 'Card payment', activityType: 'Sales', amount: 1026.04, balance: 2320.94 },
      { date: '2025-09-08', description: 'Transfer in', activityType: 'Transfer in', amount: 200.00, balance: 2520.94 },
      { date: '2025-09-08', description: 'USPS', activityType: 'Card spend', amount: -1116.93, balance: 1404.01 },
      { date: '2025-09-09', description: 'Card payment', activityType: 'Sales', amount: 164.77, balance: 1568.78 },
      { date: '2025-09-09', description: 'USPS', activityType: 'Card spend', amount: -1233.02, balance: 335.76 },
      { date: '2025-09-13', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 1015.16 },
      { date: '2025-09-15', description: 'Card payment', activityType: 'Sales', amount: 659.98, balance: 1675.14 },
      { date: '2025-09-17', description: 'Card payment', activityType: 'Sales', amount: 450.00, balance: 2125.14 },
      { date: '2025-09-19', description: 'Card payment', activityType: 'Sales', amount: 315.27, balance: 2440.41 },
      { date: '2025-09-22', description: 'Card payment', activityType: 'Sales', amount: 339.55, balance: 2779.96 },
      { date: '2025-09-26', description: 'Card payment', activityType: 'Sales', amount: 873.60, balance: 3653.56 },
      { date: '2025-09-30', description: '4 Over International', activityType: 'Card spend', amount: -1378.66, balance: 2274.90 },
      { date: '2025-09-30', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 2711.55 },

      // October 2025
      { date: '2025-10-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 2689.80 },
      { date: '2025-10-02', description: 'Card payment', activityType: 'Sales', amount: 242.45, balance: 2932.25 },
      { date: '2025-10-06', description: 'USPS', activityType: 'Card spend', amount: -1116.44, balance: 1815.81 },
      { date: '2025-10-07', description: 'USPS', activityType: 'Card spend', amount: -1233.77, balance: 582.04 },
      { date: '2025-10-21', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 1018.69 },
      { date: '2025-10-22', description: 'Card payment', activityType: 'Sales', amount: 786.21, balance: 1804.90 },
      { date: '2025-10-24', description: 'Card payment', activityType: 'Sales', amount: 388.10, balance: 2193.00 },
      { date: '2025-10-27', description: 'Card payment', activityType: 'Sales', amount: 315.27, balance: 2508.27 },
      { date: '2025-10-30', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 3187.67 }
    ];

    // Process and categorize each transaction
    const transactions = rawTransactions.map((trans, index) => {
      const cat = autoCategorizeTransaction(trans.description, trans.activityType, trans.amount);

      return {
        id: `sq-${Date.now()}-${index}`,
        date: trans.date,
        description: trans.description,
        amount: trans.amount,
        balance: trans.balance,
        type: cat.type,
        category: cat.category,
        subcategory: cat.subcategory,
        notes: `Imported from Square statement - ${trans.activityType}`,
        source: 'square_import'
      };
    });

    // Add to financial state
    financialState.transactions = transactions;
    financialState.loaded = true;

    // Save to Supabase
    await saveFinancialData();

    // Render
    renderFinancialRegister();

    console.log(`‚úÖ Imported ${transactions.length} transactions from Square statements`);
    toast(`‚úÖ Imported ${transactions.length} transactions!`, true);

  } catch (err) {
    console.error('Error importing Square statements:', err);
    toast('‚ö†Ô∏è Failed to import statements', false);
  }
}

function updateBreadcrumbHighlight(tabName) {
  const breadcrumbContainer = document.getElementById('workflowBreadcrumb');
  if (!breadcrumbContainer) return;

  // Map tab names to breadcrumb IDs
  const tabToBreadcrumb = {
    'lead-generation': 'breadcrumb-generator',
    'prospects': 'breadcrumb-pool',
    'pipeline': 'breadcrumb-pipeline',
    'clients': 'breadcrumb-clients'
  };

  // Hide breadcrumb on non-workflow tabs
  const workflowTabs = ['lead-generation', 'prospects', 'pipeline', 'clients'];
  if (!workflowTabs.includes(tabName)) {
    breadcrumbContainer.parentElement.style.display = 'none';
    return;
  }

  // Show breadcrumb on workflow tabs
  breadcrumbContainer.parentElement.style.display = 'block';

  // Remove active state from all breadcrumb buttons
  document.querySelectorAll('[id^="breadcrumb-"]').forEach(btn => {
    btn.classList.remove('bg-white', 'shadow-lg', 'ring-2', 'ring-indigo-500');
    btn.classList.add('hover:bg-white', 'hover:shadow-md');
  });

  // Add active state to current step
  const breadcrumbId = tabToBreadcrumb[tabName];
  if (breadcrumbId) {
    const activeBreadcrumb = document.getElementById(breadcrumbId);
    if (activeBreadcrumb) {
      activeBreadcrumb.classList.remove('hover:bg-white', 'hover:shadow-md');
      activeBreadcrumb.classList.add('bg-white', 'shadow-lg', 'ring-2', 'ring-indigo-500');
    }
  }
}

function showProspectSuccessModal(categorizedResults, totalCount) {
  // Create modal if it doesn't exist
  let modal = document.getElementById('prospectSuccessModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'prospectSuccessModal';
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4';
    modal.style.display = 'none';
    document.body.appendChild(modal);
  }

  // Build category breakdown HTML
  const categoryHTML = Object.entries(categorizedResults)
    .map(([category, count]) => `
      <div class="flex items-center justify-between py-2 border-b border-green-100">
        <span class="text-gray-700 font-medium capitalize">${category}</span>
        <span class="text-2xl font-black text-green-600">${count}</span>
      </div>
    `).join('');

  modal.innerHTML = `
    <div class="bg-white rounded-3xl shadow-2xl max-w-lg w-full max-h-[90vh] overflow-y-auto p-8 relative animate-bounce-in">
      <button onclick="closeProspectSuccessModal()" class="sticky top-0 right-0 float-right text-gray-400 hover:text-gray-600 transition z-10 bg-white rounded-full p-1 -mt-2 -mr-2">
        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
          <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
        </svg>
      </button>

      <div class="text-center mb-6">
        <div class="text-6xl mb-4">üéâ</div>
        <h3 class="text-3xl font-black text-gray-900 mb-2">Success!</h3>
        <p class="text-lg text-gray-600">Found <span class="text-green-600 font-black">${totalCount}</span> businesses!</p>
      </div>

      <div class="bg-green-50 rounded-2xl p-4 mb-6 max-h-60 overflow-y-auto">
        <h4 class="text-base font-bold text-gray-900 mb-3 sticky top-0 bg-green-50">Category Breakdown:</h4>
        ${categoryHTML}
      </div>

      <div class="flex gap-3 sticky bottom-0 bg-white pt-4">
        <button onclick="closeProspectSuccessModal(); switchTab('clients'); setTimeout(() => renderProspectPool(), 100);" class="flex-1 px-4 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 text-white rounded-xl hover:from-indigo-700 hover:to-purple-700 font-black text-base shadow-xl transform hover:scale-105 transition">
          View Businesses ‚Üí
        </button>
        <button onclick="closeProspectSuccessModal();" class="px-4 py-3 bg-gray-200 text-gray-700 rounded-xl hover:bg-gray-300 font-bold transition">
          Generate More
        </button>
      </div>
    </div>
  `;

  // Add bounce-in animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes bounce-in {
      0% { transform: scale(0.3); opacity: 0; }
      50% { transform: scale(1.05); }
      70% { transform: scale(0.9); }
      100% { transform: scale(1); opacity: 1; }
    }
    .animate-bounce-in {
      animation: bounce-in 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
  `;
  if (!document.getElementById('successModalStyle')) {
    style.id = 'successModalStyle';
    document.head.appendChild(style);
  }

  modal.style.display = 'flex';

  // Close on backdrop click
  modal.onclick = (e) => {
    if (e.target === modal) {
      closeProspectSuccessModal();
    }
  };

  // Close on ESC key
  const escHandler = (e) => {
    if (e.key === 'Escape') {
      closeProspectSuccessModal();
      document.removeEventListener('keydown', escHandler);
    }
  };
  document.addEventListener('keydown', escHandler);
}

function closeProspectSuccessModal() {
  const modal = document.getElementById('prospectSuccessModal');
  if (modal) {
    modal.style.display = 'none';
  }
}

// ========== PROSPECT REVIEW MODAL ==========
// Stores pending prospects for review before adding to pool
let pendingProspectsForReview = [];

function showProspectReviewModal(businesses, categorizedResults) {
  pendingProspectsForReview = businesses;

  // Create modal if it doesn't exist
  let modal = document.getElementById('prospectReviewModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'prospectReviewModal';
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4';
    modal.style.display = 'none';
    document.body.appendChild(modal);
  }

  // Group businesses by category for display
  const byCategory = {};
  businesses.forEach(b => {
    const cat = b.category || 'Other';
    if (!byCategory[cat]) byCategory[cat] = [];
    byCategory[cat].push(b);
  });

  // Build business list HTML
  let businessListHTML = '';
  Object.keys(byCategory).sort().forEach(category => {
    const catBusinesses = byCategory[category];
    businessListHTML += `
      <div class="mb-4">
        <div class="flex items-center justify-between bg-gray-100 px-3 py-2 rounded-lg mb-2">
          <span class="font-bold text-gray-800 capitalize">${category}</span>
          <span class="text-sm text-gray-500">${catBusinesses.length} found</span>
        </div>
        <div class="space-y-2 pl-2">
    `;
    catBusinesses.forEach((business, idx) => {
      const uniqueId = `review-${business.placeId || idx}`;
      businessListHTML += `
        <label class="flex items-start gap-3 p-2 hover:bg-gray-50 rounded cursor-pointer group">
          <input type="checkbox" id="${uniqueId}" data-place-id="${business.placeId}" checked
                 class="review-prospect-checkbox mt-1 rounded text-green-600 focus:ring-green-500">
          <div class="flex-1 min-w-0">
            <div class="font-medium text-gray-900 truncate">${business.name}</div>
            <div class="text-sm text-gray-500 truncate">${business.address || business.vicinity || 'No address'}</div>
            ${business.phone ? `<div class="text-xs text-gray-400">${business.phone}</div>` : ''}
          </div>
          ${business.rating ? `<div class="text-sm text-yellow-600">‚òÖ ${business.rating}</div>` : ''}
        </label>
      `;
    });
    businessListHTML += `</div></div>`;
  });

  modal.innerHTML = `
    <div class="bg-white rounded-3xl shadow-2xl max-w-2xl w-full max-h-[90vh] flex flex-col relative animate-bounce-in">
      <!-- Header -->
      <div class="p-6 border-b border-gray-200">
        <button onclick="closeProspectReviewModal()" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition">
          <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
          </svg>
        </button>
        <div class="text-center">
          <div class="text-4xl mb-2">üîç</div>
          <h3 class="text-2xl font-black text-gray-900">Review Found Prospects</h3>
          <p class="text-gray-600 mt-1">Found <span class="text-green-600 font-bold">${businesses.length}</span> businesses. Uncheck any you don't want to add.</p>
        </div>
        <div class="flex items-center justify-center gap-4 mt-4">
          <button onclick="toggleAllReviewProspects(true)" class="text-sm text-indigo-600 hover:text-indigo-800 font-medium">Select All</button>
          <span class="text-gray-300">|</span>
          <button onclick="toggleAllReviewProspects(false)" class="text-sm text-indigo-600 hover:text-indigo-800 font-medium">Deselect All</button>
          <span class="text-gray-300">|</span>
          <span id="reviewSelectedCount" class="text-sm text-gray-500">${businesses.length} selected</span>
        </div>
      </div>

      <!-- Scrollable Content -->
      <div class="flex-1 overflow-y-auto p-6">
        ${businessListHTML}
      </div>

      <!-- Footer -->
      <div class="p-6 border-t border-gray-200 bg-gray-50 rounded-b-3xl">
        <div class="flex gap-3">
          <button onclick="confirmProspectReview()" id="btnConfirmReview" class="flex-1 px-4 py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-xl hover:from-green-600 hover:to-emerald-700 font-black text-base shadow-lg transform hover:scale-105 transition">
            ‚úì Add Selected to Pool
          </button>
          <button onclick="closeProspectReviewModal()" class="px-4 py-3 bg-gray-200 text-gray-700 rounded-xl hover:bg-gray-300 font-bold transition">
            Cancel
          </button>
        </div>
        <p class="text-xs text-gray-400 text-center mt-2">Unchecked businesses will be marked as "Not Interested"</p>
      </div>
    </div>
  `;

  modal.style.display = 'flex';

  // Add event listeners for checkboxes to update count
  setTimeout(() => {
    document.querySelectorAll('.review-prospect-checkbox').forEach(cb => {
      cb.addEventListener('change', updateReviewSelectedCount);
    });
  }, 100);

  // Close on backdrop click
  modal.onclick = (e) => {
    if (e.target === modal) {
      closeProspectReviewModal();
    }
  };
}

function closeProspectReviewModal() {
  const modal = document.getElementById('prospectReviewModal');
  if (modal) {
    modal.style.display = 'none';
  }
  pendingProspectsForReview = [];
}

function toggleAllReviewProspects(selectAll) {
  document.querySelectorAll('.review-prospect-checkbox').forEach(cb => {
    cb.checked = selectAll;
  });
  updateReviewSelectedCount();
}

function updateReviewSelectedCount() {
  const total = document.querySelectorAll('.review-prospect-checkbox').length;
  const selected = document.querySelectorAll('.review-prospect-checkbox:checked').length;
  const countEl = document.getElementById('reviewSelectedCount');
  if (countEl) {
    countEl.textContent = `${selected} of ${total} selected`;
  }

  // Update button text
  const btn = document.getElementById('btnConfirmReview');
  if (btn) {
    btn.textContent = selected > 0 ? `‚úì Add ${selected} to Pool` : 'Skip All';
  }
}

async function confirmProspectReview() {
  const checkboxes = document.querySelectorAll('.review-prospect-checkbox');
  const selectedPlaceIds = new Set();
  const rejectedPlaceIds = new Set();

  checkboxes.forEach(cb => {
    const placeId = cb.dataset.placeId;
    if (placeId) {
      if (cb.checked) {
        selectedPlaceIds.add(placeId);
      } else {
        rejectedPlaceIds.add(placeId);
      }
    }
  });

  // Add rejected prospects to "Not Interested" list
  if (rejectedPlaceIds.size > 0) {
    const rejectedBusinesses = pendingProspectsForReview.filter(b => rejectedPlaceIds.has(b.placeId));

    rejectedBusinesses.forEach(business => {
      if (!notInterestedState.placeIds.has(business.placeId)) {
        notInterestedState.placeIds.add(business.placeId);
        notInterestedState.businesses[business.placeId] = {
          placeId: business.placeId,
          name: business.name,
          removedAt: new Date().toISOString()
        };
      }
    });

    // Save to localStorage and cloud
    saveNotInterestedList();

    console.log(`üö´ Marked ${rejectedPlaceIds.size} prospects as "Not Interested"`);
  }

  // Remove rejected prospects from the cache
  if (rejectedPlaceIds.size > 0) {
    Object.keys(placesCache.searches).forEach(cacheKey => {
      const cached = placesCache.searches[cacheKey];
      if (cached.cachedData) {
        cached.cachedData = cached.cachedData.filter(b => !rejectedPlaceIds.has(b.placeId));
      }
    });
    await savePlacesCache();
  }

  const selectedCount = selectedPlaceIds.size;
  const rejectedCount = rejectedPlaceIds.size;

  closeProspectReviewModal();

  // Show brief success message
  if (selectedCount > 0) {
    toast(`‚úÖ Added ${selectedCount} prospects to pool${rejectedCount > 0 ? `, skipped ${rejectedCount}` : ''}`, true);
  } else {
    toast(`Skipped all ${rejectedCount} prospects`, true);
  }

  // Track that user generated prospects (for Getting Started checklist)
  if (selectedCount > 0) {
    markGettingStartedComplete('generate_prospects');
  }

  // Switch to Businesses tab to show discovered prospects
  setTimeout(() => {
    switchTab('clients');
    setTimeout(() => renderProspectPool(), 100);
  }, 500);
}

// Expose review modal functions globally
window.showProspectReviewModal = showProspectReviewModal;
window.closeProspectReviewModal = closeProspectReviewModal;
window.toggleAllReviewProspects = toggleAllReviewProspects;
window.confirmProspectReview = confirmProspectReview;

// ========== ONBOARDING WIZARD ==========
let onboardingStep = 1;
const ONBOARDING_COMPLETED_KEY = '9x12_onboarding_completed';

// Check if should show onboarding on page load
function checkOnboarding() {
  const completed = localStorage.getItem(ONBOARDING_COMPLETED_KEY);
  if (!completed) {
    // Show onboarding after a short delay to let the app load
    setTimeout(() => {
      showOnboarding();
    }, 1000);
  }
}

// Show the onboarding modal
function showOnboarding() {
  const modal = document.getElementById('onboardingModal');
  if (modal) {
    modal.classList.remove('hidden');
    onboardingStep = 1;
    updateOnboardingUI();
  }
}

// Update the onboarding UI for current step
function updateOnboardingUI() {
  // Hide all steps
  document.querySelectorAll('.onboarding-step').forEach(step => {
    step.classList.add('hidden');
  });

  // Show current step
  const currentStep = document.querySelector(`[data-onboarding-step="${onboardingStep}"]`);
  if (currentStep) {
    currentStep.classList.remove('hidden');
  }

  // Update dots
  for (let i = 1; i <= 3; i++) {
    const dot = document.getElementById(`onboardingDot${i}`);
    if (dot) {
      if (i <= onboardingStep) {
        dot.classList.remove('bg-gray-300');
        dot.classList.add('bg-indigo-600');
      } else {
        dot.classList.remove('bg-indigo-600');
        dot.classList.add('bg-gray-300');
      }
    }
  }

  // Update button text
  const nextBtn = document.getElementById('onboardingNextBtn');
  if (nextBtn) {
    nextBtn.textContent = onboardingStep === 3 ? 'Get Started!' : 'Next ‚Üí';
  }
}

// Move to next onboarding step
function nextOnboardingStep() {
  if (onboardingStep < 3) {
    onboardingStep++;
    updateOnboardingUI();
  } else {
    completeOnboarding();
  }
}

// Skip onboarding
function skipOnboarding() {
  completeOnboarding();
}

// Complete onboarding and close modal
function completeOnboarding() {
  localStorage.setItem(ONBOARDING_COMPLETED_KEY, 'true');
  const modal = document.getElementById('onboardingModal');
  if (modal) {
    modal.classList.add('hidden');
  }
  toast('Welcome to 9x12 Pro! üéâ', true);
}

// Reset onboarding (for testing)
function resetOnboarding() {
  localStorage.removeItem(ONBOARDING_COMPLETED_KEY);
  toast('Onboarding reset. Refresh to see it again.', true);
}

// Expose onboarding functions globally
window.showOnboarding = showOnboarding;
window.nextOnboardingStep = nextOnboardingStep;
window.skipOnboarding = skipOnboarding;
window.resetOnboarding = resetOnboarding;

// Check onboarding on DOMContentLoaded
document.addEventListener('DOMContentLoaded', function() {
  // Delay check to let app fully load
  setTimeout(checkOnboarding, 2000);
});

// ============================================
// ADMIN UTILITIES (run from browser console)
// ============================================

// Show all businesses in a ZIP code and let user mark them as clients
window.markClientsInZip = async function(zipCode = '14072') {
  console.log(`\nüîç Finding businesses in ZIP ${zipCode}...\n`);

  // Gather all businesses from all sources
  const allBusinesses = [];

  // From crmState.clients
  Object.values(crmState.clients || {}).forEach(client => {
    const zip = client.zipCode || client.town || '';
    if (zip.includes(zipCode)) {
      allBusinesses.push({
        source: 'clients',
        id: client.id,
        name: client.businessName,
        zip: zip,
        phone: client.contact?.phone || client.phone || '',
        isClient: true,
        data: client
      });
    }
  });

  // From campaign boards
  if (campaignBoardsState?.boards) {
    Object.values(campaignBoardsState.boards).forEach(board => {
      if (board.columns) {
        Object.values(board.columns).forEach(column => {
          column.forEach(prospect => {
            const zip = prospect.zipCode || prospect.town || prospect.actualZip || '';
            if (zip.includes(zipCode)) {
              const alreadyAdded = allBusinesses.some(b =>
                b.name?.toLowerCase() === (prospect.businessName || prospect.name || '').toLowerCase()
              );
              if (!alreadyAdded) {
                allBusinesses.push({
                  source: 'campaign',
                  id: prospect.id,
                  name: prospect.businessName || prospect.name,
                  zip: zip,
                  phone: prospect.phone || '',
                  isClient: false,
                  data: prospect
                });
              }
            }
          });
        });
      }
    });
  }

  // From prospect pool
  (prospectPoolState?.manualProspects || []).forEach(prospect => {
    const zip = prospect.zipCode || prospect.town || prospect.actualZip || '';
    if (zip.includes(zipCode)) {
      const alreadyAdded = allBusinesses.some(b =>
        b.name?.toLowerCase() === (prospect.businessName || prospect.name || '').toLowerCase()
      );
      if (!alreadyAdded) {
        allBusinesses.push({
          source: 'prospect',
          id: prospect.id,
          name: prospect.businessName || prospect.name,
          zip: zip,
          phone: prospect.phone || '',
          isClient: false,
          data: prospect
        });
      }
    }
  });

  console.log(`Found ${allBusinesses.length} businesses in ZIP ${zipCode}:\n`);

  // Display as a table
  const tableData = allBusinesses.map((b, i) => ({
    '#': i,
    'Name': b.name?.substring(0, 40) || 'Unknown',
    'Phone': b.phone || '-',
    'Source': b.source,
    'Is Client': b.isClient ? '‚úÖ YES' : '‚ùå NO'
  }));

  console.table(tableData);

  console.log('\nüìã To mark businesses as clients, run:');
  console.log('   convertToClients([0, 1, 5])  // Pass array of row numbers from table above\n');

  // Store for the conversion function
  window._adminBusinessList = allBusinesses;

  return allBusinesses;
};

// Convert selected businesses to clients
window.convertToClients = async function(indices) {
  if (!window._adminBusinessList) {
    console.log('‚ùå Run markClientsInZip() first to see the list');
    return;
  }

  if (!Array.isArray(indices) || indices.length === 0) {
    console.log('‚ùå Pass an array of row numbers, e.g.: convertToClients([0, 1, 5])');
    return;
  }

  let converted = 0;

  for (const idx of indices) {
    const business = window._adminBusinessList[idx];
    if (!business) {
      console.log(`‚ö†Ô∏è Invalid index: ${idx}`);
      continue;
    }

    if (business.isClient) {
      console.log(`‚è≠Ô∏è "${business.name}" is already a client`);
      continue;
    }

    // Create client record
    const clientId = business.data.placeId || business.id || Date.now().toString();
    const clientData = {
      id: clientId,
      placeId: business.data.placeId || null,
      businessName: business.name,
      category: business.data.category || '',
      status: 'active',
      contact: {
        name: business.data.contactName || business.data.ownerName || '',
        firstName: '',
        phone: business.data.phone || '',
        email: business.data.email || ''
      },
      phone: business.data.phone || '',
      email: business.data.email || '',
      website: business.data.website || '',
      facebook: business.data.facebook || '',
      instagram: business.data.instagram || '',
      address: business.data.address || business.data.fullAddress || '',
      zipCode: business.zip,
      monthlyPrice: 0,
      history: [],
      lifetime: { totalSpent: 0, cardsBought: 0 },
      interactions: business.data.interactions || [],
      convertedAt: new Date().toISOString()
    };

    crmState.clients[clientId] = clientData;
    converted++;
    console.log(`‚úÖ Converted: "${business.name}"`);
  }

  if (converted > 0) {
    await saveClients();
    console.log(`\nüéâ Converted ${converted} businesses to clients!`);
    console.log('Refreshing client list...');
    renderClientList();
  }

  // Clear the temp list
  window._adminBusinessList = null;
};

// Quick function to list current clients
window.listClients = function() {
  const clients = Object.values(crmState.clients || {});
  console.log(`\nüìã Current Clients (${clients.length} total):\n`);
  console.table(clients.map(c => ({
    'Name': c.businessName?.substring(0, 35) || 'Unknown',
    'ZIP': c.zipCode || c.town || '-',
    'Phone': c.contact?.phone || c.phone || '-',
    'Monthly': c.monthlyPrice ? `$${c.monthlyPrice}` : '-',
    'Status': c.status || 'active'
  })));
};

// Show a visual modal to select clients from a ZIP code
window.showClientSelector = function(zipCode = '14072') {
  // Gather all businesses (same logic as markClientsInZip)
  const allBusinesses = [];
  const seenNames = new Set();

  // From crmState.clients
  Object.values(crmState.clients || {}).forEach(client => {
    const zip = client.zipCode || client.town || '';
    if (zip.includes(zipCode)) {
      const normalizedName = (client.businessName || '').toLowerCase().split(/[‚Ä¢¬∑‚óè|:\-‚Äì‚Äî]/)[0].trim();
      if (!seenNames.has(normalizedName)) {
        seenNames.add(normalizedName);
        allBusinesses.push({
          id: client.id,
          name: client.businessName,
          phone: client.contact?.phone || client.phone || '',
          isClient: true,
          data: client
        });
      }
    }
  });

  // From campaign boards
  if (campaignBoardsState?.boards) {
    Object.values(campaignBoardsState.boards).forEach(board => {
      if (board.columns) {
        Object.values(board.columns).forEach(column => {
          column.forEach(prospect => {
            const zip = prospect.zipCode || prospect.town || prospect.actualZip || '';
            if (zip.includes(zipCode)) {
              const name = prospect.businessName || prospect.name || '';
              const normalizedName = name.toLowerCase().split(/[‚Ä¢¬∑‚óè|:\-‚Äì‚Äî]/)[0].trim();
              if (!seenNames.has(normalizedName)) {
                seenNames.add(normalizedName);
                allBusinesses.push({
                  id: prospect.id,
                  name: name,
                  phone: prospect.phone || '',
                  isClient: false,
                  data: prospect
                });
              }
            }
          });
        });
      }
    });
  }

  // From prospect pool
  (prospectPoolState?.manualProspects || []).forEach(prospect => {
    const zip = prospect.zipCode || prospect.town || prospect.actualZip || '';
    if (zip.includes(zipCode)) {
      const name = prospect.businessName || prospect.name || '';
      const normalizedName = name.toLowerCase().split(/[‚Ä¢¬∑‚óè|:\-‚Äì‚Äî]/)[0].trim();
      if (!seenNames.has(normalizedName)) {
        seenNames.add(normalizedName);
        allBusinesses.push({
          id: prospect.id,
          name: name,
          phone: prospect.phone || '',
          isClient: false,
          data: prospect
        });
      }
    }
  });

  // Sort alphabetically
  allBusinesses.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

  // Build modal HTML
  const modalHTML = `
    <div id="clientSelectorModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[9999]" onclick="if(event.target === this) this.remove()">
      <div class="bg-white rounded-xl shadow-2xl max-w-2xl w-full mx-4 max-h-[85vh] flex flex-col" onclick="event.stopPropagation()">
        <div class="p-4 border-b bg-gradient-to-r from-green-600 to-emerald-600 text-white rounded-t-xl">
          <div class="flex justify-between items-center">
            <div>
              <h3 class="font-bold text-lg">Select Your Clients in ${zipCode}</h3>
              <p class="text-sm text-white/80">${allBusinesses.length} businesses found - check the ones that are clients</p>
            </div>
            <button onclick="document.getElementById('clientSelectorModal').remove()" class="text-white/80 hover:text-white text-2xl">&times;</button>
          </div>
        </div>

        <div class="p-4 overflow-y-auto flex-1">
          <div class="space-y-2">
            ${allBusinesses.map((b, i) => `
              <label class="flex items-center gap-3 p-3 rounded-lg border ${b.isClient ? 'bg-green-50 border-green-300' : 'bg-white border-gray-200 hover:bg-gray-50'} cursor-pointer">
                <input type="checkbox"
                  class="client-selector-checkbox w-5 h-5 text-green-600 rounded"
                  data-index="${i}"
                  ${b.isClient ? 'checked disabled' : ''}>
                <div class="flex-1 min-w-0">
                  <div class="font-medium text-gray-900 ${b.isClient ? 'text-green-700' : ''}">${b.name || 'Unknown'}</div>
                  <div class="text-sm text-gray-500">${b.phone || 'No phone'}</div>
                </div>
                ${b.isClient ? '<span class="text-xs px-2 py-1 bg-green-200 text-green-800 rounded-full font-medium">Already Client</span>' : ''}
              </label>
            `).join('')}
          </div>
        </div>

        <div class="p-4 border-t bg-gray-50 rounded-b-xl flex justify-between items-center">
          <div class="text-sm text-gray-600">
            <span id="selectedCount">0</span> selected
          </div>
          <div class="flex gap-2">
            <button onclick="document.getElementById('clientSelectorModal').remove()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
            <button onclick="saveSelectedClients()" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium">Save as Clients</button>
          </div>
        </div>
      </div>
    </div>
  `;

  // Store businesses for the save function
  window._selectorBusinesses = allBusinesses;

  // Remove existing modal if any
  const existing = document.getElementById('clientSelectorModal');
  if (existing) existing.remove();

  // Add modal to DOM
  document.body.insertAdjacentHTML('beforeend', modalHTML);

  // Add change listener to update count
  document.querySelectorAll('.client-selector-checkbox:not([disabled])').forEach(cb => {
    cb.addEventListener('change', updateSelectedCount);
  });
};

function updateSelectedCount() {
  const checked = document.querySelectorAll('.client-selector-checkbox:checked:not([disabled])').length;
  const countEl = document.getElementById('selectedCount');
  if (countEl) countEl.textContent = checked;
}

async function saveSelectedClients() {
  const checkboxes = document.querySelectorAll('.client-selector-checkbox:checked:not([disabled])');
  const businesses = window._selectorBusinesses;

  if (!businesses || checkboxes.length === 0) {
    toast('No businesses selected', false);
    return;
  }

  let converted = 0;
  for (const cb of checkboxes) {
    const idx = parseInt(cb.dataset.index);
    const business = businesses[idx];
    if (!business || business.isClient) continue;

    // Create client record
    const clientId = business.data.placeId || business.id || Date.now().toString() + Math.random();
    const clientData = {
      id: clientId,
      placeId: business.data.placeId || null,
      businessName: business.name,
      category: business.data.category || '',
      status: 'active',
      contact: {
        name: business.data.contactName || business.data.ownerName || '',
        firstName: '',
        phone: business.data.phone || '',
        email: business.data.email || ''
      },
      phone: business.data.phone || '',
      email: business.data.email || '',
      website: business.data.website || '',
      facebook: business.data.facebook || '',
      instagram: business.data.instagram || '',
      address: business.data.address || business.data.fullAddress || '',
      zipCode: business.data.zipCode || business.data.town || '',
      monthlyPrice: 0,
      history: [],
      lifetime: { totalSpent: 0, cardsBought: 0 },
      interactions: business.data.interactions || [],
      convertedAt: new Date().toISOString()
    };

    crmState.clients[clientId] = clientData;
    converted++;
  }

  if (converted > 0) {
    await saveClients();
    toast(`‚úÖ ${converted} businesses marked as clients!`, true);
    renderClientList();
  }

  // Close modal
  document.getElementById('clientSelectorModal')?.remove();
  window._selectorBusinesses = null;
}

// Clean up duplicate clients by merging similar names
window.cleanupDuplicateClients = async function() {
  const clients = Object.entries(crmState.clients);
  console.log(`\nüîç Scanning ${clients.length} clients for duplicates...\n`);

  // Normalize name for comparison (matches renderClientList)
  const normalize = (name) => {
    if (!name) return '';
    // Truncate at separators first
    let n = name.split(/[‚Ä¢¬∑‚óè|:\-‚Äì‚Äî‚ñ∫‚ñ∏‚Ä£‚ÅÉ]/)[0];
    n = n.toLowerCase()
      .replace(/&/g, ' and ')  // Normalize all & to and (with or without spaces)
      .replace(/['''`¬¥",.]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
    // Remove common business suffixes repeatedly (including trailing "and", "of")
    const suffixes = /\s+(and|of|inc|llc|corp|svce?|services?|the|repair|towing?|automobile|automotive|auto|shop|shoppe|community|preschool|pre-school|school|daycare|day care|childcare|center|centre|salon|spa|studio|learning|early childhood)\s*$/gi;
    for (let i = 0; i < 5; i++) {
      n = n.replace(suffixes, '');
    }
    return n.trim();
  };

  // Group by normalized name
  const groups = {};
  clients.forEach(([id, client]) => {
    const normalizedName = normalize(client.businessName);
    if (!groups[normalizedName]) {
      groups[normalizedName] = [];
    }
    groups[normalizedName].push({ id, client });
  });

  // Find duplicates
  const duplicateGroups = Object.entries(groups).filter(([_, arr]) => arr.length > 1);

  if (duplicateGroups.length === 0) {
    console.log('‚úÖ No duplicates found!');
    return;
  }

  console.log(`Found ${duplicateGroups.length} groups of duplicates:\n`);

  let totalMerged = 0;
  let totalDeleted = 0;

  for (const [normalizedName, entries] of duplicateGroups) {
    console.log(`üìã "${entries[0].client.businessName}" has ${entries.length} duplicates:`);
    entries.forEach((e, i) => {
      console.log(`   ${i}: "${e.client.businessName}" (ID: ${e.id.substring(0, 20)}...)`);
    });

    // Find the "best" record (most data)
    const scored = entries.map(e => {
      let score = 0;
      const c = e.client;
      if (c.phone || c.contact?.phone) score += 10;
      if (c.email || c.contact?.email) score += 10;
      if (c.website) score += 5;
      if (c.monthlyPrice > 0) score += 20;
      if (c.contact?.name || c.contact?.firstName) score += 5;
      if ((c.lifetime?.totalSpent || 0) > 0) score += 15;
      if ((c.interactions?.length || 0) > 0) score += 5;
      // Prefer shorter names (less junk in them)
      score -= (c.businessName?.length || 0) / 10;
      return { ...e, score };
    });

    scored.sort((a, b) => b.score - a.score);
    const keeper = scored[0];
    const toDelete = scored.slice(1);

    // Merge data from duplicates into keeper
    for (const dup of toDelete) {
      const k = keeper.client;
      const d = dup.client;

      // Merge contact info (keep non-empty values)
      if (!k.phone && d.phone) k.phone = d.phone;
      if (!k.email && d.email) k.email = d.email;
      if (!k.website && d.website) k.website = d.website;
      if (!k.facebook && d.facebook) k.facebook = d.facebook;
      if (!k.instagram && d.instagram) k.instagram = d.instagram;
      if (!k.address && d.address) k.address = d.address;

      if (k.contact && d.contact) {
        if (!k.contact.phone && d.contact.phone) k.contact.phone = d.contact.phone;
        if (!k.contact.email && d.contact.email) k.contact.email = d.contact.email;
        if (!k.contact.name && d.contact.name) k.contact.name = d.contact.name;
      }

      // Keep higher monthly price
      if ((d.monthlyPrice || 0) > (k.monthlyPrice || 0)) {
        k.monthlyPrice = d.monthlyPrice;
      }

      // Merge lifetime stats
      if (d.lifetime) {
        k.lifetime = k.lifetime || { totalSpent: 0, cardsBought: 0 };
        k.lifetime.totalSpent = Math.max(k.lifetime.totalSpent || 0, d.lifetime.totalSpent || 0);
        k.lifetime.cardsBought = Math.max(k.lifetime.cardsBought || 0, d.lifetime.cardsBought || 0);
      }

      // Merge interactions
      if (d.interactions?.length > 0) {
        k.interactions = k.interactions || [];
        k.interactions.push(...d.interactions);
      }

      // Delete the duplicate
      delete crmState.clients[dup.id];
      totalDeleted++;
    }

    console.log(`   ‚úÖ Kept: "${keeper.client.businessName}", merged ${toDelete.length} duplicate(s)`);
    totalMerged++;
  }

  // Save
  await saveClients();

  console.log(`\nüéâ Cleanup complete!`);
  console.log(`   - ${totalMerged} groups merged`);
  console.log(`   - ${totalDeleted} duplicate records removed`);
  console.log(`   - ${Object.keys(crmState.clients).length} clients remaining\n`);

  // Refresh UI
  renderClientList();

  return { merged: totalMerged, deleted: totalDeleted };
};

// =====================================================
// OUTREACH WORKSHEET FUNCTIONS
// =====================================================

const outreachState = {
  sortBy: 'businessName',
  sortDir: 'asc',
  categoryFilter: '',
  columnFilter: 'attempting', // Default to "Attempting" (column 2)
  selectedProspect: null,
  currentTemplate: 'text'
};

function renderOutreachTable() {
  let prospects = [];

  // Read from Campaign Board (single source of truth)
  const board = getCurrentCampaignBoard();
  if (board && board.columns) {
    if (outreachState.columnFilter === 'all') {
      prospects = [
        ...(board.columns['attempting'] || []),
        ...(board.columns['negotiating'] || []),
        ...(board.columns['invoice-sent'] || []),
        ...(board.columns['proof-approved'] || [])
      ];
    } else {
      prospects = board.columns[outreachState.columnFilter] || [];
    }
  } else {
    showOutreachEmptyState(true, 'Select a campaign first');
    return;
  }

  // Filter to only include objects (not strings/nulls)
  prospects = prospects.filter(p => typeof p === 'object' && p !== null);

  // Populate category filter dropdown
  populateOutreachCategoryFilter(prospects);

  // Apply category filter
  if (outreachState.categoryFilter) {
    prospects = prospects.filter(p => p.category === outreachState.categoryFilter);
  }

  // Sort prospects
  prospects.sort((a, b) => {
    let valA, valB;

    // Contact columns: sort by has/doesn't have
    if (['phone', 'email', 'facebook', 'instagram'].includes(outreachState.sortBy)) {
      const col = outreachState.sortBy;
      valA = !!(a[col] || a.contact?.[col]) ? 1 : 0;
      valB = !!(b[col] || b.contact?.[col]) ? 1 : 0;
      return outreachState.sortDir === 'desc' ? valB - valA : valA - valB;
    }

    // Text columns: alphabetical
    valA = (a[outreachState.sortBy] || '').toString().toLowerCase();
    valB = (b[outreachState.sortBy] || '').toString().toLowerCase();
    return outreachState.sortDir === 'asc'
      ? valA.localeCompare(valB)
      : valB.localeCompare(valA);
  });

  // Update stats
  const statsEl = document.getElementById('outreachStats');
  if (statsEl) {
    const phoneCount = prospects.filter(p => {
      const ph = p.phone || p.contact?.phone || '';
      return ph && String(ph).trim();
    }).length;
    const emailCount = prospects.filter(p => {
      const em = p.email || p.contact?.email || '';
      return em && String(em).trim() && String(em).includes('@');
    }).length;
    statsEl.textContent = `${prospects.length} to contact ‚Ä¢ ${phoneCount} with phone ‚Ä¢ ${emailCount} with email`;
  }

  // Show empty state if no prospects
  if (prospects.length === 0) {
    showOutreachEmptyState(true);
    return;
  }
  showOutreachEmptyState(false);

  // Render rows
  const tbody = document.getElementById('outreachTableBody');
  if (!tbody) return;

  tbody.innerHTML = prospects.map(p => renderOutreachRow(p)).join('');

  // Add click delegation for rows (more reliable than inline onclick)
  tbody.onclick = function(e) {
    const row = e.target.closest('tr[data-prospect-id]');
    if (row) {
      const prospectId = row.dataset.prospectId;
      if (prospectId) {
        selectOutreachProspect(prospectId);
      }
    }
  };

  // Update sort icons
  updateOutreachSortIcons();
}

function renderOutreachRow(prospect) {
  const phone = prospect.phone || prospect.contact?.phone || '';
  const email = prospect.email || prospect.contact?.email || prospect.channelStatus?.email?.address || '';
  const hasPhone = !!(phone && String(phone).trim());
  const hasEmail = !!(email && String(email).trim() && String(email).includes('@'));
  const hasFB = !!(prospect.facebook && String(prospect.facebook).trim());
  const hasIG = !!prospect.instagram && prospect.instagram.trim() !== '';
  const isSelected = outreachState.selectedProspect?.id === prospect.id;

  // Escape HTML helper
  const escapeHtml = (str) => {
    if (!str) return '';
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
  };

  // Safely encode the ID for use in onclick
  const safeId = escapeHtml(String(prospect.id));

  return `
    <tr onclick="selectOutreachProspect('${safeId}')"
        class="cursor-pointer transition-colors ${isSelected ? 'bg-green-100 border-l-4 border-green-500' : 'hover:bg-gray-50'}"
        data-prospect-id="${safeId}">
      <td class="py-2.5 px-3">
        <span class="font-semibold text-gray-900">${escapeHtml(prospect.businessName || 'Unknown')}</span>
      </td>
      <td class="py-2.5 px-3">
        <span class="px-2 py-0.5 bg-indigo-100 text-indigo-700 rounded text-xs font-medium">
          ${escapeHtml((prospect.category || '?').replace(/_/g, ' '))}
        </span>
      </td>
      <td class="py-2.5 px-3 text-center">
        ${hasPhone ? '<span class="text-green-600 font-bold">‚úì</span>' : '<span class="text-gray-300">‚Äî</span>'}
      </td>
      <td class="py-2.5 px-3 text-center">
        ${hasEmail ? '<span class="text-blue-600 font-bold">‚úì</span>' : '<span class="text-gray-300">‚Äî</span>'}
      </td>
      <td class="py-2.5 px-3 text-center">
        ${hasFB ? '<span class="text-blue-600 font-bold">‚úì</span>' : '<span class="text-gray-300">‚Äî</span>'}
      </td>
      <td class="py-2.5 px-3 text-center">
        ${hasIG ? '<span class="text-pink-600 font-bold">‚úì</span>' : '<span class="text-gray-300">‚Äî</span>'}
      </td>
    </tr>
  `;
}

function selectOutreachProspect(prospectId) {
  let prospect = null;
  let prospectColumn = null;

  // Search Campaign Board columns
  const board = getCurrentCampaignBoard();
  if (board && board.columns) {
    const searchCols = ['attempting', 'negotiating', 'invoice-sent', 'proof-approved'];
    for (const colName of searchCols) {
      const items = board.columns[colName] || [];
      const found = items.find(p => typeof p === 'object' && p && String(p.id) === String(prospectId));
      if (found) {
        prospect = found;
        prospectColumn = colName;
        break;
      }
    }
  }

  if (!prospect) return;

  outreachState.selectedProspect = { ...prospect, currentColumn: prospectColumn };

  // Update UI - show panel, hide placeholder
  document.getElementById('outreachNoSelection')?.classList.add('hidden');
  document.getElementById('outreachSelectedPanel')?.classList.remove('hidden');

  // Update prospect info
  const categoryIcons = {
    'restaurant': 'üçΩÔ∏è', 'plumber': 'üîß', 'electrician': '‚ö°', 'hvac': '‚ùÑÔ∏è',
    'landscaping': 'üåø', 'roofing': 'üè†', 'auto repair': 'üöó', 'dentist': 'ü¶∑',
    'salon': 'üíá', 'gym': 'üí™', 'lawyer': '‚öñÔ∏è', 'accountant': 'üìä'
  };
  const icon = categoryIcons[prospect.category?.toLowerCase()] || 'üè¢';

  document.getElementById('outreachSelectedIcon').textContent = icon;
  document.getElementById('outreachSelectedName').textContent = prospect.businessName || 'Unknown';
  document.getElementById('outreachSelectedCategory').textContent = (prospect.category || 'Business').replace(/_/g, ' ');

  // Contact info
  const phone = prospect.phone || prospect.contact?.phone || '';
  const email = prospect.email || prospect.contact?.email || '';
  const cleanPhone = phone.replace(/\D/g, '');
  const displayPhone = cleanPhone.length === 10
    ? `(${cleanPhone.slice(0,3)}) ${cleanPhone.slice(3,6)}-${cleanPhone.slice(6)}`
    : phone || '‚Äî';

  const phoneEl = document.getElementById('outreachSelectedPhone');
  const emailEl = document.getElementById('outreachSelectedEmail');
  const fbEl = document.getElementById('outreachSelectedFB');
  const igEl = document.getElementById('outreachSelectedIG');

  if (phoneEl) {
    phoneEl.textContent = displayPhone;
    phoneEl.href = phone ? `tel:${cleanPhone}` : '#';
    phoneEl.classList.toggle('text-gray-400', !phone);
    phoneEl.classList.toggle('text-green-600', !!phone);
  }
  if (emailEl) {
    emailEl.textContent = email || '‚Äî';
    emailEl.href = email ? `mailto:${email}` : '#';
    emailEl.classList.toggle('text-gray-400', !email);
    emailEl.classList.toggle('text-blue-600', !!email);
  }
  if (fbEl) {
    fbEl.textContent = prospect.facebook ? 'View Page' : '‚Äî';
    fbEl.href = prospect.facebook || '#';
    fbEl.classList.toggle('text-gray-400', !prospect.facebook);
    fbEl.classList.toggle('text-blue-600', !!prospect.facebook);
  }
  if (igEl) {
    igEl.textContent = prospect.instagram ? 'View Profile' : '‚Äî';
    igEl.href = prospect.instagram || '#';
    igEl.classList.toggle('text-gray-400', !prospect.instagram);
    igEl.classList.toggle('text-pink-600', !!prospect.instagram);
  }

  // Update templates with prospect data
  updateOutreachTemplates(prospect);

  // Load notes for this prospect
  const notesEl = document.getElementById('outreachNotes');
  if (notesEl) {
    notesEl.value = loadOutreachNotes(prospect.id);
  }

  // Show phone number in the text template panel
  const phoneDisplay = document.getElementById('outreachTextPhoneNumber');
  if (phoneDisplay) {
    const cleanPhone = phone.replace(/\D/g, '');
    const displayPhone = cleanPhone.length === 10
      ? `(${cleanPhone.slice(0,3)}) ${cleanPhone.slice(3,6)}-${cleanPhone.slice(6)}`
      : (phone || 'No phone on file');
    phoneDisplay.textContent = phone ? `üìû ${displayPhone}` : 'No phone on file';
  }

  // Re-render table to show selection highlight
  renderOutreachTable();
}

function updateOutreachTemplates(prospect) {
  // Get settings
  const savedSettings = JSON.parse(localStorage.getItem('salesToolkitSettings') || '{}');
  const yourName = savedSettings.yourName || '[YOUR_NAME]';
  const spotPrice = savedSettings.spotPrice || '$399';

  const zip = prospect.zipCode || prospect.actualZip || '[ZIP]';
  const businessName = prospect.businessName || '[BUSINESS]';
  const category = (prospect.category || 'business').replace(/_/g, ' ');

  // Load saved custom templates or use defaults
  const savedTemplates = JSON.parse(localStorage.getItem('outreachTemplates') || '{}');

  const defaultText = `Hey! I'm putting together a community postcard for [ZIP] and wanted to see if [BUSINESS_NAME] would be interested in being featured. You'd be the only [CATEGORY] on the card. Want me to send over the details?`;
  const defaultEmail = `Hi,

I'm putting together a community postcard going to about 5,000 homes in [ZIP]. I think [BUSINESS_NAME] would be a great fit - you'd be the only [CATEGORY] on the card.

The cost is [SPOT_PRICE] for a premium spot. Interested in learning more?

[YOUR_NAME]`;
  const defaultSubject = `Quick question about local advertising`;

  // Use saved templates if available, otherwise defaults
  const textTemplate = savedTemplates.text || defaultText;
  const emailTemplate = savedTemplates.email || defaultEmail;
  const subjectTemplate = savedTemplates.subject || defaultSubject;

  // Replace placeholders with prospect data
  function fillTemplate(template) {
    return template
      .replace(/\[ZIP\]/g, zip)
      .replace(/\[BUSINESS_NAME\]/g, businessName)
      .replace(/\[BUSINESS\]/g, businessName)
      .replace(/\[CATEGORY\]/g, category)
      .replace(/\[SPOT_PRICE\]/g, spotPrice)
      .replace(/\[YOUR_NAME\]/g, yourName);
  }

  // Text template (textarea - use .value)
  const textPreview = document.getElementById('outreachTextPreview');
  if (textPreview) {
    textPreview.value = fillTemplate(textTemplate);
  }

  // Email subject
  const emailSubject = document.getElementById('outreachEmailSubject');
  if (emailSubject) {
    emailSubject.value = fillTemplate(subjectTemplate);
  }

  // Email template (textarea - use .value)
  const emailPreview = document.getElementById('outreachEmailPreview');
  if (emailPreview) {
    emailPreview.value = fillTemplate(emailTemplate);
  }
}

function saveOutreachTemplates() {
  // Save the current textarea content as templates (with placeholders restored)
  const prospect = outreachState.selectedProspect;
  if (!prospect) return;

  const savedSettings = JSON.parse(localStorage.getItem('salesToolkitSettings') || '{}');
  const yourName = savedSettings.yourName || '[YOUR_NAME]';
  const spotPrice = savedSettings.spotPrice || '$399';
  const zip = prospect.zipCode || prospect.actualZip || '[ZIP]';
  const businessName = prospect.businessName || '[BUSINESS]';
  const category = (prospect.category || 'business').replace(/_/g, ' ');

  // Reverse-fill: replace prospect data back to placeholders
  function unfillTemplate(text) {
    let result = text;
    if (businessName && businessName !== '[BUSINESS]') result = result.replace(new RegExp(businessName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), '[BUSINESS_NAME]');
    if (zip && zip !== '[ZIP]') result = result.replace(new RegExp(zip.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), '[ZIP]');
    if (category && category !== 'business') result = result.replace(new RegExp(category.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), '[CATEGORY]');
    if (spotPrice && spotPrice !== '[SPOT_PRICE]') result = result.replace(new RegExp(spotPrice.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), '[SPOT_PRICE]');
    if (yourName && yourName !== '[YOUR_NAME]') result = result.replace(new RegExp(yourName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), '[YOUR_NAME]');
    return result;
  }

  const templates = {};
  const textEl = document.getElementById('outreachTextPreview');
  const emailEl = document.getElementById('outreachEmailPreview');
  const subjectEl = document.getElementById('outreachEmailSubject');

  if (textEl) templates.text = unfillTemplate(textEl.value);
  if (emailEl) templates.email = unfillTemplate(emailEl.value);
  if (subjectEl) templates.subject = unfillTemplate(subjectEl.value);

  // Save locally
  localStorage.setItem('outreachTemplates', JSON.stringify(templates));

  // Save to cloud
  saveToCloud('outreach-templates', templates);

  toast('Templates saved!', true);
}

// Load outreach templates from cloud on startup
async function loadOutreachTemplatesFromCloud() {
  try {
    const cloudData = await loadFromCloud('outreach-templates');
    if (cloudData && typeof cloudData === 'object') {
      // Merge into localStorage (cloud is source of truth)
      localStorage.setItem('outreachTemplates', JSON.stringify(cloudData));
      console.log('‚úÖ Outreach templates loaded from cloud');
    }
  } catch (e) {
    console.warn('Could not load outreach templates from cloud:', e);
  }
}

// Insert a variable placeholder at cursor position in the active template textarea
function insertOutreachVariable(variable) {
  // Determine which textarea is active
  const activeTemplate = outreachState.currentTemplate;
  let textarea;
  if (activeTemplate === 'text') {
    textarea = document.getElementById('outreachTextPreview');
  } else if (activeTemplate === 'email') {
    textarea = document.getElementById('outreachEmailPreview');
  } else {
    return; // Phone script isn't editable
  }

  if (!textarea) return;

  const placeholder = `[${variable}]`;
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const text = textarea.value;

  // Insert at cursor position (or replace selection)
  textarea.value = text.substring(0, start) + placeholder + text.substring(end);

  // Move cursor after the inserted placeholder
  const newPos = start + placeholder.length;
  textarea.selectionStart = newPos;
  textarea.selectionEnd = newPos;
  textarea.focus();
}

function switchOutreachTemplate(templateName) {
  outreachState.currentTemplate = templateName;

  // Update tab buttons
  document.querySelectorAll('.outreach-template-btn').forEach(btn => {
    const isActive = btn.dataset.outreachTemplate === templateName;
    btn.classList.toggle('bg-green-100', isActive);
    btn.classList.toggle('text-green-700', isActive);
    btn.classList.toggle('bg-gray-100', !isActive);
    btn.classList.toggle('text-gray-600', !isActive);
  });

  // Show/hide template panes
  document.querySelectorAll('.outreach-template-pane').forEach(pane => pane.classList.add('hidden'));
  const activePane = document.getElementById(`outreachTemplate${templateName.charAt(0).toUpperCase() + templateName.slice(1)}`);
  if (activePane) activePane.classList.remove('hidden');
}

function copyOutreachTemplate(type) {
  const prospect = outreachState.selectedProspect;
  if (!prospect) {
    toast('Select a prospect first', false);
    return;
  }

  // Auto-save template edits
  saveOutreachTemplates();

  if (type === 'text') {
    const text = document.getElementById('outreachTextPreview')?.value || '';
    navigator.clipboard.writeText(text).then(() => {
      toast('Message copied! Paste into Google Voice.', true);
    });
  } else if (type === 'email') {
    const body = document.getElementById('outreachEmailPreview')?.value || '';
    const subject = document.getElementById('outreachEmailSubject')?.value || 'Quick question about local advertising';
    const email = prospect.email || prospect.contact?.email || '';
    if (email) {
      const subjectEncoded = encodeURIComponent(subject);
      const bodyEncoded = encodeURIComponent(body);
      window.open(`mailto:${email}?subject=${subjectEncoded}&body=${bodyEncoded}`, '_blank');
      toast('Opening email...', true);
    } else {
      navigator.clipboard.writeText(body).then(() => {
        toast('Email copied (no email address on file)', true);
      });
    }
  }
}

// Quick action buttons
function outreachQuickCall() {
  const prospect = outreachState.selectedProspect;
  if (!prospect) return;
  const phone = prospect.phone || prospect.contact?.phone || '';
  if (!phone) {
    toast('No phone number', false);
    return;
  }
  window.open(`tel:${phone.replace(/\D/g, '')}`, '_blank');
  toast(`Calling ${prospect.businessName}...`, true);
}

function outreachOpenGoogleVoice() {
  const prospect = outreachState.selectedProspect;
  if (!prospect) return;
  const phone = prospect.phone || prospect.contact?.phone || '';
  if (!phone) {
    toast('No phone number', false);
    return;
  }
  const cleanPhone = phone.replace(/\D/g, '');
  window.open(`https://voice.google.com/u/0/messages?itemId=t.+1${cleanPhone}`, '_blank');
}

function copyOutreachPhone() {
  const prospect = outreachState.selectedProspect;
  if (!prospect) return;
  const phone = prospect.phone || prospect.contact?.phone || '';
  if (!phone) {
    toast('No phone number', false);
    return;
  }
  const cleanPhone = phone.replace(/\D/g, '');
  navigator.clipboard.writeText(cleanPhone).then(() => {
    toast('Phone number copied!', true);
  });
}

// Save notes for the selected prospect
function saveOutreachNotes() {
  const prospect = outreachState.selectedProspect;
  if (!prospect) return;

  const notes = document.getElementById('outreachNotes')?.value || '';
  const allNotes = JSON.parse(localStorage.getItem('outreachNotes') || '{}');
  allNotes[prospect.id] = notes;
  localStorage.setItem('outreachNotes', JSON.stringify(allNotes));

  // Save to cloud (debounced)
  saveToCloud('outreach-notes', allNotes);
}

// Load notes for a prospect
function loadOutreachNotes(prospectId) {
  const allNotes = JSON.parse(localStorage.getItem('outreachNotes') || '{}');
  return allNotes[prospectId] || '';
}

// Load outreach notes from cloud on startup
async function loadOutreachNotesFromCloud() {
  try {
    const cloudData = await loadFromCloud('outreach-notes');
    if (cloudData && typeof cloudData === 'object') {
      // Merge: cloud wins for existing keys, keep local-only keys
      const localNotes = JSON.parse(localStorage.getItem('outreachNotes') || '{}');
      const merged = { ...localNotes, ...cloudData };
      localStorage.setItem('outreachNotes', JSON.stringify(merged));
      console.log('‚úÖ Outreach notes loaded from cloud');
    }
  } catch (e) {
    console.warn('Could not load outreach notes from cloud:', e);
  }
}

function outreachQuickEmail() {
  const prospect = outreachState.selectedProspect;
  if (!prospect) return;
  const email = prospect.email || prospect.contact?.email || '';
  if (!email) {
    toast('No email address', false);
    return;
  }
  window.open(`mailto:${email}`, '_blank');
}

function outreachMarkContacted() {
  const prospect = outreachState.selectedProspect;
  if (!prospect) return;

  // Move from "to-contact/attempting" to "negotiating" (campaign board column name)
  if (prospect.currentColumn === 'to-contact' || prospect.currentColumn === 'attempting') {
    outreachMoveToStage('negotiating');
    toast(`${prospect.businessName} marked as contacted`, true);
  } else {
    toast('Already in progress or later stage', true);
  }
}

function outreachMoveToStage(toColumn) {
  const prospect = outreachState.selectedProspect;
  if (!prospect) return;

  const fromColumn = prospect.currentColumn;

  const columnLabels = {
    'attempting': 'Attempting',
    'negotiating': 'Negotiating',
    'invoice-sent': 'Invoice Sent',
    'proof-approved': 'Proof Approved'
  };

  const board = getCurrentCampaignBoard();
  if (!board || !board.columns) {
    toast('No campaign board available', false);
    return;
  }

  if (fromColumn === toColumn) {
    toast(`Already in ${columnLabels[toColumn] || toColumn}`, true);
    return;
  }

  // Use the campaign board move function
  const success = moveCampaignBoardItem(prospect.id, fromColumn, toColumn, board);

  if (success) {
    saveCampaignBoards();
    outreachState.selectedProspect.currentColumn = toColumn;
    toast(`Moved to ${columnLabels[toColumn] || toColumn}`, true);
  } else {
    toast('Could not move prospect', false);
    return;
  }

  // Re-render if moved out of current filter view
  if (outreachState.columnFilter !== 'all' && outreachState.columnFilter !== toColumn) {
    outreachState.selectedProspect = null;
    document.getElementById('outreachNoSelection')?.classList.remove('hidden');
    document.getElementById('outreachSelectedPanel')?.classList.add('hidden');
  }
  renderOutreachTable();
  renderKanban();
}

function openOutreachProspectCRM() {
  const prospect = outreachState.selectedProspect;
  if (prospect) {
    openProspectDetailModal(prospect, 'prospect');
  }
}

function sortOutreach(column) {
  if (outreachState.sortBy === column) {
    outreachState.sortDir = outreachState.sortDir === 'asc' ? 'desc' : 'asc';
  } else {
    outreachState.sortBy = column;
    outreachState.sortDir = ['phone', 'email', 'facebook', 'instagram'].includes(column) ? 'desc' : 'asc';
  }
  renderOutreachTable();
}

function updateOutreachSortIcons() {
  const columns = ['businessName', 'category', 'phone', 'email', 'facebook', 'instagram'];
  columns.forEach(col => {
    const icon = document.getElementById(`sortIcon_${col}`);
    if (icon) {
      if (col === outreachState.sortBy) {
        icon.textContent = outreachState.sortDir === 'asc' ? '‚ñ≤' : '‚ñº';
        icon.classList.remove('text-gray-400');
        icon.classList.add('text-green-600');
      } else {
        icon.textContent = '‚Üï';
        icon.classList.remove('text-green-600');
        icon.classList.add('text-gray-400');
      }
    }
  });
}

function filterOutreachTable() {
  const categorySelect = document.getElementById('outreachCategoryFilter');
  const columnSelect = document.getElementById('outreachColumnFilter');

  if (categorySelect) outreachState.categoryFilter = categorySelect.value;
  if (columnSelect) outreachState.columnFilter = columnSelect.value;

  // Clear selection when changing filters
  outreachState.selectedProspect = null;
  document.getElementById('outreachNoSelection')?.classList.remove('hidden');
  document.getElementById('outreachSelectedPanel')?.classList.add('hidden');

  renderOutreachTable();
}

function populateOutreachCategoryFilter(prospects) {
  const select = document.getElementById('outreachCategoryFilter');
  if (!select) return;

  const categories = [...new Set(prospects.map(p => p.category).filter(Boolean))].sort();
  const currentValue = select.value;

  select.innerHTML = '<option value="">All Categories</option>' +
    categories.map(cat => `<option value="${cat}">${cat.replace(/_/g, ' ')}</option>`).join('');

  if (categories.includes(currentValue)) select.value = currentValue;
}

function showOutreachEmptyState(show, message) {
  const emptyState = document.getElementById('outreachEmptyState');
  const tbody = document.getElementById('outreachTableBody');
  if (emptyState) {
    emptyState.classList.toggle('hidden', !show);
    if (message) {
      const msgEl = emptyState.querySelector('p.text-lg');
      if (msgEl) msgEl.textContent = message;
    }
  }
  if (tbody && show) tbody.innerHTML = '';
}

// Expose functions globally
window.renderOutreachTable = renderOutreachTable;
window.sortOutreach = sortOutreach;
window.filterOutreachTable = filterOutreachTable;
window.selectOutreachProspect = selectOutreachProspect;
window.switchOutreachTemplate = switchOutreachTemplate;
window.copyOutreachTemplate = copyOutreachTemplate;
window.saveOutreachTemplates = saveOutreachTemplates;
window.insertOutreachVariable = insertOutreachVariable;
window.saveOutreachNotes = saveOutreachNotes;
window.copyOutreachPhone = copyOutreachPhone;
window.outreachOpenGoogleVoice = outreachOpenGoogleVoice;
window.outreachQuickCall = outreachQuickCall;
// outreachQuickText removed - replaced by copyOutreachPhone + outreachOpenGoogleVoice
window.outreachQuickEmail = outreachQuickEmail;
window.outreachMarkContacted = outreachMarkContacted;
window.outreachMoveToStage = outreachMoveToStage;
window.openOutreachProspectCRM = openOutreachProspectCRM;

console.log('‚úÖ app-main.js fully parsed - script end reached');
console.log('üí° Admin: Run showClientSelector() or cleanupDuplicateClients()');
