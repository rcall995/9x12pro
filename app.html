<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>9x12 Pro - Community Card Management</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- VERSION: 2025-01-13-v18 CACHE BUSTER -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Maps API callback must be defined BEFORE script loads -->
  <script>
    window.googleMapsLoaded = false;
    window.initGoogleMaps = function() {
      window.googleMapsLoaded = true;
    };
  </script>
  <!-- Google Maps JavaScript API with Places Library -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCNzXL-8UT-JI1Dy9wBN14KtH-UDMbeOlo&libraries=places&callback=initGoogleMaps" async defer></script>
  <!-- Supabase JS Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 16 16%22><circle cx=%228%22 cy=%228%22 r=%226%22 fill=%22%23333%22/></svg>">
  <style>
    /* Core card */
    .card{border-width:2px;border-radius:.75rem;padding:.85rem;text-align:center;font-weight:600;position:relative;display:flex;align-items:center;justify-content:center;user-select:none;animation:fadeIn .25s ease-in-out;outline-offset:2px;z-index:1;transition:transform .15s ease,box-shadow .15s ease,outline .15s ease}
    .card:hover{filter:brightness(.98)}
    .spot-label{position:absolute;top:6px;left:8px;font-size:.7rem;font-weight:700;opacity:.65}
    .status-badge{position:absolute;bottom:6px;right:8px;font-size:.7rem;padding:6px 10px;border-radius:9999px;background:rgba(255,255,255,.96);border:1px solid rgba(0,0,0,.06);color:#0f172a;font-weight:700;box-shadow:0 2px 6px rgba(0,0,0,.08)}
    .price-badge{position:absolute;top:6px;right:8px;font-size:.7rem;padding:4px 8px;border-radius:9999px;background:rgba(34,197,94,.92);color:white;font-weight:700;box-shadow:0 2px 6px rgba(34,197,94,.3)}
    .selected-pill{position:absolute;top:50%;right:8px;font-size:.65rem;padding:4px 8px;border-radius:9999px;background:rgba(59,130,246,.95);color:white;font-weight:700;box-shadow:0 6px 14px rgba(59,130,246,.12);transform:translateY(-50%)}
    .selected{outline:4px solid rgba(59,130,246,.95);box-shadow:0 18px 40px rgba(2,6,23,.25);transform:scale(1.01)}
    .banner{font-weight:800}
    .grid-front,.grid-back{
      display:grid;
      grid-template-columns:repeat(4,1fr);
      grid-template-rows:40fr 14fr 40fr;
      gap:.5rem;
      width:100%;
      box-sizing:border-box;
      aspect-ratio:12/9;
    }
    .col-span-2{grid-column:span 2 / span 2}
    .col-span-4{grid-column:span 4 / span 4}
    @keyframes fadeIn{from{opacity:0;transform:scale(.985)}to{opacity:1;transform:scale(1)}}
    @media (max-width:900px){.grid-front,.grid-back{grid-template-columns:repeat(2,1fr);aspect-ratio:unset}}
    @media (max-width:600px){
        .grid-front,.grid-back{grid-template-columns:1fr;aspect-ratio:unset}
        .card{min-height:110px;padding:1rem}
        .spot-label{font-size:.8rem;top:8px;left:10px}
        .status-badge{font-size:.75rem;padding:7px 11px;bottom:8px;right:10px}
    }
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:9999;padding:1rem}
    .modal{width:100%;max-width:560px;max-height:90vh;overflow-y:auto;background:#fff;border-radius:.75rem;border:1px solid #e5e7eb;box-shadow:0 20px 40px rgba(0,0,0,.18);padding:1rem}
    .modal.show{display:flex!important}
    @media (max-width:640px){
        .modal{max-height:95vh;border-radius:.5rem;padding:.75rem}
        .modal-backdrop{padding:.5rem}
    }
    
    /* OVERLAY EDIT BUTTON - appears on top of selected card */
    .card-edit-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .card.selected .card-edit-overlay {
      opacity: 1;
      pointer-events: all;
    }
    .card-edit-overlay button {
      padding: 0.5rem 1rem;
      background: rgba(37, 99, 235, 0.95);
      color: white;
      border: none;
      border-radius: 0.5rem;
      font-weight: 700;
      box-shadow: 0 8px 18px rgba(37, 99, 235, 0.3);
      cursor: pointer;
      font-size: 0.875rem;
    }
    .card-edit-overlay button:hover {
      background: rgba(29, 78, 216, 0.95);
    }
    
    .toast{position:fixed;bottom:22px;right:22px;z-index:50;padding:.6rem .9rem;border-radius:.6rem;color:#fff;box-shadow:0 10px 20px rgba(0,0,0,.2)}
    .toast-ok{background:#059669}.toast-warn{background:#b45309}
    @media print{#legendArea,.toast{display:none!important}}
    #legendGrid{
      display:flex;
      gap:.6rem;
      align-items:center;
      justify-content:flex-start;
      flex-wrap:wrap;
      padding-top:.25rem;
      max-width:48rem;
    }
    .legend-item{display:flex;align-items:center;gap:.5rem;padding:.2rem .35rem;border-radius:.4rem;background:transparent}
    .legend-dot{width:10px;height:10px;border-radius:9999px;display:inline-block;flex:0 0 auto}
    .postcard {
      background: #000000;
      border: 1px solid #e5e7eb;
      border-radius: 0;
      padding: .75rem;
      box-shadow: 0 6px 18px rgba(0,0,0,.06);
      transition: background-color .15s ease, border-color .15s ease;
      position: relative;
      max-width: 100%;
    }
    .postcard .card { border-radius: .5rem; }

    /* Postcard Size Scaling - 6.5√ó12 is 72.2% of 9√ó12 height */
    .postcard.size-6x12 {
      transform: scaleY(0.722);
      transform-origin: top center;
    }

    /* Mobile Responsiveness - Scale postcards to fit phone width */
    @media (max-width: 768px) {
      .postcard {
        width: 100%;
        max-width: calc(100vw - 2rem);
        margin: 0 auto;
      }
      .side-wrap {
        max-width: 100%;
        overflow-x: auto;
      }
    }
    .placeholder {
        background: #fdfdfd;
        border: 1px dashed #d1d5db;
        color: #9ca3af;
        font-style: normal;
        font-weight: 500;
        opacity: 1;
    }
    .header-controls { display:flex; gap:.5rem; align-items:center; }
    .color-preview { width:18px; height:18px; border-radius:4px; border:1px solid #e5e7eb; display:inline-block; vertical-align:middle }
    .color-label { font-size:0.85rem; color:#374151; margin-right:4px }
    .banner-text {
      display: inline-block;
      font-weight: 800;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: clamp(1.2rem, 1.6vw + 1rem, 2rem);
      line-height: 1;
    }
    .sort-row{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:6px;margin-bottom:6px;background:#fff;border:1px solid #eef2f7}
    .sort-controls button{padding:6px 8px;border-radius:6px;background:#f8fafc;border:1px solid #e6eef4;cursor:pointer}
    .tab-pane { padding-top: 0.5rem; }
    .tab-pane.hidden { display: none; }
    .tab-btn {
        border-color: transparent;
        color: #6b7280;
        padding: 0.5rem 1rem;
        transition: all 0.2s ease;
        border-radius: 0.375rem 0.375rem 0 0;
        margin-bottom: -2px;
        font-weight: 600;
    }
    .tab-btn:hover:not(.active) {
        color: #374151;
        background-color: #f3f4f6;
    }
    .tab-btn.active {
        border-bottom: 2px solid #4f46e5;
        color: #1f2937;
        background-color: white;
        box-shadow: 0 -2px 5px rgba(0,0,0,0.05);
    }
    .dashboard-widget {
        background-color: white;
        border-radius: 0.5rem;
        padding: 1.5rem;
        box-shadow: 0 4px 6px rgba(0,0,0,0.05);
    }
    .metric-value {
        font-size: 2.25rem;
        font-weight: 700;
    }
    .metric-label {
        color: #6b7280;
        font-weight: 500;
    }
    .kanban-column {
        min-height: 150px;
        background-color: #f3f4f6;
        border-radius: 0.375rem;
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        width: calc(25% - 0.75rem);  /* 4 equal columns */
        min-width: 220px;
        flex-shrink: 0;
    }
    #salesActivityContainer {
        /* Flex styles moved to inner wrapper div in renderKanban() */
    }
    @media (max-width: 1023px) {
        .kanban-column {
            width: calc(50% - 0.5rem);  /* 2 columns on tablets */
            min-width: 200px;
        }
    }
    @media (max-width: 640px) {
        .kanban-column {
            width: 100%;  /* 1 column on mobile */
            min-width: unset;
        }
    }
    .control-btn {
        background-color: white;
        color: #1f2937;
        font-weight: 700;
        border: 1px solid #d1d5db;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .control-btn:hover {
        background-color: #f3f4f6;
    }
    #legendContainer {
        display: flex;
        justify-content: flex-start;
        width: 100%;
        margin-bottom: 1rem;
    }
    .task-item {
        cursor: grab;
        padding: 0.5rem;
        border-radius: 0.375rem;
        background-color: #f8fafc;
        border: 1px solid #e2e8f0;
    }
    .task-item.dragging {
        opacity: 0.5;
        border: 1px dashed #4f46e5;
    }
    .kanban-item {
      cursor: grab;
      transition: opacity 0.2s, transform 0.2s;
    }
    .kanban-item.dragging {
      opacity: 0.3;
      border: 2px dashed #4f46e5 !important;
      background-color: #f0f0f0 !important;
    }
    .kanban-item.drag-over {
      border-top: 3px solid #4f46e5 !important;
      padding-top: 4px;
    }
    .kanban-column.drag-over-column {
      background-color: #eef2ff;
      border-radius: 8px;
    }
    .card > div:not(.spot-label):not(.status-badge):not(.selected-pill):not(.price-badge):not(.card-edit-overlay) {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      width: 100%;
    }
    .task-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem;
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 0.375rem;
      margin-bottom: 0.5rem;
      cursor: grab;
      transition: opacity 0.2s;
    }
    .task-row.dragging {
      opacity: 0.5;
      border: 1px dashed #4f46e5;
    }
    .task-row.completed {
      opacity: 0.6;
    }
    .task-row.completed .task-text {
      text-decoration: line-through;
      color: #9ca3af;
    }
    .task-checkbox {
      width: 18px;
      height: 18px;
      cursor: pointer;
      flex-shrink: 0;
    }
    .task-text {
      flex: 1;
      margin-right: 1rem;
    }
    .task-date {
      font-size: 0.875rem;
      color: #6b7280;
      min-width: 120px;
    }
    .overdue { color: #dc2626; font-weight: bold; }
    #taskList {
      min-height: 200px;
    }
    
    /* Client row styles */
    .client-row {
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .client-row:hover {
      background-color: #f9fafb;
      border-color: #d1d5db;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen font-sans">
  <!-- Inline script to set initial tab state before page renders -->
  <script>
    (function() {
      // Hide all tabs initially to prevent flash
      document.addEventListener('DOMContentLoaded', function() {
        const savedTab = localStorage.getItem('9x12_active_tab') || 'pipeline';

        // Hide all tabs and deactivate all buttons
        document.querySelectorAll('.tab-pane').forEach(pane => {
          pane.classList.add('hidden');
          pane.classList.remove('active-pane');
        });
        document.querySelectorAll('.tab-btn').forEach(btn => {
          btn.classList.remove('active');
        });

        // Show the saved tab
        const activePane = document.querySelector(`.tab-pane[data-content="${savedTab}"]`);
        const activeBtn = document.querySelector(`.tab-btn[data-tab="${savedTab}"]`);

        if (activePane) {
          activePane.classList.remove('hidden');
          activePane.classList.add('active-pane');
        }
        if (activeBtn) {
          activeBtn.classList.add('active');
        }
      });
    })();
  </script>
  <iframe name="saveFrame" style="display:none"></iframe>
  <form id="saveForm" target="saveFrame" style="display:none" method="POST" enctype="multipart/form-data">
    <input type="hidden" name="payload" id="payloadField" />
  </form>
  <header class="bg-white shadow px-4 py-3 flex flex-col md:flex-row md:justify-between md:items-center gap-3 sticky top-0 z-30">
    <h1 class="text-2xl font-bold flex items-center gap-2">
      <span class="text-indigo-600 font-black">9√ó12</span>
      <span class="font-bold">PRO</span>
    </h1>

    <!-- Current Postcard Selector (Main Control) - Split into Town and Month -->
    <!-- Only visible on Postcards & Activation tab -->
    <div id="postcardSelectorContainer" class="flex-1 flex justify-center hidden">
      <div class="flex flex-col md:flex-row items-center gap-2">
        <label class="text-sm font-semibold text-gray-700 whitespace-nowrap">Town:</label>
        <select id="headerTownSelect" onchange="onTownChanged()" class="border-2 border-indigo-300 rounded-lg px-3 py-2 bg-white text-sm font-medium hover:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent" style="min-width: 150px;">
          <option value="">‚Äî Select Town ‚Äî</option>
        </select>
        <label class="text-sm font-semibold text-gray-700 whitespace-nowrap">Month:</label>
        <select id="headerMonthSelect" onchange="updatePostcardFromSelectors()" class="border-2 border-indigo-300 rounded-lg px-3 py-2 bg-white text-sm font-medium hover:border-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent" style="min-width: 150px;">
          <option value="">‚Äî Select Month ‚Äî</option>
        </select>
      </div>
    </div>

    <div class="flex items-center gap-2 md:gap-3">
      <!-- Auto-Save Status Indicator (Compact) -->
      <div id="autoSaveStatus" class="flex items-center gap-1 px-2 py-1 rounded-md text-xs font-medium bg-gray-50 border">
        <span id="autoSaveIcon">‚úì</span>
        <span id="autoSaveText" class="hidden lg:inline">Saved</span>
      </div>
      <button id="btnManualSave" onclick="manualSaveNow()" class="px-2 py-1 bg-blue-600 text-white rounded-md text-xs hover:bg-blue-700 font-medium hidden">
        <span class="hidden sm:inline">‚òÅÔ∏è</span>
      </button>
      <button onclick="openReportsModal()" class="px-2 py-1.5 md:px-3 bg-purple-600 text-white rounded-md text-xs md:text-sm hover:bg-purple-700">
        <span class="hidden sm:inline">üìä Reports</span>
        <span class="sm:hidden">üìä</span>
      </button>
      <button onclick="openEmailModal()" class="px-2 py-1.5 md:px-3 bg-blue-600 text-white rounded-md text-xs md:text-sm hover:bg-blue-700">
        <span class="hidden sm:inline">‚úâÔ∏è Email</span>
        <span class="sm:hidden">‚úâÔ∏è</span>
      </button>
    </div>
  </header>
  <main class="max-w-6xl mx-auto mt-6 px-3 pb-20">
    <div class="flex border-b border-gray-300 mb-6 overflow-x-auto" id="navTabs" style="scrollbar-width: thin;">
        <button data-tab="pipeline" class="tab-btn active px-3 md:px-4 py-2 text-xs md:text-sm whitespace-nowrap">
            <span class="hidden sm:inline">Dashboard & Pipeline</span>
            <span class="sm:hidden">Dashboard</span>
        </button>
        <button data-tab="prospects" class="tab-btn px-3 md:px-4 py-2 text-xs md:text-sm whitespace-nowrap">
            <span class="hidden sm:inline">üîç Prospect Pool</span>
            <span class="sm:hidden">Prospects</span>
        </button>
        <button data-tab="lead-generation" class="tab-btn px-3 md:px-4 py-2 text-xs md:text-sm whitespace-nowrap">
            <span class="hidden sm:inline">üéØ Lead Generation</span>
            <span class="sm:hidden">Leads</span>
        </button>
        <button data-tab="manager" class="tab-btn px-3 md:px-4 py-2 text-xs md:text-sm whitespace-nowrap">
            <span class="hidden sm:inline">Postcards & Activation</span>
            <span class="sm:hidden">Postcards</span>
        </button>
        <button data-tab="clients" class="tab-btn px-3 md:px-4 py-2 text-xs md:text-sm whitespace-nowrap">
            <span class="hidden sm:inline">Client Database</span>
            <span class="sm:hidden">Clients</span>
        </button>
        <button data-tab="admin" class="tab-btn px-3 md:px-4 py-2 text-xs md:text-sm whitespace-nowrap">
            <span class="hidden sm:inline">üí∞ Financials</span>
            <span class="sm:hidden">üí∞</span>
        </button>
        <div class="flex-grow"></div>
        <div id="quickControls" class="flex items-center gap-2"></div>
    </div>
    <div id="tabContent">
       
        <div data-content="pipeline" class="tab-pane active-pane">
            <div class="mb-6">
                <h3 class="text-lg md:text-xl font-bold">Sales & Performance Dashboard</h3>
            </div>

            <!-- CARDS IN PROGRESS SECTION -->
            <div id="cardsInProgressSection" class="mb-8">
                <!-- Dynamically populated by renderCardsInProgress() -->
            </div>

            <!-- Campaign stats moved to Postcards & Activation tab -->
            <div class="grid grid-cols-1 gap-6">

                <!-- AUTO-POPULATE PROSPECTS SECTION (Kanban - moved above Tasks) -->
                <div class="dashboard-widget">
                    <div class="flex justify-between items-center mb-4 cursor-pointer" onclick="toggleSalesActivity()">
                        <h4 class="font-semibold text-gray-800">Weekly Sales Activity (Kanban View)</h4>
                        <button class="text-gray-600 hover:text-gray-900 transition-colors">
                            <svg id="salesActivityToggleIcon" class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </button>
                    </div>

                    <!-- Daily Goal Progress - always visible -->
                    <div id="dailyGoalContainer">
                        <!-- Daily goal dynamically populated -->
                    </div>

                    <!-- Collapsible Kanban Columns -->
                    <div id="salesActivityKanbanColumns" class="transition-all duration-300 ease-in-out overflow-hidden">
                        <!-- Kanban columns dynamically populated -->
                    </div>
                </div>

                <div class="dashboard-widget">
                    <div class="flex justify-between items-center mb-4">
                        <h4 class="font-semibold text-gray-800">Tasks Due & Renewal Nudges</h4>
                        <button onclick="openTaskModal()" class="px-3 py-1.5 bg-indigo-600 text-white rounded-md text-sm hover:bg-indigo-700">
                            + Add Task
                        </button>
                    </div>
                    <p id="overdueText" class="text-sm text-gray-500 mb-2">Loading...</p>
                    <div id="taskList" class="space-y-2 text-sm text-gray-700">
                        <!-- Tasks dynamically populated -->
                    </div>
                </div>
            </div>
        </div>

        <!-- PROSPECT POOL TAB -->
        <div data-content="prospects" class="tab-pane hidden">
            <div class="flex justify-between items-center mb-6">
                <div>
                    <h3 class="text-xl font-bold">Prospect Pool Management</h3>
                    <p class="text-sm text-gray-600 mt-1">Review and manage all businesses found from Google Places searches</p>
                </div>
                <button onclick="clearProspectPool()" class="px-4 py-2 text-sm bg-red-50 text-red-600 border border-red-200 rounded-md hover:bg-red-100 font-medium">
                    Clear All
                </button>
            </div>

            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                <div class="flex items-start gap-3">
                    <span class="text-2xl">üí°</span>
                    <div class="flex-1">
                        <h4 class="font-semibold text-blue-900 mb-1">How this works:</h4>
                        <ul class="text-sm text-blue-800 space-y-1">
                            <li>‚Ä¢ All businesses from your searches are stored here and organized by category</li>
                            <li>‚Ä¢ Use the <strong>ZIP Code filter</strong> to view businesses from specific areas</li>
                            <li>‚Ä¢ Select businesses by checking the boxes</li>
                            <li>‚Ä¢ Click "Add Selected to Pipeline" to move them to your Prospecting column</li>
                            <li>‚Ä¢ Results stay cached for 30 days - repeat searches won't use API quota</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-4 p-4 bg-gray-50 rounded-lg border">
                <div class="flex flex-col gap-2 w-full sm:w-auto">
                    <label class="text-sm font-medium text-gray-700">Filter by ZIP Codes:</label>
                    <div id="prospectPoolZipCheckboxes" class="flex flex-wrap gap-3">
                        <!-- Checkboxes will be populated dynamically -->
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <label class="text-sm font-medium text-gray-700 whitespace-nowrap">Show from:</label>
                    <select id="prospectPoolDateFilter" onchange="filterProspectPoolByDate()" class="border rounded-md px-3 py-2 text-sm bg-white focus:ring-2 focus:ring-indigo-500">
                        <option value="all">All Time</option>
                        <option value="7">Last 7 Days</option>
                        <option value="30">Last 30 Days</option>
                        <option value="90">Last 90 Days</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <button onclick="exportProspectPoolCSV()" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 font-medium text-sm whitespace-nowrap">
                        üì• Export CSV
                    </button>
                    <label for="importProspectPoolCSV" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 font-medium text-sm cursor-pointer whitespace-nowrap">
                        üì§ Import CSV
                    </label>
                    <input type="file" id="importProspectPoolCSV" accept=".csv" onchange="importProspectPoolCSV(event)" class="hidden" />
                </div>
            </div>

            <div id="prospectPoolStats" class="grid grid-cols-4 gap-4 mb-6">
                <!-- Stats populated by JavaScript -->
            </div>

            <div id="prospectPoolContainer">
                <!-- Content populated by JavaScript -->
            </div>

            <div class="sticky bottom-4 mt-6 p-4 bg-white border-2 border-indigo-200 rounded-lg shadow-xl">
                <div class="flex justify-between items-center">
                    <div>
                        <span id="prospectPoolSelectedCount" class="text-2xl font-bold text-indigo-600">0</span>
                        <span class="text-gray-600 ml-2">businesses selected</span>
                    </div>
                    <button id="btnAddFromPool" onclick="addFromProspectPool()" class="px-8 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 font-semibold shadow-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        Add Selected to Pipeline
                    </button>
                </div>
            </div>
        </div>

        <!-- LEAD GENERATION TAB -->
        <div data-content="lead-generation" class="tab-pane hidden">
            <div class="mb-6">
                <h3 class="text-2xl font-bold text-gray-900">Lead Generation</h3>
                <p class="text-gray-600 mt-1">Search for and discover new prospects using Google Places API</p>
            </div>

            <!-- Auto-Populate Section -->
            <div class="bg-gradient-to-r from-purple-600 to-indigo-600 rounded-xl shadow-xl p-6 text-white mb-6">
                <div class="flex flex-col lg:flex-row lg:items-center justify-between gap-4 mb-6">
                    <div>
                        <h3 class="text-2xl font-black mb-2 flex items-center gap-2">
                            üîç Auto-Populate Prospects
                        </h3>
                        <p class="text-purple-100 text-sm">
                            Search Google Places to automatically find and add businesses to your prospecting pipeline
                        </p>
                    </div>
                    <div class="bg-white/10 backdrop-blur-sm rounded-lg px-4 py-3 border border-white/20">
                        <div class="text-xs text-purple-100 mb-1">API Usage This Month</div>
                        <div class="font-bold text-lg" id="quickApiUsage">0 / 28,000</div>
                        <div class="text-xs text-purple-200" id="quickApiReset">Resets Dec 1</div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <!-- Left: Zip Code & Radius -->
                    <div class="bg-white/10 backdrop-blur-sm rounded-lg p-4 border border-white/20">
                        <h4 class="font-semibold mb-3 flex items-center gap-2">
                            <span class="text-2xl">üìç</span> Location
                        </h4>
                        <div class="space-y-3">
                            <div>
                                <label class="text-sm font-medium text-purple-100 block mb-1">Zip Code *</label>
                                <input
                                    id="bulkPopZipCode"
                                    type="text"
                                    maxlength="5"
                                    placeholder="14072"
                                    class="w-full px-3 py-2 bg-white/20 border border-white/30 rounded-lg text-white placeholder-purple-200 focus:outline-none focus:ring-2 focus:ring-white/50"
                                />
                            </div>
                            <div>
                                <label class="text-sm font-medium text-purple-100 block mb-1">Search Radius</label>
                                <select
                                    id="bulkPopRadius"
                                    class="w-full px-3 py-2 bg-white/20 border border-white/30 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-white/50"
                                >
                                    <option value="3000">~2 miles</option>
                                    <option value="5000" selected>~3 miles</option>
                                    <option value="8000">~5 miles</option>
                                    <option value="16000">~10 miles</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Middle: Business Categories (Multi-Select) -->
                    <div class="lg:col-span-2 bg-white/10 backdrop-blur-sm rounded-lg p-4 border border-white/20">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-semibold flex items-center gap-2">
                                <span class="text-2xl">üè¢</span> Business Categories (Select Multiple)
                            </h4>
                            <div class="flex gap-2">
                                <button onclick="openManageCategoriesModal()" class="text-xs px-2 py-1 bg-blue-600 hover:bg-blue-700 rounded transition font-semibold">
                                    ‚öôÔ∏è Manage
                                </button>
                                <label class="flex items-center gap-2 text-sm cursor-pointer hover:bg-white/20 px-3 py-1.5 rounded transition font-semibold">
                                    <input type="checkbox" id="selectAllCategories" class="rounded text-purple-600 focus:ring-purple-500" onchange="toggleAllCategories()" />
                                    <span>Select All</span>
                                </label>
                            </div>
                        </div>
                        <div id="categoryCheckboxContainer" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2 max-h-64 overflow-y-auto pr-2" style="scrollbar-width: thin;">
                            <!-- Categories will be dynamically rendered here -->
                        </div>

                        <!-- Custom Category Input -->
                        <div class="mt-4 pt-4 border-t border-white/20">
                            <label class="flex items-center gap-2 text-sm mb-2">
                                <input type="checkbox" id="enableCustomCategory" class="category-checkbox rounded text-purple-600" onchange="toggleBulkCustomCategory()" />
                                <span class="font-medium">Add custom category</span>
                            </label>
                            <input
                                id="bulkCustomCategory"
                                type="text"
                                placeholder="e.g., bookstore, bakery, snowplowing, etc."
                                disabled
                                class="w-full px-3 py-2 bg-white/20 border border-white/30 rounded-lg text-white placeholder-purple-200 focus:outline-none focus:ring-2 focus:ring-white/50 disabled:opacity-50 disabled:cursor-not-allowed"
                            />
                        </div>
                    </div>
                </div>

                <!-- Search Button & Stats -->
                <div class="mt-6 flex flex-col sm:flex-row items-center justify-between gap-4">
                    <div class="flex flex-col gap-2">
                        <div class="flex items-center gap-2 text-sm text-purple-100">
                            <span class="inline-block w-2 h-2 bg-yellow-400 rounded-full animate-pulse"></span>
                            <span>Results cached for 30 days ‚Ä¢ Repeat searches are FREE</span>
                        </div>
                        <label class="flex items-center gap-2 text-sm text-purple-100 cursor-pointer hover:text-white transition">
                            <input type="checkbox" id="clearBeforeSearch" checked class="rounded text-purple-600 focus:ring-purple-500" />
                            <span>üóëÔ∏è Clear previous searches before searching (recommended)</span>
                        </label>
                    </div>
                    <button
                        id="btnRunBulkPopulate"
                        onclick="runBulkAutoPopulate()"
                        class="w-full sm:w-auto px-8 py-3 bg-white text-purple-600 font-bold rounded-lg hover:bg-purple-50 transition shadow-lg hover:shadow-xl transform hover:scale-105"
                    >
                        üîç Search & Add Prospects
                    </button>
                </div>
            </div>

            <!-- Help & Tips Section -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-6">
                    <h4 class="font-semibold text-blue-900 mb-3 flex items-center gap-2">
                        <span class="text-2xl">üí°</span> How It Works
                    </h4>
                    <ul class="text-sm text-blue-800 space-y-2">
                        <li>‚Ä¢ Enter a zip code and select your search radius</li>
                        <li>‚Ä¢ Choose business categories or add custom ones</li>
                        <li>‚Ä¢ Results are cached for 30 days - repeat searches are FREE!</li>
                        <li>‚Ä¢ Found businesses go to Prospect Pool for review</li>
                        <li>‚Ä¢ Select and add promising prospects to your pipeline</li>
                    </ul>
                </div>

                <div class="bg-green-50 border border-green-200 rounded-lg p-6">
                    <h4 class="font-semibold text-green-900 mb-3 flex items-center gap-2">
                        <span class="text-2xl">üéØ</span> Pro Tips
                    </h4>
                    <ul class="text-sm text-green-800 space-y-2">
                        <li>‚Ä¢ Search multiple categories at once for better coverage</li>
                        <li>‚Ä¢ Use custom categories for niche industries (e.g., "snowplowing")</li>
                        <li>‚Ä¢ Results are linked to your current postcard automatically</li>
                        <li>‚Ä¢ Check Prospect Pool tab to review and select businesses</li>
                    </ul>
                </div>
            </div>
        </div>

        <div data-content="manager" class="tab-pane hidden">
            <!-- CAMPAIGN STATS -->
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div class="dashboard-widget">
                    <div class="metric-label">Slots Sold (Current Card)</div>
                    <div class="flex items-baseline gap-2">
                        <div class="metric-value text-indigo-600" id="slotsSoldMetric">0/18</div>
                        <span class="text-sm text-gray-500" id="slotsSoldPercent"></span>
                    </div>
                    <div class="w-full h-2 bg-gray-200 rounded-full mt-2">
                        <div id="slotsSoldBar" class="h-2 bg-indigo-500 rounded-full transition-all duration-300" style="width: 0%;"></div>
                    </div>
                </div>

                <div class="dashboard-widget">
                    <div class="metric-label">Revenue Progress</div>
                    <div class="metric-value text-green-600" id="currentRevenue">$0</div>
                    <p class="text-sm text-gray-500 mt-1" id="revenueProgressText">of $9,000 goal</p>
                    <div class="w-full h-2 bg-gray-200 rounded-full mt-2">
                        <div id="revenueProgressBar" class="h-2 bg-green-500 rounded-full transition-all duration-300" style="width: 0%;"></div>
                    </div>
                </div>

                <div class="dashboard-widget">
                    <div class="metric-label">Current Profit/Loss</div>
                    <div id="profitStatus" class="metric-value text-gray-400">$0</div>
                    <p class="text-sm text-gray-500 mt-1" id="spotsToBreakeven">Select a postcard</p>
                </div>

                <div class="dashboard-widget cursor-pointer hover:shadow-lg transition-shadow" onclick="openExpenseModal()">
                    <div class="metric-label flex justify-between items-center">
                        <span>Total Expenses</span>
                        <span class="text-xs text-blue-600 font-semibold">‚úé Edit</span>
                    </div>
                    <div class="metric-value text-orange-600" id="oldTotalExpenses">$0</div>
                    <p class="text-sm text-gray-500 mt-1">Click to manage expenses</p>
                </div>
            </div>

            <!-- CAMPAIGN CONTROLS - 3 COLUMN LAYOUT -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-8">
                <!-- LEFT: New Campaign -->
                <div class="border-2 border-green-500 p-4 rounded-lg bg-green-50 shadow-sm">
                    <div class="font-semibold mb-3 text-green-800 text-sm">New Campaign</div>
                    <div class="space-y-2">
                        <button onclick="openNewPostcardModal()" class="w-full px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 font-semibold text-sm shadow transition-all">
                            + Create Postcard
                        </button>
                        <button onclick="openDuplicatePostcardModal()" class="w-full px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 font-semibold text-sm shadow transition-all">
                            üìã Duplicate Card
                        </button>
                    </div>
                    <p class="text-xs text-gray-600 mt-2">Start or copy a campaign</p>
                </div>

                <!-- MIDDLE: Postcard Actions -->
                <div class="border-2 border-blue-500 p-4 rounded-lg bg-blue-50 shadow-sm">
                    <div class="font-semibold mb-3 text-blue-800 text-sm">Postcard Actions</div>

                    <!-- Action Buttons in One Row -->
                    <div class="flex flex-wrap gap-2">
                        <button id="btnEditStatusModal" onclick="openEditStatusModal()" class="flex-1 min-w-[100px] px-2 py-2 rounded bg-indigo-600 text-white hover:bg-indigo-700 text-xs font-medium transition-all">
                            üìù Edit Status
                        </button>
                        <button onclick="openPricingModal()" class="flex-1 min-w-[100px] px-2 py-2 rounded bg-purple-600 text-white hover:bg-purple-700 text-xs font-medium transition-all">
                            üí∞ Set Pricing
                        </button>
                        <button onclick="openEditDetailsModal()" class="flex-1 min-w-[100px] px-2 py-2 rounded bg-teal-600 text-white hover:bg-teal-700 text-xs font-medium transition-all">
                            üìÖ Edit Details
                        </button>
                        <button id="btnAdjustPostcard" class="flex-1 min-w-[100px] px-2 py-2 rounded bg-blue-600 text-white hover:bg-blue-700 text-xs font-medium transition-all">
                            üé® Edit Colors
                        </button>
                        <button onclick="deleteCurrentPostcard()" class="flex-1 min-w-[100px] px-2 py-2 rounded bg-red-600 text-white hover:bg-red-700 text-xs font-medium transition-all">
                            üóëÔ∏è Delete Card
                        </button>
                    </div>
                </div>

                <!-- RIGHT: Save Changes -->
                <div class="border-2 border-green-600 p-4 rounded-lg bg-gradient-to-br from-green-50 to-green-100 shadow-md">
                    <div class="font-semibold mb-3 text-green-800 text-sm">Save Changes</div>
                    <button id="btnSaveCommit"
                        class="w-full px-4 py-2.5 rounded-md bg-green-600 text-white hover:bg-green-700 opacity-50 cursor-not-allowed font-bold text-sm shadow-lg transition-all"
                        disabled>
                        ‚úÖ Commit to Database
                    </button>
                    <p class="text-xs text-center text-gray-600 mt-2">Saves all changes to Supabase</p>
                </div>
            </div>
            <div class="side-wrap mb-12" id="frontWrap">
                <h2 class="font-semibold mb-2 text-lg text-gray-900">Front Side</h2>
                <div class="postcard" id="frontPostcard">
                    <div id="frontGrid" class="grid-front"></div>
                </div>
            </div>
            <div class="side-wrap mb-16" id="backWrap">
                <h2 class="font-semibold mb-2 text-lg text-gray-900">Back Side</h2>
                <div class="postcard" id="backPostcard">
                    <div id="backGrid" class="grid-back"></div>
                </div>
            </div>
        </div>
        
        <!-- CLIENT DATABASE TAB -->
        <div data-content="clients" class="tab-pane hidden">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-bold">Client Database</h3>
                <div class="flex gap-2">
                    <button onclick="document.getElementById('csvFileInput').click()" class="px-3 py-1.5 bg-purple-600 text-white rounded-md text-sm hover:bg-purple-700">
                        üì§ Import CSV
                    </button>
                    <input type="file" id="csvFileInput" accept=".csv" onchange="importClientsCSV(event)" style="display: none;" />
                    <button onclick="exportClientsCSV()" class="px-3 py-1.5 bg-green-600 text-white rounded-md text-sm hover:bg-green-700">
                        üì• Export CSV
                    </button>
                    <button onclick="syncClientsToSheets()" class="px-3 py-1.5 bg-blue-600 text-white rounded-md text-sm hover:bg-blue-700">
                        ‚òÅÔ∏è Sync to Sheets
                    </button>
                    <button onclick="openClientModal()" class="px-4 py-1.5 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">
                        + Add Client
                    </button>
                </div>
            </div>
            
            <div class="bg-white rounded-lg shadow p-4 mb-4">
                <input id="clientSearch" type="text" placeholder="Search by business name, category, or contact..." 
                       class="w-full p-2 border rounded-md mb-3" onkeyup="filterClients()" />
                
                <div class="flex gap-2">
                    <select id="categoryFilter" class="border rounded-md p-1.5 text-sm" onchange="filterClients()">
                        <option value="">All Categories</option>
                        <option value="Restaurant">Restaurant</option>
                        <option value="HVAC">HVAC</option>
                        <option value="Plumbing">Plumbing</option>
                        <option value="Legal">Legal</option>
                        <option value="Medical">Medical</option>
                        <option value="Other">Other</option>
                    </select>
                    
                    <select id="statusFilter" class="border rounded-md p-1.5 text-sm" onchange="filterClients()">
                        <option value="">All Clients</option>
                        <option value="active">Active (Paid Card)</option>
                        <option value="pending">Pending Payment</option>
                        <option value="inactive">Inactive</option>
                    </select>
                </div>
            </div>
            
            <div id="clientList" class="space-y-2">
                <p class="text-sm text-gray-500 text-center py-8">No clients yet. Add your first client above!</p>
            </div>
        </div>
        
        <div data-content="admin" class="tab-pane hidden">
            <!-- Financials Dashboard -->
            <div class="mb-6 flex justify-between items-center">
                <h3 class="text-2xl font-bold">üí∞ Financials & Tax Tracking</h3>
                <div class="flex gap-2">
                    <button onclick="importSquareStatements()" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 font-medium text-sm">
                        üìÑ Import Square Data
                    </button>
                    <button onclick="exportFinancialCSV()" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 font-medium text-sm">
                        üì• Export CSV
                    </button>
                    <button onclick="showAddTransactionModal()" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 font-medium text-sm">
                        + Add Transaction
                    </button>
                </div>
            </div>

            <!-- Monthly Summary Cards -->
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                <div class="bg-green-50 border-2 border-green-200 rounded-lg p-4">
                    <div class="text-xs text-green-700 font-medium mb-1">Total Revenue</div>
                    <div id="totalRevenue" class="text-2xl font-bold text-green-600">$0.00</div>
                </div>
                <div class="bg-red-50 border-2 border-red-200 rounded-lg p-4">
                    <div class="text-xs text-red-700 font-medium mb-1">Total Expenses</div>
                    <div id="totalExpenses" class="text-2xl font-bold text-red-600">$0.00</div>
                </div>
                <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4">
                    <div class="text-xs text-blue-700 font-medium mb-1">Net Income</div>
                    <div id="netIncome" class="text-2xl font-bold text-blue-600">$0.00</div>
                </div>
                <div class="bg-purple-50 border-2 border-purple-200 rounded-lg p-4">
                    <div class="text-xs text-purple-700 font-medium mb-1">Current Balance</div>
                    <div id="currentBalance" class="text-2xl font-bold text-purple-600">$0.00</div>
                </div>
            </div>

            <!-- Filters -->
            <div class="mb-4 flex gap-4 items-center bg-gray-50 p-4 rounded-lg border">
                <div class="flex items-center gap-2">
                    <label class="text-sm font-medium text-gray-700">Period:</label>
                    <select id="financialPeriodFilter" onchange="renderFinancialRegister()" class="border rounded-md px-3 py-2 text-sm bg-white">
                        <option value="all">All Time</option>
                        <option value="current-month">Current Month</option>
                        <option value="last-month">Last Month</option>
                        <option value="current-year" selected>Current Year (2025)</option>
                        <option value="q1">Q1 2025</option>
                        <option value="q2">Q2 2025</option>
                        <option value="q3">Q3 2025</option>
                        <option value="q4">Q4 2025</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <label class="text-sm font-medium text-gray-700">Category:</label>
                    <select id="financialCategoryFilter" onchange="renderFinancialRegister()" class="border rounded-md px-3 py-2 text-sm bg-white">
                        <option value="all">All Categories</option>
                        <option value="revenue">Revenue</option>
                        <option value="cogs">COGS</option>
                        <option value="operating">Operating Expenses</option>
                        <option value="owner">Owner Draw</option>
                    </select>
                </div>
                <button onclick="showProfitLossReport()" class="ml-auto px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 font-medium text-sm">
                    üìä View P&L Report
                </button>
            </div>

            <!-- Transaction Register Table -->
            <div class="bg-white border rounded-lg overflow-hidden">
                <div class="overflow-x-auto">
                    <table class="w-full text-sm">
                        <thead class="bg-gray-100 border-b">
                            <tr>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Date</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Description</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Category</th>
                                <th class="px-4 py-3 text-right font-semibold text-gray-700">Amount</th>
                                <th class="px-4 py-3 text-right font-semibold text-gray-700">Balance</th>
                                <th class="px-4 py-3 text-left font-semibold text-gray-700">Notes</th>
                                <th class="px-4 py-3 text-center font-semibold text-gray-700">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="financialRegisterBody">
                            <tr>
                                <td colspan="7" class="px-4 py-8 text-center text-gray-500">
                                    Loading transactions...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Transaction Count -->
            <div class="mt-4 text-sm text-gray-600 text-center">
                <span id="transactionCount">0 transactions</span>
            </div>
        </div>
    </div>
  </main>
  
  <!-- Edit Spot Modal -->
  <div id="editModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" id="editDialog" aria-labelledby="modalTitle">
      <h3 id="modalTitle" class="text-lg font-bold mb-3">Edit Selected Spots</h3>
      <div class="mb-4">
        <label class="text-sm font-medium text-gray-700">Link to Client</label>
        <div class="flex gap-2">
          <select id="editClient" class="border rounded-md flex-1 p-2 bg-white">
            <option value="">‚Äî Select existing client ‚Äî</option>
          </select>
          <button type="button" onclick="quickAddClient()" class="px-3 py-2 bg-gray-100 border rounded-md hover:bg-gray-200 text-sm">
            + New
          </button>
        </div>
        <p class="text-xs text-gray-500 mt-1">Select a client to auto-fill business name below</p>
      </div>
      <div class="mb-4">
        <label class="text-sm font-medium text-gray-700">Enter Business Name</label>
        <input id="editName" class="border rounded-md w-full p-2 mt-1" placeholder="Example: Adam's Pizza" />
      </div>
      <div class="mb-4">
        <label class="text-sm font-medium text-gray-700">Status</label>
        <select id="editStatus" class="border rounded-md w-full p-2 mt-1 bg-white">
          <option value="AVAIL">Available</option>
          <option value="INVOICE">Invoice Sent</option>
          <option value="DEPOSIT">Deposit Paid</option>
          <option value="PROOF">Proof In Progress</option>
          <option value="APPROVED">Ad Approved</option>
          <option value="PAID">Paid In Full</option>
          <option value="RESERVED">Reserved</option>
        </select>
      </div>
      <div class="mb-4">
        <label class="text-sm font-medium text-gray-700">Spot Price</label>
        <div class="relative mt-1">
          <span class="absolute left-3 top-2 text-gray-500">$</span>
          <input id="editPrice" type="number" step="50" class="border rounded-md w-full p-2 pl-7" placeholder="500" />
        </div>
        <p class="text-xs text-gray-500 mt-1">Price for this specific ad spot</p>
      </div>
      <div class="flex justify-end gap-2">
        <button id="btnCancelEdit" class="px-3 py-1.5 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnApplyEdit" class="px-3 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700">Apply</button>
      </div>
    </div>
  </div>
  
  <!-- Postcard Color Modal -->
  <div id="postcardModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" id="postcardDialog">
      <h3>Adjust Postcard Colors</h3>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px">
        <div>
          <label style="display:block;font-weight:700;margin-bottom:6px">Postcard Background</label>
          <input id="pickerPostcard" type="color" value="#000000" />
        </div>
        <div>
          <label style="display:block;font-weight:700;margin-bottom:6px">Banner (front) Background</label>
          <input id="pickerBanner" type="color" value="#fed7aa" />
        </div>
      </div>
      <div style="margin-bottom:12px">
        <div style="font-size:.9rem;color:#374151;margin-bottom:6px">Preview</div>
        <div style="display:flex;gap:12px;align-items:center">
          <div id="previewPostcard" style="width:160px;height:100px;border-radius:8px;border:1px solid #e5e7eb;display:flex;align-items:center;justify-content:center;background:#000">
            <div id="previewBanner" style="background:#000000;padding:6px 8px;border-radius:6px"><span style="font-weight:800;color:#ffffff">TOWN ‚Äî MONTH</span></div>
          </div>
          <div style="font-size:.9rem;color:#6b7280">Postcard bg controls the simulated postcard container. Banner bg changes the front postcard banner visually and will be saved on Commit.</div>
        </div>
      </div>
      <div style="display:flex;justify-content:flex-end;gap:8px">
        <button id="btnCancelPostcard" class="px-3 py-1.5 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnApplyPostcard" class="px-3 py-1.5 bg-green-600 text-white rounded-md hover:bg-green-700">Apply & Close</button>
      </div>
    </div>
  </div>
  
  <!-- Duplicate Postcard Modal -->
  <div id="duplicatePostcardModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 600px;">
      <h3 class="text-lg font-bold mb-4">Duplicate Postcard</h3>

      <div class="space-y-4">
        <!-- Select Source Postcard -->
        <div class="p-4 bg-blue-50 rounded-lg border border-blue-200">
          <h4 class="font-semibold text-blue-900 mb-2">Select Postcard to Duplicate</h4>
          <select id="duplicateSourcePostcard" class="border rounded-md p-2 w-full bg-white">
            <option value="">‚Äî Select postcard ‚Äî</option>
          </select>
        </div>

        <!-- New Details -->
        <div class="p-4 bg-orange-50 rounded-lg border border-orange-200">
          <h4 class="font-semibold text-orange-900 mb-3">New Details (must change at least one)</h4>
          <div class="space-y-3">
            <div>
              <label class="text-sm font-medium block mb-1">New Town (optional)</label>
              <input id="duplicateTown" type="text" class="border rounded-md p-2 w-full" placeholder="Leave empty to keep same town" />
            </div>
            <div class="grid grid-cols-2 gap-2">
              <div>
                <label class="text-sm font-medium block mb-1">New Month (optional)</label>
                <select id="duplicateMonth" class="border rounded-md p-2 w-full bg-white">
                  <option value="">Keep same</option>
                  <option value="01">January</option>
                  <option value="02">February</option>
                  <option value="03">March</option>
                  <option value="04">April</option>
                  <option value="05">May</option>
                  <option value="06">June</option>
                  <option value="07">July</option>
                  <option value="08">August</option>
                  <option value="09">September</option>
                  <option value="10">October</option>
                  <option value="11">November</option>
                  <option value="12">December</option>
                </select>
              </div>
              <div>
                <label class="text-sm font-medium block mb-1">New Year (optional)</label>
                <input id="duplicateYear" type="number" class="border rounded-md p-2 w-full" placeholder="Keep same" />
              </div>
            </div>
            <div>
              <label class="text-sm font-medium block mb-1">New Size (optional)</label>
              <select id="duplicateSize" class="border rounded-md p-2 w-full bg-white">
                <option value="">Keep same</option>
                <option value="9x12">9√ó12</option>
                <option value="6x12">6.5√ó12</option>
              </select>
            </div>
          </div>
        </div>

        <!-- What to Copy -->
        <div class="p-4 bg-purple-50 rounded-lg border border-purple-200">
          <h4 class="font-semibold text-purple-900 mb-2">What to Copy</h4>
          <div class="space-y-2">
            <label class="flex items-center gap-2">
              <input type="checkbox" id="duplicateCopyAdvertisers" checked />
              <span class="text-sm">Copy all advertisers (as "Reserved")</span>
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="duplicateCopyExpenses" checked />
              <span class="text-sm">Copy expenses</span>
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="duplicateCopyPricing" checked />
              <span class="text-sm">Copy pricing (single/double/banner costs)</span>
            </label>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="duplicateCopyColors" checked />
              <span class="text-sm">Copy postcard & banner colors</span>
            </label>
          </div>
        </div>
      </div>

      <div class="flex justify-end gap-2 mt-6">
        <button id="btnCancelDuplicate" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnCreateDuplicate" class="px-6 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 font-semibold">
          Create Duplicate
        </button>
      </div>
    </div>
  </div>

  <!-- Set Pricing Modal -->
  <div id="pricingModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 500px;">
      <h3 class="text-lg font-bold mb-4">Set Ad Pricing</h3>

      <div class="space-y-4">
        <div class="bg-purple-50 rounded-lg p-4 border border-purple-200">
          <p class="text-sm text-gray-700 mb-3">Set the price you charge clients for each ad type. This will auto-calculate revenue in your profit/loss card.</p>

          <div class="space-y-3">
            <div>
              <label class="text-sm font-medium block mb-1">Single Ad Cost ($)</label>
              <input id="pricingSingleAd" type="number" step="0.01" class="border rounded-md p-2 w-full" placeholder="e.g., 199.00" />
            </div>
            <div>
              <label class="text-sm font-medium block mb-1">Double Ad Cost ($)</label>
              <input id="pricingDoubleAd" type="number" step="0.01" class="border rounded-md p-2 w-full" placeholder="e.g., 349.00" />
            </div>
            <div>
              <label class="text-sm font-medium block mb-1">Banner Ad Cost ($)</label>
              <input id="pricingBannerAd" type="number" step="0.01" class="border rounded-md p-2 w-full" placeholder="e.g., 699.00" />
            </div>
          </div>
        </div>

        <!-- Revenue Goal Calculator -->
        <div class="bg-green-50 rounded-lg p-4 border border-green-200">
          <div class="text-sm font-semibold text-green-900 mb-3">üìä Revenue Goal Calculator</div>
          <p class="text-xs text-gray-600 mb-3">Set your revenue goal based on how many of each ad size you plan to sell:</p>

          <div class="space-y-3">
            <div class="flex gap-3 items-center">
              <div class="flex-1">
                <label class="text-xs font-medium block mb-1">Singles (#)</label>
                <input id="goalSingleCount" type="number" min="0" class="border rounded-md p-2 w-full text-sm" placeholder="0" oninput="updateRevenueGoalCalculator()" />
              </div>
              <div class="flex-1">
                <label class="text-xs font-medium block mb-1">Price Each ($)</label>
                <input id="goalSinglePrice" type="number" step="0.01" min="0" class="border rounded-md p-2 w-full text-sm" placeholder="0.00" oninput="updateRevenueGoalCalculator()" />
              </div>
              <div class="flex-1 text-right">
                <label class="text-xs font-medium block mb-1">Subtotal</label>
                <div id="goalSingleTotal" class="text-sm font-semibold text-gray-700">$0.00</div>
              </div>
            </div>

            <div class="flex gap-3 items-center">
              <div class="flex-1">
                <label class="text-xs font-medium block mb-1">Doubles (#)</label>
                <input id="goalDoubleCount" type="number" min="0" class="border rounded-md p-2 w-full text-sm" placeholder="0" oninput="updateRevenueGoalCalculator()" />
              </div>
              <div class="flex-1">
                <label class="text-xs font-medium block mb-1">Price Each ($)</label>
                <input id="goalDoublePrice" type="number" step="0.01" min="0" class="border rounded-md p-2 w-full text-sm" placeholder="0.00" oninput="updateRevenueGoalCalculator()" />
              </div>
              <div class="flex-1 text-right">
                <label class="text-xs font-medium block mb-1">Subtotal</label>
                <div id="goalDoubleTotal" class="text-sm font-semibold text-gray-700">$0.00</div>
              </div>
            </div>

            <div class="flex gap-3 items-center">
              <div class="flex-1">
                <label class="text-xs font-medium block mb-1">Banners (#)</label>
                <input id="goalBannerCount" type="number" min="0" class="border rounded-md p-2 w-full text-sm" placeholder="0" oninput="updateRevenueGoalCalculator()" />
              </div>
              <div class="flex-1">
                <label class="text-xs font-medium block mb-1">Price Each ($)</label>
                <input id="goalBannerPrice" type="number" step="0.01" min="0" class="border rounded-md p-2 w-full text-sm" placeholder="0.00" oninput="updateRevenueGoalCalculator()" />
              </div>
              <div class="flex-1 text-right">
                <label class="text-xs font-medium block mb-1">Subtotal</label>
                <div id="goalBannerTotal" class="text-sm font-semibold text-gray-700">$0.00</div>
              </div>
            </div>

            <div class="border-t border-green-300 pt-3 mt-3">
              <div class="flex justify-between items-center">
                <span class="text-sm font-bold text-green-900">Total Revenue Goal:</span>
                <span id="goalTotalRevenue" class="text-lg font-bold text-green-700">$0.00</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="flex justify-end gap-2 mt-6">
        <button id="btnCancelPricing" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnSavePricing" class="px-6 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 font-semibold">
          Save Pricing
        </button>
      </div>
    </div>
  </div>

  <!-- Edit Status Modal (Legend + Sort) -->
  <div id="editStatusModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 700px;">
      <h3 class="text-lg font-bold mb-4">Edit Status Colors & Order</h3>

      <!-- Current Status Colors Legend -->
      <div class="bg-blue-50 rounded-lg p-4 mb-4 border border-blue-200">
        <div class="font-medium text-blue-900 text-sm mb-2">Current Status Colors:</div>
        <div id="editStatusLegendGrid" class="flex gap-3 flex-wrap text-xs">
          <!-- Populated dynamically -->
        </div>
      </div>

      <!-- Sort Interface -->
      <div class="mb-4">
        <div class="font-medium text-gray-700 text-sm mb-2">Drag to Reorder:</div>
        <div class="flex gap-3 items-start">
          <div class="flex-1">
            <div id="sortListContainer" style="background:#fafafa;border:1px solid #e6eef4;border-radius:8px;padding:8px;min-height:200px"></div>
          </div>
          <div style="width:240px">
            <div style="font-size:.9rem;color:#374151;margin-bottom:8px">Preview (left ‚Üí right)</div>
            <div id="sortPreview" style="height:48px;border-radius:6px;border:1px solid #e6eef4"></div>
          </div>
        </div>
      </div>

      <div class="flex justify-end gap-2">
        <button id="btnCancelEditStatus" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnSaveEditStatus" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Edit Postcard Details Modal -->
  <div id="editDetailsModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 500px;">
      <h3 class="text-lg font-bold mb-4">Edit Postcard Details</h3>

      <div class="space-y-4">
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Expected In Homes Date</label>
          <input id="editInHomesDate" type="date" class="border rounded-md p-2 w-full" />
          <p class="text-xs text-gray-500 mt-1">Date when the postcard is expected to arrive in mailboxes</p>
        </div>
      </div>

      <div class="flex justify-end gap-2 mt-6">
        <button onclick="closeEditDetailsModal()" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button onclick="saveEditDetailsModal()" class="px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- Expense Management Modal -->
  <div id="expenseModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" id="expenseDialog" style="max-width: 640px;">
      <h3 class="text-lg font-bold mb-4">Manage Postcard Expenses</h3>
      
      <div class="space-y-4">
        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Printing Cost</label>
            <div class="relative">
              <span class="absolute left-3 top-2 text-gray-500">$</span>
              <input id="expensePrinting" type="number" step="10" class="border rounded-md w-full p-2 pl-7" placeholder="0" />
            </div>
          </div>

          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Postage Cost (EDDM)</label>
            <div class="relative">
              <span class="absolute left-3 top-2 text-gray-500">$</span>
              <input id="expensePostage" type="number" step="10" class="border rounded-md w-full p-2 pl-7" placeholder="0" />
            </div>
            <p class="text-xs text-gray-500 mt-1">~$0.20-0.23 per piece</p>
          </div>

          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Design/Labor Cost</label>
            <div class="relative">
              <span class="absolute left-3 top-2 text-gray-500">$</span>
              <input id="expenseDesign" type="number" step="10" class="border rounded-md w-full p-2 pl-7" placeholder="0" />
            </div>
          </div>

          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Misc/Other Costs</label>
            <div class="relative">
              <span class="absolute left-3 top-2 text-gray-500">$</span>
              <input id="expenseMisc" type="number" step="10" class="border rounded-md w-full p-2 pl-7" placeholder="0" />
            </div>
          </div>
        </div>
        
        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <div class="flex justify-between items-center">
            <span class="font-semibold text-gray-700">Total Expenses:</span>
            <span id="expenseTotal" class="text-2xl font-bold text-orange-600">$0</span>
          </div>
        </div>
        
        <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
          <h4 class="font-semibold text-blue-900 mb-2">üí° Quick Calculation Help</h4>
          <div class="text-sm text-blue-800 space-y-1">
            <p><strong>5,000 pieces:</strong> ~$1,000-1,150 postage</p>
            <p><strong>10,000 pieces:</strong> ~$2,000-2,300 postage</p>
            <p><strong>Printing:</strong> $0.10-0.15 per postcard</p>
          </div>
        </div>
      </div>
      
      <div class="flex justify-end gap-2 mt-6">
        <button id="btnCancelExpense" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnSaveExpense" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Save Expenses</button>
      </div>
    </div>
  </div>

  <!-- Manage Business Categories Modal -->
  <div id="manageCategoriesModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 600px; max-height: 90vh; overflow-y: auto;">
      <h3 class="text-lg font-bold mb-4">‚öôÔ∏è Manage Business Categories</h3>

      <div class="space-y-4">
        <!-- Add New Category Section -->
        <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
          <label class="text-sm font-medium text-gray-700 block mb-2">Add New Category</label>
          <div class="flex gap-2">
            <input
              id="newCategoryInput"
              type="text"
              class="border rounded-md flex-1 p-2"
              placeholder="e.g., Coffee Shop"
              onkeypress="if(event.key==='Enter') addNewCategory()"
            />
            <button onclick="addNewCategory()" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 font-semibold">
              ‚ûï Add
            </button>
          </div>
        </div>

        <!-- Current Categories List -->
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-2">Current Categories</label>
          <div id="manageCategoriesList" class="space-y-2 max-h-96 overflow-y-auto pr-2" style="scrollbar-width: thin;">
            <!-- Categories will be rendered here -->
          </div>
        </div>
      </div>

      <div class="flex justify-end gap-2 mt-6">
        <button onclick="closeManageCategoriesModal()" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Close</button>
        <button onclick="saveManageCategories()" class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700">üíæ Save Categories</button>
      </div>
    </div>
  </div>

  <!-- Daily Goal Settings Modal -->
  <div id="dailyGoalSettingsModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 500px;">
      <h3 class="text-lg font-bold mb-4">‚öôÔ∏è Daily Outreach Goal Settings</h3>

      <div class="space-y-4">
        <!-- Set Daily Goal -->
        <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
          <label class="text-sm font-medium text-gray-700 block mb-2">Daily Outreach Goal</label>
          <div class="flex gap-2 items-center">
            <input
              id="dailyGoalInput"
              type="number"
              min="1"
              class="border rounded-md flex-1 p-2"
              placeholder="Enter number of contacts per day"
              onkeypress="if(event.key==='Enter') saveDailyGoalFromModal()"
            />
            <span class="text-sm text-gray-600">contacts/day</span>
          </div>
          <p class="text-xs text-gray-500 mt-2">Set how many prospects you want to contact each day.</p>
        </div>

        <!-- Reset Count Button -->
        <div class="bg-red-50 p-4 rounded-lg border border-red-200">
          <label class="text-sm font-medium text-gray-700 block mb-2">Reset Today's Count</label>
          <button onclick="resetDailyGoalFromModal()" class="w-full px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 font-medium">
            üîÑ Reset Count to 0
          </button>
          <p class="text-xs text-gray-500 mt-2">Reset today's outreach count back to zero.</p>
        </div>
      </div>

      <div class="flex justify-end gap-2 mt-6">
        <button onclick="closeDailyGoalSettings()" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button onclick="saveDailyGoalFromModal()" class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700">üíæ Save Goal</button>
      </div>
    </div>
  </div>

  <!-- Client Management Modal -->
  <div id="clientModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
      <h3 id="clientModalTitle" class="text-lg font-bold mb-4">Add New Client</h3>
      
      <div class="space-y-4">
        <div class="grid grid-cols-2 gap-4">
          <div class="col-span-2">
            <label class="text-sm font-medium text-gray-700 block mb-1">Business Name *</label>
            <input id="clientBusinessName" type="text" class="border rounded-md w-full p-2" placeholder="Adam's Pizza" required />
          </div>
          
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Category</label>
            <select id="clientCategory" class="border rounded-md w-full p-2 bg-white" onchange="toggleCustomCategory()">
              <option value="">Select category...</option>
              <option value="Restaurant">Restaurant</option>
              <option value="HVAC">HVAC</option>
              <option value="Plumbing">Plumbing</option>
              <option value="Electrician">Electrician</option>
              <option value="Legal">Legal</option>
              <option value="Medical">Medical</option>
              <option value="Real Estate">Real Estate</option>
              <option value="Home Services">Home Services</option>
              <option value="Automotive">Automotive</option>
              <option value="Other">Other (Specify)</option>
            </select>
            <input id="clientCustomCategory" type="text" class="border rounded-md w-full p-2 mt-2 hidden" placeholder="Enter custom category..." />
          </div>
          
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Contact Name</label>
            <input id="clientContactName" type="text" class="border rounded-md w-full p-2" placeholder="Adam Smith" />
          </div>
          
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Phone</label>
            <input id="clientPhone" type="tel" class="border rounded-md w-full p-2" placeholder="(555) 123-4567" />
          </div>
          
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Email</label>
            <input id="clientEmail" type="email" class="border rounded-md w-full p-2" placeholder="adam@adamspizza.com" />
          </div>
        </div>
        
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Notes</label>
          <textarea id="clientNotes" rows="3" class="border rounded-md w-full p-2" placeholder="Special requests, preferences, etc."></textarea>
        </div>

        <!-- Contract Section -->
        <div class="border-t pt-4">
          <div class="flex justify-between items-center mb-3">
            <h4 class="font-semibold text-gray-700">Multi-Month Contract (Optional)</h4>
            <label class="flex items-center gap-2">
              <input type="checkbox" id="hasContract" onchange="toggleContractFields()" />
              <span class="text-sm">Enable Contract</span>
            </label>
          </div>

          <div id="contractFields" class="hidden space-y-3">
            <div class="grid grid-cols-2 gap-4">
              <div>
                <label class="text-sm font-medium text-gray-700 block mb-1">Contract Start Date</label>
                <input id="contractStartDate" type="date" class="border rounded-md w-full p-2" onchange="calculateContractEnd()" />
              </div>
              <div>
                <label class="text-sm font-medium text-gray-700 block mb-1">Contract Length</label>
                <select id="contractLength" class="border rounded-md w-full p-2 bg-white" onchange="calculateContractEnd()">
                  <option value="1">1 month</option>
                  <option value="3">3 months</option>
                  <option value="6" selected>6 months</option>
                  <option value="12">12 months</option>
                </select>
              </div>
            </div>

            <div class="grid grid-cols-2 gap-4">
              <div>
                <label class="text-sm font-medium text-gray-700 block mb-1">Monthly Rate</label>
                <div class="relative">
                  <span class="absolute left-3 top-2 text-gray-500">$</span>
                  <input id="contractMonthlyRate" type="number" step="50" class="border rounded-md w-full p-2 pl-7" placeholder="500" onchange="calculateContractTotal()" />
                </div>
              </div>
              <div>
                <label class="text-sm font-medium text-gray-700 block mb-1">Total Contract Value</label>
                <div id="contractTotalValue" class="text-2xl font-bold text-green-600 mt-1">$0</div>
              </div>
            </div>

            <div class="bg-gray-50 p-3 rounded-md">
              <div class="text-sm text-gray-700 mb-1">Contract End Date: <span id="contractEndDate" class="font-semibold">‚Äî</span></div>
              <label class="flex items-center gap-2 mt-2">
                <input type="checkbox" id="contractAutoRenew" />
                <span class="text-sm">Auto-renew contract</span>
              </label>
            </div>

            <div class="bg-blue-50 p-3 rounded-lg border border-blue-200">
              <p class="text-sm text-blue-900 font-medium mb-2">üí° Best Practice for SaaS Model:</p>
              <ul class="text-xs text-blue-800 space-y-1 ml-4 list-disc">
                <li>Offer 3, 6, or 12-month packages with discounts</li>
                <li>Automatically reserve spots for contract holders when creating new postcards</li>
                <li>Set renewal reminders 30 days before contract end</li>
              </ul>
            </div>
          </div>
        </div>

        <div id="clientHistorySection" class="hidden">
          <div class="border-t pt-4">
            <h4 class="font-semibold text-gray-700 mb-2">Purchase History</h4>
            <div id="clientHistory" class="space-y-2">
            </div>
          </div>
          
          <div class="grid grid-cols-3 gap-4 mt-4 p-3 bg-gray-50 rounded-lg">
            <div class="text-center">
              <div class="text-xs text-gray-600">Lifetime Spent</div>
              <div id="clientLifetimeSpent" class="text-lg font-bold text-green-600">$0</div>
            </div>
            <div class="text-center">
              <div class="text-xs text-gray-600">Cards Bought</div>
              <div id="clientCardsBought" class="text-lg font-bold text-indigo-600">0</div>
            </div>
            <div class="text-center">
              <div class="text-xs text-gray-600">Avg Price</div>
              <div id="clientAvgPrice" class="text-lg font-bold text-blue-600">$0</div>
            </div>
          </div>
        </div>
      </div>
      
      <input type="hidden" id="clientId" />
      
      <div class="flex justify-between items-center gap-2 mt-6 pt-4 border-t">
        <button id="btnDeleteClient" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 hidden">Delete Client</button>
        <div class="flex gap-2 ml-auto">
          <button id="btnCancelClient" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
          <button id="btnSaveClient" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Save Client</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Email Modal -->
  <div id="emailModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 600px;">
      <h3 class="text-lg font-bold mb-4">Send Email</h3>
      
      <div class="space-y-4">
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Template</label>
          <select id="emailTemplate" class="border rounded-md w-full p-2 bg-white" onchange="loadEmailTemplate()">
            <option value="">‚Äî Select Template ‚Äî</option>
            <option value="invoice">Invoice Reminder</option>
            <option value="proof">Proof Ready for Review</option>
            <option value="renewal">Renewal Offer</option>
            <option value="thankyou">Thank You</option>
          </select>
        </div>
        
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">To</label>
          <input id="emailTo" type="email" class="border rounded-md w-full p-2" placeholder="client@example.com" />
        </div>
        
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Subject</label>
          <input id="emailSubject" type="text" class="border rounded-md w-full p-2" placeholder="Subject line" />
        </div>
        
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Message</label>
          <textarea id="emailBody" rows="8" class="border rounded-md w-full p-2" placeholder="Email body..."></textarea>
        </div>
      </div>
      
      <div class="flex justify-end gap-2 mt-6">
        <button id="btnCancelEmail" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnSendEmail" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Send Email</button>
      </div>
    </div>
  </div>
  
  <!-- Reports Modal -->
  <div id="reportsModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 800px;">
      <h3 class="text-lg font-bold mb-4">Financial Reports & Analytics</h3>
      
      <div class="space-y-4">
        <div class="grid grid-cols-2 gap-4">
          <button onclick="generateProfitLossReport()" class="p-4 border-2 border-gray-300 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-all text-left">
            <div class="font-semibold text-gray-900">üìä Profit & Loss Report</div>
            <div class="text-sm text-gray-600 mt-1">Monthly revenue vs expenses breakdown</div>
          </button>
          
          <button onclick="generateClientValueReport()" class="p-4 border-2 border-gray-300 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-all text-left">
            <div class="font-semibold text-gray-900">üí∞ Client Value Analysis</div>
            <div class="text-sm text-gray-600 mt-1">Lifetime value & renewal rates</div>
          </button>
          
          <button onclick="generateCampaignReport()" class="p-4 border-2 border-gray-300 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-all text-left">
            <div class="font-semibold text-gray-900">üìà Campaign Performance</div>
            <div class="text-sm text-gray-600 mt-1">Compare all campaigns side-by-side</div>
          </button>
          
          <button onclick="generateSalesFunnelReport()" class="p-4 border-2 border-gray-300 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-all text-left">
            <div class="font-semibold text-gray-900">üéØ Sales Funnel</div>
            <div class="text-sm text-gray-600 mt-1">Conversion rates by stage</div>
          </button>
        </div>
        
        <div id="reportOutput" class="border rounded-lg p-4 bg-gray-50 min-h-[200px] hidden">
          <div class="flex justify-between items-center mb-2">
            <h4 class="font-semibold">Report Output</h4>
            <button onclick="downloadReport()" class="text-sm px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700">Download CSV</button>
          </div>
          <div id="reportContent" class="text-sm"></div>
        </div>
      </div>
      
      <div class="flex justify-end gap-2 mt-6">
        <button id="btnCloseReports" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Close</button>
      </div>
    </div>
  </div>
  
  <!-- Task Management Modal -->
  <div id="taskModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 500px;">
      <h3 id="taskModalTitle" class="text-lg font-bold mb-4">Add New Task</h3>

      <div class="space-y-4">
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Task Description *</label>
          <input id="taskText" type="text" class="border rounded-md w-full p-2" placeholder="Follow up with client..." required />
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Due Date *</label>
          <input id="taskDueDate" type="date" class="border rounded-md w-full p-2" required />
        </div>
      </div>

      <input type="hidden" id="taskId" />

      <div class="flex justify-end gap-2 mt-6">
        <button id="btnCancelTask" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnSaveTask" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Save Task</button>
      </div>
    </div>
  </div>

  <!-- Lead Management Modal -->
  <div id="leadModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 550px;">
      <h3 id="leadModalTitle" class="text-lg font-bold mb-4">Add New Lead</h3>

      <div class="space-y-4">
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Business Name *</label>
          <input id="leadBusinessName" type="text" class="border rounded-md w-full p-2" placeholder="Joe's Plumbing" required />
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Contact Name</label>
            <input id="leadContactName" type="text" class="border rounded-md w-full p-2" placeholder="Joe Smith" />
          </div>

          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Phone</label>
            <input id="leadPhone" type="tel" class="border rounded-md w-full p-2" placeholder="(555) 123-4567" />
          </div>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Email</label>
          <input id="leadEmail" type="email" class="border rounded-md w-full p-2" placeholder="joe@joesplumbing.com" />
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Website</label>
          <input id="leadWebsite" type="url" class="border rounded-md w-full p-2" placeholder="https://joesplumbing.com" />
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Facebook</label>
            <input id="leadFacebook" type="url" class="border rounded-md w-full p-2" placeholder="https://facebook.com/..." />
          </div>

          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Instagram</label>
            <input id="leadInstagram" type="url" class="border rounded-md w-full p-2" placeholder="https://instagram.com/..." />
          </div>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Estimated Value</label>
          <div class="relative">
            <span class="absolute left-3 top-2 text-gray-500">$</span>
            <input id="leadValue" type="number" step="50" class="border rounded-md w-full p-2 pl-7" placeholder="500" />
          </div>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Notes</label>
          <textarea id="leadNotes" rows="2" class="border rounded-md w-full p-2" placeholder="Details about this lead..."></textarea>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">üìÖ Follow-Up Date</label>
          <input id="leadFollowUpDate" type="date" class="border rounded-md w-full p-2" />
          <p class="text-xs text-gray-500 mt-1">Set a reminder to contact this prospect later</p>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-2">Activity Log</label>
          <div id="leadActivityLog" class="border rounded-md p-3 bg-gray-50 max-h-32 overflow-y-auto text-xs space-y-1">
            <div class="text-gray-400 italic">No activity yet</div>
          </div>
          <div class="mt-2 flex gap-2">
            <input id="leadNewActivity" type="text" class="border rounded-md flex-1 p-2 text-sm" placeholder="Add a note (e.g., 'Called, left voicemail')" />
            <button onclick="addActivityNote()" class="px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 text-sm">Add</button>
          </div>
        </div>
      </div>

      <input type="hidden" id="leadColumn" />
      <input type="hidden" id="leadId" />

      <div class="flex justify-end gap-2 mt-6">
        <button id="btnCancelLead" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnSaveLead" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Save Lead</button>
      </div>
    </div>
  </div>

  <!-- Contact Later Modal -->
  <div id="contactLaterModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 400px;">
      <h3 class="text-lg font-bold mb-4">üìÖ Contact Later</h3>

      <p class="text-sm text-gray-600 mb-4">Set a follow-up date and move this prospect to your pool.</p>

      <div class="space-y-4">
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Business Name</label>
          <div id="contactLaterBusinessName" class="text-sm font-semibold text-gray-900"></div>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Follow-Up Date *</label>
          <input id="contactLaterDate" type="date" class="border rounded-md w-full p-2" required />
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Quick Note (Optional)</label>
          <input id="contactLaterNote" type="text" class="border rounded-md w-full p-2" placeholder="e.g., 'Call back in 2 weeks'" />
        </div>
      </div>

      <input type="hidden" id="contactLaterLeadId" />

      <div class="flex justify-end gap-2 mt-6">
        <button id="btnCancelContactLater" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnSaveContactLater" class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700">üìÖ Move to Pool</button>
      </div>
    </div>
  </div>

  <!-- Add Transaction Modal -->
  <div id="addTransactionModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 600px;">
      <h3 class="text-lg font-bold mb-4">üíµ Add Transaction</h3>

      <div class="space-y-4">
        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Date *</label>
            <input id="txnDate" type="date" class="border rounded-md w-full p-2" required />
          </div>

          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Type *</label>
            <select id="txnType" class="border rounded-md w-full p-2 bg-white" required>
              <option value="">Select type...</option>
              <option value="revenue">Revenue (Income)</option>
              <option value="cogs">Cost of Goods Sold</option>
              <option value="operating">Operating Expense</option>
              <option value="owner_draw">Owner Draw</option>
            </select>
          </div>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Description *</label>
          <input id="txnDescription" type="text" class="border rounded-md w-full p-2" placeholder="e.g., Client payment, Office supplies, etc." required />
          <p class="text-xs text-gray-500 mt-1">A clear description helps your accountant categorize expenses</p>
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Amount *</label>
            <div class="relative">
              <span class="absolute left-3 top-2 text-gray-500">$</span>
              <input id="txnAmount" type="number" step="0.01" class="border rounded-md w-full p-2 pl-7" placeholder="0.00" required />
            </div>
            <p class="text-xs text-gray-500 mt-1">Enter positive amount (we'll auto-adjust for expenses)</p>
          </div>

          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Category</label>
            <input id="txnCategory" type="text" class="border rounded-md w-full p-2" placeholder="Auto-assigned" readonly />
          </div>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Notes (Optional)</label>
          <textarea id="txnNotes" rows="2" class="border rounded-md w-full p-2" placeholder="Additional details for your accountant..."></textarea>
        </div>

        <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
          <p class="text-sm text-blue-900"><strong>üí° Tip:</strong> Add detailed descriptions to make tax preparation easier. Your accountant will thank you!</p>
        </div>
      </div>

      <div class="flex justify-end gap-2 mt-6 pt-4 border-t">
        <button id="btnCancelAddTransaction" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnSaveAddTransaction" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Save Transaction</button>
      </div>
    </div>
  </div>

  <!-- Edit Transaction Modal -->
  <div id="editTransactionModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 600px;">
      <h3 class="text-lg font-bold mb-4">‚úèÔ∏è Edit Transaction</h3>

      <div class="space-y-4">
        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Date *</label>
            <input id="editTxnDate" type="date" class="border rounded-md w-full p-2" required />
          </div>

          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Type *</label>
            <select id="editTxnType" class="border rounded-md w-full p-2 bg-white" required>
              <option value="revenue">Revenue (Income)</option>
              <option value="cogs">Cost of Goods Sold</option>
              <option value="operating">Operating Expense</option>
              <option value="owner_draw">Owner Draw</option>
            </select>
          </div>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Description *</label>
          <input id="editTxnDescription" type="text" class="border rounded-md w-full p-2" placeholder="e.g., Client payment, Office supplies, etc." required />
        </div>

        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Amount *</label>
            <div class="relative">
              <span class="absolute left-3 top-2 text-gray-500">$</span>
              <input id="editTxnAmount" type="number" step="0.01" class="border rounded-md w-full p-2 pl-7" required />
            </div>
          </div>

          <div>
            <label class="text-sm font-medium text-gray-700 block mb-1">Category</label>
            <input id="editTxnCategory" type="text" class="border rounded-md w-full p-2" readonly />
          </div>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Notes (Optional)</label>
          <textarea id="editTxnNotes" rows="2" class="border rounded-md w-full p-2" placeholder="Additional details..."></textarea>
        </div>
      </div>

      <input type="hidden" id="editTxnId" />

      <div class="flex justify-end gap-2 mt-6 pt-4 border-t">
        <button id="btnCancelEditTransaction" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnSaveEditTransaction" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Save Changes</button>
      </div>
    </div>
  </div>

  <!-- P&L Report Modal -->
  <div id="plReportModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
      <div class="flex justify-between items-start mb-4">
        <div>
          <h3 class="text-xl font-bold">üìä Profit & Loss Statement</h3>
          <p class="text-sm text-gray-600 mt-1">Professional financial report for your accountant</p>
        </div>
        <button onclick="closePLReportModal()" class="text-gray-400 hover:text-gray-600 text-2xl leading-none">&times;</button>
      </div>

      <div class="mb-4">
        <label class="text-sm font-medium text-gray-700 block mb-1">Report Period</label>
        <select id="plReportPeriod" class="border rounded-md p-2 bg-white" onchange="generatePLReport()">
          <option value="current-year">Current Year (2025)</option>
          <option value="q1">Q1 2025 (Jan-Mar)</option>
          <option value="q2">Q2 2025 (Apr-Jun)</option>
          <option value="q3">Q3 2025 (Jul-Sep)</option>
          <option value="q4">Q4 2025 (Oct-Dec)</option>
          <option value="current-month">Current Month</option>
          <option value="last-month">Last Month</option>
          <option value="all">All Time</option>
        </select>
      </div>

      <div id="plReportContent" class="bg-white border rounded-lg">
        <!-- Report content will be generated here -->
      </div>

      <div class="flex justify-end gap-2 mt-4">
        <button onclick="exportPLReportPDF()" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">üìÑ Export PDF</button>
        <button onclick="closePLReportModal()" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Close</button>
      </div>
    </div>
  </div>

  <!-- Auto-Populate Prospects Modal -->
  <div id="autoPopulateModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 600px;">
      <h3 class="text-lg font-bold mb-4">üîç Auto-Populate Prospects</h3>

      <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
        <p class="text-sm text-blue-900">
          Search Google Places API for businesses in your area and automatically add them to your prospecting list.
        </p>
      </div>

      <!-- API Usage Stats -->
      <div id="apiUsageDisplay" class="mb-4 p-3 rounded-lg border">
        <!-- Populated by JavaScript -->
      </div>

      <div class="space-y-4">
        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Zip Code *</label>
          <input id="autoPopZipCode" type="text" class="border rounded-md w-full p-2" placeholder="02101" maxlength="10" required />
          <p class="text-xs text-gray-500 mt-1">5-digit US zip code</p>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Business Category *</label>
          <select id="autoPopCategory" class="border rounded-md w-full p-2 bg-white" required>
            <option value="">Select category...</option>
            <option value="restaurant">Restaurant</option>
            <option value="cafe">Cafe / Coffee Shop</option>
            <option value="bar">Bar / Pub</option>
            <option value="retail">Retail Store</option>
            <option value="grocery_or_supermarket">Grocery Store</option>
            <option value="pharmacy">Pharmacy</option>
            <option value="gym">Gym / Fitness</option>
            <option value="hair_care">Hair Salon / Barber</option>
            <option value="beauty_salon">Beauty Salon / Spa</option>
            <option value="dentist">Dentist</option>
            <option value="doctor">Doctor / Medical</option>
            <option value="lawyer">Law Firm</option>
            <option value="real_estate_agency">Real Estate Agency</option>
            <option value="car_dealer">Car Dealer</option>
            <option value="car_repair">Auto Repair</option>
            <option value="plumber">Plumber</option>
            <option value="electrician">Electrician</option>
            <option value="roofing_contractor">Roofing Contractor</option>
            <option value="general_contractor">General Contractor</option>
            <option value="painter">Painter</option>
            <option value="locksmith">Locksmith</option>
            <option value="florist">Florist</option>
            <option value="pet_store">Pet Store</option>
            <option value="veterinary_care">Veterinarian</option>
            <option value="accounting">Accountant</option>
            <option value="insurance_agency">Insurance Agency</option>
            <option value="bank">Bank</option>
            <option value="hotel">Hotel / Lodging</option>
            <option value="moving_company">Moving Company</option>
            <option value="storage">Storage Facility</option>
            <option value="laundry">Laundromat</option>
            <option value="dry_cleaning">Dry Cleaning</option>
          </select>
        </div>

        <div>
          <label class="text-sm font-medium text-gray-700 block mb-1">Search Radius</label>
          <select id="autoPopRadius" class="border rounded-md w-full p-2 bg-white">
            <option value="3000">~2 miles</option>
            <option value="5000" selected>~3 miles</option>
            <option value="8000">~5 miles</option>
            <option value="16000">~10 miles</option>
          </select>
        </div>

        <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3">
          <p class="text-xs text-yellow-900">
            ‚ö° <strong>Note:</strong> Results are cached for 30 days to minimize API costs. Re-running the same search is free!
          </p>
        </div>
      </div>

      <div class="flex justify-end gap-2 mt-6">
        <button id="btnCancelAutoPopulate" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnRunAutoPopulate" class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700">
          üîç Search & Add Prospects
        </button>
      </div>
    </div>
  </div>

  <!-- Prospects Results Preview Modal -->
  <div id="prospectsResultsModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
      <div class="flex justify-between items-start mb-4">
        <div>
          <h3 class="text-xl font-bold">Search Results</h3>
          <p class="text-sm text-gray-600 mt-1">Select businesses to add to your prospecting pipeline</p>
        </div>
        <button onclick="closeProspectsResultsModal()" class="text-gray-400 hover:text-gray-600 text-2xl leading-none">&times;</button>
      </div>

      <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
        <div class="flex items-start gap-2">
          <span class="text-blue-600 text-lg">üí°</span>
          <div class="text-sm text-blue-900">
            <strong>Select which businesses to add.</strong> Unchecked businesses won't be added. Click "Not Interested" to permanently hide a business from future searches.
          </div>
        </div>
      </div>

      <div id="prospectsResultsStats" class="grid grid-cols-3 gap-4 mb-4">
        <!-- Stats populated by JavaScript -->
      </div>

      <div id="prospectsResultsContainer" class="space-y-2 max-h-96 overflow-y-auto pr-2" style="scrollbar-width: thin;">
        <!-- Results populated by JavaScript -->
      </div>

      <div class="flex justify-end gap-3 mt-6 pt-4 border-t">
        <button onclick="closeProspectsResultsModal()" class="px-6 py-2 border rounded-md bg-gray-100 hover:bg-gray-200 font-medium">
          Cancel
        </button>
        <button id="btnAddSelectedProspects" onclick="addSelectedProspects()" class="px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 font-semibold">
          Add Selected to Pipeline
        </button>
      </div>
    </div>
  </div>

  <!-- New Postcard Creation Modal -->
  <div id="newPostcardModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
      <h3 class="text-lg font-bold mb-4">Create New Postcard Mailing</h3>

      <div class="space-y-6">
        <!-- Step 1: Town Selection -->
        <div class="p-4 bg-blue-50 rounded-lg border border-blue-200">
          <h4 class="font-semibold text-blue-900 mb-3">Step 1: Select Town/Territory</h4>
          <div class="space-y-2">
            <label class="flex items-center gap-2">
              <input type="radio" name="townOption" value="existing" checked onchange="toggleTownInput()" />
              <span class="text-sm font-medium">Use existing town</span>
            </label>
            <select id="newPostcardTownSelect" class="border rounded-md p-2 w-full bg-white ml-6">
              <option value="">‚Äî Select existing town ‚Äî</option>
            </select>

            <label class="flex items-center gap-2 mt-3">
              <input type="radio" name="townOption" value="new" onchange="toggleTownInput()" />
              <span class="text-sm font-medium">Add new town</span>
            </label>
            <input id="newPostcardTownInput" type="text" class="border rounded-md p-2 w-full ml-6" placeholder="Enter new town name (e.g., Buffalo, West Seneca)" disabled />
          </div>
        </div>

        <!-- Step 2: Mail Date -->
        <div class="p-4 bg-green-50 rounded-lg border border-green-200">
          <h4 class="font-semibold text-green-900 mb-3">Step 2: Select Mail Date</h4>
          <div class="grid grid-cols-2 gap-4">
            <div>
              <label class="text-sm font-medium block mb-1">Month</label>
              <select id="newPostcardMonth" class="border rounded-md p-2 w-full bg-white">
                <option value="01">January</option>
                <option value="02">February</option>
                <option value="03">March</option>
                <option value="04">April</option>
                <option value="05">May</option>
                <option value="06">June</option>
                <option value="07">July</option>
                <option value="08">August</option>
                <option value="09">September</option>
                <option value="10">October</option>
                <option value="11">November</option>
                <option value="12">December</option>
              </select>
            </div>
            <div>
              <label class="text-sm font-medium block mb-1">Year</label>
              <select id="newPostcardYear" class="border rounded-md p-2 w-full bg-white">
              </select>
            </div>
          </div>
          <div class="mt-3">
            <label class="text-sm font-medium block mb-1">In-Homes Date</label>
            <input id="newPostcardInHomesDate" type="date" class="border rounded-md p-2 w-full" />
          </div>
        </div>

        <!-- Step 2.5: Postcard Size -->
        <div class="p-4 bg-orange-50 rounded-lg border border-orange-200">
          <h4 class="font-semibold text-orange-900 mb-3">Postcard Size</h4>
          <div class="space-y-2">
            <label class="text-sm font-medium block mb-1">Format</label>
            <select id="newPostcardSize" class="border rounded-md p-2 w-full bg-white">
              <option value="9x12">9√ó12 (12" wide √ó 9" tall)</option>
              <option value="6x12">6.5√ó12 (12" wide √ó 6.5" tall)</option>
            </select>
          </div>
        </div>

        <!-- Step 3: Copy from Previous -->
        <div class="p-4 bg-purple-50 rounded-lg border border-purple-200">
          <h4 class="font-semibold text-purple-900 mb-3">Step 3: Copy from Previous Postcard (Optional)</h4>
          <label class="flex items-center gap-2 mb-3">
            <input type="checkbox" id="copyFromPrevious" onchange="toggleCopyOptions()" />
            <span class="text-sm font-medium">Copy advertisers from a previous postcard</span>
          </label>
          <label class="flex items-center gap-2 mb-3">
            <input type="checkbox" id="copyExpensesFromPrevious" />
            <span class="text-sm font-medium">Copy expenses (printing, postage, design, misc) from selected postcard</span>
          </label>

          <div id="copyOptions" class="hidden space-y-3">
            <div>
              <label class="text-sm font-medium block mb-1">Select postcard to copy from:</label>
              <select id="copySourcePostcard" class="border rounded-md p-2 w-full bg-white" onchange="loadAdvertisersForCopy()">
                <option value="">‚Äî Select postcard ‚Äî</option>
              </select>
            </div>

            <div id="advertiserChecklistContainer" class="hidden">
              <p class="text-sm font-medium mb-2">Select advertisers to carry forward:</p>
              <div id="advertiserChecklist" class="max-h-60 overflow-y-auto border rounded-md p-3 bg-white space-y-2">
                <!-- Populated dynamically -->
              </div>
              <p class="text-xs text-gray-600 mt-2">üí° Selected advertisers will have their spots auto-reserved in the new postcard with "Reserved" status.</p>
            </div>
          </div>
        </div>
      </div>

      <div class="flex justify-end gap-2 mt-6 pt-4 border-t">
        <button id="btnCancelNewPostcard" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">Cancel</button>
        <button id="btnCreatePostcard" class="px-6 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 font-semibold">
          Create Postcard
        </button>
      </div>
    </div>
  </div>

  <!-- Prospect/Client Detail Modal -->
  <div id="prospectDetailModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
      <div class="flex justify-between items-start mb-4">
        <div>
          <h3 id="prospectDetailTitle" class="text-xl font-bold">Business Details</h3>
          <p id="prospectDetailSubtitle" class="text-sm text-gray-600 mt-1"></p>
        </div>
        <button onclick="closeProspectDetailModal()" class="text-gray-400 hover:text-gray-600 text-2xl leading-none">&times;</button>
      </div>

      <!-- Business Info Section -->
      <div class="bg-gray-50 rounded-lg p-4 mb-4">
        <div class="grid grid-cols-2 gap-4">
          <div>
            <div class="text-xs text-gray-500 font-medium">Business Name</div>
            <div id="detailBusinessName" class="text-base font-semibold text-gray-900 mt-1">‚Äî</div>
          </div>
          <div>
            <div class="text-xs text-gray-500 font-medium">Category</div>
            <div id="detailCategory" class="text-base text-gray-900 mt-1">‚Äî</div>
          </div>
          <div>
            <div class="text-xs text-gray-500 font-medium">ZIP Code</div>
            <div id="detailZipCode" class="text-base text-gray-900 mt-1">‚Äî</div>
          </div>
          <div>
            <div class="text-xs text-gray-500 font-medium">Rating</div>
            <div id="detailRating" class="text-base text-gray-900 mt-1">‚Äî</div>
          </div>
        </div>
      </div>

      <!-- Contact Info & Quick Actions Section -->
      <div class="bg-white rounded-lg border p-4 mb-4">
        <h4 class="font-semibold text-gray-700 mb-3">Contact Information & Quick Actions</h4>

        <div class="space-y-2">
          <div class="flex justify-between items-center">
            <div>
              <div class="text-xs text-gray-500">Phone</div>
              <div id="detailPhone" class="text-sm text-gray-900">‚Äî</div>
            </div>
            <button id="btnCallAction" onclick="quickAction('call')" class="px-3 py-1.5 bg-green-600 text-white rounded-md text-sm hover:bg-green-700 disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
              üìû Call
            </button>
          </div>

          <div class="flex justify-between items-center">
            <div>
              <div class="text-xs text-gray-500">Email</div>
              <div id="detailEmail" class="text-sm text-gray-900">‚Äî</div>
            </div>
            <button id="btnEmailAction" onclick="quickAction('email')" class="px-3 py-1.5 bg-blue-600 text-white rounded-md text-sm hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
              ‚úâÔ∏è Email
            </button>
          </div>

          <div class="flex justify-between items-center">
            <div>
              <div class="text-xs text-gray-500">Website</div>
              <div id="detailWebsite" class="text-sm text-gray-900 truncate max-w-md">‚Äî</div>
            </div>
            <button id="btnWebsiteAction" onclick="quickAction('website')" class="px-3 py-1.5 bg-gray-600 text-white rounded-md text-sm hover:bg-gray-700 disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
              üåê Visit
            </button>
          </div>

          <div class="flex justify-between items-center">
            <div>
              <div class="text-xs text-gray-500">Facebook</div>
              <div id="detailFacebook" class="text-sm text-gray-900 truncate max-w-md">‚Äî</div>
            </div>
            <button id="btnFacebookAction" onclick="quickAction('facebook')" class="px-3 py-1.5 bg-blue-700 text-white rounded-md text-sm hover:bg-blue-800 disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
              üìò Message
            </button>
          </div>

          <div class="flex justify-between items-center">
            <div>
              <div class="text-xs text-gray-500">Instagram</div>
              <div id="detailInstagram" class="text-sm text-gray-900 truncate max-w-md">‚Äî</div>
            </div>
            <button id="btnInstagramAction" onclick="quickAction('instagram')" class="px-3 py-1.5 bg-pink-600 text-white rounded-md text-sm hover:bg-pink-700 disabled:bg-gray-300 disabled:cursor-not-allowed" disabled>
              üì∑ DM
            </button>
          </div>
        </div>
      </div>

      <!-- Interaction Timeline Section -->
      <div class="bg-white rounded-lg border p-4 mb-4">
        <h4 class="font-semibold text-gray-700 mb-3">Interaction History</h4>
        <div id="interactionTimeline" class="space-y-3 max-h-64 overflow-y-auto">
          <div class="text-sm text-gray-400 italic text-center py-4">No interactions yet</div>
        </div>
      </div>

      <!-- Add New Interaction Form -->
      <div class="bg-blue-50 rounded-lg border border-blue-200 p-4 mb-4">
        <h4 class="font-semibold text-blue-900 mb-3">Log New Interaction</h4>

        <div class="space-y-3">
          <div class="grid grid-cols-2 gap-3">
            <div>
              <label class="text-xs font-medium text-gray-700 block mb-1">Interaction Type</label>
              <select id="newInteractionType" class="border rounded-md w-full p-2 text-sm bg-white">
                <option value="call">üìû Phone Call</option>
                <option value="email">‚úâÔ∏è Email</option>
                <option value="messenger">üìò Facebook Messenger</option>
                <option value="instagram">üì∑ Instagram DM</option>
                <option value="in-person">ü§ù In-Person Meeting</option>
                <option value="other">üìù Other</option>
              </select>
            </div>
            <div>
              <label class="text-xs font-medium text-gray-700 block mb-1">Date</label>
              <input id="newInteractionDate" type="date" class="border rounded-md w-full p-2 text-sm" />
            </div>
          </div>

          <div>
            <label class="text-xs font-medium text-gray-700 block mb-1">Notes</label>
            <textarea id="newInteractionNotes" rows="2" class="border rounded-md w-full p-2 text-sm" placeholder="What was discussed? What's the next step?"></textarea>
          </div>

          <div>
            <label class="text-xs font-medium text-gray-700 block mb-1">Next Follow-Up Date (Optional)</label>
            <input id="newInteractionFollowUp" type="date" class="border rounded-md w-full p-2 text-sm" />
          </div>

          <button onclick="addNewInteraction()" class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 font-medium">
            Add Interaction
          </button>
        </div>
      </div>

      <!-- Message Templates Section -->
      <div class="bg-green-50 rounded-lg border border-green-200 p-4 mb-4">
        <h4 class="font-semibold text-green-900 mb-3">üìã Message Templates</h4>

        <div class="space-y-2">
          <button onclick="showMessageTemplate('messenger')" class="w-full text-left px-3 py-2 bg-white border rounded-md hover:bg-gray-50 text-sm">
            <span class="font-medium">Facebook Messenger - First Contact</span>
          </button>
          <button onclick="showMessageTemplate('email')" class="w-full text-left px-3 py-2 bg-white border rounded-md hover:bg-gray-50 text-sm">
            <span class="font-medium">Email - First Contact</span>
          </button>
          <button onclick="showMessageTemplate('instagram')" class="w-full text-left px-3 py-2 bg-white border rounded-md hover:bg-gray-50 text-sm">
            <span class="font-medium">Instagram DM - First Contact</span>
          </button>
          <button onclick="showMessageTemplate('followup')" class="w-full text-left px-3 py-2 bg-white border rounded-md hover:bg-gray-50 text-sm">
            <span class="font-medium">Follow-up After Initial Contact</span>
          </button>
        </div>

        <div id="templatePreview" class="hidden mt-3 p-3 bg-white border rounded-md">
          <div class="flex justify-between items-start mb-2">
            <h5 id="templateTitle" class="font-semibold text-sm"></h5>
            <button onclick="copyTemplate()" class="px-2 py-1 bg-green-600 text-white rounded text-xs hover:bg-green-700">
              üìã Copy
            </button>
          </div>
          <div id="templateSubject" class="text-xs text-gray-600 mb-2"></div>
          <pre id="templateBody" class="text-xs text-gray-700 whitespace-pre-wrap font-sans"></pre>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="flex justify-between items-center gap-2 pt-4 border-t">
        <button id="btnNotInterested" onclick="markNotInterested()" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 font-medium">
          üö´ Not Interested
        </button>
        <div class="flex gap-2">
          <button onclick="closeProspectDetailModal()" class="px-4 py-2 border rounded-md bg-gray-100 hover:bg-gray-200">
            Close
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast hidden" role="status" aria-live="polite" aria-atomic="true"></div>

  <script>
    /* ========= CONFIG ========= */
    // Supabase Configuration
    const SUPABASE_URL = "https://kurhsdvxsgkgnfimfqdo.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt1cmhzZHZ4c2drZ25maW1mcWRvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4MDk3NDYsImV4cCI6MjA3ODM4NTc0Nn0.nB_GsE89WJ3eAQrgmNKb-fbCktHTHf-987D-G6lscZA";
    const ACTIVE_USER = "lastcall.me@hotmail.com";

    // Initialize Supabase client
    const { createClient } = window.supabase;
    const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Cloud Sync State - Tracks what's syncing and when
    const cloudSyncState = {
      syncing: false,
      lastSync: null,
      pendingSaves: new Set(), // Track which data types need saving (temporary failures)
      permanentlyFailedSaves: new Set(), // Track data types that are too large (permanent failures)
      syncErrors: {},
      userNotified: new Set(), // Track which errors we've already notified user about
      inProgressSaves: new Map(), // Track saves currently in progress (dataType -> Promise)
      debouncedSaves: new Map() // Track debounced save timers (dataType -> timeoutId)
    };

    // ‚ö†Ô∏è SECURITY WARNING: Never commit real API keys to version control!
    //
    // Google Places API Key - Replace with your actual key
    // Get your key at: https://console.cloud.google.com/google/maps-apis/
    // IMPORTANT: Restrict this key by HTTP referrer in Google Cloud Console to prevent abuse
    const GOOGLE_PLACES_API_KEY = "YOUR_GOOGLE_PLACES_API_KEY_HERE";

    // Message Templates - For outreach to prospects
    const MESSAGE_TEMPLATES = {
      messenger: {
        name: "Facebook Messenger - First Contact",
        subject: "",
        body: `Hi there! üëã

I noticed [BUSINESS_NAME] on Facebook and wanted to reach out about a local advertising opportunity.

We help local businesses like yours reach thousands of households in [TOWN] through our shared mailer program. Your business would be featured alongside other quality local services.

Would you be open to a quick chat about how this could work for you?

Looking forward to hearing from you!

Best regards,
[YOUR_NAME]
[YOUR_PHONE]`
      },
      email: {
        name: "Email - First Contact",
        subject: "Local Advertising Opportunity for [BUSINESS_NAME]",
        body: `Hi,

I hope this email finds you well. I'm reaching out regarding a cost-effective advertising opportunity for [BUSINESS_NAME] in [TOWN].

We publish a shared mailer that goes directly to thousands of local households. Your business would be featured alongside other quality local services, giving you exposure to potential customers in your area.

Here's what makes this different:
‚Ä¢ Direct mail to targeted local households
‚Ä¢ Professional design included
‚Ä¢ Shared cost model makes it affordable
‚Ä¢ Proven results for local businesses

Would you be interested in learning more? I'd be happy to send over some details and pricing.

Best regards,
[YOUR_NAME]
[YOUR_PHONE]
[YOUR_EMAIL]`
      },
      instagram: {
        name: "Instagram DM - First Contact",
        subject: "",
        body: `Hey! üëã

Love what [BUSINESS_NAME] is doing! I wanted to reach out about a local advertising opportunity that might interest you.

We help businesses in [TOWN] reach thousands of local households through our shared mailer program.

Would you be open to a quick chat? I think this could be a great fit for you!

[YOUR_NAME]
[YOUR_PHONE]`
      },
      followup: {
        name: "Follow-up - After Initial Contact",
        subject: "Following up - [BUSINESS_NAME]",
        body: `Hi,

I wanted to follow up on my message from [DATE] about the local advertising opportunity.

I know you're busy, but I wanted to make sure this didn't get lost in your inbox.

We're putting together our next mailer for [TOWN] and I'd love to include [BUSINESS_NAME] if you're interested.

Do you have 5 minutes to chat this week?

Thanks!
[YOUR_NAME]
[YOUR_PHONE]`
      }
    };

    // Application Configuration Constants
    const TOTAL_SPOTS_PER_POSTCARD = 18;
    const DEFAULT_DESIGN_COST = 150;
    const CLOUD_SYNC_URL_LENGTH_LIMIT = 6000; // Browser URL length limit for GET requests
    const CLOUD_SYNC_RETRY_INTERVAL = 60000; // 1 minute in milliseconds
    const DEBOUNCE_RENDER_DELAY = 150; // Milliseconds to debounce kanban rendering

    /* ========= LOCALSTORAGE UTILITY ========= */

    // Safe localStorage wrapper with quota exceeded handling
    function safeSetItem(key, value) {
      try {
        localStorage.setItem(key, value);
        return true;
      } catch (err) {
        // Check if this is a quota exceeded error
        const isQuotaExceeded = err.name === 'QuotaExceededError' ||
                                err.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||
                                err.code === 22 || // Chrome
                                err.code === 1014; // Firefox

        if (isQuotaExceeded) {
          console.error('localStorage quota exceeded:', {
            key,
            valueSize: value.length,
            error: err.message
          });

          // Show user-friendly warning (only once per session)
          if (!window._localStorageQuotaWarningShown) {
            toast('‚ö†Ô∏è Local storage is full. Some data may not be saved offline. Consider clearing old cached data.', false);
            window._localStorageQuotaWarningShown = true;
          }

          // Try to free up space by clearing old cache data
          try {
            // Clear places cache (largest non-critical data)
            localStorage.removeItem('mailslot-places-cache');

            // Retry the save after clearing cache
            localStorage.setItem(key, value);
            toast('‚úì Freed up space and saved successfully', true);
            return true;
          } catch (retryErr) {
            console.error('Failed to save even after clearing cache:', retryErr);
            return false;
          }
        } else {
          // Other localStorage error
          console.error('localStorage error:', err);
          return false;
        }
      }
    }

    function safeGetItem(key) {
      try {
        return localStorage.getItem(key);
      } catch (err) {
        console.error('localStorage getItem error:', err);
        return null;
      }
    }

    function safeRemoveItem(key) {
      try {
        localStorage.removeItem(key);
        return true;
      } catch (err) {
        console.error('localStorage removeItem error:', err);
        return false;
      }
    }

    /* ========= CLOUD SYNC SYSTEM ========= */

    // Unified function to load data from Google Sheets
    async function loadFromCloud(dataType) {
      try {
        // Query Supabase app_data table for this data type
        const { data, error } = await supabaseClient
          .from('app_data')
          .select('data')
          .eq('user_email', ACTIVE_USER)
          .eq('data_type', dataType)
          .single();

        if (error) {
          // If no data found (404), return null (not an error)
          if (error.code === 'PGRST116') {
            return null;
          }
          throw error;
        }

        const appData = data?.data || null;

        // Cache to localStorage
        if (appData !== null && appData !== undefined) {
          safeSetItem(`mailslot-${dataType}`, JSON.stringify(appData));
        }

        return appData;
      } catch (err) {
        console.warn(`‚ö†Ô∏è Failed to load ${dataType} from cloud, using localStorage:`, err);
        cloudSyncState.syncErrors[dataType] = err.message;

        // Fallback to localStorage
        const cached = safeGetItem(`mailslot-${dataType}`);
        return cached ? JSON.parse(cached) : null;
      }
    }

    // Unified function to save data to Supabase
    async function saveToCloud(dataType, data, options = {}) {
      try {
        // Use upsert to insert or update
        const { error } = await supabaseClient
          .from('app_data')
          .upsert({
            user_email: ACTIVE_USER,
            data_type: dataType,
            data: data
          }, {
            onConflict: 'user_email,data_type'
          });

        if (error) throw error;

        // Update cache
        safeSetItem(`mailslot-${dataType}`, JSON.stringify(data));
        cloudSyncState.lastSync = Date.now();
        delete cloudSyncState.syncErrors[dataType];

        return { success: true };

      } catch (err) {
        console.error(`‚ùå Failed to save ${dataType} to cloud:`, err);
        cloudSyncState.syncErrors[dataType] = err.message;

        // Still save to localStorage as backup
        safeSetItem(`mailslot-${dataType}`, JSON.stringify(data));

        // Check if this is a permanent failure (data too large)
        if (err.message && err.message.includes('Data too large')) {
          // Mark as permanently failed (don't retry)
          cloudSyncState.permanentlyFailedSaves.add(dataType);

          // Show user notification once
          if (!cloudSyncState.userNotified.has(dataType)) {
            toast(`‚ö†Ô∏è ${dataType} data is too large for cloud sync. Saved locally only.`, false);
            cloudSyncState.userNotified.add(dataType);
          }

          console.warn(`üì¶ ${dataType} marked as localStorage-only (too large for cloud sync)`);
        } else {
          // Temporary failure - add to retry queue
          cloudSyncState.pendingSaves.add(dataType);
        }

        throw err;
      }
    }

    // Optimized cloud sync wrapper - prevents duplicate simultaneous saves
    // Optional debouncing for non-critical saves (set debounceMs > 0)
    async function saveToCloudOptimized(dataType, data, debounceMs = 0) {
      // If this dataType is already being saved, wait for that save to complete
      // then trigger a new save with the latest data
      if (cloudSyncState.inProgressSaves.has(dataType)) {
        try {
          await cloudSyncState.inProgressSaves.get(dataType);
        } catch (err) {
          // Ignore errors from previous save, we'll try again
        }
      }

      // Clear any pending debounced save for this dataType (update to latest data)
      if (cloudSyncState.debouncedSaves.has(dataType)) {
        clearTimeout(cloudSyncState.debouncedSaves.get(dataType));
        cloudSyncState.debouncedSaves.delete(dataType);
      }

      // For non-critical saves with debouncing, delay the save
      if (debounceMs > 0) {
        return new Promise((resolve, reject) => {
          const timeoutId = setTimeout(async () => {
            cloudSyncState.debouncedSaves.delete(dataType);

            const savePromise = saveToCloud(dataType, data)
              .finally(() => {
                cloudSyncState.inProgressSaves.delete(dataType);
              });

            cloudSyncState.inProgressSaves.set(dataType, savePromise);

            try {
              const result = await savePromise;
              resolve(result);
            } catch (err) {
              reject(err);
            }
          }, debounceMs);

          cloudSyncState.debouncedSaves.set(dataType, timeoutId);
        });
      }

      // For immediate/critical saves, execute right away
      const savePromise = saveToCloud(dataType, data)
        .finally(() => {
          cloudSyncState.inProgressSaves.delete(dataType);
        });

      cloudSyncState.inProgressSaves.set(dataType, savePromise);
      return savePromise;
    }

    // Auto-retry failed syncs (but not permanently failed ones)
    setInterval(() => {
      // Remove any permanently failed saves from the retry queue
      cloudSyncState.permanentlyFailedSaves.forEach(dataType => {
        cloudSyncState.pendingSaves.delete(dataType);
      });

      if (cloudSyncState.pendingSaves.size > 0 && !cloudSyncState.syncing) {
        // Will be handled by individual save functions
      }
    }, CLOUD_SYNC_RETRY_INTERVAL); // Retry every minute

    const CANONICAL_STATUSES = [
      "Available",
      "Reserved",
      "Invoice Sent",
      "Deposit Paid",
      "Proof In Progress",
      "Ad Approved",
      "Paid in Full"
    ];
    
    let sortOrder = [...CANONICAL_STATUSES];
    let visibleStatuses = [...CANONICAL_STATUSES];
    const GRADIENT_HEX = ["#fef3c7", "#fff7ed", "#fed7aa", "#fdba74", "#dbeafe", "#2563eb", "#16a34a"];
    const GRADIENT_PILL = ["#fcd34d", "#fb923c", "#f97316", "#ea580c", "#3b82f6", "#1d4ed8", "#15803d"];
    let STATUS_HEX = {};
    let STATUS_PILL = {};
    
    function updateColorMappings() {
      const visibleSorted = sortOrder.filter(s => visibleStatuses.includes(s));
      const numVisible = visibleSorted.length;
      const usedHex = GRADIENT_HEX.slice(0, numVisible - 1);
      usedHex.push(GRADIENT_HEX[GRADIENT_HEX.length - 1]);
      const usedPill = GRADIENT_PILL.slice(0, numVisible - 1);
      usedPill.push(GRADIENT_PILL[GRADIENT_PILL.length - 1]);
      visibleSorted.forEach((s, i) => {
        STATUS_HEX[s] = usedHex[i];
        STATUS_PILL[s] = usedPill[i];
      });
      const hiddenDefault = STATUS_HEX["Available"] || GRADIENT_HEX[0];
      CANONICAL_STATUSES.filter(s => !visibleStatuses.includes(s)).forEach(s => {
        STATUS_HEX[s] = hiddenDefault;
        STATUS_PILL[s] = GRADIENT_PILL[0];
      });
    }
    
    const PAIRS = [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18]];
    const keyPair = (a,b)=>[Math.min(a,b),Math.max(a,b)].join("-");
    const isValidPair=(a,b)=>PAIRS.some(([x,y])=>x===Math.min(a,b)&&y===Math.max(a,b));
    const mateOf = n => { for (const [a,b] of PAIRS) { if (a===n) return b; if (b===n) return a; } return null; };

    // VERSION CHECK - If you don't see this in console, you're viewing cached HTML
    console.log('üî• APP VERSION: 2025-01-14-v21 - Fix date timezone issue (display correct date)');

    const state = {
      mailers: [],
      current: null,
      availability: {},
      initial: {},
      merged: new Set(),
      selected: new Set(),
      dirty: false,
      lastSide: "front",
      updatingSelectors: false  // Flag to prevent circular updates when syncing dropdowns
    };
    
    const stagedColors = {
      Postcard_BG: "",
      Banner_BG: "#000000"  // Black - ensures white text by default
    };

    // AUTO-SAVE STATE
    const autoSaveState = {
      timer: null,
      lastSaveTime: null,
      saving: false,
      updateInterval: null
    };

    // PRODUCTION STATE (OLD - for expenses and spot pricing)
    const productionState = {
      expenses: {},
      spotPricing: {},
      pricing: {}, // Per-postcard pricing: { mailerId: { singleAd, doubleAd, bannerAd } }
      revenueGoals: {} // Per-postcard revenue goals: { mailerId: { singleCount, singlePrice, doubleCount, doublePrice, bannerCount, bannerPrice, total } }
    };
    
    const DEFAULT_SPOT_PRICE = 500;
    const DEFAULT_EXPENSES = {
      printing: 0,
      postage: 0,
      design: 0,
      misc: 0
    };
    
    // CRM STATE
    const crmState = {
      clients: {},
      nextClientId: 1
    };
    
    // KANBAN STATE
    const kanbanState = {
      columns: {
        'prospect-list': [],      // Renamed from 'prospect-list'
        'to-contact': [],          // Renamed from 'to-contact'
        'in-progress': [],         // Renamed from 'in-progress'
        'committed': []            // Renamed from 'committed'
      }
    };

    // DAILY OUTREACH GOAL STATE
    const dailyGoalState = {
      dailyGoal: 10,               // Default goal: contact 10 businesses per day
      todayCount: 0,               // How many contacted today
      lastResetDate: new Date().toDateString(),  // Track when we last reset
      history: []                  // Array of {date, goal, actual, businesses: []}
    };

    // CLOUD SYNC SELECTION STATE
    const cloudSyncSelection = {
      selectedIds: new Set(),
      showSyncUI: false
    };

    // TASKS STATE
    const tasksState = {
      tasks: []
    };

    // API QUOTA TRACKING STATE
    const apiQuotaState = {
      monthlyLimit: 28000,  // Google Places API free tier
      currentMonth: new Date().toISOString().slice(0, 7), // "2025-11"
      callsThisMonth: 0,
      userQuotas: {},  // Per-user quotas when restrictions activate
      restrictionsActive: false,
      warningThreshold: 0.8,  // 80% = 22,400 calls
      criticalThreshold: 0.95  // 95% = 26,600 calls
    };

    // PLACES CACHE STATE (30-day cache + permanent Place IDs)
    const placesCache = {
      searches: {}  // Format: { "zipCode-category": { placeIds: [], cachedData: [], cachedUntil: "date" } }
    };

    // NOT INTERESTED LIST STATE (permanent exclusion list)
    const notInterestedState = {
      placeIds: new Set(),  // Set of Place IDs marked as "not interested"
      businesses: {}  // Map of Place ID => business info for reference
    };

    // PROSPECTS RESULTS STATE (temporary storage for search results)
    let prospectsResultsState = {
      businesses: [],
      selectedIds: new Set()
    };

    let lastFocusedElementBeforeModal = null;
    let draggedItem = null;
    let draggedTask = null;
    
    /* ========= UTILITIES ========= */
    const $ = sel => document.querySelector(sel);
    const esc = s => String(s ?? "").replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    const ensureHttps = url => {
      if (!url) return '';
      const trimmed = url.trim();
      if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) return trimmed;
      return 'https://' + trimmed;
    };
    const show = (el, on=true) => el && el.classList.toggle("hidden", !on);
    const toast = (msg, ok=true, durationMs=null) => {
      const t = document.getElementById("toast");
      t.textContent = msg;
      t.className = `toast ${ok ? "toast-ok" : "toast-warn"}`;
      t.classList.remove("hidden");
      t.removeAttribute("aria-hidden");

      // Calculate duration based on message length if not specified
      // Base: 2000ms, +50ms per character over 20 chars, max 6000ms
      const duration = durationMs || Math.min(2000 + Math.max(0, msg.length - 20) * 50, 6000);

      setTimeout(()=>{ t.classList.add("hidden"); t.setAttribute("aria-hidden","true"); }, duration);
    };
    
    function formatDate(dateStr) {
      return new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric', year: 'numeric' }).format(new Date(dateStr));
    }
    
    function isOverdue(dateStr) {
      const due = new Date(dateStr);
      const today = new Date();
      return due < today;
    }
    
    function updateTaskDate(input) {
      const row = input.closest('.task-row');
      const taskId = row.dataset.taskId;
      const newDate = input.value;
      if (newDate) {
        row.dataset.dueDate = newDate;
        const task = tasksState.tasks.find(t => t.id == taskId);
        if (task) {
          task.dueDate = newDate;
          saveTasks();
        }
        updateTasksDisplay();
        toast('Task date updated');
      }
    }
    
    function toggleTaskComplete(checkbox) {
      const row = checkbox.closest('.task-row');
      const taskId = row.dataset.taskId;
      const task = tasksState.tasks.find(t => t.id == taskId);
      if (task) {
        task.completed = checkbox.checked;
        saveTasks();
        if (checkbox.checked) {
          row.classList.add('completed');
        } else {
          row.classList.remove('completed');
        }
        updateTasksDisplay();
      }
    }
    
    /* ========= FINANCIAL CALCULATIONS ========= */
    function calculateFinancials(mailerId, campaign = null) {
      if (!mailerId) return null;

      console.log(`\nüí∞ CALCULATING FINANCIALS FOR: ${mailerId}`);
      console.log('Campaign data provided?', !!campaign);
      console.log('spotPricing loaded?', Object.keys(productionState.spotPricing).length > 0);
      console.log('pricing loaded?', Object.keys(productionState.pricing).length > 0);

      // If pricing data hasn't loaded yet, return null to avoid showing $500 defaults
      // The calculations will run again once pricing loads
      const hasPricingData = Object.keys(productionState.pricing).length > 0 || Object.keys(productionState.spotPricing).length > 0;
      if (!hasPricingData) {
        console.log('‚è≥ Skipping financial calculations - waiting for pricing data to load');
        return null;
      }

      const expenses = productionState.expenses[mailerId] || { ...DEFAULT_EXPENSES };
      const totalExpenses = Object.values(expenses).reduce((sum, val) => sum + (parseFloat(val) || 0), 0);

      let paidRevenue = 0;
      let depositRevenue = 0;
      let projectedRevenue = 0;
      let spotsSold = 0;
      let spotsPaid = 0;

      // Use campaign data if provided, otherwise use state.availability (for current postcard)
      const getSpotData = (i) => {
        if (campaign && campaign[`Spot_${i}`]) {
          const spotValue = campaign[`Spot_${i}`];

          // Handle plain "Available" string (empty spot)
          if (spotValue === "Available") {
            return { name: "", status: "Available" };
          }

          // Handle string format "Status: Business Name"
          if (typeof spotValue === 'string') {
            // Check if it's "Status: Name" format
            if (spotValue.includes(':')) {
              const colonIndex = spotValue.indexOf(':');
              const status = spotValue.substring(0, colonIndex).trim();
              const name = spotValue.substring(colonIndex + 1).trim();
              return { name, status };
            }

            // Try JSON parse as fallback
            try {
              return JSON.parse(spotValue);
            } catch (e) {
              // If not JSON and no colon, treat as Available
              return { name: "", status: "Available" };
            }
          }

          // Handle object
          return spotValue;
        }
        return state.availability[`Spot_${i}`];
      };

      // Get pricing for this postcard (new system)
      const pricing = productionState.pricing[mailerId] || null;

      for (let i = 1; i <= TOTAL_SPOTS_PER_POSTCARD; i++) {
        const spot = getSpotData(i);

        // Check if this spot is the SECOND spot in a merged pair
        const mate = mateOf(i);
        let isMergedSecond = false;
        let isMerged = false;
        if (mate && mate < i) {
          if (campaign) {
            // When using campaign data, check if spot names match (indicates merge)
            const mateSpot = getSpotData(mate);
            const spotName = spot?.name?.trim() || '';
            const mateName = mateSpot?.name?.trim() || '';
            isMergedSecond = spotName && mateName && spotName === mateName;
          } else {
            // When using state.availability, use state.merged
            isMergedSecond = state.merged.has(keyPair(i, mate));
          }
        }

        // Check if this spot is the FIRST in a merged pair
        if (mate && mate > i) {
          if (campaign) {
            const mateSpot = getSpotData(mate);
            const spotName = spot?.name?.trim() || '';
            const mateName = mateSpot?.name?.trim() || '';
            isMerged = spotName && mateName && spotName === mateName;
          } else {
            isMerged = state.merged.has(keyPair(i, mate));
          }
        }

        // Skip if this is the second spot in a merged pair (already counted with first spot)
        if (isMergedSecond) {
          continue;
        }

        // Simple pricing logic:
        // 1. If spot has custom price (manually set) ‚Üí use it
        // 2. Otherwise ‚Üí use Set Pricing defaults (Single/Double/Banner)
        let price;
        const priceKey = normalizePriceKey(mailerId, i);
        const customSpotPrice = productionState.spotPricing[priceKey];

        // Debug pricing lookup for first spot only
        if (i === 1) {
          console.log('üîç PRICING DEBUG for Spot 1:');
          console.log('  priceKey:', priceKey);
          console.log('  customSpotPrice:', customSpotPrice);
          console.log('  pricing object:', pricing);
          console.log('  spotPricing keys:', Object.keys(productionState.spotPricing).slice(0, 5));
        }

        if (customSpotPrice !== undefined && customSpotPrice !== null && customSpotPrice > 0) {
          // Use manually set price
          price = parseFloat(customSpotPrice);
          if (i === 1) console.log('  ‚úÖ Using custom spot price:', price);
        } else if (pricing) {
          // Use Set Pricing defaults
          if (isMerged) {
            if ((i === 13 || i === 14) && mate && (mate === 13 || mate === 14)) {
              price = parseFloat(pricing.bannerAd) || DEFAULT_SPOT_PRICE;
            } else {
              price = parseFloat(pricing.doubleAd) || DEFAULT_SPOT_PRICE;
            }
          } else {
            price = parseFloat(pricing.singleAd) || DEFAULT_SPOT_PRICE;
          }
          if (i === 1) console.log('  ‚úÖ Using Set Pricing:', price, '(isMerged:', isMerged, ')');
        } else {
          // Fallback if nothing is set
          price = DEFAULT_SPOT_PRICE;
          if (i === 1) console.log('  ‚ö†Ô∏è Using default price:', price);
        }

        // Only count revenue if spot has a business name entered
        if (spot && spot.status !== "Available" && spot.name && spot.name.trim() !== "") {
          console.log(`  üìç Spot ${i}: "${spot.name}" | Status: "${spot.status}" | Price: $${price} | Merged: ${isMerged}`);
          spotsSold++;
          projectedRevenue += price;

          // Count all filled spots as revenue (Reserved and beyond)
          if (spot.status === "Deposit Paid") {
            // Deposit Paid = only 50% received so far
            const depositAmount = price * 0.5;
            console.log(`    üí∞ DEPOSIT PAID - Adding $${depositAmount} to revenue`);
            depositRevenue += depositAmount;
          } else {
            // Reserved, Invoice Sent, Ad Approved, Paid in Full = full price
            console.log(`    ‚úÖ ${spot.status} - Adding $${price} to revenue`);
            paidRevenue += price;
            spotsPaid++;
          }
        }
      }
      
      const currentRevenue = paidRevenue + depositRevenue;
      const currentProfit = currentRevenue - totalExpenses;
      const projectedProfit = projectedRevenue - totalExpenses;
      const breakeven = currentRevenue >= totalExpenses;

      console.log(`üíµ REVENUE SUMMARY:`);
      console.log(`  Spots Sold: ${spotsSold}`);
      console.log(`  Projected Revenue: $${projectedRevenue.toFixed(2)}`);
      console.log(`  Paid Revenue: $${paidRevenue.toFixed(2)}`);
      console.log(`  Deposit Revenue: $${depositRevenue.toFixed(2)}`);
      console.log(`  Current Revenue: $${currentRevenue.toFixed(2)}`);
      console.log(`  Total Expenses: $${totalExpenses.toFixed(2)}`);
      console.log(`  Current Profit: $${currentProfit.toFixed(2)}\n`);

      const avgSpotPrice = spotsSold > 0 ? projectedRevenue / spotsSold : DEFAULT_SPOT_PRICE;
      const remainingToBreakeven = Math.max(0, totalExpenses - currentRevenue);
      const spotsNeeded = Math.ceil(remainingToBreakeven / avgSpotPrice);

      // Calculate effective total spots (18 minus number of merged pairs)
      // Each merged pair reduces total by 1 (4 singles become 2 doubles = -2 spots)
      let mergedPairsCount = 0;
      if (campaign) {
        // Count merged pairs by checking if adjacent spots have matching names
        for (let i = 1; i <= TOTAL_SPOTS_PER_POSTCARD; i++) {
          const mate = mateOf(i);
          if (mate && mate > i) { // Only count each pair once
            const spot = getSpotData(i);
            const mateSpot = getSpotData(mate);
            const spotName = spot?.name?.trim() || '';
            const mateName = mateSpot?.name?.trim() || '';
            if (spotName && mateName && spotName === mateName) {
              mergedPairsCount++;
            }
          }
        }
      } else {
        mergedPairsCount = state.merged.size;
      }
      const effectiveTotalSpots = TOTAL_SPOTS_PER_POSTCARD - mergedPairsCount;

      // Calculate maximum potential revenue by summing actual price for each spot
      // This accounts for custom spot pricing - if a spot has a custom price, use it
      let maxPotentialRevenue = 0;
      for (let i = 1; i <= TOTAL_SPOTS_PER_POSTCARD; i++) {
        const priceKey = normalizePriceKey(mailerId, i);
        const customSpotPrice = productionState.spotPricing[priceKey];

        // Use same 3-step pricing logic
        let spotPrice;
        if (customSpotPrice !== undefined && customSpotPrice !== null && customSpotPrice > 0) {
          spotPrice = parseFloat(customSpotPrice);
        } else if (pricing) {
          spotPrice = parseFloat(pricing.singleAd) || DEFAULT_SPOT_PRICE;
        } else {
          spotPrice = DEFAULT_SPOT_PRICE;
        }

        maxPotentialRevenue += spotPrice;
      }

      // Use revenue goal if set, otherwise use maxPotentialRevenue
      const revenueGoal = productionState.revenueGoals[mailerId];
      const revenueTarget = (revenueGoal && revenueGoal.total > 0) ? revenueGoal.total : maxPotentialRevenue;

      return {
        revenue: {
          paid: paidRevenue,
          deposit: depositRevenue,
          current: currentRevenue,
          projected: projectedRevenue,
          target: revenueTarget
        },
        expenses: {
          ...expenses,
          total: totalExpenses
        },
        profit: {
          current: currentProfit,
          projected: projectedProfit,
          margin: projectedRevenue > 0 ? (projectedProfit / projectedRevenue * 100) : 0
        },
        metrics: {
          spotsSold,
          spotsPaid,
          spotsAvailable: effectiveTotalSpots - spotsSold,
          avgSpotPrice,
          breakeven,
          spotsNeeded,
          progressPercent: effectiveTotalSpots > 0 ? (spotsSold / effectiveTotalSpots * 100) : 0,
          effectiveTotalSpots // Add this for display purposes
        }
      };
    }
    
    function formatCurrency(amount) {
      return new Intl.NumberFormat('en-US', { 
        style: 'currency', 
        currency: 'USD',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      }).format(amount || 0);
    }
    
    function updateFinancialDashboard() {
      if (!state.current) return;

      const financials = calculateFinancials(state.current.Mailer_ID, state.current);
      if (!financials) return;
      
      const profitEl = document.getElementById('profitStatus');
      const revenueEl = document.getElementById('currentRevenue');
      const expensesEl = document.getElementById('oldTotalExpenses');
      const spotsToBreakevenEl = document.getElementById('spotsToBreakeven');
      const progressBarEl = document.getElementById('revenueProgressBar');
      const progressTextEl = document.getElementById('revenueProgressText');
      
      if (profitEl) {
        profitEl.textContent = formatCurrency(financials.profit.current);
        profitEl.className = `metric-value ${financials.metrics.breakeven ? 'text-green-600' : 'text-red-500'}`;
      }
      
      if (revenueEl) revenueEl.textContent = formatCurrency(financials.revenue.current);
      if (expensesEl) expensesEl.textContent = formatCurrency(financials.expenses.total);
      
      if (spotsToBreakevenEl) {
        if (financials.metrics.breakeven) {
          spotsToBreakevenEl.innerHTML = '‚úì <span class="text-green-600 font-bold">Profitable!</span>';
        } else {
          spotsToBreakevenEl.innerHTML = `Need <span class="font-bold text-indigo-600">${financials.metrics.spotsNeeded} more spot${financials.metrics.spotsNeeded === 1 ? '' : 's'}</span> to break even`;
        }
      }
      
      if (progressBarEl) {
        const percent = (financials.revenue.current / financials.revenue.target * 100);
        progressBarEl.style.width = `${Math.min(percent, 100)}%`;
      }
      
      if (progressTextEl) {
        const revenuePercent = Math.round((financials.revenue.current / financials.revenue.target) * 100);
        progressTextEl.textContent = `${formatCurrency(financials.revenue.current)} of ${formatCurrency(financials.revenue.target)} goal (${revenuePercent}%)`;
      }
      
      const slotsSoldEl = document.getElementById('slotsSoldMetric');
      const slotsSoldPercentEl = document.getElementById('slotsSoldPercent');
      if (slotsSoldEl) {
        slotsSoldEl.textContent = `${financials.metrics.spotsSold}/${financials.metrics.effectiveTotalSpots}`;
      }
      if (slotsSoldPercentEl) {
        const percent = Math.round(financials.metrics.progressPercent);
        slotsSoldPercentEl.textContent = `(${percent}%)`;
      }

      const slotsSoldBarEl = document.getElementById('slotsSoldBar');
      if (slotsSoldBarEl) {
        slotsSoldBarEl.style.width = `${financials.metrics.progressPercent}%`;
      }
    }
    
    /* ========= EXPENSE MODAL ========= */
    function openExpenseModal() {
      if (!state.current) {
        toast("Please select a postcard first", false);
        return;
      }
      
      const modal = document.getElementById("expenseModal");
      const mailerId = state.current.Mailer_ID;
      const expenses = productionState.expenses[mailerId] || { ...DEFAULT_EXPENSES };
      
      document.getElementById("expensePrinting").value = expenses.printing || DEFAULT_EXPENSES.printing;
      document.getElementById("expensePostage").value = expenses.postage || DEFAULT_EXPENSES.postage;
      document.getElementById("expenseDesign").value = expenses.design || DEFAULT_EXPENSES.design;
      document.getElementById("expenseMisc").value = expenses.misc || DEFAULT_EXPENSES.misc;
      
      updateExpenseTotal();
      
      lastFocusedElementBeforeModal = document.activeElement;
      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
      document.getElementById("expensePrinting").focus();
    }
    
    function closeExpenseModal() {
      const modal = document.getElementById("expenseModal");
      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
      if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();
    }
    
    function updateExpenseTotal() {
      const printing = parseFloat(document.getElementById("expensePrinting").value) || 0;
      const postage = parseFloat(document.getElementById("expensePostage").value) || 0;
      const design = parseFloat(document.getElementById("expenseDesign").value) || 0;
      const misc = parseFloat(document.getElementById("expenseMisc").value) || 0;
      
      const total = printing + postage + design + misc;
      document.getElementById("expenseTotal").textContent = formatCurrency(total);
    }
    
    async function loadExpenses() {
      try {
        // Try loading from cloud first
        const cloudData = await loadFromCloud('expenses');

        if (cloudData) {
          productionState.expenses = cloudData;
        } else {
          // Fallback to localStorage
          const saved = localStorage.getItem('mailslot-expenses');
          if (saved) {
            productionState.expenses = JSON.parse(saved);
            // Sync to cloud
            saveToCloud('expenses', productionState.expenses).catch(e => console.warn('Failed to sync expenses to cloud:', e));
          }
        }
      } catch(e) {
        console.error('Error loading expenses:', e);
      }
    }

    async function saveExpenses() {
      try {
        // Save to cloud and localStorage
        await saveToCloud('expenses', productionState.expenses);
      } catch(e) {
        console.warn('Expenses saved to localStorage only (cloud sync failed):', e);
      }
    }

    function saveExpenseModal() {
      if (!state.current) return;

      const mailerId = state.current.Mailer_ID;
      productionState.expenses[mailerId] = {
        printing: parseFloat(document.getElementById("expensePrinting").value) || 0,
        postage: parseFloat(document.getElementById("expensePostage").value) || 0,
        design: parseFloat(document.getElementById("expenseDesign").value) || 0,
        misc: parseFloat(document.getElementById("expenseMisc").value) || 0
      };

      saveExpenses();

      updateFinancialDashboard();
      toast("Expenses saved");
      closeExpenseModal();
      state.dirty = true;
      updateToolbar();
      scheduleAutoSave(); // Trigger auto-save
    }
    
    /* ========= CRM FUNCTIONS ========= */

    function buildClientObject(data) {
      return {
        id: data.id || `CLT-${String(crmState.nextClientId++).padStart(4, '0')}`,
        businessName: data.businessName || "",
        category: data.category || "",
        contact: {
          name: data.contactName || "",
          phone: data.phone || "",
          email: data.email || "",
          address: data.address || ""
        },
        history: data.history || [],
        interactions: data.interactions || [], // Interaction tracking: [{date, type, notes, nextFollowUp}]
        lifetime: {
          totalSpent: 0,
          cardsBought: 0,
          renewalRate: 0,
          avgPrice: 0
        },
        notes: data.notes || "",
        tags: data.tags || [],
        createdDate: data.createdDate || new Date().toISOString(),
        lastContact: data.lastContact || null,
        nextRenewal: data.nextRenewal || null,
        contract: data.contract || {
          enabled: false,
          startDate: null,
          length: 6,
          monthlyRate: 0,
          totalValue: 0,
          endDate: null,
          autoRenew: false
        }
      };
    }
    
    async function loadClients() {
      try {
        // Try loading from cloud first
        const cloudData = await loadFromCloud('clients');

        if (cloudData) {
          crmState.clients = cloudData.clients || {};
          crmState.nextClientId = cloudData.nextClientId || 1;

          // Normalize client data to ensure all have required structure
          Object.keys(crmState.clients).forEach(clientId => {
            const client = crmState.clients[clientId];

            // If client is missing expected properties, normalize it
            if (!client.history || !client.lifetime || !client.contact || typeof client.contact === 'string') {
              crmState.clients[clientId] = buildClientObject({
                id: client.id || clientId,
                businessName: client.businessName || client.business_name || "",
                category: client.category || "",
                contactName: client.contactName || client.contact_name || client.contact || "",
                phone: client.phone || "",
                email: client.email || "",
                address: client.address || "",
                notes: client.notes || "",
                history: client.history || [],
                tags: client.tags || [],
                createdDate: client.createdDate || client.created_at || new Date().toISOString(),
                lastContact: client.lastContact || null,
                nextRenewal: client.nextRenewal || null,
                contract: client.contract || undefined
              });
            }
          });
        } else {
          // Fallback to localStorage
          const saved = localStorage.getItem('mailslot-clients');
          if (saved) {
            const data = JSON.parse(saved);
            crmState.clients = data.clients || {};
            crmState.nextClientId = data.nextClientId || 1;
            // Sync to cloud
            saveToCloud('clients', { clients: crmState.clients, nextClientId: crmState.nextClientId }).catch(e => console.warn('Failed to sync clients to cloud:', e));
          }
        }

        // Render client list (inside try-catch to prevent promise rejection)
        renderClientList();
      } catch(e) {
        console.error('Error loading clients:', e);
        // Still try to render with empty state
        crmState.clients = {};
        crmState.nextClientId = 1;
        renderClientList();
      }
    }

    async function saveClients() {
      try {
        const data = {
          clients: crmState.clients,
          nextClientId: crmState.nextClientId
        };
        // Save to cloud and localStorage
        await saveToCloud('clients', data);
      } catch(e) {
        console.warn('Clients saved to localStorage only (cloud sync failed):', e);
      }
    }
    
    function renderClientList() {
      const container = document.getElementById('clientList');
      const clients = Object.values(crmState.clients);
      
      if (clients.length === 0) {
        container.innerHTML = '<p class="text-sm text-gray-500 text-center py-8">No clients yet. Add your first client above!</p>';
        return;
      }
      
      clients.sort((a, b) => a.businessName.localeCompare(b.businessName));
      
      container.innerHTML = clients.map(client => {
        const lastPurchase = client.history.length > 0 
          ? client.history[client.history.length - 1] 
          : null;
        
        return `
          <div class="client-row" 
               onclick="openClientModal('${client.id}')" 
               data-client-id="${client.id}"
               data-category="${client.category}"
               data-business="${client.businessName.toLowerCase()}">
            <div class="flex justify-between items-start">
              <div class="flex-1">
                <div class="font-semibold text-gray-900">${esc(client.businessName)}</div>
                <div class="text-sm text-gray-600">${esc(client.category || 'Uncategorized')}</div>
                ${client.contact.name ? `<div class="text-sm text-gray-500">${esc(client.contact.name)} ‚Ä¢ ${esc(client.contact.phone)}</div>` : ''}
              </div>
              <div class="text-right">
                <div class="text-sm font-semibold text-green-600">${formatCurrency(client.lifetime.totalSpent)}</div>
                <div class="text-xs text-gray-500">${client.lifetime.cardsBought} card${client.lifetime.cardsBought === 1 ? '' : 's'}</div>
              </div>
            </div>
            ${lastPurchase ? `
              <div class="mt-2 pt-2 border-t text-xs text-gray-500">
                Last: ${lastPurchase.campaign} (${lastPurchase.status})
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
    }
    
    function filterClients() {
      const searchTerm = document.getElementById('clientSearch').value.toLowerCase();
      const categoryFilter = document.getElementById('categoryFilter').value;
      const statusFilter = document.getElementById('statusFilter').value;
      
      const clientEls = document.querySelectorAll('#clientList .client-row');
      
      clientEls.forEach(el => {
        const business = el.dataset.business || '';
        const category = el.dataset.category || '';
        const clientId = el.dataset.clientId;
        const client = crmState.clients[clientId];
        
        let visible = true;
        
        if (searchTerm && !business.includes(searchTerm) && !category.toLowerCase().includes(searchTerm)) {
          visible = false;
        }
        
        if (categoryFilter && category !== categoryFilter) {
          visible = false;
        }
        
        if (statusFilter && client) {
          const hasActivePurchase = client.history.some(h => h.status === 'Paid in Full');
          const hasPendingPurchase = client.history.some(h => h.status !== 'Paid in Full' && h.status !== 'Available');
          
          if (statusFilter === 'active' && !hasActivePurchase) visible = false;
          if (statusFilter === 'pending' && !hasPendingPurchase) visible = false;
          if (statusFilter === 'inactive' && (hasActivePurchase || hasPendingPurchase)) visible = false;
        }
        
        el.style.display = visible ? 'block' : 'none';
      });
    }
    
    /* ========= CONTRACT MANAGEMENT ========= */
    function toggleContractFields() {
      const enabled = document.getElementById('hasContract').checked;
      document.getElementById('contractFields').classList.toggle('hidden', !enabled);
      if (enabled) {
        // Set default start date to today if empty
        if (!document.getElementById('contractStartDate').value) {
          const today = new Date().toISOString().split('T')[0];
          document.getElementById('contractStartDate').value = today;
          calculateContractEnd();
        }
      }
    }

    function calculateContractEnd() {
      const startDate = document.getElementById('contractStartDate').value;
      const length = parseInt(document.getElementById('contractLength').value);

      if (!startDate) {
        document.getElementById('contractEndDate').textContent = '‚Äî';
        return;
      }

      const start = new Date(startDate);
      const end = new Date(start);
      end.setMonth(end.getMonth() + length);

      // Format as readable date
      const options = { year: 'numeric', month: 'long', day: 'numeric' };
      document.getElementById('contractEndDate').textContent = end.toLocaleDateString('en-US', options);

      calculateContractTotal();
    }

    function calculateContractTotal() {
      const monthlyRate = parseFloat(document.getElementById('contractMonthlyRate').value) || 0;
      const length = parseInt(document.getElementById('contractLength').value);
      const total = monthlyRate * length;

      document.getElementById('contractTotalValue').textContent = formatCurrency(total);
    }

    function openClientModal(clientId = null) {
      const modal = document.getElementById('clientModal');
      const title = document.getElementById('clientModalTitle');
      const deleteBtn = document.getElementById('btnDeleteClient');
      const historySection = document.getElementById('clientHistorySection');
      
      lastFocusedElementBeforeModal = document.activeElement;
      
      if (clientId && crmState.clients[clientId]) {
        const client = crmState.clients[clientId];
        title.textContent = 'Edit Client';
        deleteBtn.classList.remove('hidden');
        historySection.classList.remove('hidden');
        
        document.getElementById('clientId').value = client.id;
        document.getElementById('clientBusinessName').value = client.businessName;
        document.getElementById('clientCategory').value = client.category;
        document.getElementById('clientContactName').value = client.contact.name;
        document.getElementById('clientPhone').value = client.contact.phone;
        document.getElementById('clientEmail').value = client.contact.email;
        document.getElementById('clientNotes').value = client.notes;
        
        renderClientHistory(client);
        
        document.getElementById('clientLifetimeSpent').textContent = formatCurrency(client.lifetime.totalSpent);
        document.getElementById('clientCardsBought').textContent = client.lifetime.cardsBought;
        document.getElementById('clientAvgPrice').textContent = formatCurrency(client.lifetime.avgPrice);

        // Load contract data
        if (client.contract && client.contract.enabled) {
          document.getElementById('hasContract').checked = true;
          document.getElementById('contractFields').classList.remove('hidden');
          document.getElementById('contractStartDate').value = client.contract.startDate || '';
          document.getElementById('contractLength').value = client.contract.length || 6;
          document.getElementById('contractMonthlyRate').value = client.contract.monthlyRate || '';
          document.getElementById('contractAutoRenew').checked = client.contract.autoRenew || false;
          calculateContractEnd();
        } else {
          document.getElementById('hasContract').checked = false;
          document.getElementById('contractFields').classList.add('hidden');
        }
      } else {
        title.textContent = 'Add New Client';
        deleteBtn.classList.add('hidden');
        historySection.classList.add('hidden');

        document.getElementById('clientId').value = '';
        document.getElementById('clientBusinessName').value = '';
        document.getElementById('clientCategory').value = '';
        document.getElementById('clientCustomCategory').value = '';
        document.getElementById('clientCustomCategory').classList.add('hidden');
        document.getElementById('clientContactName').value = '';
        document.getElementById('clientPhone').value = '';
        document.getElementById('clientEmail').value = '';
        document.getElementById('clientNotes').value = '';

        // Reset contract fields
        document.getElementById('hasContract').checked = false;
        document.getElementById('contractFields').classList.add('hidden');
        document.getElementById('contractStartDate').value = '';
        document.getElementById('contractLength').value = '6';
        document.getElementById('contractMonthlyRate').value = '';
        document.getElementById('contractAutoRenew').checked = false;
        document.getElementById('contractEndDate').textContent = '‚Äî';
        document.getElementById('contractTotalValue').textContent = '$0';
      }
      
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
      document.getElementById('clientBusinessName').focus();
    }
    
    function renderClientHistory(client) {
      const container = document.getElementById('clientHistory');
      
      if (client.history.length === 0) {
        container.innerHTML = '<p class="text-sm text-gray-500 text-center py-2">No purchase history yet</p>';
        return;
      }
      
      container.innerHTML = client.history.map(purchase => `
        <div class="flex justify-between items-center p-2 bg-white border rounded">
          <div>
            <div class="font-medium text-sm">${esc(purchase.campaign)}</div>
            <div class="text-xs text-gray-500">Spot ${purchase.spot} ‚Ä¢ ${purchase.status}</div>
          </div>
          <div class="text-right">
            <div class="font-semibold text-green-600">${formatCurrency(purchase.price)}</div>
            <div class="text-xs text-gray-500">${purchase.date || 'N/A'}</div>
          </div>
        </div>
      `).join('');
    }
    
    function toggleCustomCategory() {
      const categorySelect = document.getElementById('clientCategory');
      const customInput = document.getElementById('clientCustomCategory');

      if (categorySelect.value === 'Other') {
        customInput.classList.remove('hidden');
        customInput.focus();
      } else {
        customInput.classList.add('hidden');
        customInput.value = '';
      }
    }

    function closeClientModal() {
      const modal = document.getElementById('clientModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
      if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();
    }

    function saveClientModal() {
      const businessName = document.getElementById('clientBusinessName').value.trim();

      if (!businessName) {
        toast('Business name is required', false);
        document.getElementById('clientBusinessName').focus();
        return;
      }

      // Handle custom category
      let category = document.getElementById('clientCategory').value;
      if (category === 'Other') {
        const customCategory = document.getElementById('clientCustomCategory').value.trim();
        if (!customCategory) {
          toast('Please enter a custom category or select a different option', false);
          document.getElementById('clientCustomCategory').focus();
          return;
        }
        category = customCategory;

        // Add custom category to dropdown for future use
        const categorySelect = document.getElementById('clientCategory');
        const existingOption = Array.from(categorySelect.options).find(opt => opt.value === customCategory);
        if (!existingOption) {
          const newOption = document.createElement('option');
          newOption.value = customCategory;
          newOption.textContent = customCategory;
          // Insert before "Other" option
          const otherOption = categorySelect.querySelector('option[value="Other"]');
          categorySelect.insertBefore(newOption, otherOption);
        }
      }

      const clientId = document.getElementById('clientId').value;
      const isNew = !clientId;

      const clientData = {
        id: clientId || undefined,
        businessName,
        category: category,
        contactName: document.getElementById('clientContactName').value,
        phone: document.getElementById('clientPhone').value,
        email: document.getElementById('clientEmail').value,
        notes: document.getElementById('clientNotes').value
      };
      
      let client;
      if (isNew) {
        client = buildClientObject(clientData);
        crmState.clients[client.id] = client;
      } else {
        client = crmState.clients[clientId];
        client.businessName = clientData.businessName;
        client.category = clientData.category;
        client.contact.name = clientData.contactName;
        client.contact.phone = clientData.phone;
        client.contact.email = clientData.email;
        client.notes = clientData.notes;
      }

      // Save contract data
      const hasContract = document.getElementById('hasContract').checked;
      if (hasContract) {
        const startDate = document.getElementById('contractStartDate').value;
        const length = parseInt(document.getElementById('contractLength').value);
        const monthlyRate = parseFloat(document.getElementById('contractMonthlyRate').value) || 0;
        const autoRenew = document.getElementById('contractAutoRenew').checked;

        // Calculate end date
        let endDate = null;
        if (startDate) {
          const start = new Date(startDate);
          const end = new Date(start);
          end.setMonth(end.getMonth() + length);
          endDate = end.toISOString().split('T')[0];
        }

        client.contract = {
          enabled: true,
          startDate: startDate,
          length: length,
          monthlyRate: monthlyRate,
          totalValue: monthlyRate * length,
          endDate: endDate,
          autoRenew: autoRenew
        };
      } else {
        client.contract = {
          enabled: false,
          startDate: null,
          length: 6,
          monthlyRate: 0,
          totalValue: 0,
          endDate: null,
          autoRenew: false
        };
      }

      saveClients();
      renderClientList();
      closeClientModal();
      toast(isNew ? 'Client added' : 'Client updated');
    }
    
    function deleteClientModal() {
      const clientId = document.getElementById('clientId').value;
      if (!clientId) return;

      const client = crmState.clients[clientId];
      if (!client) return;

      const historyCount = client.history?.length || 0;
      const confirmMsg = `Are you sure you want to delete "${client.businessName}"?\n\n` +
        `This client has ${historyCount} purchase ${historyCount === 1 ? 'record' : 'records'}.\n\n` +
        `This action cannot be undone.`;

      if (confirm(confirmMsg)) {
        delete crmState.clients[clientId];
        saveClients();
        renderClientList();
        closeClientModal();
        toast('Client deleted');
      }
    }
    
    function linkClientToSpot(clientId, spotNum, campaign, price, status) {
      const client = crmState.clients[clientId];
      if (!client) return;
      
      const purchase = {
        campaign: campaign,
        spot: spotNum,
        price: price,
        status: status,
        date: new Date().toISOString().split('T')[0]
      };
      
      client.history.push(purchase);
      
      client.lifetime.cardsBought = client.history.length;
      client.lifetime.totalSpent = client.history.reduce((sum, p) => sum + (p.price || 0), 0);
      client.lifetime.avgPrice = client.lifetime.totalSpent / client.lifetime.cardsBought;
      
      saveClients();
    }
    
    function populateClientDropdown() {
      const select = document.getElementById('editClient');
      if (!select) return;

      const clients = Object.values(crmState.clients).sort((a, b) =>
        a.businessName.localeCompare(b.businessName)
      );

      select.innerHTML = '<option value="">‚Äî Select existing client ‚Äî</option>' +
        clients.map(c => `<option value="${c.id}">${esc(c.businessName)} (${esc(c.category)})</option>`).join('');

      // Auto-fill business name when client is selected
      select.onchange = function() {
        const clientId = this.value;
        if (clientId && crmState.clients[clientId]) {
          document.getElementById('editName').value = crmState.clients[clientId].businessName;
        }
      };
    }
    
    function quickAddClient() {
      const businessName = document.getElementById('editName').value.trim();
      openClientModal();
      if (businessName) {
        document.getElementById('clientBusinessName').value = businessName;
      }
    }
    
    /* ========= EXPORT/IMPORT FUNCTIONS ========= */
    
    function exportClientsCSV() {
      const clients = Object.values(crmState.clients);
      if (clients.length === 0) {
        toast('No clients to export', false);
        return;
      }
      
      const headers = ['Business Name', 'Category', 'Contact Name', 'Phone', 'Email', 'Lifetime Spent', 'Cards Bought', 'Notes'];
      const rows = clients.map(c => [
        c.businessName,
        c.category,
        c.contact.name,
        c.contact.phone,
        c.contact.email,
        c.lifetime.totalSpent,
        c.lifetime.cardsBought,
        c.notes
      ]);
      
      let csv = headers.join(',') + '\n';
      rows.forEach(row => {
        csv += row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',') + '\n';
      });
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `clients-${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
      
      toast('Clients exported to CSV');
    }

    function importClientsCSV(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const csv = e.target.result;
          const lines = csv.split('\n').filter(line => line.trim());

          if (lines.length < 2) {
            toast('CSV file is empty or invalid', false);
            return;
          }

          // Parse CSV
          const parseCsvLine = (line) => {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"') {
                if (inQuotes && line[i + 1] === '"') {
                  current += '"';
                  i++;
                } else {
                  inQuotes = !inQuotes;
                }
              } else if (char === ',' && !inQuotes) {
                result.push(current);
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current);
            return result;
          };

          // Parse header
          const headers = parseCsvLine(lines[0]).map(h => h.trim().toLowerCase());

          // Validate headers
          const requiredHeaders = ['business name', 'category', 'contact name', 'phone', 'email'];
          const missingHeaders = requiredHeaders.filter(h => !headers.includes(h));
          if (missingHeaders.length > 0) {
            toast(`CSV missing required columns: ${missingHeaders.join(', ')}`, false);
            return;
          }

          // Parse data rows
          const imported = [];
          const errors = [];

          for (let i = 1; i < lines.length; i++) {
            const values = parseCsvLine(lines[i]);
            if (values.length !== headers.length) continue;

            const row = {};
            headers.forEach((header, idx) => {
              row[header] = values[idx];
            });

            // Validate required fields
            if (!row['business name'] || !row['business name'].trim()) {
              errors.push(`Row ${i + 1}: Missing business name`);
              continue;
            }

            // Create or update client object
            const businessName = row['business name'].trim();

            // Check if client already exists (by business name)
            let existingClient = Object.values(crmState.clients).find(
              c => c.businessName.toLowerCase() === businessName.toLowerCase()
            );

            const clientId = existingClient ? existingClient.id : Date.now() + i;

            const client = {
              id: clientId,
              businessName: businessName,
              category: row['category'] || '',
              contact: {
                name: row['contact name'] || '',
                phone: row['phone'] || '',
                email: row['email'] || ''
              },
              lifetime: {
                totalSpent: parseFloat(row['lifetime spent']) || 0,
                cardsBought: parseInt(row['cards bought']) || 0
              },
              notes: row['notes'] || '',
              contracts: existingClient ? existingClient.contracts : []
            };

            crmState.clients[clientId] = client;
            imported.push(businessName);
          }

          // Save and re-render
          saveClients();
          renderClientList();

          // Reset file input
          event.target.value = '';

          // Show results
          if (imported.length > 0) {
            toast(`Successfully imported ${imported.length} client${imported.length === 1 ? '' : 's'}`, true);
          }
          if (errors.length > 0) {
            console.warn('Import errors:', errors);
            toast(`Imported with ${errors.length} error${errors.length === 1 ? '' : 's'} (check console)`, false);
          }

        } catch (err) {
          console.error('CSV import error:', err);
          toast('Failed to import CSV. Please check the file format.', false);
        }
      };

      reader.onerror = () => {
        toast('Failed to read CSV file', false);
      };

      reader.readAsText(file);
    }

    function syncClientsToSheets() {
      // Google Sheets sync deprecated - now using Supabase cloud storage
      toast('Clients are now automatically synced to Supabase', true);
      return;
    }

    function syncClientsToSheets_DEPRECATED() {
      const clients = Object.values(crmState.clients);

      if (clients.length === 0) {
        toast('No clients to sync', false);
        return;
      }

      toast('Syncing clients to Google Sheets...', true);

      const payload = {
        action: 'syncClients',
        user: ACTIVE_USER,
        clients: clients
      };

      fetch(GAS_URL, {
        method: 'POST',
        mode: 'no-cors',  // Google Apps Script requires no-cors
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload)
      })
      .then(() => {
        // no-cors mode doesn't allow reading response, so we assume success
        toast(`‚úì Client sync request sent (${clients.length} clients)`, true);
      })
      .catch(err => {
        console.error('Sync error:', err);
        toast('‚ö†Ô∏è Sync failed. Your Google Apps Script may need to handle "syncClients" action. Clients are saved locally.', false);
      });

      // Note: To make this fully functional, add this to your Google Apps Script doPost():
      // if (data.action === 'syncClients') {
      //   // Handle client sync logic here
      //   return ContentService.createTextOutput(JSON.stringify({success: true}))
      //     .setMimeType(ContentService.MimeType.JSON);
      // }
    }
    
    /* ========= EMAIL FUNCTIONS ========= */
    
    const emailTemplates = {
      invoice: {
        subject: 'Invoice Reminder - {businessName}',
        body: 'Hi {contactName},\n\nThis is a friendly reminder that your invoice for {campaign} is still pending.\n\nAmount Due: {amount}\n\nPlease let me know if you have any questions.\n\nBest regards'
      },
      proof: {
        subject: 'Your Ad Proof is Ready - {businessName}',
        body: 'Hi {contactName},\n\nGreat news! Your ad proof for {campaign} is ready for review.\n\nPlease review and let me know if you\'d like any changes.\n\nBest regards'
      },
      renewal: {
        subject: 'Time to Renew - {businessName}',
        body: 'Hi {contactName},\n\nI hope your campaign with us has been successful!\n\nWe\'re preparing our next mailing and would love to have you on board again.\n\nWould you like to renew your spot?\n\nBest regards'
      },
      thankyou: {
        subject: 'Thank You - {businessName}',
        body: 'Hi {contactName},\n\nThank you for advertising with us on {campaign}!\n\nWe appreciate your business and look forward to working with you again.\n\nBest regards'
      }
    };
    
    function openEmailModal() {
      const modal = document.getElementById('emailModal');
      lastFocusedElementBeforeModal = document.activeElement;
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
    }
    
    function closeEmailModal() {
      const modal = document.getElementById('emailModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
      if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();
    }
    
    function loadEmailTemplate() {
      const templateKey = document.getElementById('emailTemplate').value;
      if (!templateKey) return;
      
      const template = emailTemplates[templateKey];
      document.getElementById('emailSubject').value = template.subject;
      document.getElementById('emailBody').value = template.body;
    }
    
    function sendEmail() {
      const to = document.getElementById('emailTo').value;
      const subject = document.getElementById('emailSubject').value;
      const body = document.getElementById('emailBody').value;
      
      if (!to || !subject || !body) {
        toast('Please fill in all fields', false);
        return;
      }
      
      // In production, this would call your email API
      const mailtoLink = `mailto:${to}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      window.location.href = mailtoLink;
      
      toast('Email client opened');
      closeEmailModal();
    }
    
    /* ========= REPORTS FUNCTIONS ========= */
    
    function openReportsModal() {
      const modal = document.getElementById('reportsModal');
      lastFocusedElementBeforeModal = document.activeElement;
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
    }
    
    function closeReportsModal() {
      const modal = document.getElementById('reportsModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
      if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();
    }
    
    function generateProfitLossReport() {
      const output = document.getElementById('reportOutput');
      const content = document.getElementById('reportContent');
      
      let report = '<div class="space-y-4">';
      report += '<h3 class="font-bold text-lg">Profit & Loss Report</h3>';
      
      state.mailers.forEach(campaign => {
        const financials = calculateFinancials(campaign.Mailer_ID, campaign);
        if (!financials) return;

        report += `
          <div class="border-b pb-3">
            <div class="font-semibold">${esc(campaign.Town)} ‚Äî ${esc(campaign.Mail_Date)}</div>
            <div class="grid grid-cols-2 gap-2 mt-2 text-sm">
              <div>Revenue: ${formatCurrency(financials.revenue.current)}</div>
              <div>Expenses: ${formatCurrency(financials.expenses.total)}</div>
              <div class="${financials.profit.current >= 0 ? 'text-green-600' : 'text-red-600'} font-semibold">
                Profit: ${formatCurrency(financials.profit.current)}
              </div>
              <div>Margin: ${financials.profit.margin.toFixed(1)}%</div>
            </div>
          </div>
        `;
      });
      
      report += '</div>';
      content.innerHTML = report;
      output.classList.remove('hidden');
    }
    
    function generateClientValueReport() {
      const output = document.getElementById('reportOutput');
      const content = document.getElementById('reportContent');
      
      const clients = Object.values(crmState.clients).sort((a, b) => b.lifetime.totalSpent - a.lifetime.totalSpent);
      
      let report = '<div class="space-y-2">';
      report += '<h3 class="font-bold text-lg mb-3">Client Value Analysis</h3>';
      report += '<div class="grid grid-cols-3 gap-2 font-semibold text-sm border-b pb-2">';
      report += '<div>Client</div><div>Lifetime Value</div><div>Cards Purchased</div>';
      report += '</div>';
      
      clients.forEach(client => {
        report += `
          <div class="grid grid-cols-3 gap-2 text-sm py-1">
            <div>${esc(client.businessName)}</div>
            <div class="text-green-600 font-semibold">${formatCurrency(client.lifetime.totalSpent)}</div>
            <div>${client.lifetime.cardsBought}</div>
          </div>
        `;
      });
      
      report += '</div>';
      content.innerHTML = report;
      output.classList.remove('hidden');
    }
    
    function generateCampaignReport() {
      toast('Campaign comparison report generated');
      // Implementation similar to P&L
    }
    
    function generateSalesFunnelReport() {
      toast('Sales funnel report generated');
      // Implementation with kanban metrics
    }
    
    function downloadReport() {
      toast('Report download started');
    }

    /* ========= API QUOTA & PLACES CACHE FUNCTIONS ========= */

    function loadApiQuota() {
      try {
        const saved = safeGetItem('mailslot-api-quota');
        if (saved) {
          const data = JSON.parse(saved);
          const currentMonth = new Date().toISOString().slice(0, 7);

          // Reset if new month
          if (data.currentMonth !== currentMonth) {
            apiQuotaState.currentMonth = currentMonth;
            apiQuotaState.callsThisMonth = 0;
            apiQuotaState.userQuotas = {};
            apiQuotaState.restrictionsActive = false;
            saveApiQuota();
          } else {
            Object.assign(apiQuotaState, data);
          }
        }
      } catch(e) {
        console.error('Error loading API quota:', e);
      }
    }

    function saveApiQuota() {
      safeSetItem('mailslot-api-quota', JSON.stringify(apiQuotaState));
    }

    function getApiQuota() {
      return {
        used: apiQuotaState.callsThisMonth,
        total: apiQuotaState.monthlyLimit,
        remaining: apiQuotaState.monthlyLimit - apiQuotaState.callsThisMonth,
        percentUsed: (apiQuotaState.callsThisMonth / apiQuotaState.monthlyLimit) * 100,
        restrictionsActive: apiQuotaState.restrictionsActive
      };
    }

    async function loadNotInterestedList() {
      try {
        // Try loading from cloud first
        const cloudData = await loadFromCloud('notInterested');

        if (cloudData) {
          notInterestedState.placeIds = new Set(cloudData.placeIds || []);
          notInterestedState.businesses = cloudData.businesses || {};
        } else {
          // Fallback to localStorage
          const saved = localStorage.getItem('mailslot-not-interested');
          if (saved) {
            const data = JSON.parse(saved);
            notInterestedState.placeIds = new Set(data.placeIds || []);
            notInterestedState.businesses = data.businesses || {};
            // Sync to cloud
            const cloudData = {
              placeIds: Array.from(notInterestedState.placeIds),
              businesses: notInterestedState.businesses
            };
            saveToCloud('notInterested', cloudData).catch(e => console.warn('Failed to sync not interested list to cloud:', e));
          }
        }
      } catch(e) {
        console.error('Error loading not interested list:', e);
      }
    }

    async function saveNotInterestedList() {
      try {
        const data = {
          placeIds: Array.from(notInterestedState.placeIds),
          businesses: notInterestedState.businesses
        };
        await saveToCloud('notInterested', data);
      } catch(e) {
        console.warn('Not interested list saved to localStorage only (cloud sync failed):', e);
      }
    }

    async function loadPlacesCache() {
      try {
        // Load from cloud first
        const cloudData = await loadFromCloud('placesCache');

        // Load from localStorage
        const localSaved = safeGetItem('mailslot-places-cache');
        const localData = localSaved ? JSON.parse(localSaved) : {};

        // Merge cloud and local data (keep newer entries)
        const merged = { ...cloudData };

        Object.keys(localData).forEach(cacheKey => {
          const local = localData[cacheKey];
          const cloud = merged[cacheKey];

          if (!cloud) {
            // Only in local - add it
            merged[cacheKey] = local;
          } else if (local.lastFetched && cloud.lastFetched) {
            // In both - keep the newer one
            const localDate = new Date(local.lastFetched);
            const cloudDate = new Date(cloud.lastFetched);
            if (localDate > cloudDate) {
              merged[cacheKey] = local;
            }
          }
        });

        placesCache.searches = merged;

        const totalProspects = Object.values(merged).reduce((sum, cache) =>
          sum + (cache.cachedData?.length || 0), 0
        );

        console.log(`üì¶ Loaded prospect cache: ${Object.keys(merged).length} searches, ${totalProspects} total prospects`);

        // Save merged back to localStorage
        safeSetItem('mailslot-places-cache', JSON.stringify(merged));

      } catch(e) {
        console.error('Error loading places cache:', e);
        // Fall back to localStorage only
        const saved = safeGetItem('mailslot-places-cache');
        if (saved) {
          placesCache.searches = JSON.parse(saved);
        }
      }
    }

    async function savePlacesCache() {
      try {
        // Save to localStorage first (always)
        safeSetItem('mailslot-places-cache', JSON.stringify(placesCache.searches));

        // Check size before saving to cloud
        const dataStr = JSON.stringify(placesCache.searches);
        const sizeKB = Math.round(dataStr.length / 1024);

        console.log(`üíæ Saving prospect cache to cloud (${sizeKB} KB)...`);

        // Supabase has a reasonable size limit - if under 5MB we're good
        if (dataStr.length > 5000000) {
          console.warn('‚ö†Ô∏è Prospect cache too large for cloud sync, keeping local only');
          toast('‚ö†Ô∏è Prospect data is large - saved locally only', false);
          return;
        }

        // Save to cloud
        await saveToCloud('placesCache', placesCache.searches);
        console.log(`‚úÖ Prospect cache saved to cloud (${sizeKB} KB)`);

      } catch(e) {
        console.error('Error saving places cache to cloud:', e);
        // Data is already in localStorage, so no data loss
      }
    }

    function trackApiCall(count = 1) {
      apiQuotaState.callsThisMonth += count;

      const percentUsed = apiQuotaState.callsThisMonth / apiQuotaState.monthlyLimit;

      // Activate restrictions at warning threshold
      if (percentUsed >= apiQuotaState.warningThreshold && !apiQuotaState.restrictionsActive) {
        apiQuotaState.restrictionsActive = true;
        // Set per-user quota: remaining calls divided by estimated active users (default 10)
        const remainingCalls = apiQuotaState.monthlyLimit - apiQuotaState.callsThisMonth;
        const perUserQuota = Math.floor(remainingCalls / 10); // Conservative estimate

        toast(`‚ö†Ô∏è API quota at ${Math.round(percentUsed * 100)}% - Per-user limits now active (${perUserQuota} searches/user)`, false);
      }

      // Critical warning
      if (percentUsed >= apiQuotaState.criticalThreshold) {
        toast(`üö® API quota at ${Math.round(percentUsed * 100)}% - Very limited searches remaining`, false);
      }

      saveApiQuota();
    }

    function canUserSearch(userId = ACTIVE_USER) {
      const percentUsed = apiQuotaState.callsThisMonth / apiQuotaState.monthlyLimit;

      // If under warning threshold, everyone can search
      if (percentUsed < apiQuotaState.warningThreshold) {
        return { allowed: true, reason: null };
      }

      // If restrictions active, check user quota
      if (apiQuotaState.restrictionsActive) {
        const userCalls = apiQuotaState.userQuotas[userId] || 0;
        const remainingCalls = apiQuotaState.monthlyLimit - apiQuotaState.callsThisMonth;
        const perUserLimit = Math.floor(remainingCalls / 10);

        if (userCalls >= perUserLimit) {
          return {
            allowed: false,
            reason: `Monthly search limit reached (${perUserLimit} searches). Resets ${getNextMonthDate()}.`
          };
        }
      }

      // Check absolute limit
      if (apiQuotaState.callsThisMonth >= apiQuotaState.monthlyLimit) {
        return {
          allowed: false,
          reason: `System-wide monthly limit reached. Resets ${getNextMonthDate()}.`
        };
      }

      return { allowed: true, reason: null };
    }

    function recordUserSearch(userId = ACTIVE_USER) {
      if (!apiQuotaState.userQuotas[userId]) {
        apiQuotaState.userQuotas[userId] = 0;
      }
      apiQuotaState.userQuotas[userId]++;
      saveApiQuota();
    }

    function getNextMonthDate() {
      const now = new Date();
      const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      return nextMonth.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }

    function getApiUsageStats() {
      const percentUsed = (apiQuotaState.callsThisMonth / apiQuotaState.monthlyLimit * 100).toFixed(1);
      const remaining = apiQuotaState.monthlyLimit - apiQuotaState.callsThisMonth;

      return {
        used: apiQuotaState.callsThisMonth,
        limit: apiQuotaState.monthlyLimit,
        remaining: remaining,
        percentUsed: percentUsed,
        restrictionsActive: apiQuotaState.restrictionsActive,
        resetsOn: getNextMonthDate()
      };
    }

    /* ========= GOOGLE PLACES AUTO-POPULATE FUNCTIONS ========= */

    function openAutoPopulateModal() {
      if (!GOOGLE_PLACES_API_KEY) {
        toast('Google Places API key not configured. Please add your API key to the GOOGLE_PLACES_API_KEY constant.', false);
        return;
      }

      const modal = document.getElementById('autoPopulateModal');
      modal.classList.add('show');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');

      // Update API usage display
      updateApiUsageDisplay();

      // Focus first input
      document.getElementById('autoPopZipCode').focus();
    }

    function closeAutoPopulateModal() {
      const modal = document.getElementById('autoPopulateModal');
      modal.classList.remove('show');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');

      // Reset form
      document.getElementById('autoPopZipCode').value = '';
      document.getElementById('autoPopCategory').value = '';
      document.getElementById('autoPopRadius').value = '5000';
    }

    function updateApiUsageDisplay() {
      const stats = getApiUsageStats();
      const display = document.getElementById('apiUsageDisplay');

      let bgColor = 'bg-green-50 border-green-300';
      let textColor = 'text-green-900';
      let icon = '‚úÖ';

      if (stats.percentUsed >= 95) {
        bgColor = 'bg-red-50 border-red-300';
        textColor = 'text-red-900';
        icon = 'üö®';
      } else if (stats.percentUsed >= 80) {
        bgColor = 'bg-orange-50 border-orange-300';
        textColor = 'text-orange-900';
        icon = '‚ö†Ô∏è';
      } else if (stats.percentUsed >= 50) {
        bgColor = 'bg-yellow-50 border-yellow-300';
        textColor = 'text-yellow-900';
        icon = 'üí°';
      }

      display.className = `mb-4 p-3 rounded-lg border ${bgColor}`;
      display.innerHTML = `
        <div class="${textColor}">
          <div class="font-semibold text-sm mb-1">${icon} API Usage This Month</div>
          <div class="text-xs">
            <strong>${stats.used}</strong> of ${stats.limit} searches used (${stats.percentUsed}%)
            <br>
            ${stats.remaining} searches remaining ‚Ä¢ Resets ${stats.resetsOn}
          </div>
          ${stats.restrictionsActive ? '<div class="text-xs mt-1 font-semibold">‚ö†Ô∏è Per-user quotas active</div>' : ''}
        </div>
      `;
    }

    // Initialize Google Maps API - script loads from <head> tag with callback
    function loadGoogleMapsAPI() {
      return new Promise((resolve, reject) => {
        // Check if already loaded
        if (typeof google !== 'undefined' && google.maps && googleMapsLoaded) {
          resolve();
          return;
        }

        // Wait for callback (script is loading from <head>)
        const checkInterval = setInterval(() => {
          if (googleMapsLoaded && typeof google !== 'undefined' && google.maps) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);

        // Timeout after 10 seconds
        setTimeout(() => {
          clearInterval(checkInterval);
          if (!googleMapsLoaded) {
            reject(new Error('Google Maps API failed to load within 10 seconds'));
          }
        }, 10000);
      });
    }

    // Extract ZIP code from an address string
    function extractZipFromAddress(address) {
      if (!address) return null;

      // Match 5-digit ZIP codes (with optional +4 extension)
      const zipMatch = address.match(/\b(\d{5})(?:-\d{4})?\b/);
      return zipMatch ? zipMatch[1] : null;
    }

    async function convertZipToLatLng(zipCode) {
      try {
        // Ensure Google Maps API is loaded
        await loadGoogleMapsAPI();

        // Use Google Maps Geocoder (client-side, no CORS issues)
        const geocoder = new google.maps.Geocoder();

        return new Promise((resolve, reject) => {
          geocoder.geocode(
            {
              address: zipCode,
              componentRestrictions: { country: 'US' }
            },
            (results, status) => {
              if (status === 'OK' && results.length > 0) {
                const location = results[0].geometry.location;
                resolve({ lat: location.lat(), lng: location.lng() });
              } else {
                reject(new Error(`Geocoding failed: ${status}`));
              }
            }
          );
        });
      } catch(err) {
        console.error('Geocoding error:', err);
        return null;
      }
    }

    async function searchGooglePlaces(zipCode, category, radiusMeters) {
      // Check quota first
      const quotaCheck = canUserSearch();
      if (!quotaCheck.allowed) {
        toast(quotaCheck.reason, false);
        return [];
      }

      const cacheKey = `${zipCode}-${category}`;

      // Check cache first
      if (placesCache.searches[cacheKey]) {
        const cached = placesCache.searches[cacheKey];
        const cacheDate = new Date(cached.cachedUntil);

        if (new Date() < cacheDate) {
          toast('‚úÖ Using cached results (FREE!)', true);
          return cached.cachedData || [];
        }
      }

      try {
        // Ensure Google Maps API is loaded
        await loadGoogleMapsAPI();

        // Convert zip code to lat/lng
        toast('üìç Finding location...', true);
        const location = await convertZipToLatLng(zipCode);

        if (!location) {
          toast('Invalid zip code or geocoding failed', false);
          return [];
        }

        // Track API call for geocoding
        trackApiCall(1);
        recordUserSearch();

        // Search nearby places using Places Service (client-side, no CORS issues)
        toast('üîç Searching for businesses...', true);

        // Create a temporary div for PlacesService (required by Google Maps API)
        const mapDiv = document.createElement('div');
        const map = new google.maps.Map(mapDiv);
        const service = new google.maps.places.PlacesService(map);

        // List of Google's predefined place types
        const predefinedTypes = [
          'accounting', 'airport', 'amusement_park', 'aquarium', 'art_gallery', 'atm', 'bakery', 'bank', 'bar',
          'beauty_salon', 'bicycle_store', 'book_store', 'bowling_alley', 'bus_station', 'cafe', 'campground',
          'car_dealer', 'car_rental', 'car_repair', 'car_wash', 'casino', 'cemetery', 'church', 'city_hall',
          'clothing_store', 'convenience_store', 'courthouse', 'dentist', 'department_store', 'doctor', 'drugstore',
          'electrician', 'electronics_store', 'embassy', 'fire_station', 'florist', 'funeral_home', 'furniture_store',
          'gas_station', 'gym', 'hair_care', 'hardware_store', 'hindu_temple', 'home_goods_store', 'hospital',
          'insurance_agency', 'jewelry_store', 'laundry', 'lawyer', 'library', 'light_rail_station', 'liquor_store',
          'local_government_office', 'locksmith', 'lodging', 'meal_delivery', 'meal_takeaway', 'mosque', 'movie_rental',
          'movie_theater', 'moving_company', 'museum', 'night_club', 'painter', 'park', 'parking', 'pet_store',
          'pharmacy', 'physiotherapist', 'plumber', 'police', 'post_office', 'primary_school', 'real_estate_agency',
          'restaurant', 'roofing_contractor', 'rv_park', 'school', 'secondary_school', 'shoe_store', 'shopping_mall',
          'spa', 'stadium', 'storage', 'store', 'subway_station', 'supermarket', 'synagogue', 'taxi_stand',
          'tourist_attraction', 'train_station', 'transit_station', 'travel_agency', 'university', 'veterinary_care',
          'zoo', 'administrative_area_level_1', 'administrative_area_level_2', 'administrative_area_level_3',
          'administrative_area_level_4', 'administrative_area_level_5', 'archipelago', 'colloquial_area', 'continent',
          'country', 'establishment', 'finance', 'floor', 'food', 'general_contractor', 'geocode', 'health',
          'intersection', 'locality', 'natural_feature', 'neighborhood', 'place_of_worship', 'plus_code', 'point_of_interest',
          'political', 'post_box', 'postal_code', 'postal_code_prefix', 'postal_code_suffix', 'postal_town', 'premise',
          'room', 'route', 'street_address', 'street_number', 'sublocality', 'sublocality_level_1', 'sublocality_level_2',
          'sublocality_level_3', 'sublocality_level_4', 'sublocality_level_5', 'subpremise', 'town_square', 'grocery_or_supermarket'
        ];

        const isCustomCategory = !predefinedTypes.includes(category.toLowerCase());

        return new Promise((resolve, reject) => {
          let request;

          if (isCustomCategory) {
            // Use textSearch for custom categories (more accurate for niche industries)
            request = {
              query: `${category} in ${zipCode}`,
              location: new google.maps.LatLng(location.lat, location.lng),
              radius: radiusMeters
            };

            service.textSearch(request, (results, status) => {
              // Track API call for places search
              trackApiCall(1);

              if (status === google.maps.places.PlacesServiceStatus.OK ||
                  status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {

                // First, map all operational businesses
                const allBusinesses = (results || [])
                  .filter(place => place.business_status === 'OPERATIONAL') // Only active businesses
                  .map(place => {
                    const address = place.vicinity || place.formatted_address || '';
                    return {
                      placeId: place.place_id,
                      name: place.name,
                      address: address,
                      rating: place.rating || 0,
                      userRatingsTotal: place.user_ratings_total || 0,
                      types: place.types || [],
                      category: category, // Track which category this came from
                      zipCode: zipCode, // Track which ZIP code was used for the search
                      actualZip: extractZipFromAddress(address) // Extract actual ZIP from address
                    };
                  });

                // Filter to only businesses actually in the searched ZIP code
                // IMPORTANT: Only filter OUT if we can confirm it's a DIFFERENT ZIP
                // If no ZIP in address (actualZip is null), KEEP IT (Google often doesn't include ZIP in vicinity)
                const businesses = allBusinesses.filter(b => {
                  if (!b.actualZip) return true; // No ZIP in address, keep it (can't confirm it's wrong)
                  return b.actualZip === zipCode; // Has ZIP, only keep if it matches
                });

                const filteredOutCount = allBusinesses.length - businesses.length;
                if (filteredOutCount > 0) {
                  console.log(`üîç Filtered out ${filteredOutCount} business(es) with confirmed different ZIP codes (searched: ${zipCode})`);
                }

                // Cache results for 30 days
                const cacheExpiry = new Date();
                cacheExpiry.setDate(cacheExpiry.getDate() + 30);

                placesCache.searches[cacheKey] = {
                  placeIds: businesses.map(b => b.placeId),
                  cachedData: businesses,
                  cachedUntil: cacheExpiry.toISOString(),
                  lastFetched: new Date().toISOString(),
                  town: state.current?.Town || null // Tag with current town
                };

                savePlacesCache();

                resolve(businesses);
              } else {
                reject(new Error(`Places API error: ${status}`));
              }
            });
          } else {
            // Use nearbySearch for predefined types (faster and more accurate)
            request = {
              location: new google.maps.LatLng(location.lat, location.lng),
              radius: radiusMeters,
              type: category
            };

            service.nearbySearch(request, (results, status) => {
              // Track API call for places search
              trackApiCall(1);

              if (status === google.maps.places.PlacesServiceStatus.OK ||
                  status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {

                // First, map all operational businesses
                const allBusinesses = (results || [])
                  .filter(place => place.business_status === 'OPERATIONAL') // Only active businesses
                  .map(place => {
                    const address = place.vicinity || place.formatted_address || '';
                    return {
                      placeId: place.place_id,
                      name: place.name,
                      address: address,
                      rating: place.rating || 0,
                      userRatingsTotal: place.user_ratings_total || 0,
                      types: place.types || [],
                      category: category, // Track which category this came from
                      zipCode: zipCode, // Track which ZIP code was used for the search
                      actualZip: extractZipFromAddress(address) // Extract actual ZIP from address
                    };
                  });

                // Filter to only businesses actually in the searched ZIP code
                // IMPORTANT: Only filter OUT if we can confirm it's a DIFFERENT ZIP
                // If no ZIP in address (actualZip is null), KEEP IT (Google often doesn't include ZIP in vicinity)
                const businesses = allBusinesses.filter(b => {
                  if (!b.actualZip) return true; // No ZIP in address, keep it (can't confirm it's wrong)
                  return b.actualZip === zipCode; // Has ZIP, only keep if it matches
                });

                const filteredOutCount = allBusinesses.length - businesses.length;
                if (filteredOutCount > 0) {
                  console.log(`üîç Filtered out ${filteredOutCount} business(es) with confirmed different ZIP codes (searched: ${zipCode})`);
                }

                // Cache results for 30 days
                const cacheExpiry = new Date();
                cacheExpiry.setDate(cacheExpiry.getDate() + 30);

                placesCache.searches[cacheKey] = {
                  placeIds: businesses.map(b => b.placeId),
                  cachedData: businesses,
                  cachedUntil: cacheExpiry.toISOString(),
                  lastFetched: new Date().toISOString(),
                  town: state.current?.Town || null // Tag with current town
                };

                savePlacesCache();

                resolve(businesses);
              } else {
                reject(new Error(`Places API error: ${status}`));
              }
            });
          }
        });
      } catch(err) {
        console.error('Google Places search error:', err);
        toast(`Search failed: ${err.message}`, false);
        return [];
      }
    }

    // Fetch additional details for a place (phone, website, etc.)
    async function fetchPlaceDetails(placeId) {
      try {
        await loadGoogleMapsAPI();

        return new Promise((resolve, reject) => {
          const service = new google.maps.places.PlacesService(document.createElement('div'));

          service.getDetails(
            {
              placeId: placeId,
              fields: ['formatted_phone_number', 'international_phone_number', 'website', 'opening_hours', 'url']
            },
            (place, status) => {
              if (status === google.maps.places.PlacesServiceStatus.OK) {
                const hasData = !!(place.formatted_phone_number || place.international_phone_number || place.website);
                resolve({
                  phone: place.formatted_phone_number || place.international_phone_number || '',
                  website: place.website || '',
                  email: '', // Google Places doesn't provide emails
                  facebook: '', // Google Places doesn't provide social media
                  instagram: '',
                  googleMapsUrl: place.url || '',
                  openingHours: place.opening_hours?.weekday_text || [],
                  enriched: hasData, // Mark as enriched if we got phone or website
                  cost: 0 // Google Places is free
                });
              } else {
                // Don't reject - just return empty data
                resolve({ phone: '', website: '', email: '', facebook: '', instagram: '', googleMapsUrl: '', openingHours: [], enriched: false, cost: 0 });
              }
            }
          );
        });
      } catch(err) {
        console.error('Error fetching place details:', err);
        return { phone: '', website: '', email: '', facebook: '', instagram: '', googleMapsUrl: '', openingHours: [], enriched: false, cost: 0 };
      }
    }

    // Fetch enriched business details from Outscraper (phone, email, social media)
    // Uses Vercel serverless function as proxy to avoid CORS issues
    // Removed Outscraper - use CSV import workflow for Facebook/Instagram enrichment
    async function fetchOutscraperDetails(businessName, address, placeId) {
      // Return empty social media fields - user will enrich via CSV import
      return {
        phone: '',
        website: '',
        email: '',
        facebook: '',
        instagram: '',
        enriched: false,
        source: 'google-places'
      };
    }

    async function runAutoPopulate() {
      const zipCode = document.getElementById('autoPopZipCode').value.trim();
      const category = document.getElementById('autoPopCategory').value;
      const radius = parseInt(document.getElementById('autoPopRadius').value);

      // Validation
      if (!zipCode || !/^\d{5}$/.test(zipCode)) {
        toast('Please enter a valid 5-digit zip code', false);
        return;
      }

      if (!category) {
        toast('Please select a business category', false);
        return;
      }

      // Disable button during search
      const btn = document.getElementById('btnRunAutoPopulate');
      const originalText = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Searching...';

      try {
        const businesses = await searchGooglePlaces(zipCode, category, radius);

        if (businesses.length === 0) {
          toast('No businesses found in this area', false);
          btn.disabled = false;
          btn.innerHTML = originalText;
          return;
        }

        // Just cache results - searchGooglePlaces already handled caching
        closeAutoPopulateModal();

        toast(`‚úÖ Found ${businesses.length} businesses! Go to Prospect Pool tab to review and add them.`, true);

        // Switch to Prospect Pool
        setTimeout(() => {
          switchTab('prospects');
        }, 1500);

      } catch(err) {
        console.error('Auto-populate error:', err);
        toast('Search failed. Please try again.', false);
      } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
      }
    }

    // Toggle custom category input
    function toggleBulkCustomCategory() {
      const checkbox = document.getElementById('enableCustomCategory');
      const input = document.getElementById('bulkCustomCategory');
      input.disabled = !checkbox.checked;
      if (checkbox.checked) {
        input.focus();
      } else {
        input.value = '';
      }
    }

    // Update quick API usage display in prospecting section
    function updateQuickApiUsage() {
      const stats = getApiQuota();
      const usageEl = document.getElementById('quickApiUsage');
      const resetEl = document.getElementById('quickApiReset');

      if (usageEl) {
        usageEl.textContent = `${stats.used.toLocaleString()} / ${stats.total.toLocaleString()}`;
      }

      if (resetEl) {
        const nextMonth = new Date();
        nextMonth.setMonth(nextMonth.getMonth() + 1);
        nextMonth.setDate(1);
        const monthName = nextMonth.toLocaleString('en-US', { month: 'short' });
        resetEl.textContent = `Resets ${monthName} 1`;
      }
    }

    // Toggle all category checkboxes
    function toggleAllCategories() {
      const selectAllCheckbox = document.getElementById('selectAllCategories');
      const categoryCheckboxes = document.querySelectorAll('.category-checkbox');

      categoryCheckboxes.forEach(checkbox => {
        checkbox.checked = selectAllCheckbox.checked;
      });
    }

    // Run bulk auto-populate with multiple categories - shows results in modal
    async function runBulkAutoPopulate() {
      // Check if user wants to clear previous searches first
      const clearBeforeSearch = document.getElementById('clearBeforeSearch')?.checked;
      if (clearBeforeSearch) {
        console.log('üóëÔ∏è Clearing previous searches before new search...');
        placesCache.searches = {};
        prospectPoolState.selectedIds.clear();
        savePlacesCache();
        toast('Cleared previous searches', true);
      }

      const zipCode = document.getElementById('bulkPopZipCode').value.trim();
      const radius = parseInt(document.getElementById('bulkPopRadius').value);

      // Validation
      if (!zipCode || !/^\d{5}$/.test(zipCode)) {
        toast('Please enter a valid 5-digit zip code', false);
        return;
      }

      // Get selected categories
      const categoryCheckboxes = document.querySelectorAll('.category-checkbox:checked');
      const selectedCategories = [];

      categoryCheckboxes.forEach(checkbox => {
        if (checkbox.id === 'enableCustomCategory') {
          // Handle custom category
          const customInput = document.getElementById('bulkCustomCategory');
          if (customInput.value.trim()) {
            selectedCategories.push(customInput.value.trim());
          }
        } else {
          selectedCategories.push(checkbox.value);
        }
      });

      if (selectedCategories.length === 0) {
        toast('Please select at least one business category', false);
        return;
      }

      // Disable button during search
      const btn = document.getElementById('btnRunBulkPopulate');
      const originalText = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Searching...';

      try {
        // Track all businesses found across all categories
        const allBusinesses = [];
        const seenPlaceIds = new Set();
        let successfulSearches = 0;
        let failedSearches = 0;

        // Search each category
        for (const category of selectedCategories) {
          try {
            btn.innerHTML = `‚è≥ Searching ${category}... (${successfulSearches + failedSearches + 1}/${selectedCategories.length})`;

            const businesses = await searchGooglePlaces(zipCode, category, radius);

            // Deduplicate by place ID and filter out "not interested"
            businesses.forEach(business => {
              if (!seenPlaceIds.has(business.placeId) && !notInterestedState.placeIds.has(business.placeId)) {
                seenPlaceIds.add(business.placeId);
                allBusinesses.push(business);
              }
            });

            successfulSearches++;

            // Small delay between requests to be polite to the API
            if (selectedCategories.length > 1) {
              await new Promise(resolve => setTimeout(resolve, 500));
            }
          } catch (err) {
            console.error(`Failed to search category ${category}:`, err);
            failedSearches++;
          }
        }

        if (allBusinesses.length === 0) {
          toast(`Searched ${selectedCategories.length} categories. No businesses found in this area.`, false);
          btn.disabled = false;
          btn.innerHTML = originalText;
          updateQuickApiUsage();
          return;
        }

        // Check which businesses already exist
        const existingLeads = new Set();
        Object.values(kanbanState.columns).forEach(column => {
          if (Array.isArray(column)) {
            column.forEach(lead => {
              if (lead && lead.placeId) {
                existingLeads.add(lead.placeId);
              }
            });
          }
        });

        Object.values(crmState.clients).forEach(client => {
          if (client.placeId) {
            existingLeads.add(client.placeId);
          }
        });

        // Mark businesses with status
        allBusinesses.forEach(business => {
          business.alreadyExists = existingLeads.has(business.placeId);
        });

        // Just cache results - don't auto-add to prospecting
        toast(`‚úÖ Found ${allBusinesses.length} businesses! Go to Prospect Pool tab to review and add them.`, true);

        // Update API usage display
        updateQuickApiUsage();

        // Automatically switch to Prospect Pool tab to review
        setTimeout(() => {
          switchTab('prospects');
        }, 1500);

      } catch(err) {
        console.error('Bulk auto-populate error:', err);
        toast('Search failed. Please try again.', false);
      } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
      }
    }

    /* ========= PROSPECTS RESULTS MODAL FUNCTIONS ========= */

    function openProspectsResultsModal() {
      const modal = document.getElementById('prospectsResultsModal');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
    }

    function closeProspectsResultsModal() {
      const modal = document.getElementById('prospectsResultsModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
    }

    function renderProspectsResults() {
      const { businesses, selectedIds } = prospectsResultsState;
      const container = document.getElementById('prospectsResultsContainer');
      const statsContainer = document.getElementById('prospectsResultsStats');

      // Calculate stats
      const newBusinesses = businesses.filter(b => !b.alreadyExists).length;
      const existingBusinesses = businesses.filter(b => b.alreadyExists).length;
      const selectedCount = selectedIds.size;

      // Render stats
      statsContainer.innerHTML = `
        <div class="bg-green-50 border border-green-200 rounded-lg p-3 text-center">
          <div class="text-2xl font-bold text-green-600">${newBusinesses}</div>
          <div class="text-xs text-green-800">New Businesses</div>
        </div>
        <div class="bg-gray-50 border border-gray-200 rounded-lg p-3 text-center">
          <div class="text-2xl font-bold text-gray-600">${existingBusinesses}</div>
          <div class="text-xs text-gray-800">Already in System</div>
        </div>
        <div class="bg-indigo-50 border border-indigo-200 rounded-lg p-3 text-center">
          <div class="text-2xl font-bold text-indigo-600">${selectedCount}</div>
          <div class="text-xs text-indigo-800">Selected to Add</div>
        </div>
      `;

      // Render business list
      container.innerHTML = businesses.map(business => {
        const isSelected = selectedIds.has(business.placeId);
        const isDisabled = business.alreadyExists;

        return `
          <div class="border rounded-lg p-3 ${isDisabled ? 'bg-gray-50 opacity-60' : 'bg-white hover:shadow-md'} transition">
            <div class="flex items-start gap-3">
              <input
                type="checkbox"
                ${isSelected ? 'checked' : ''}
                ${isDisabled ? 'disabled' : ''}
                onchange="toggleProspectSelection('${business.placeId}')"
                class="mt-1 w-5 h-5 text-indigo-600 rounded cursor-pointer"
              />
              <div class="flex-1 min-w-0">
                <div class="flex items-start justify-between gap-2">
                  <div class="flex-1 min-w-0">
                    <h4 class="font-semibold text-gray-900 truncate">${esc(business.name)}</h4>
                    <p class="text-sm text-gray-600 mt-0.5">${esc(business.address)}</p>
                    <div class="flex items-center gap-3 mt-1 text-xs text-gray-500">
                      ${business.rating ? `<span>‚≠ê ${business.rating} (${business.userRatingsTotal || 0} reviews)</span>` : ''}
                    </div>
                  </div>
                  ${isDisabled
                    ? '<span class="text-xs font-medium px-2 py-1 bg-gray-200 text-gray-600 rounded whitespace-nowrap">Already in System</span>'
                    : `<button onclick="markNotInterested('${business.placeId}')" class="text-xs font-medium px-2 py-1 bg-red-50 text-red-600 rounded hover:bg-red-100 whitespace-nowrap">Not Interested</button>`
                  }
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      // Update button text
      const addButton = document.getElementById('btnAddSelectedProspects');
      addButton.textContent = `Add ${selectedCount} to Pipeline`;
      addButton.disabled = selectedCount === 0;
      addButton.classList.toggle('opacity-50', selectedCount === 0);
      addButton.classList.toggle('cursor-not-allowed', selectedCount === 0);
    }

    function toggleProspectSelection(placeId) {
      if (prospectsResultsState.selectedIds.has(placeId)) {
        prospectsResultsState.selectedIds.delete(placeId);
      } else {
        prospectsResultsState.selectedIds.add(placeId);
      }
      renderProspectsResults();
    }

    function markNotInterested(placeId) {
      // Find the business
      const business = prospectsResultsState.businesses.find(b => b.placeId === placeId);
      if (!business) return;

      // Confirmation dialog
      if (!confirm(`Mark "${business.name}" as "Not Interested"?\n\nThis business will be permanently hidden from all future searches.\n\nYou can undo this later from the Not Interested list.`)) {
        return;
      }

      // Add to not interested list
      notInterestedState.placeIds.add(placeId);
      notInterestedState.businesses[placeId] = {
        name: business.name,
        address: business.address,
        addedDate: new Date().toISOString()
      };
      saveNotInterestedList();

      // Remove from results
      prospectsResultsState.businesses = prospectsResultsState.businesses.filter(b => b.placeId !== placeId);
      prospectsResultsState.selectedIds.delete(placeId);

      toast(`"${business.name}" marked as not interested and will be hidden from future searches`, true);
      renderProspectsResults();
    }

    async function addSelectedProspects() {
      const { businesses, selectedIds } = prospectsResultsState;

      if (selectedIds.size === 0) {
        toast('No businesses selected', false);
        return;
      }

      // Disable button while fetching details
      const btn = document.getElementById('btnAddSelectedProspects');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = '‚è≥ Fetching details...';

      const prospectingColumn = 'prospect-list';
      let addedCount = 0;
      const selectedBusinesses = businesses.filter(b => selectedIds.has(b.placeId) && !b.alreadyExists);

      try {
        // Fetch details for all selected businesses
        for (let i = 0; i < selectedBusinesses.length; i++) {
          const business = selectedBusinesses[i];

          btn.textContent = `‚è≥ Fetching details... (${i + 1}/${selectedBusinesses.length})`;

          // Fetch basic details from Google Places API
          let details = { phone: '', website: '', email: '', facebook: '', instagram: '', source: 'google-places' };

          if (business.placeId) {
            details = await fetchPlaceDetails(business.placeId);
          }

          const newLead = {
            id: Date.now() + Math.random(),
            businessName: business.name,
            contactName: '',
            phone: details.phone || '',
            email: details.email || '',
            estimatedValue: 500,
            notes: `Found via Google Places\nAddress: ${business.address}\nRating: ${business.rating} (${business.userRatingsTotal} reviews)\n${details.phone ? `Phone: ${details.phone}\n` : ''}${details.website ? `Website: ${details.website}\n` : ''}Place ID: ${business.placeId}\n\nüí° Use CSV export/import to add Facebook/Instagram URLs`,
            source: 'google-places',
            placeId: business.placeId,
            website: details.website || '',
            facebook: '',
            instagram: '',
            category: business.category || 'other',
            zipCode: business.zipCode || null, // Tag with ZIP code from search
            mailerId: state.current?.Mailer_ID || null, // Tag with current postcard
            town: state.current?.Town || null, // Tag with current town
            addedDate: new Date().toISOString(),
            interactions: [] // Interaction history: [{date, type, notes, nextFollowUp}]
          };

          kanbanState.columns[prospectingColumn].push(newLead);
          addedCount++;

          // Small delay to avoid rate limiting
          if (i < selectedBusinesses.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 300));
          }
        }

        saveKanban();
        renderKanban();
        closeProspectsResultsModal();

        // Show success message
        toast(`‚úÖ Added ${addedCount} new prospect${addedCount === 1 ? '' : 's'} to pipeline! Use CSV export/import to add social media URLs.`, true);

        // Scroll to kanban section
        setTimeout(() => {
          const kanbanSection = document.querySelector('[data-content="pipeline"]');
          if (kanbanSection) {
            kanbanSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 100);
      } catch(err) {
        console.error('Error adding prospects:', err);
        toast('Failed to fetch all details. Some prospects may be incomplete.', false);
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    /* ========= PROSPECT POOL FUNCTIONS ========= */

    // State for prospect pool selections and manual moves
    let prospectPoolState = {
      selectedIds: new Set(),
      manualProspects: [] // Prospects manually moved from Prospecting to Pool
    };

    // State for tracking selected prospects in Prospecting column
    let prospectingSelectionState = {
      selectedIds: new Set()
    };

    // Business Categories State
    let businessCategories = [
      { value: "restaurant", label: "Restaurant" },
      { value: "cafe", label: "Cafe" },
      { value: "bar", label: "Bar/Pub" },
      { value: "store", label: "Retail Store" },
      { value: "grocery_or_supermarket", label: "Grocery" },
      { value: "pharmacy", label: "Pharmacy" },
      { value: "gym", label: "Gym" },
      { value: "hair_care", label: "Hair Salon" },
      { value: "beauty_salon", label: "Beauty/Spa" },
      { value: "dentist", label: "Dentist" },
      { value: "doctor", label: "Doctor" },
      { value: "lawyer", label: "Law Firm" },
      { value: "real_estate_agency", label: "Real Estate" },
      { value: "car_dealer", label: "Car Dealer" },
      { value: "car_repair", label: "Auto Repair" },
      { value: "plumber", label: "Plumber" },
      { value: "electrician", label: "Electrician" },
      { value: "roofing_contractor", label: "Roofer" },
      { value: "general_contractor", label: "Contractor" },
      { value: "painter", label: "Painter" },
      { value: "florist", label: "Florist" },
      { value: "pet_store", label: "Pet Store" },
      { value: "accounting", label: "Accountant" },
      { value: "insurance_agency", label: "Insurance" },
      { value: "bank", label: "Bank" }
    ];

    // Load business categories from cloud/localStorage
    async function loadBusinessCategories() {
      try {
        const cloudData = await loadFromCloud('businessCategories');
        if (cloudData && Array.isArray(cloudData) && cloudData.length > 0) {
          businessCategories = cloudData;
        }
        // Sort alphabetically by label
        businessCategories.sort((a, b) => a.label.localeCompare(b.label));
        renderBusinessCategories();
      } catch(err) {
        console.warn('Using default business categories:', err);
        businessCategories.sort((a, b) => a.label.localeCompare(b.label));
        renderBusinessCategories();
      }
    }

    // Save business categories to cloud
    async function saveBusinessCategories() {
      try {
        // Sort alphabetically before saving
        businessCategories.sort((a, b) => a.label.localeCompare(b.label));
        await saveToCloud('businessCategories', businessCategories);
        toast('Categories saved', true);
      } catch(err) {
        console.warn('Failed to save categories:', err);
        toast('Categories saved locally only', false);
      }
    }

    // Render business categories dynamically
    function renderBusinessCategories() {
      const container = document.getElementById('categoryCheckboxContainer');
      if (!container) return;

      container.innerHTML = businessCategories.map(cat => `
        <label class="flex items-center gap-2 text-sm cursor-pointer hover:bg-white/10 p-2 rounded transition">
          <input type="checkbox" value="${cat.value}" class="category-checkbox rounded text-purple-600 focus:ring-purple-500" />
          <span>${cat.label}</span>
        </label>
      `).join('');
    }

    // Open Manage Categories Modal
    function openManageCategoriesModal() {
      const modal = document.getElementById('manageCategoriesModal');
      if (!modal) return;

      // Sort categories alphabetically before displaying
      businessCategories.sort((a, b) => a.label.localeCompare(b.label));
      renderManageCategoriesList();

      lastFocusedElementBeforeModal = document.activeElement;
      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);

      // Focus on input field
      const input = document.getElementById('newCategoryInput');
      if (input) input.focus();
    }

    // Close Manage Categories Modal
    function closeManageCategoriesModal() {
      const modal = document.getElementById('manageCategoriesModal');
      if (!modal) return;

      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
      if (lastFocusedElementBeforeModal) lastFocusedElementBeforeModal.focus();

      // Clear input field
      const input = document.getElementById('newCategoryInput');
      if (input) input.value = '';
    }

    // Render the categories list in the manage modal
    function renderManageCategoriesList() {
      const container = document.getElementById('manageCategoriesList');
      if (!container) return;

      if (businessCategories.length === 0) {
        container.innerHTML = '<p class="text-gray-500 text-sm italic">No categories yet. Add one above!</p>';
        return;
      }

      container.innerHTML = businessCategories.map((cat, index) => `
        <div class="flex items-center justify-between p-3 bg-white/10 border border-white/20 rounded-lg hover:bg-white/20 transition">
          <span class="font-medium">${cat.label}</span>
          <button
            onclick="removeCategory(${index})"
            class="px-3 py-1 text-sm bg-red-500 hover:bg-red-600 text-white rounded transition font-semibold"
            title="Remove ${cat.label}"
          >
            ‚ùå Remove
          </button>
        </div>
      `).join('');
    }

    // Add a new category
    function addNewCategory() {
      const input = document.getElementById('newCategoryInput');
      if (!input) return;

      const newLabel = input.value.trim();
      if (!newLabel) {
        toast('Please enter a category name', false);
        return;
      }

      // Check for duplicates (case-insensitive)
      const exists = businessCategories.some(cat =>
        cat.label.toLowerCase() === newLabel.toLowerCase()
      );

      if (exists) {
        toast('Category already exists', false);
        return;
      }

      // Create a value from the label (lowercase, replace spaces with hyphens)
      const newValue = newLabel.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

      // Add the new category
      businessCategories.push({
        value: newValue,
        label: newLabel
      });

      // Sort alphabetically
      businessCategories.sort((a, b) => a.label.localeCompare(b.label));

      // Re-render the list
      renderManageCategoriesList();

      // Clear input
      input.value = '';
      input.focus();

      toast(`Added "${newLabel}"`, true);
    }

    // Remove a category
    function removeCategory(index) {
      if (index < 0 || index >= businessCategories.length) return;

      const category = businessCategories[index];

      if (!confirm(`Remove "${category.label}" from categories?`)) {
        return;
      }

      businessCategories.splice(index, 1);
      renderManageCategoriesList();
      toast(`Removed "${category.label}"`, true);
    }

    // Save categories and close modal
    async function saveManageCategories() {
      await saveBusinessCategories();
      renderBusinessCategories();
      closeManageCategoriesModal();
    }

    // Deduplicate manual prospects pool
    function deduplicateManualProspects() {
      const seenPlaceIds = new Set();
      const seenBusinessNames = new Map();
      const deduped = [];
      let totalRemoved = 0;

      prospectPoolState.manualProspects.forEach(prospect => {
        if (typeof prospect !== 'object') {
          deduped.push(prospect);
          return;
        }

        // Skip if we've seen this placeId
        if (prospect.placeId) {
          if (seenPlaceIds.has(prospect.placeId)) {
            totalRemoved++;
            return; // Skip duplicate
          }
          seenPlaceIds.add(prospect.placeId);
        }
        // Fallback to businessName + mailerId
        else if (prospect.businessName && prospect.mailerId) {
          const key = `${prospect.businessName.toLowerCase()}|${prospect.mailerId}`;
          if (seenBusinessNames.has(key)) {
            totalRemoved++;
            return; // Skip duplicate
          }
          seenBusinessNames.set(key, true);
        }

        deduped.push(prospect);
      });

      prospectPoolState.manualProspects = deduped;

      if (totalRemoved > 0) {
        console.log(`üßπ Removed ${totalRemoved} duplicate prospect(s) from manual prospects pool`);
      }

      return totalRemoved;
    }

    // Load manual prospects from localStorage
    async function loadManualProspects() {
      try {
        // Try loading from cloud first
        const cloudData = await loadFromCloud('manualProspects');

        if (cloudData && Array.isArray(cloudData)) {
          prospectPoolState.manualProspects = cloudData;
        } else {
          // Fallback to localStorage
          const saved = localStorage.getItem('9x12_manual_prospects');
          if (saved) {
            prospectPoolState.manualProspects = JSON.parse(saved);
            // Sync to cloud
            saveToCloud('manualProspects', prospectPoolState.manualProspects).catch(e => console.warn('Failed to sync manual prospects to cloud:', e));
          }
        }

        // Deduplicate after loading
        const duplicatesRemoved = deduplicateManualProspects();
        if (duplicatesRemoved > 0) {
          // Save cleaned data back
          await saveToCloud('manualProspects', prospectPoolState.manualProspects).catch(e => console.warn('Failed to save deduplicated manual prospects:', e));
        }
      } catch(err) {
        console.error('Error loading manual prospects:', err);
      }
    }

    // Save manual prospects to cloud and localStorage
    async function saveManualProspects() {
      try {
        // Deduplicate before saving
        deduplicateManualProspects();

        await saveToCloud('manualProspects', prospectPoolState.manualProspects);
      } catch(err) {
        console.warn('‚ö†Ô∏è Manual prospects saved to localStorage only (cloud sync failed):', err);
      }
    }

    // Toggle selection of a prospect in Prospecting column
    function toggleProspectingSelection(leadId) {
      if (prospectingSelectionState.selectedIds.has(leadId)) {
        prospectingSelectionState.selectedIds.delete(leadId);
      } else {
        prospectingSelectionState.selectedIds.add(leadId);
      }
      updateMoveToPoolButton();
    }

    // Select all prospects in the prospect-list column
    function selectAllProspects() {
      const prospectingColumn = 'prospect-list';
      const items = kanbanState.columns[prospectingColumn] || [];

      // Clear existing selections first
      prospectingSelectionState.selectedIds.clear();

      // Add all prospect IDs to selection
      items.forEach((item, idx) => {
        if (typeof item === 'object' && item) {
          const leadId = item.id || idx;
          prospectingSelectionState.selectedIds.add(leadId);
        }
      });

      // Update UI
      updateMoveToPoolButton();
      renderKanban();

      toast(`Selected ${prospectingSelectionState.selectedIds.size} prospects`, true);
    }

    // Update visibility of "Move Selected to Pool" button
    function updateMoveToPoolButton() {
      const btn = document.getElementById('btnMoveSelectedToPool');
      if (btn) {
        if (prospectingSelectionState.selectedIds.size > 0) {
          btn.classList.remove('hidden');
          btn.textContent = `‚¨Ö Move ${prospectingSelectionState.selectedIds.size} to Pool`;
        } else {
          btn.classList.add('hidden');
        }
      }
    }

    // Move all selected prospects to Prospect Pool (bulk operation)
    function moveSelectedToPool() {
      const selectedCount = prospectingSelectionState.selectedIds.size;

      if (selectedCount === 0) {
        toast('No prospects selected', false);
        return;
      }

      // Single confirmation for all
      if (!confirm(`Move ${selectedCount} prospect${selectedCount === 1 ? '' : 's'} to Prospect Pool?`)) {
        return;
      }

      const prospectingColumn = 'prospect-list';
      const items = kanbanState.columns[prospectingColumn] || [];
      const movedProspects = [];

      // Collect all selected prospects
      prospectingSelectionState.selectedIds.forEach(leadId => {
        const leadIndex = items.findIndex(item => typeof item === 'object' && item.id === leadId);
        if (leadIndex !== -1) {
          movedProspects.push({
            lead: items[leadIndex],
            index: leadIndex
          });
        }
      });

      // Sort by index descending to safely remove from array
      movedProspects.sort((a, b) => b.index - a.index);

      // Move each prospect
      movedProspects.forEach(({ lead, index }) => {
        // Check if prospect already exists in pool (prevent duplicates)
        const existingIndex = prospectPoolState.manualProspects.findIndex(p =>
          p.id === lead.id ||
          (p.placeId && p.placeId === lead.placeId) ||
          (p.businessName && p.businessName.toLowerCase() === lead.businessName.toLowerCase() && p.mailerId === lead.mailerId)
        );

        if (existingIndex !== -1) {
          // Update existing prospect instead of creating duplicate
          prospectPoolState.manualProspects[existingIndex] = {
            ...prospectPoolState.manualProspects[existingIndex],
            ...lead,
            movedToPoolDate: new Date().toISOString(),
            mailerId: state.current?.Mailer_ID || null,
            town: state.current?.Town || null,
            isEnriched: false // Keep standard search result styling
          };
        } else {
          // Add new prospect to pool
          prospectPoolState.manualProspects.push({
            ...lead,
            movedToPoolDate: new Date().toISOString(),
            mailerId: state.current?.Mailer_ID || null, // Tag with current postcard
            town: state.current?.Town || null, // Tag with current town
            isEnriched: false // Keep standard search result styling
          });
        }

        // Remove from prospecting
        kanbanState.columns[prospectingColumn].splice(index, 1);
      });

      // Clear selections
      prospectingSelectionState.selectedIds.clear();

      saveManualProspects();
      saveKanban();
      renderKanban();

      toast(`‚úÖ Moved ${selectedCount} prospect${selectedCount === 1 ? '' : 's'} to Prospect Pool for ${state.current?.Town || 'current campaign'}`, true);
    }

    // Legacy function - kept for backwards compatibility but now uses bulk selection
    function moveProspectToPool(leadId, event) {
      if (event) {
        event.stopPropagation();
        event.preventDefault();
      }

      const prospectingColumn = 'prospect-list';
      const items = kanbanState.columns[prospectingColumn] || [];
      const leadIndex = items.findIndex(item => typeof item === 'object' && item.id === leadId);

      if (leadIndex === -1) {
        toast('Prospect not found', false);
        return;
      }

      const lead = items[leadIndex];

      // Check if prospect already exists in pool (prevent duplicates)
      const existingIndex = prospectPoolState.manualProspects.findIndex(p =>
        p.id === lead.id ||
        (p.placeId && p.placeId === lead.placeId) ||
        (p.businessName && p.businessName.toLowerCase() === lead.businessName.toLowerCase() && p.mailerId === lead.mailerId)
      );

      if (existingIndex !== -1) {
        // Update existing prospect instead of creating duplicate
        prospectPoolState.manualProspects[existingIndex] = {
          ...prospectPoolState.manualProspects[existingIndex],
          ...lead,
          movedToPoolDate: new Date().toISOString(),
          mailerId: state.current?.Mailer_ID || null,
          town: state.current?.Town || null
        };
      } else {
        // Add new prospect to pool
        prospectPoolState.manualProspects.push({
          ...lead,
          movedToPoolDate: new Date().toISOString(),
          mailerId: state.current?.Mailer_ID || null, // Tag with current postcard
          town: state.current?.Town || null // Tag with current town
        });
      }

      // Remove from prospecting
      kanbanState.columns[prospectingColumn].splice(leadIndex, 1);

      // Clear this prospect from selection if it was selected
      prospectingSelectionState.selectedIds.delete(leadId);

      saveManualProspects();
      saveKanban();
      renderKanban();

      toast(`"${lead.businessName}" moved to Prospect Pool for ${state.current?.Town || 'current campaign'}`, true);

      // Ask if user wants to view the pool
      setTimeout(() => {
        if (confirm('Go to Prospect Pool to view this prospect?')) {
          switchTab('prospects');
        }
      }, 500);
    }

    // Move prospect from Pool back to Prospecting
    function moveProspectFromPool(prospectId) {
      const prospectIndex = prospectPoolState.manualProspects.findIndex(p => p.id === prospectId);

      if (prospectIndex === -1) {
        toast('Prospect not found in pool', false);
        return;
      }

      const prospect = prospectPoolState.manualProspects[prospectIndex];

      // Check for duplicate by placeId if exists
      const prospectingColumn = 'prospect-list';
      const existingLeads = kanbanState.columns[prospectingColumn] || [];

      if (prospect.placeId) {
        const currentMailerId = state.current?.Mailer_ID;
        const duplicate = existingLeads.find(lead =>
          lead.placeId === prospect.placeId &&
          lead.mailerId === currentMailerId
        );

        if (duplicate) {
          toast(`"${prospect.businessName}" already exists in Prospecting for this card`, false);
          return;
        }
      }

      // Remove from pool
      prospectPoolState.manualProspects.splice(prospectIndex, 1);

      // Add back to prospecting with mailerId
      kanbanState.columns[prospectingColumn].push({
        ...prospect,
        mailerId: prospect.mailerId || state.current?.Mailer_ID, // Preserve or set mailerId
        movedBackDate: new Date().toISOString()
      });

      saveManualProspects();
      saveKanban();
      renderProspectPool();
      renderKanban();

      toast(`"${prospect.businessName}" moved back to Prospecting`, true);
    }

    // Expose functions globally
    window.toggleProspectingSelection = toggleProspectingSelection;
    window.moveSelectedToPool = moveSelectedToPool;
    window.moveProspectToPool = moveProspectToPool;
    window.moveProspectFromPool = moveProspectFromPool;
    window.filterProspectPoolByDate = filterProspectPoolByDate;
    window.toggleAllZips = toggleAllZips;
    window.handleZipChange = handleZipChange;

    function filterProspectPoolByDate() {
      renderProspectPool();
    }

    function toggleAllZips(checkbox) {
      const container = document.getElementById('prospectPoolZipCheckboxes');
      if (!container) return;

      if (checkbox.checked) {
        // When ALL is checked, uncheck all individual ZIPs
        const individualCheckboxes = container.querySelectorAll('input[type="checkbox"]:not([value="all"])');
        individualCheckboxes.forEach(cb => cb.checked = false);
      }
      // Re-render to apply filter
      renderProspectPool();
    }

    function handleZipChange(checkbox) {
      const container = document.getElementById('prospectPoolZipCheckboxes');
      if (!container) return;

      if (checkbox.checked) {
        // When an individual ZIP is checked, uncheck ALL
        const allCheckbox = container.querySelector('input[value="all"]');
        if (allCheckbox) allCheckbox.checked = false;
      }
      // Re-render to apply filter
      renderProspectPool();
    }

    function renderProspectPool() {
      const container = document.getElementById('prospectPoolContainer');
      const statsContainer = document.getElementById('prospectPoolStats');
      const zipCheckboxContainer = document.getElementById('prospectPoolZipCheckboxes');

      if (!container || !statsContainer) return;

      // Get selected ZIP codes from checkboxes
      const selectedZips = [];
      let allSelected = false;
      if (zipCheckboxContainer) {
        const checkboxes = zipCheckboxContainer.querySelectorAll('input[type="checkbox"]:checked');
        checkboxes.forEach(cb => {
          if (cb.value === 'all') {
            allSelected = true;
          } else {
            selectedZips.push(cb.value);
          }
        });
      }

      // ZIP filter logic:
      // - ALL selected: show all ZIPs (no filter)
      // - Specific ZIPs selected: show only those ZIPs
      // - NONE selected: show nothing (filter with empty list)
      const showAllZips = allSelected;
      const showNoZips = !allSelected && selectedZips.length === 0;
      const filterByZip = !allSelected; // Always filter unless ALL is checked

      // Get date filter selection
      const filterDays = document.getElementById('prospectPoolDateFilter')?.value || 'all';
      const now = new Date();
      const cutoffDate = filterDays === 'all' ? null : new Date(now.getTime() - (parseInt(filterDays) * 24 * 60 * 60 * 1000));

      // Get all cached searches and organize by category
      const categorizedProspects = {};
      let totalProspects = 0;
      let alreadyInSystem = 0;

      // Check what's already in the system
      const existingPlaceIds = new Set();
      Object.values(kanbanState.columns).forEach(column => {
        if (Array.isArray(column)) {
          column.forEach(lead => {
            if (lead && lead.placeId) {
              existingPlaceIds.add(lead.placeId);
            }
          });
        }
      });

      Object.values(crmState.clients).forEach(client => {
        if (client.placeId) {
          existingPlaceIds.add(client.placeId);
        }
      });

      // Collect all available ZIP codes for the filter dropdown
      const availableZips = new Set();

      // Process cached searches (with deduplication)
      const seenPlaceIds = new Set(); // Track placeIds to prevent duplicates
      let skippedByZip = 0;
      let skippedByDate = 0;
      let processedCaches = 0;

      Object.keys(placesCache.searches).forEach(cacheKey => {
        const [zipCode, category] = cacheKey.split('-');
        const cached = placesCache.searches[cacheKey];

        // console.log(`üîç DEBUG: Processing cache key: ${cacheKey}, has data: ${cached.cachedData ? cached.cachedData.length : 0}, lastFetched: ${cached.lastFetched}`);

        if (!cached.cachedData || cached.cachedData.length === 0) return;

        // Track available ZIP codes
        availableZips.add(zipCode);

        // Filter by selected ZIP codes
        if (filterByZip && !selectedZips.includes(zipCode)) {
          skippedByZip++;
          // console.log(`üîç DEBUG: Skipping ${cacheKey} - ZIP filter (${zipCode} not in selected)`);
          return; // Skip searches from unselected ZIP codes
        }

        // NOTE: Don't check cache expiration - user should always see their prospect data
        // even if it's older than 30 days. They worked hard to build this list!

        // Apply date filter - ONLY if lastFetched exists and cutoff is set
        if (cutoffDate && cached.lastFetched) {
          const fetchedDate = new Date(cached.lastFetched);
          if (fetchedDate < cutoffDate) {
            skippedByDate++;
            // console.log(`üîç DEBUG: Skipping ${cacheKey} - Date filter (fetched: ${fetchedDate.toLocaleDateString()}, cutoff: ${cutoffDate.toLocaleDateString()})`);
            return; // Skip if outside date range
          }
        }

        processedCaches++;

        if (!categorizedProspects[category]) {
          categorizedProspects[category] = [];
        }

        cached.cachedData.forEach(business => {
          // Skip if already seen (prevents duplicates across searches)
          if (seenPlaceIds.has(business.placeId)) return;

          if (!notInterestedState.placeIds.has(business.placeId)) {
            const isInSystem = existingPlaceIds.has(business.placeId);
            categorizedProspects[category].push({
              ...business,
              zipCode,
              inSystem: isInSystem
            });
            seenPlaceIds.add(business.placeId); // Mark as seen
            totalProspects++;
            if (isInSystem) alreadyInSystem++;
          }
        });
      });

      // console.log(`üîç DEBUG SUMMARY: Total cache keys: ${Object.keys(placesCache.searches).length}, Processed: ${processedCaches}, Skipped by ZIP: ${skippedByZip}, Skipped by Date: ${skippedByDate}`);
      // console.log(`üîç DEBUG SUMMARY: Total prospects found: ${totalProspects}, Categories: ${Object.keys(categorizedProspects).length}`);

      // Render stats
      const categories = Object.keys(categorizedProspects).length;
      const selectedCount = prospectPoolState.selectedIds.size;
      const available = totalProspects - alreadyInSystem;
      const manualCount = prospectPoolState.manualProspects.length;

      statsContainer.innerHTML = `
        <div class="bg-white border rounded-lg p-4 text-center">
          <div class="text-3xl font-bold text-purple-600">${manualCount}</div>
          <div class="text-xs text-gray-600 mt-1">My Prospect List</div>
        </div>
        <div class="bg-white border rounded-lg p-4 text-center">
          <div class="text-3xl font-bold text-gray-900">${categories}</div>
          <div class="text-xs text-gray-600 mt-1">Categories</div>
        </div>
        <div class="bg-white border rounded-lg p-4 text-center">
          <div class="text-3xl font-bold text-indigo-600">${totalProspects}</div>
          <div class="text-xs text-gray-600 mt-1">Total Businesses</div>
        </div>
        <div class="bg-white border rounded-lg p-4 text-center">
          <div class="text-3xl font-bold text-green-600">${available}</div>
          <div class="text-xs text-gray-600 mt-1">Available to Add</div>
        </div>
      `;

      // Populate ZIP code checkboxes
      if (zipCheckboxContainer) {
        const sortedZips = Array.from(availableZips).sort();

        // Determine what should be checked
        // Default: ALL is checked
        // If user has made selections: honor those
        const isFirstLoad = !zipCheckboxContainer.querySelector('input[type="checkbox"]');
        const shouldCheckAll = isFirstLoad || (allSelected && selectedZips.length === 0);

        zipCheckboxContainer.innerHTML = `
          <label class="inline-flex items-center gap-2 px-4 py-2 bg-white border-2 rounded-lg cursor-pointer hover:bg-blue-50 hover:border-blue-400 transition-colors font-semibold ${shouldCheckAll ? 'border-blue-500 bg-blue-50' : 'border-gray-300'}">
            <input type="checkbox" value="all" ${shouldCheckAll ? 'checked' : ''} onchange="toggleAllZips(this)" class="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500">
            <span class="text-sm font-bold text-gray-900">ALL</span>
          </label>
        ` + sortedZips.map(zip => `
          <label class="inline-flex items-center gap-2 px-3 py-2 bg-white border-2 rounded-lg cursor-pointer hover:bg-indigo-50 hover:border-indigo-300 transition-colors ${selectedZips.includes(zip) ? 'border-indigo-500 bg-indigo-50' : 'border-gray-300'}">
            <input type="checkbox" value="${zip}" ${selectedZips.includes(zip) ? 'checked' : ''} onchange="handleZipChange(this)" class="w-4 h-4 text-indigo-600 rounded focus:ring-2 focus:ring-indigo-500">
            <span class="text-sm font-medium text-gray-700">${zip}</span>
          </label>
        `).join('');
      }

      // ========= UNIFIED POOL: Merge manual prospects + search results by category =========

      // Check if we have any prospects at all
      if (Object.keys(categorizedProspects).length === 0 && prospectPoolState.manualProspects.length === 0) {
        container.innerHTML = `
          <div class="text-center py-16 bg-gray-50 rounded-lg border-2 border-dashed border-gray-300">
            <div class="text-6xl mb-4">üîç</div>
            <h3 class="text-xl font-bold text-gray-700 mb-2">No prospects in your pool yet</h3>
            <p class="text-gray-600 mb-6">Run a search from Lead Generation to populate your prospect pool</p>
            <button onclick="switchTab('lead-generation')" class="px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 font-semibold">
              Go to Lead Generation
            </button>
          </div>
        `;
        return;
      }

      // Merge both manual prospects and search results into unified categories
      const unifiedByCategory = {};

      // 1. Add manual prospects (enriched) to unified pool - filter by ZIP and date
      prospectPoolState.manualProspects
        .filter(prospect => {
          // Filter by selected ZIP codes
          if (filterByZip && prospect.zipCode && !selectedZips.includes(prospect.zipCode)) {
            return false; // Skip if ZIP doesn't match filter
          }
          // Track available ZIP code
          if (prospect.zipCode) availableZips.add(prospect.zipCode);
          return true;
        })
        .filter(prospect => {
          // Apply date filter
          if (!cutoffDate) return true; // Show all if no date filter
          if (!prospect.movedToPoolDate) return true; // Show if no date (legacy)
          const movedDate = new Date(prospect.movedToPoolDate);
          return movedDate >= cutoffDate;
        })
        .forEach(prospect => {
          const category = prospect.category || 'other';
          if (!unifiedByCategory[category]) {
            unifiedByCategory[category] = [];
          }
          unifiedByCategory[category].push({
            ...prospect,
            isEnriched: true, // From manual list = has contact info
            type: 'manual'
          });
        });

      // 2. Add search results (raw) to unified pool
      Object.keys(categorizedProspects).forEach(category => {
        if (!unifiedByCategory[category]) {
          unifiedByCategory[category] = [];
        }
        categorizedProspects[category].forEach(prospect => {
          unifiedByCategory[category].push({
            ...prospect,
            isEnriched: false, // From search = no contact info yet
            type: 'search'
          });
        });
      });

      // Render unified pool header
      container.innerHTML = `
        <div class="bg-indigo-50 border-2 border-indigo-200 rounded-lg p-4 mb-6 flex justify-between items-center">
          <div>
            <h3 class="text-lg font-bold text-indigo-900">üéØ Prospect Pool</h3>
            <p class="text-sm text-indigo-700 mt-1">All prospects organized by category - click to add to your pipeline</p>
          </div>
          <button onclick="clearAllProspects()" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-semibold text-sm">
            Clear All
          </button>
        </div>

        ${Object.keys(unifiedByCategory).sort().map(category => {
        const prospects = unifiedByCategory[category];
        const categoryName = category.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const enrichedCount = prospects.filter(p => p.isEnriched).length;
        const rawCount = prospects.filter(p => !p.isEnriched).length;

        return `
          <div class="mb-8">
            <div class="flex items-center justify-between mb-4 pb-2 border-b-2 border-gray-200">
              <div>
                <h4 class="text-lg font-bold text-gray-900">${categoryName}</h4>
                <p class="text-sm text-gray-600">${prospects.length} total ‚Ä¢ <span class="text-green-600">${enrichedCount} enriched</span> ‚Ä¢ <span class="text-blue-600">${rawCount} raw</span></p>
              </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
              ${prospects.map(prospect => {
                // For enriched prospects (from manual list) - show with green border and contact icons
                if (prospect.isEnriched) {
                  const hasContact = prospect.phone || prospect.website || prospect.email;
                  const contactIcons = [];
                  if (prospect.phone) contactIcons.push('üìû');
                  if (prospect.website) contactIcons.push('üåê');
                  if (prospect.email) contactIcons.push('‚úâÔ∏è');
                  if (prospect.facebook) contactIcons.push('üìò');
                  if (prospect.instagram) contactIcons.push('üì∑');

                  return `
                    <div class="bg-white border-2 ${hasContact ? 'border-green-400' : 'border-gray-200'} rounded-lg p-3 hover:shadow-md transition cursor-pointer" onclick="openProspectDetailModal(${JSON.stringify(prospect).replace(/"/g, '&quot;')}, 'prospect')">
                      <h5 class="font-semibold text-sm text-gray-900 mb-2">${esc(prospect.businessName)}</h5>
                      ${contactIcons.length > 0 ? `<div class="flex gap-2 text-lg mb-2">${contactIcons.join(' ')}</div>` : ''}
                      ${prospect.followUpDate ? `<div class="text-xs text-purple-600 font-medium mb-2">üìÖ ${prospect.followUpDate}</div>` : ''}
                      <button onclick="event.stopPropagation(); moveProspectFromPool(${prospect.id})" class="w-full px-3 py-1.5 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 font-semibold text-xs">
                        Add to Prospecting ‚Üí
                      </button>
                    </div>
                  `;
                }

                // For raw prospects (from search results) - show with checkbox
                const isSelected = prospectPoolState.selectedIds.has(prospect.placeId);
                const isDisabled = prospect.inSystem;

                return `
                  <div class="border rounded-lg p-3 ${isDisabled ? 'bg-gray-50 opacity-60' : 'bg-white hover:shadow-md cursor-pointer'} transition" onclick="openProspectDetailModal(${JSON.stringify(prospect).replace(/"/g, '&quot;')}, 'prospect')">
                    <div class="flex items-start gap-2">
                      <input
                        type="checkbox"
                        ${isSelected ? 'checked' : ''}
                        ${isDisabled ? 'disabled' : ''}
                        onchange="event.stopPropagation(); togglePoolProspect('${prospect.placeId}')"
                        onclick="event.stopPropagation()"
                        class="mt-1 w-4 h-4 text-indigo-600 rounded cursor-pointer flex-shrink-0"
                      />
                      <div class="flex-1 min-w-0">
                        <h5 class="font-semibold text-sm text-gray-900 truncate">${esc(prospect.name)}</h5>
                        <p class="text-xs text-gray-600 mt-0.5 truncate">${esc(prospect.address)}</p>
                        <div class="flex items-center gap-2 mt-1 text-xs text-gray-500">
                          ${prospect.rating ? `<span>‚≠ê ${prospect.rating}</span>` : ''}
                          ${isDisabled ? '<span class="text-xs px-1.5 py-0.5 bg-gray-200 text-gray-600 rounded">In System</span>' : ''}
                        </div>
                      </div>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;
      }).join('')}
      `;

      // ZIP code filter is now handled by checkboxes above
      // No need to populate a dropdown anymore

      // Update selected count
      updatePoolSelectedCount();
    }

    function togglePoolProspect(placeId) {
      if (prospectPoolState.selectedIds.has(placeId)) {
        prospectPoolState.selectedIds.delete(placeId);
      } else {
        prospectPoolState.selectedIds.add(placeId);
      }
      updatePoolSelectedCount();
      // Just update the checkbox state, don't re-render everything
    }

    function areCategoryProspectsSelected(category) {
      const cached = placesCache.searches;
      let allSelected = true;
      let hasAny = false;

      Object.keys(cached).forEach(cacheKey => {
        if (!cacheKey.endsWith(`-${category}`)) return;

        cached[cacheKey].cachedData?.forEach(business => {
          if (notInterestedState.placeIds.has(business.placeId)) return;

          // Check if in system
          const existingPlaceIds = new Set();
          Object.values(kanbanState.columns).forEach(column => {
            column.forEach(lead => {
              if (lead && lead.placeId) existingPlaceIds.add(lead.placeId);
            });
          });

          if (existingPlaceIds.has(business.placeId)) return;

          hasAny = true;
          if (!prospectPoolState.selectedIds.has(business.placeId)) {
            allSelected = false;
          }
        });
      });

      return hasAny && allSelected;
    }

    function selectCategoryProspects(category, select) {
      const cached = placesCache.searches;

      // Get existing place IDs
      const existingPlaceIds = new Set();
      Object.values(kanbanState.columns).forEach(column => {
        column.forEach(lead => {
          if (lead && lead.placeId) existingPlaceIds.add(lead.placeId);
        });
      });

      Object.keys(cached).forEach(cacheKey => {
        if (!cacheKey.endsWith(`-${category}`)) return;

        cached[cacheKey].cachedData?.forEach(business => {
          if (notInterestedState.placeIds.has(business.placeId)) return;
          if (existingPlaceIds.has(business.placeId)) return;

          if (select) {
            prospectPoolState.selectedIds.add(business.placeId);
          } else {
            prospectPoolState.selectedIds.delete(business.placeId);
          }
        });
      });

      renderProspectPool();
    }

    function updatePoolSelectedCount() {
      const countEl = document.getElementById('prospectPoolSelectedCount');
      const btnEl = document.getElementById('btnAddFromPool');

      if (countEl) {
        countEl.textContent = prospectPoolState.selectedIds.size;
      }

      if (btnEl) {
        btnEl.disabled = prospectPoolState.selectedIds.size === 0;
      }
    }

    async function addFromProspectPool() {
      if (prospectPoolState.selectedIds.size === 0) {
        toast('No prospects selected', false);
        return;
      }

      // Get current mailer ID
      const currentMailerId = state.current?.Mailer_ID;
      if (!currentMailerId) {
        toast('Please select a postcard first', false);
        return;
      }

      const btn = document.getElementById('btnAddFromPool');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = '‚è≥ Adding...';

      try {
        // Collect all selected businesses
        const selectedBusinesses = [];
        Object.values(placesCache.searches).forEach(cached => {
          cached.cachedData?.forEach(business => {
            if (prospectPoolState.selectedIds.has(business.placeId)) {
              selectedBusinesses.push(business);
            }
          });
        });

        // Fetch details and add to kanban
        const prospectingColumn = 'prospect-list';
        const existingLeads = kanbanState.columns[prospectingColumn] || [];

        // Get existing placeIds for current mailer to prevent duplicates
        const existingPlaceIds = new Set(
          existingLeads
            .filter(lead => lead.mailerId === currentMailerId && lead.placeId)
            .map(lead => lead.placeId)
        );

        let addedCount = 0;
        let skippedCount = 0;

        for (let i = 0; i < selectedBusinesses.length; i++) {
          const business = selectedBusinesses[i];

          // Skip if already exists for this mailer
          if (existingPlaceIds.has(business.placeId)) {
            skippedCount++;
            continue;
          }

          btn.textContent = `‚è≥ Fetching contact details... (${i + 1}/${selectedBusinesses.length})`;

          // Fetch basic details from Google Places API
          let details = { phone: '', website: '', email: '', facebook: '', instagram: '', source: 'google-places' };

          if (business.placeId) {
            details = await fetchPlaceDetails(business.placeId);
          }

          const newLead = {
            id: Date.now() + Math.random(),
            businessName: business.name,
            contactName: '',
            phone: details.phone || '',
            email: details.email || '',
            estimatedValue: 500,
            notes: `Found via Google Places\nAddress: ${business.address}\nRating: ${business.rating} (${business.userRatingsTotal} reviews)\n${details.phone ? `Phone: ${details.phone}\n` : ''}${details.website ? `Website: ${details.website}\n` : ''}Place ID: ${business.placeId}\n\nüí° Use CSV export/import to add Facebook/Instagram URLs`,
            source: 'google-places',
            placeId: business.placeId,
            website: details.website || '',
            facebook: '',
            instagram: '',
            category: business.category || 'other',
            zipCode: business.zipCode || null, // Tag with ZIP code from search
            mailerId: currentMailerId, // Link to current card
            town: state.current?.Town, // Tag with town for organization
            addedDate: new Date().toISOString(),
            interactions: [] // Interaction history: [{date, type, notes, nextFollowUp}]
          };

          kanbanState.columns[prospectingColumn].push(newLead);
          addedCount++;

          // Small delay to avoid rate limiting
          if (i < selectedBusinesses.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 300));
          }
        }

        saveKanban();
        renderKanban();

        // Clear selections and re-render pool
        prospectPoolState.selectedIds.clear();
        renderProspectPool();

        // Show success message
        let message = `‚úÖ Added ${addedCount} prospect${addedCount === 1 ? '' : 's'} to Pipeline!`;
        if (skippedCount > 0) {
          message += ` ${skippedCount} duplicate${skippedCount === 1 ? '' : 's'} skipped.`;
        }
        message += ` Use CSV export/import to add social media URLs.`;
        toast(message, true);

        // Switch to pipeline tab
        switchTab('pipeline');
      } catch(err) {
        console.error('Error adding from pool:', err);
        toast('Failed to add prospects. Please try again.', false);
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    function clearProspectPool() {
      if (!confirm('Are you sure you want to clear the entire prospect pool? This will remove all cached searches.')) {
        return;
      }

      placesCache.searches = {};
      savePlacesCache();
      prospectPoolState.selectedIds.clear();
      renderProspectPool();
      toast('Prospect pool cleared', true);
    }

    // Clear prospects for CURRENT CARD only
    function clearAllProspects() {
      const currentMailerId = state.current?.Mailer_ID;
      if (!currentMailerId) {
        toast('Please select a postcard first', false);
        return;
      }

      const cardName = `${state.current.Town} ‚Äî ${state.current.Mail_Date}`;

      if (!confirm(`‚ö†Ô∏è This will clear all prospects for:\n"${cardName}"\n\n‚Ä¢ All search results in the prospect pool\n‚Ä¢ All prospects in the pipeline (all stages)\n\nAre you sure?`)) {
        return;
      }

      // Clear ALL cached search results (entire prospect pool)
      placesCache.searches = {};
      savePlacesCache();

      // Clear manual prospects for this card only
      prospectPoolState.manualProspects = prospectPoolState.manualProspects.filter(
        p => p.mailerId && p.mailerId !== currentMailerId
      );

      // Clear prospecting column for this card only
      const prospectingColumn = 'prospect-list';
      kanbanState.columns[prospectingColumn] = (kanbanState.columns[prospectingColumn] || []).filter(
        lead => !lead.mailerId || lead.mailerId !== currentMailerId
      );

      // Clear all other kanban columns for this card
      ['to-contact', 'in-progress', 'committed'].forEach(column => {
        kanbanState.columns[column] = (kanbanState.columns[column] || []).filter(
          lead => !lead.mailerId || lead.mailerId !== currentMailerId
        );
      });

      prospectPoolState.selectedIds.clear();

      saveManualProspects();
      saveKanban();

      renderProspectPool();
      renderKanban();

      toast(`‚úÖ All prospects cleared for ${cardName}!`, true);
    }

    // Expose globally
    window.clearAllProspects = clearAllProspects;

    /* ========= PROSPECT POOL CSV EXPORT/IMPORT ========= */

    function exportProspectListCSV() {
      // Export ONLY prospects from the "Prospect List" kanban column
      const prospectList = kanbanState.columns['prospect-list'] || [];

      if (prospectList.length === 0) {
        toast('‚ö†Ô∏è No prospects in Prospect List to export', false);
        return;
      }

      const allProspects = prospectList
        .filter(item => item && typeof item === 'object')
        .map(item => ({
          businessName: item.businessName || item.name || '',
          phone: item.phone || '',
          website: item.website || '',
          email: item.email || '',
          facebook: item.facebook || '',
          instagram: item.instagram || '',
          category: item.category || '',
          zipCode: item.zipCode || '',
          address: item.address || '',
          rating: item.rating || '',
          reviewsCount: item.reviewsCount || item.userRatingsTotal || '',
          placeId: item.placeId || '',
          notes: item.notes || '',
          dateAdded: item.dateAdded || new Date().toISOString().split('T')[0]
        }));

      // Create CSV
      const headers = [
        'Business Name',
        'Phone',
        'Website',
        'Email',
        'Facebook',
        'Instagram',
        'Category',
        'ZIP Code',
        'Address',
        'Rating',
        'Review Count',
        'Place ID',
        'Notes',
        'Date Added'
      ];

      const csvContent = [
        headers.join(','),
        ...allProspects.map(p => [
          `"${(p.businessName || '').replace(/"/g, '""')}"`,
          `"${(p.phone || '').replace(/"/g, '""')}"`,
          `"${(p.website || '').replace(/"/g, '""')}"`,
          `"${(p.email || '').replace(/"/g, '""')}"`,
          `"${(p.facebook || '').replace(/"/g, '""')}"`,
          `"${(p.instagram || '').replace(/"/g, '""')}"`,
          `"${(p.category || '').replace(/"/g, '""')}"`,
          `"${(p.zipCode || '').replace(/"/g, '""')}"`,
          `"${(p.address || '').replace(/"/g, '""')}"`,
          `"${(p.rating || '').toString().replace(/"/g, '""')}"`,
          `"${(p.reviewsCount || '').toString().replace(/"/g, '""')}"`,
          `"${(p.placeId || '').replace(/"/g, '""')}"`,
          `"${(p.notes || '').replace(/"/g, '""')}"`,
          `"${(p.dateAdded || '').replace(/"/g, '""')}"`
        ].join(','))
      ].join('\n');

      // Trigger download
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `prospect-list-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      toast(`‚úÖ Exported ${allProspects.length} prospects from Prospect List`, true);
    }

    function exportProspectPoolCSV() {
      // Collect all prospects from searches cache
      const allProspects = [];

      Object.keys(placesCache.searches).forEach(cacheKey => {
        const cached = placesCache.searches[cacheKey];
        if (cached.cachedData && cached.cachedData.length > 0) {
          cached.cachedData.forEach(business => {
            // Skip if already in system
            if (notInterestedState.placeIds.has(business.placeId)) return;

            allProspects.push({
              businessName: business.name || '',
              phone: business.phone || '',
              website: business.website || '',
              email: business.email || '',
              facebook: business.facebook || '',
              instagram: business.instagram || '',
              category: business.category || '',
              zipCode: business.zipCode || '',
              address: business.address || '',
              rating: business.rating || '',
              reviewsCount: business.reviewsCount || '',
              placeId: business.placeId || '',
              notes: business.notes || '',
              dateAdded: business.dateAdded || new Date().toISOString().split('T')[0]
            });
          });
        }
      });

      if (allProspects.length === 0) {
        toast('‚ö†Ô∏è No prospects to export', false);
        return;
      }

      // Create CSV
      const headers = [
        'Business Name',
        'Phone',
        'Website',
        'Email',
        'Facebook',
        'Instagram',
        'Category',
        'ZIP Code',
        'Address',
        'Rating',
        'Review Count',
        'Place ID',
        'Notes',
        'Date Added'
      ];

      const rows = allProspects.map(p => [
        p.businessName,
        p.phone,
        p.website,
        p.email,
        p.facebook,
        p.instagram,
        p.category,
        p.zipCode,
        p.address,
        p.rating,
        p.reviewsCount,
        p.placeId,
        p.notes,
        p.dateAdded
      ]);

      let csv = headers.join(',') + '\n';
      rows.forEach(row => {
        csv += row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',') + '\n';
      });

      // Download
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `prospect-pool-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      toast(`‚úÖ Exported ${allProspects.length} prospects to CSV`, true);
    }

    function importProspectPoolCSV(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const csv = e.target.result;
          const lines = csv.split('\n').filter(line => line.trim());

          if (lines.length < 2) {
            toast('‚ö†Ô∏è CSV file is empty or invalid', false);
            return;
          }

          // Parse CSV (simple parser for quoted fields)
          const parseCsvLine = (line) => {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"') {
                if (inQuotes && line[i + 1] === '"') {
                  current += '"';
                  i++;
                } else {
                  inQuotes = !inQuotes;
                }
              } else if (char === ',' && !inQuotes) {
                result.push(current);
                current = '';
              } else {
                current += char;
              }
            }
            result.push(current);
            return result;
          };

          const headers = parseCsvLine(lines[0]);

          // Find column indices
          const colMap = {
            businessName: headers.findIndex(h => h.toLowerCase().includes('business')),
            phone: headers.findIndex(h => h.toLowerCase().includes('phone')),
            website: headers.findIndex(h => h.toLowerCase().includes('website')),
            email: headers.findIndex(h => h.toLowerCase().includes('email')),
            facebook: headers.findIndex(h => h.toLowerCase().includes('facebook')),
            instagram: headers.findIndex(h => h.toLowerCase().includes('instagram')),
            category: headers.findIndex(h => h.toLowerCase().includes('category')),
            zipCode: headers.findIndex(h => h.toLowerCase().includes('zip')),
            address: headers.findIndex(h => h.toLowerCase().includes('address')),
            rating: headers.findIndex(h => h.toLowerCase().includes('rating')),
            reviewsCount: headers.findIndex(h => h.toLowerCase().includes('review')),
            placeId: headers.findIndex(h => h.toLowerCase().includes('place')),
            notes: headers.findIndex(h => h.toLowerCase().includes('notes')),
            dateAdded: headers.findIndex(h => h.toLowerCase().includes('date'))
          };

          let updated = 0;
          let added = 0;

          // Process each row
          for (let i = 1; i < lines.length; i++) {
            const fields = parseCsvLine(lines[i]);
            if (fields.length < 2) continue; // Skip empty/invalid rows

            const businessName = fields[colMap.businessName] || '';
            if (!businessName.trim()) continue;

            const prospectData = {
              name: businessName,
              businessName: businessName,
              phone: fields[colMap.phone] || '',
              website: fields[colMap.website] || '',
              email: fields[colMap.email] || '',
              facebook: fields[colMap.facebook] || '',
              instagram: fields[colMap.instagram] || '',
              category: fields[colMap.category] || 'other',
              zipCode: fields[colMap.zipCode] || '',
              address: fields[colMap.address] || '',
              rating: parseFloat(fields[colMap.rating]) || 0,
              reviewsCount: parseInt(fields[colMap.reviewsCount]) || 0,
              placeId: fields[colMap.placeId] || `MANUAL-${Date.now()}-${Math.random()}`,
              notes: fields[colMap.notes] || '',
              dateAdded: fields[colMap.dateAdded] || new Date().toISOString().split('T')[0]
            };

            // Try to find existing prospect by Place ID or business name
            let found = false;

            // FIRST: Check kanban columns (Prospect List, To Contact, In Progress, Committed)
            Object.keys(kanbanState.columns).forEach(columnKey => {
              const column = kanbanState.columns[columnKey];
              if (!Array.isArray(column)) return;

              const existingIndex = column.findIndex(item =>
                item && typeof item === 'object' && (
                  item.placeId === prospectData.placeId ||
                  item.id === prospectData.placeId ||
                  (item.businessName && item.businessName.toLowerCase() === businessName.toLowerCase())
                )
              );

              if (existingIndex !== -1) {
                // Update existing prospect in kanban with enriched data
                kanbanState.columns[columnKey][existingIndex] = {
                  ...kanbanState.columns[columnKey][existingIndex],
                  ...prospectData,
                  id: kanbanState.columns[columnKey][existingIndex].id || prospectData.placeId
                };
                found = true;
                updated++;
              }
            });

            // SECOND: Check places cache
            if (!found) {
              Object.keys(placesCache.searches).forEach(cacheKey => {
                const cached = placesCache.searches[cacheKey];
                if (cached.cachedData) {
                  const existingIndex = cached.cachedData.findIndex(p =>
                    p.placeId === prospectData.placeId ||
                    (p.name && p.name.toLowerCase() === businessName.toLowerCase())
                  );

                  if (existingIndex !== -1) {
                    // Update existing prospect with enriched data
                    cached.cachedData[existingIndex] = {
                      ...cached.cachedData[existingIndex],
                      ...prospectData,
                      interactions: cached.cachedData[existingIndex].interactions || []
                    };
                    found = true;
                    updated++;
                  }
                }
              });
            }

            // If not found, add to appropriate category in cache
            if (!found) {
              const category = prospectData.category || 'other';
              const cacheKey = `${prospectData.zipCode || 'UNKNOWN'}-${category}`;

              if (!placesCache.searches[cacheKey]) {
                placesCache.searches[cacheKey] = {
                  cachedData: [],
                  cachedAt: Date.now(),
                  zipCode: prospectData.zipCode,
                  category: category
                };
              }

              placesCache.searches[cacheKey].cachedData.push({
                ...prospectData,
                interactions: []
              });
              added++;
            }
          }

          // Save to localStorage
          localStorage.setItem('mailslot-places-cache', JSON.stringify(placesCache));

          // Save kanban changes to cloud
          saveKanban();

          // Re-render both prospect pool and kanban
          renderProspectPool();
          renderKanban();

          toast(`‚úÖ CSV Import Complete: ${updated} updated, ${added} added`, true);

          // Reset file input
          event.target.value = '';

        } catch (error) {
          console.error('CSV import error:', error);
          toast('‚ö†Ô∏è Failed to import CSV. Check format and try again.', false);
        }
      };

      reader.readAsText(file);
    }

    // Expose globally
    window.exportProspectListCSV = exportProspectListCSV;
    window.exportProspectPoolCSV = exportProspectPoolCSV;
    window.importProspectPoolCSV = importProspectPoolCSV;

    /* ========= PROSPECT DETAIL MODAL FUNCTIONS ========= */

    // Global variable to track current prospect being viewed
    let currentProspectDetail = null;

    function openProspectDetailModal(prospectData, source = 'prospect') {
      const modal = document.getElementById('prospectDetailModal');
      if (!modal) return;

      // Normalize business name field (raw prospects have 'name', enriched have 'businessName')
      const businessName = prospectData.businessName || prospectData.name || 'Unknown Business';

      // Store current prospect data with normalized businessName
      currentProspectDetail = { ...prospectData, businessName, source };

      // Set title and subtitle
      document.getElementById('prospectDetailTitle').textContent = businessName;
      document.getElementById('prospectDetailSubtitle').textContent = source === 'client' ? 'Client' : 'Prospect';

      // Populate business info
      document.getElementById('detailBusinessName').textContent = businessName;
      document.getElementById('detailCategory').textContent = prospectData.category || '‚Äî';
      document.getElementById('detailZipCode').textContent = prospectData.zipCode || prospectData.town || '‚Äî';

      if (prospectData.rating) {
        document.getElementById('detailRating').textContent = `‚≠ê ${prospectData.rating} (${prospectData.reviewsCount || 0} reviews)`;
      } else {
        document.getElementById('detailRating').textContent = '‚Äî';
      }

      // Populate contact info and enable/disable quick action buttons
      const phone = prospectData.phone || '';
      const email = prospectData.email || '';
      const website = prospectData.website || '';
      const facebook = prospectData.facebook || '';
      const instagram = prospectData.instagram || '';

      document.getElementById('detailPhone').textContent = phone || '‚Äî';
      document.getElementById('btnCallAction').disabled = !phone;

      document.getElementById('detailEmail').textContent = email || '‚Äî';
      document.getElementById('btnEmailAction').disabled = !email;

      document.getElementById('detailWebsite').textContent = website || '‚Äî';
      document.getElementById('btnWebsiteAction').disabled = !website;

      document.getElementById('detailFacebook').textContent = facebook || '‚Äî';
      document.getElementById('btnFacebookAction').disabled = !facebook;

      document.getElementById('detailInstagram').textContent = instagram || '‚Äî';
      document.getElementById('btnInstagramAction').disabled = !instagram;

      // Render interaction timeline
      renderInteractionTimeline(prospectData.interactions || []);

      // Set default date for new interaction
      document.getElementById('newInteractionDate').valueAsDate = new Date();

      // Clear form
      document.getElementById('newInteractionNotes').value = '';
      document.getElementById('newInteractionFollowUp').value = '';
      document.getElementById('templatePreview').classList.add('hidden');

      // Show modal
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
    }

    function closeProspectDetailModal() {
      const modal = document.getElementById('prospectDetailModal');
      if (!modal) return;

      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      currentProspectDetail = null;
    }

    function renderInteractionTimeline(interactions) {
      const timeline = document.getElementById('interactionTimeline');
      if (!timeline) return;

      if (!interactions || interactions.length === 0) {
        timeline.innerHTML = '<div class="text-sm text-gray-400 italic text-center py-4">No interactions yet</div>';
        return;
      }

      // Sort interactions by date (newest first)
      const sorted = [...interactions].sort((a, b) => new Date(b.date) - new Date(a.date));

      timeline.innerHTML = sorted.map(interaction => {
        const date = new Date(interaction.date).toLocaleDateString('en-US', {
          month: 'short', day: 'numeric', year: 'numeric'
        });

        const typeIcons = {
          call: 'üìû',
          email: '‚úâÔ∏è',
          messenger: 'üìò',
          instagram: 'üì∑',
          'in-person': 'ü§ù',
          other: 'üìù'
        };

        const icon = typeIcons[interaction.type] || 'üìù';
        const typeLabel = interaction.type.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());

        let html = `
          <div class="border-l-4 border-blue-400 pl-3 py-2">
            <div class="flex justify-between items-start mb-1">
              <div class="font-medium text-sm">${icon} ${esc(typeLabel)}</div>
              <div class="text-xs text-gray-500">${date}</div>
            </div>
            <div class="text-sm text-gray-700">${esc(interaction.notes || 'No notes')}</div>
        `;

        if (interaction.nextFollowUp) {
          const followUpDate = new Date(interaction.nextFollowUp).toLocaleDateString('en-US', {
            month: 'short', day: 'numeric', year: 'numeric'
          });
          html += `<div class="text-xs text-purple-600 mt-1">üìÖ Follow-up: ${followUpDate}</div>`;
        }

        html += `</div>`;
        return html;
      }).join('');
    }

    function quickAction(type) {
      if (!currentProspectDetail) return;

      const prospect = currentProspectDetail;

      switch (type) {
        case 'call':
          if (prospect.phone) {
            window.location.href = `tel:${prospect.phone}`;
          }
          break;
        case 'email':
          if (prospect.email) {
            const subject = encodeURIComponent(`Re: ${prospect.businessName}`);
            window.location.href = `mailto:${prospect.email}?subject=${subject}`;
          }
          break;
        case 'website':
          if (prospect.website) {
            window.open(ensureHttps(prospect.website), '_blank');
          }
          break;
        case 'facebook':
          if (prospect.facebook) {
            window.open(ensureHttps(prospect.facebook), '_blank');
          }
          break;
        case 'instagram':
          if (prospect.instagram) {
            window.open(ensureHttps(prospect.instagram), '_blank');
          }
          break;
      }
    }

    function addNewInteraction() {
      if (!currentProspectDetail) return;

      const type = document.getElementById('newInteractionType').value;
      const date = document.getElementById('newInteractionDate').value;
      const notes = document.getElementById('newInteractionNotes').value.trim();
      const followUp = document.getElementById('newInteractionFollowUp').value;

      if (!date) {
        toast('‚ö†Ô∏è Please select a date', false);
        return;
      }

      if (!notes) {
        toast('‚ö†Ô∏è Please enter notes about the interaction', false);
        return;
      }

      const newInteraction = {
        type,
        date,
        notes,
        nextFollowUp: followUp || null
      };

      // Find the prospect in the appropriate data source and update it
      const prospectId = currentProspectDetail.id;
      const source = currentProspectDetail.source;

      if (source === 'prospect') {
        // Update in prospect pool (searches cache)
        Object.keys(placesCache.searches).forEach(cacheKey => {
          const cached = placesCache.searches[cacheKey];
          if (cached.cachedData) {
            const prospect = cached.cachedData.find(p => p.placeId === prospectId || p.id === prospectId);
            if (prospect) {
              if (!prospect.interactions) prospect.interactions = [];
              prospect.interactions.push(newInteraction);
            }
          }
        });
        localStorage.setItem('mailslot-places-cache', JSON.stringify(placesCache));
      } else if (source === 'kanban') {
        // Update in kanban
        Object.keys(kanbanState.columns).forEach(columnKey => {
          const item = kanbanState.columns[columnKey].find(i => i.id === prospectId);
          if (item) {
            if (!item.interactions) item.interactions = [];
            item.interactions.push(newInteraction);
          }
        });
        saveKanban();
      } else if (source === 'client') {
        // Update in clients
        if (crmState.clients[prospectId]) {
          if (!crmState.clients[prospectId].interactions) crmState.clients[prospectId].interactions = [];
          crmState.clients[prospectId].interactions.push(newInteraction);
          saveClients();
        }
      }

      // Update the current prospect detail and re-render timeline
      if (!currentProspectDetail.interactions) currentProspectDetail.interactions = [];
      currentProspectDetail.interactions.push(newInteraction);
      renderInteractionTimeline(currentProspectDetail.interactions);

      // Clear form
      document.getElementById('newInteractionNotes').value = '';
      document.getElementById('newInteractionFollowUp').value = '';

      toast('‚úÖ Interaction logged!', true);
    }

    let currentTemplate = null;

    function showMessageTemplate(templateType) {
      if (!MESSAGE_TEMPLATES[templateType]) return;

      const template = MESSAGE_TEMPLATES[templateType];
      currentTemplate = template;

      // Populate template with prospect data
      let body = template.body;
      if (currentProspectDetail) {
        body = body.replace(/\[BUSINESS_NAME\]/g, currentProspectDetail.businessName || '[BUSINESS_NAME]');
        body = body.replace(/\[TOWN\]/g, currentProspectDetail.zipCode || currentProspectDetail.town || '[TOWN]');
        body = body.replace(/\[DATE\]/g, new Date().toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' }));
      }

      // Show template preview
      document.getElementById('templateTitle').textContent = template.name;
      document.getElementById('templateSubject').textContent = template.subject ? `Subject: ${template.subject}` : '';
      document.getElementById('templateBody').textContent = body;
      document.getElementById('templatePreview').classList.remove('hidden');
    }

    function copyTemplate() {
      const body = document.getElementById('templateBody').textContent;

      navigator.clipboard.writeText(body).then(() => {
        toast('‚úÖ Template copied to clipboard!', true);
      }).catch(err => {
        console.error('Failed to copy:', err);
        toast('‚ö†Ô∏è Failed to copy template', false);
      });
    }

    function markNotInterested() {
      if (!currentProspectDetail) return;

      const businessName = currentProspectDetail.businessName;
      const confirmed = confirm(`Are you sure you want to mark "${businessName}" as Not Interested?\n\nThis business will be permanently removed from your prospect pool and won't appear in future searches.`);

      if (!confirmed) return;

      const prospectId = currentProspectDetail.id;
      const placeId = currentProspectDetail.placeId;

      // Add to Not Interested list
      if (!Array.isArray(window.notInterestedList)) {
        window.notInterestedList = [];
      }

      window.notInterestedList.push({
        businessName,
        placeId: placeId || prospectId,
        dateMarked: new Date().toISOString(),
        reason: 'User marked as not interested'
      });

      localStorage.setItem('mailslot-not-interested', JSON.stringify(window.notInterestedList));

      // Remove from prospect pool (searches cache)
      let removedCount = 0;
      Object.keys(placesCache.searches).forEach(cacheKey => {
        const cached = placesCache.searches[cacheKey];
        if (cached.cachedData) {
          const beforeLength = cached.cachedData.length;
          cached.cachedData = cached.cachedData.filter(p => {
            // Keep item unless it matches the one we want to remove
            // Match by placeId
            if (placeId && p.placeId === placeId) return false;
            // Match by id
            if (prospectId && p.id === prospectId) return false;
            // Match by business name (fallback)
            if (businessName && (p.name === businessName || p.businessName === businessName)) return false;
            // Keep all others
            return true;
          });
          removedCount += (beforeLength - cached.cachedData.length);
        }
      });
      localStorage.setItem('mailslot-places-cache', JSON.stringify(placesCache));

      console.log(`Removed ${removedCount} items from prospect pool for: ${businessName}`);

      // Remove from kanban
      Object.keys(kanbanState.columns).forEach(columnKey => {
        kanbanState.columns[columnKey] = kanbanState.columns[columnKey].filter(item => {
          // Keep item unless it matches the one we want to remove
          if (placeId && item.placeId === placeId) return false;
          if (prospectId && item.id === prospectId) return false;
          if (businessName && (item.businessName === businessName || item.name === businessName)) return false;
          return true;
        });
      });
      saveKanban();

      toast(`‚úÖ "${businessName}" marked as Not Interested and removed`, true);
      closeProspectDetailModal();

      // Refresh displays
      renderProspectPool();
      renderKanban();
    }

    // Expose functions globally
    window.openProspectDetailModal = openProspectDetailModal;
    window.closeProspectDetailModal = closeProspectDetailModal;
    window.quickAction = quickAction;
    window.addNewInteraction = addNewInteraction;
    window.showMessageTemplate = showMessageTemplate;
    window.copyTemplate = copyTemplate;
    window.markNotInterested = markNotInterested;

    /* ========= KANBAN FUNCTIONS ========= */

    async function loadKanban() {
      try {
        // Try loading from cloud first
        const cloudData = await loadFromCloud('kanban');

        if (cloudData && typeof cloudData === 'object' && Object.keys(cloudData).length > 0) {
          kanbanState.columns = cloudData;
        } else {
          // Fallback to localStorage
          const saved = localStorage.getItem('mailslot-kanban');
          if (saved) {
            kanbanState.columns = JSON.parse(saved);
          }
          // Sync default/localStorage data to cloud if cloud was empty
          saveToCloud('kanban', kanbanState.columns).catch(e => console.warn('Failed to sync kanban to cloud:', e));
        }

        // MIGRATION: Move data from old column keys to new keys
        const columnMigrations = {
          'new-lead': 'prospect-list',
          'proposal-sent': 'to-contact',
          'negotiation': 'in-progress',
          'closed-won': 'committed'
        };

        let migrationNeeded = false;
        Object.keys(columnMigrations).forEach(oldKey => {
          if (kanbanState.columns[oldKey] && Array.isArray(kanbanState.columns[oldKey]) && kanbanState.columns[oldKey].length > 0) {
            const newKey = columnMigrations[oldKey];
            console.log(`üîÑ Migrating ${kanbanState.columns[oldKey].length} items from '${oldKey}' to '${newKey}'`);

            // Initialize new column if it doesn't exist
            if (!kanbanState.columns[newKey]) {
              kanbanState.columns[newKey] = [];
            }

            // Move all items from old key to new key
            kanbanState.columns[newKey].push(...kanbanState.columns[oldKey]);

            // Delete old key
            delete kanbanState.columns[oldKey];
            migrationNeeded = true;
          }
        });

        // Save if migration occurred
        if (migrationNeeded) {
          console.log('‚úÖ Column migration complete, saving to cloud...');
          await saveToCloud('kanban', kanbanState.columns).catch(e => console.warn('Failed to save migrated kanban:', e));
          localStorage.setItem('mailslot-kanban', JSON.stringify(kanbanState.columns));
        }

        // Ensure all required columns exist
        const requiredColumns = ['prospect-list', 'to-contact', 'in-progress', 'committed'];
        requiredColumns.forEach(col => {
          if (!kanbanState.columns[col]) {
            kanbanState.columns[col] = [];
          }
        });

        // Clean up any null/undefined items from all columns
        Object.keys(kanbanState.columns).forEach(key => {
          if (Array.isArray(kanbanState.columns[key])) {
            kanbanState.columns[key] = kanbanState.columns[key].filter(item => item != null);
          }
        });

        // Deduplicate data after loading (clean up any existing duplicates)
        const duplicatesRemoved = deduplicateKanbanData();
        if (duplicatesRemoved > 0) {
          // Save cleaned data back to database
          await saveToCloud('kanban', kanbanState.columns).catch(e => console.warn('Failed to save deduplicated kanban:', e));
        }

      } catch(e) {
        console.error('Error loading kanban:', e);
      }
      renderKanban();
    }

    // Remove all duplicate prospects from kanban data (not just rendering)
    function deduplicateKanbanData() {
      let totalRemoved = 0;

      Object.keys(kanbanState.columns).forEach(columnKey => {
        const items = kanbanState.columns[columnKey];
        if (!Array.isArray(items)) return;

        const seenPlaceIds = new Set();
        const seenBusinessNames = new Map(); // Map to track businessName+mailerId combos
        const deduped = [];

        items.forEach(item => {
          if (typeof item !== 'object') {
            deduped.push(item);
            return;
          }

          // Skip if we've seen this placeId (most reliable identifier)
          if (item.placeId) {
            if (seenPlaceIds.has(item.placeId)) {
              totalRemoved++;
              return; // Skip duplicate
            }
            seenPlaceIds.add(item.placeId);
          }
          // Fallback to businessName + mailerId for prospects without placeId
          else if (item.businessName && item.mailerId) {
            const key = `${item.businessName.toLowerCase()}|${item.mailerId}`;
            if (seenBusinessNames.has(key)) {
              totalRemoved++;
              return; // Skip duplicate
            }
            seenBusinessNames.set(key, true);
          }

          deduped.push(item);
        });

        kanbanState.columns[columnKey] = deduped;
      });

      if (totalRemoved > 0) {
        console.log(`üßπ Removed ${totalRemoved} duplicate prospect(s) from kanban data`);
      }

      return totalRemoved;
    }

    async function saveKanban() {
      try {
        // Deduplicate before saving
        deduplicateKanbanData();

        // Save to cloud and localStorage
        await saveToCloud('kanban', kanbanState.columns);
      } catch(e) {
        console.warn('Kanban saved to localStorage only (cloud sync failed):', e);
      }
    }

    // CLOUD PROSPECTS SYNC FUNCTIONS
    async function saveSelectedProspectsToCloud() {
      if (cloudSyncSelection.selectedIds.size === 0) {
        toast('No prospects selected', false);
        return;
      }

      try {
        const prospectsToSync = [];

        // Collect selected prospects from all columns
        Object.keys(kanbanState.columns).forEach(columnKey => {
          const items = kanbanState.columns[columnKey];

          // Safety check - ensure column is an array
          if (!Array.isArray(items)) {
            console.warn(`Column ${columnKey} is not an array:`, items);
            return;
          }

          items.forEach(item => {
            if (typeof item === 'object' && item && cloudSyncSelection.selectedIds.has(item.id)) {
              prospectsToSync.push({
                ...item,
                column: columnKey // Store which column it's in
              });
            }
          });
        });

        if (prospectsToSync.length === 0) {
          toast('Selected prospects not found', false);
          return;
        }

        // Use POST request to avoid URL length limits
        const response = await fetch(GAS_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'saveCloudProspects',
            user: ACTIVE_USER,
            prospects: prospectsToSync
          })
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();

        if (result.success) {
          toast(`‚úÖ Synced ${result.count} prospect(s) to cloud!`, true);
          cloudSyncSelection.selectedIds.clear();
          renderKanban();
        } else {
          throw new Error(result.error || 'Unknown error');
        }

      } catch (err) {
        console.error('Failed to sync prospects to cloud:', err);
        toast('Failed to sync prospects to cloud', false);
      }
    }

    async function loadCloudProspects() {
      try {
        const url = `${GAS_URL}?action=loadCloudProspects&user=${encodeURIComponent(ACTIVE_USER)}`;
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();

        if (result.success && result.prospects) {
          return result.prospects;
        }

        return [];

      } catch (err) {
        console.error('Failed to load cloud prospects:', err);
        return [];
      }
    }

    async function deleteCloudProspect(prospectId) {
      try {
        const url = `${GAS_URL}?action=deleteCloudProspect&user=${encodeURIComponent(ACTIVE_USER)}&prospectId=${encodeURIComponent(prospectId)}`;
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();
        return result.success;

      } catch (err) {
        console.error('Failed to delete cloud prospect:', err);
        return false;
      }
    }

    function toggleCloudSyncUI() {
      cloudSyncSelection.showSyncUI = !cloudSyncSelection.showSyncUI;
      if (!cloudSyncSelection.showSyncUI) {
        cloudSyncSelection.selectedIds.clear();
      }
      renderKanban();
    }

    function toggleProspectForSync(prospectId) {
      if (cloudSyncSelection.selectedIds.has(prospectId)) {
        cloudSyncSelection.selectedIds.delete(prospectId);
      } else {
        cloudSyncSelection.selectedIds.add(prospectId);
      }
      debouncedRenderKanban(); // Use debounced version for checkbox toggles
    }

    // Debounce utility to prevent excessive re-renders
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Debounced version of renderKanban for non-critical updates
    const debouncedRenderKanban = debounce(() => renderKanban(), DEBOUNCE_RENDER_DELAY);

    function renderKanban() {
      try {
        const dailyGoalContainer = document.getElementById('dailyGoalContainer');
        const kanbanColumnsContainer = document.getElementById('salesActivityKanbanColumns');

        // Safety check - if containers don't exist, bail out
        if (!dailyGoalContainer || !kanbanColumnsContainer) {
          console.warn('Kanban containers not found, skipping render');
          return;
        }

        const currentMailerId = state.current?.Mailer_ID;

      const columnDefs = [
        { key: 'prospect-list', title: '1. Prospect List', color: 'blue' },
        { key: 'to-contact', title: '2. To Contact', color: 'purple' },
        { key: 'in-progress', title: '3. In Progress', color: 'green' },
        { key: 'committed', title: '4. Committed', color: 'yellow' }
      ];

      // Cloud Sync UI at top (HIDDEN temporarily - needs more testing)
      const cloudSyncBar = cloudSyncSelection.showSyncUI
        ? `
          <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4 flex items-center justify-between">
            <div class="flex items-center gap-2">
              <span class="font-semibold text-blue-900">‚òÅÔ∏è Cloud Sync Mode</span>
              <span class="text-sm text-blue-700">${cloudSyncSelection.selectedIds.size} selected</span>
            </div>
            <div class="flex gap-2">
              <button onclick="saveSelectedProspectsToCloud()" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm font-medium" ${cloudSyncSelection.selectedIds.size === 0 ? 'disabled' : ''}>
                ‚òÅÔ∏è Sync to Cloud
              </button>
              <button onclick="toggleCloudSyncUI()" class="px-4 py-2 bg-gray-400 text-white rounded hover:bg-gray-500 text-sm">
                Cancel
              </button>
            </div>
          </div>
        `
        : ''; // Hidden for now

      const columnsHTML = columnDefs.map(col => {
        const rawItems = kanbanState.columns[col.key] || [];
        console.log(`Rendering column ${col.key}: ${rawItems.length} raw items, currentMailerId: ${currentMailerId}`);

        let items = rawItems
          .filter(item => item != null); // Filter out null/undefined

          // REMOVED mailerId filter - show all items regardless of campaign
          // This prevents the kanban from emptying when switching campaigns
          // Items are stored globally and can be used across all campaigns

        console.log(`After mailerId filter: ${items.length} items`);

        // Deduplicate by placeId (keep first occurrence)
        const seenPlaceIds = new Set();
        items = items.filter(item => {
          if (typeof item !== 'object' || !item.placeId) return true; // Keep items without placeId
          if (seenPlaceIds.has(item.placeId)) return false; // Skip duplicates
          seenPlaceIds.add(item.placeId);
          return true;
        });

        // Sort Prospecting column: items with phone/website/email first
        if (col.key === 'prospect-list') {
          items = items.sort((a, b) => {
            const aHasContact = (a.phone || a.website || a.email) ? 1 : 0;
            const bHasContact = (b.phone || b.website || b.email) ? 1 : 0;
            return bHasContact - aHasContact; // Sort descending (with contact first)
          });
        }

        // Add buttons for Prospecting column
        const buttons = col.key === 'prospect-list'
          ? `
            <div class="flex gap-1">
              <button onclick="selectAllProspects()" class="text-xs px-2 py-1 bg-indigo-600 text-white rounded hover:bg-indigo-700" title="Select All">
                ‚òëÔ∏è
              </button>
              <button onclick="exportProspectListCSV()" class="text-xs px-2 py-1 bg-green-600 text-white rounded hover:bg-green-700" title="Export Prospect List to CSV">
                üì•
              </button>
              <button id="btnMoveSelectedToPool" onclick="moveSelectedToPool()" class="text-xs px-3 py-1 bg-purple-600 text-white rounded hover:bg-purple-700 hidden" title="Move selected to pool">
                ‚¨Ö Move to Pool
              </button>
              <button onclick="openLeadModal('${col.key}')" class="text-xs px-2 py-1 bg-${col.color}-600 text-white rounded hover:bg-${col.color}-700" title="Add lead manually">
                +
              </button>
            </div>
          `
          : `
            <button onclick="openLeadModal('${col.key}')" class="text-xs px-2 py-1 bg-${col.color}-600 text-white rounded hover:bg-${col.color}-700" title="Add lead">
              +
            </button>
          `;

        return `
          <div class="kanban-column" data-column="${col.key}">
            <div class="flex justify-between items-center mb-2">
              <div class="font-semibold text-sm text-${col.color}-600">${col.title} (${items.length})</div>
              ${buttons}
            </div>
            ${items.map((item, idx) => {
              // Support both string (legacy) and object format
              // Add safety check for null/undefined items
              if (!item) return '';

              const leadName = typeof item === 'string' ? item : (item.businessName || 'Unnamed Lead');
              const leadId = typeof item === 'string' ? idx : (item.id || idx);

              // Enhanced display for Prospecting column
              if (col.key === 'prospect-list' && typeof item === 'object') {
                const hasContact = item.phone || item.website || item.email;
                const isProspectingSelected = prospectingSelectionState.selectedIds.has(leadId);
                const isCloudSyncSelected = cloudSyncSelection.selectedIds.has(leadId);

                // Build compact icon display
                const contactIcons = [];
                if (item.phone) contactIcons.push(`<a href="tel:${esc(item.phone)}" class="text-lg hover:text-blue-600" title="üìû ${esc(item.phone)}">üìû</a>`);
                if (item.website) contactIcons.push(`<a href="${esc(ensureHttps(item.website))}" target="_blank" class="text-lg hover:text-blue-600" title="üåê ${esc(item.website)}">üåê</a>`);
                if (item.email) contactIcons.push(`<a href="mailto:${esc(item.email)}" class="text-lg hover:text-blue-600" title="‚úâÔ∏è ${esc(item.email)}">‚úâÔ∏è</a>`);
                if (item.facebook) contactIcons.push(`<a href="${esc(ensureHttps(item.facebook))}" target="_blank" class="text-lg hover:text-blue-600" title="Facebook">üìò</a>`);
                if (item.instagram) contactIcons.push(`<a href="${esc(ensureHttps(item.instagram))}" target="_blank" class="text-lg hover:text-blue-600" title="Instagram">üì∑</a>`);

                return `
                  <div class="kanban-item text-xs p-2 bg-white border rounded ${hasContact ? 'border-l-4 border-l-green-500' : 'border-l-4 border-l-gray-300'} cursor-move" data-item-id="${leadId}" data-column="${col.key}" ondblclick="openProspectDetailModal(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'kanban')">
                    <div class="flex justify-between items-start gap-2 mb-2">
                      ${cloudSyncSelection.showSyncUI ? `
                        <input
                          type="checkbox"
                          ${isCloudSyncSelected ? 'checked' : ''}
                          onchange="toggleProspectForSync(${leadId})"
                          onclick="event.stopPropagation()"
                          class="mt-1 w-4 h-4 text-blue-600 rounded cursor-pointer flex-shrink-0"
                        />
                      ` : `
                        <input
                          type="checkbox"
                          ${isProspectingSelected ? 'checked' : ''}
                          onchange="toggleProspectingSelection(${leadId})"
                          onclick="event.stopPropagation()"
                          class="mt-1 w-4 h-4 text-purple-600 rounded cursor-pointer flex-shrink-0"
                        />
                      `}
                      <div class="flex-1">
                        <div class="font-medium text-xs break-words">${esc(leadName)}</div>
                        ${item.zipCode ? `<div class="text-xs text-gray-500 font-medium mt-0.5">üìç ${esc(item.zipCode)}</div>` : ''}
                      </div>
                      <div class="flex gap-1 flex-shrink-0">
                        <button onclick="event.stopPropagation(); openProspectDetailModal(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'kanban')" class="text-indigo-600 hover:text-indigo-800 text-sm cursor-pointer" title="View Details">üëÅ</button>
                        <button onclick="openContactLaterModal(${leadId}, event)" class="text-purple-600 hover:text-purple-800 text-sm cursor-pointer" title="Contact Later">üìÖ</button>
                        <button onclick="editLead('${col.key}', ${leadId}, event)" class="text-blue-600 hover:text-blue-800 text-sm cursor-pointer" title="Edit">‚úé</button>
                        <button onclick="deleteLead('${col.key}', ${leadId}, event)" class="text-red-600 hover:text-red-800 text-sm cursor-pointer" title="Delete">üóë</button>
                      </div>
                    </div>
                    ${contactIcons.length > 0 ? `
                      <div class="flex gap-2 items-center justify-center py-1">
                        ${contactIcons.join('')}
                      </div>
                    ` : '<div class="text-gray-400 italic text-center py-1">No contact info</div>'}
                  </div>
                `;
              }

              // Standard display for other columns
              const isCloudSyncSelected = cloudSyncSelection.selectedIds.has(leadId);

              return `
                <div class="kanban-item text-xs p-2 bg-white border rounded cursor-move" data-item-id="${leadId}" data-column="${col.key}" ondblclick="openProspectDetailModal(${typeof item === 'object' ? JSON.stringify(item).replace(/"/g, '&quot;') : '{}'}, 'kanban')">
                  <div class="flex justify-between items-start gap-2">
                    ${cloudSyncSelection.showSyncUI && typeof item === 'object' ? `
                      <input
                        type="checkbox"
                        ${isCloudSyncSelected ? 'checked' : ''}
                        onchange="toggleProspectForSync(${leadId})"
                        onclick="event.stopPropagation()"
                        class="mt-0.5 w-4 h-4 text-blue-600 rounded cursor-pointer flex-shrink-0"
                      />
                    ` : ''}
                    <div class="flex-1">
                      <div class="font-medium">${esc(leadName)}</div>
                      ${typeof item === 'object' && item.zipCode ? `<div class="text-xs text-gray-500 font-medium mt-0.5">üìç ${esc(item.zipCode)}</div>` : ''}
                    </div>
                    <div class="flex gap-1 flex-shrink-0">
                      ${typeof item === 'object' ? `<button onclick="event.stopPropagation(); openProspectDetailModal(${JSON.stringify(item).replace(/"/g, '&quot;')}, 'kanban')" class="text-indigo-600 hover:text-indigo-800 text-sm cursor-pointer" title="View Details">üëÅ</button>` : ''}
                      <button onclick="openContactLaterModal(${leadId}, event)" class="text-purple-600 hover:text-purple-800 text-sm cursor-pointer" title="Contact Later">üìÖ</button>
                      <button onclick="editLead('${col.key}', ${leadId}, event)" class="text-blue-600 hover:text-blue-800 text-sm cursor-pointer" title="Edit">‚úé</button>
                      <button onclick="deleteLead('${col.key}', ${leadId}, event)" class="text-red-600 hover:text-red-800 text-sm cursor-pointer" title="Delete">üóë</button>
                    </div>
                  </div>
                  ${col.key === 'to-contact' ? `
                    <div class="flex gap-2 mt-2 pt-2 border-t border-gray-200">
                      <button onclick="handleCommunicating(${leadId}, event)" class="flex-1 px-3 py-1.5 bg-green-600 text-white text-xs rounded hover:bg-green-700 font-medium">
                        üí¨ Communicating
                      </button>
                      <button onclick="handleNotInterested(${leadId}, event)" class="flex-1 px-3 py-1.5 bg-red-600 text-white text-xs rounded hover:bg-red-700 font-medium">
                        üö´ Not Interested
                      </button>
                    </div>
                  ` : ''}
                </div>
              `;
            }).join('')}
          </div>
        `;
      }).join('');

      // Daily Goal Tracker UI
      const dailyGoalHTML = `
        <div class="bg-gradient-to-r from-purple-50 to-blue-50 border-2 border-purple-300 rounded-lg p-4 mb-4">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-4">
              <div class="text-2xl">üéØ</div>
              <div>
                <div class="text-sm text-gray-600 font-medium">Daily Outreach Goal</div>
                <div class="text-2xl font-bold text-purple-700">
                  ${dailyGoalState.todayCount} <span class="text-gray-400">/</span> ${dailyGoalState.dailyGoal}
                  <span class="text-sm text-gray-500 font-normal">contacts today</span>
                </div>
              </div>
            </div>
            <div class="flex items-center gap-3">
              <div class="text-right">
                <div class="text-xs text-gray-500 mb-1">Completion</div>
                <div class="text-lg font-bold ${dailyGoalState.todayCount >= dailyGoalState.dailyGoal ? 'text-green-600' : 'text-purple-600'}">
                  ${Math.round((dailyGoalState.todayCount / dailyGoalState.dailyGoal) * 100)}%
                </div>
              </div>
              <button onclick="openDailyGoalSettings()" class="px-4 py-2 bg-purple-600 text-white text-sm rounded hover:bg-purple-700 font-medium" title="Change daily goal and reset count">
                ‚öôÔ∏è Settings
              </button>
            </div>
          </div>
          <div class="mt-3 w-full h-3 bg-gray-200 rounded-full overflow-hidden">
            <div class="h-full bg-gradient-to-r from-purple-500 to-blue-500 rounded-full transition-all duration-300" style="width: ${Math.min((dailyGoalState.todayCount / dailyGoalState.dailyGoal) * 100, 100)}%;"></div>
          </div>
          ${dailyGoalState.todayCount >= dailyGoalState.dailyGoal ? `
            <div class="mt-2 text-center text-green-700 font-semibold text-sm">
              üéâ Goal achieved! Great work today!
            </div>
          ` : ''}
        </div>
      `;

      // Wrap columns in flex container
      const columnsWrapperHTML = `
        <div style="display: flex; gap: 1rem; padding-bottom: 0.5rem; overflow-x: auto; scrollbar-width: thin; -webkit-overflow-scrolling: touch;">
          ${columnsHTML}
        </div>
      `;

      // Set daily goal in its own container (always visible)
      dailyGoalContainer.innerHTML = dailyGoalHTML;

      // Set kanban columns in collapsible container
      kanbanColumnsContainer.innerHTML = cloudSyncBar + columnsWrapperHTML;

      setupKanbanDrag();
      updateMoveToPoolButton();
      } catch (err) {
        console.error('Error rendering kanban:', err);
        toast('‚ö†Ô∏è Error displaying kanban. Please refresh.', false);
      }
    }
    
    function setupKanbanDrag() {
      // Set draggable attribute and attach listeners to each item
      const items = document.querySelectorAll('.kanban-item');

      items.forEach(item => {
        item.setAttribute('draggable', 'true');

        item.ondragstart = function(e) {
          // Prevent drag if click started on or near interactive elements
          let element = e.target;
          while (element && element !== this) {
            if (element.tagName === 'INPUT' ||
                element.tagName === 'BUTTON' ||
                element.tagName === 'A' ||
                element.tagName === 'SELECT' ||
                element.tagName === 'TEXTAREA') {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
            element = element.parentElement;
          }

          draggedItem = this;
          this.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', this.dataset.itemId);
        };

        item.ondragend = function(e) {
          this.classList.remove('dragging');
          draggedItem = null;

          // Clean up all visual indicators
          document.querySelectorAll('.kanban-item.drag-over').forEach(el => {
            el.classList.remove('drag-over');
          });
          document.querySelectorAll('.kanban-column.drag-over-column').forEach(el => {
            el.classList.remove('drag-over-column');
          });
        };

        // Add drag over for individual items to show drop position
        item.ondragover = function(e) {
          e.preventDefault();
          e.stopPropagation(); // Prevent column ondragover from interfering
          if (draggedItem && draggedItem !== this) {
            // Remove previous indicators
            document.querySelectorAll('.kanban-item.drag-over').forEach(el => {
              el.classList.remove('drag-over');
            });
            // Add indicator to this item
            this.classList.add('drag-over');
          }
        };

        item.ondragleave = function(e) {
          // Only remove if actually leaving the item
          if (!this.contains(e.relatedTarget)) {
            this.classList.remove('drag-over');
          }
        };

        // Handle drop on individual items to insert at position
        item.ondrop = async function(e) {
          e.preventDefault();
          e.stopPropagation(); // Prevent column ondrop from also firing

          // Clean up all visual indicators immediately
          document.querySelectorAll('.kanban-item.drag-over').forEach(el => {
            el.classList.remove('drag-over');
          });
          document.querySelectorAll('.kanban-column.drag-over-column').forEach(el => {
            el.classList.remove('drag-over-column');
          });

          if (!draggedItem || draggedItem === this) {
            return;
          }

          const fromColumn = draggedItem.closest('.kanban-column').dataset.column;
          const toColumn = this.closest('.kanban-column').dataset.column;
          const itemId = parseFloat(draggedItem.dataset.itemId);
          const targetItemId = parseFloat(this.dataset.itemId);

          console.log(`Dropping item ${itemId} before item ${targetItemId} in column ${toColumn}`);

          // Find and remove from old column
          const fromItems = kanbanState.columns[fromColumn] || [];
          const fromIdx = fromItems.findIndex(item => {
            if (typeof item === 'string') return false;
            return item.id === itemId;
          });

          if (fromIdx > -1) {
            const itemToMove = fromItems[fromIdx];
            fromItems.splice(fromIdx, 1);

            // Add to new column at the position BEFORE the target item
            if (!kanbanState.columns[toColumn]) {
              kanbanState.columns[toColumn] = [];
            }

            const toItems = kanbanState.columns[toColumn];
            const targetIdx = toItems.findIndex(item => {
              if (typeof item === 'string') return false;
              return item.id === targetItemId;
            });

            // Insert before target, or at end if not found
            if (targetIdx > -1) {
              toItems.splice(targetIdx, 0, itemToMove);
            } else {
              toItems.push(itemToMove);
            }

            // Track daily goal
            const businessName = typeof itemToMove === 'string' ? itemToMove : (itemToMove.businessName || 'Unnamed Lead');
            const forwardColumns = ['in-progress', 'committed'];

            if (fromColumn === 'to-contact' && forwardColumns.includes(toColumn)) {
              incrementDailyGoal(businessName);
            } else if (forwardColumns.includes(fromColumn) && toColumn === 'to-contact') {
              decrementDailyGoal(businessName);
            }

            // Save and render
            try {
              await saveKanban();
              renderKanban();
            } catch (err) {
              console.error('Error saving kanban after move:', err);
              toast('‚ö†Ô∏è Error saving changes. Refreshing...', false);
              renderKanban();
            }

            const columnTitles = {
              'prospect-list': '1. Prospect List',
              'to-contact': '2. To Contact',
              'in-progress': '3. In Progress',
              'committed': '4. Committed'
            };
            toast(`Moved to ${columnTitles[toColumn] || toColumn}`);
          }
        };
      });

      // Set up drop zones on columns
      const columns = document.querySelectorAll('.kanban-column');

      columns.forEach(col => {
        col.ondragover = function(e) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';

          // Add column highlight
          if (!this.classList.contains('drag-over-column')) {
            this.classList.add('drag-over-column');
          }
        };

        col.ondragleave = function(e) {
          // Only remove if leaving the column entirely
          if (e.target === this) {
            this.classList.remove('drag-over-column');
          }
        };

        col.ondrop = async function(e) {
          e.preventDefault();

          // Clean up all visual indicators immediately
          document.querySelectorAll('.kanban-item.drag-over').forEach(el => {
            el.classList.remove('drag-over');
          });
          document.querySelectorAll('.kanban-column.drag-over-column').forEach(el => {
            el.classList.remove('drag-over-column');
          });

          if (!draggedItem) {
            return;
          }

          const fromColumn = draggedItem.closest('.kanban-column').dataset.column;
          const toColumn = this.dataset.column;
          const itemId = parseFloat(draggedItem.dataset.itemId); // Use parseFloat to preserve decimals

          console.log(`Moving item ${itemId} from ${fromColumn} to ${toColumn}`);

          // Find and remove from old column
          const fromItems = kanbanState.columns[fromColumn] || [];
          const fromIdx = fromItems.findIndex(item => {
            if (typeof item === 'string') return false;
            return item.id === itemId;
          });

          if (fromIdx > -1) {
            const itemToMove = fromItems[fromIdx];
            console.log(`Found item to move:`, itemToMove);
            console.log(`Column ${fromColumn} had ${fromItems.length} items before removal`);
            fromItems.splice(fromIdx, 1);
            console.log(`Column ${fromColumn} now has ${fromItems.length} items after removal`);

            // Add to new column
            if (!kanbanState.columns[toColumn]) {
              kanbanState.columns[toColumn] = [];
            }

            // Check if item already exists in destination
            const alreadyExists = kanbanState.columns[toColumn].some(item => {
              if (typeof item === 'string') return false;
              return item.id === itemId;
            });

            if (!alreadyExists) {
              kanbanState.columns[toColumn].push(itemToMove);
            }

            // Track daily goal:
            // INCREMENT only when moving FORWARD from "To Contact" (to In Progress or Committed)
            // DECREMENT when moving back TO "To Contact" from forward columns
            const businessName = typeof itemToMove === 'string' ? itemToMove : (itemToMove.businessName || 'Unnamed Lead');

            // Define forward columns (after "To Contact")
            const forwardColumns = ['in-progress', 'committed'];

            if (fromColumn === 'to-contact' && forwardColumns.includes(toColumn)) {
              // Moving FORWARD from "To Contact" to "In Progress" or "Committed" - increment
              incrementDailyGoal(businessName);
            } else if (forwardColumns.includes(fromColumn) && toColumn === 'to-contact') {
              // Moving back TO "To Contact" from forward columns - decrement
              decrementDailyGoal(businessName);
            }
            // Moving from "To Contact" to "Prospect List" (backwards) - don't count

            // IMPORTANT: await saveKanban before rendering to prevent race condition
            try {
              await saveKanban();
              renderKanban();
            } catch (err) {
              console.error('Error saving kanban after move:', err);
              toast('‚ö†Ô∏è Error saving changes. Refreshing...', false);
              // Still render even if save fails
              renderKanban();
            }

            // Map column key to display title
            const columnTitles = {
              'prospect-list': '1. Prospect List',
              'to-contact': '2. To Contact',
              'in-progress': '3. In Progress',
              'committed': '4. Committed'
            };
            toast(`Moved to ${columnTitles[toColumn] || toColumn}`);
          }
        };
      });
    }
    
    /* ========= TASKS FUNCTIONS ========= */
    
    async function loadTasks() {
      try {
        // Try loading from cloud first
        const cloudData = await loadFromCloud('tasks');

        if (cloudData && Array.isArray(cloudData)) {
          tasksState.tasks = cloudData;
        } else {
          // Check localStorage as fallback
          const saved = localStorage.getItem('mailslot-tasks');
          if (saved) {
            tasksState.tasks = JSON.parse(saved);
            // Sync to cloud if we loaded from localStorage
            saveToCloud('tasks', tasksState.tasks).catch(e => console.warn('Failed to sync tasks to cloud:', e));
          } else {
            // Initialize with default tasks
            tasksState.tasks = [
              { id: 1, text: 'Call Royco Partners about Renewal', dueDate: '2025-11-20', completed: false },
              { id: 2, text: 'Follow up Capital Systems Group', dueDate: '2025-11-22', completed: false },
              { id: 3, text: 'Check Print Status: Boston Card', dueDate: '2025-11-25', completed: false },
              { id: 4, text: 'SMS Client: Stone Solutions Maine', dueDate: '2025-11-25', completed: false },
              { id: 5, text: 'Prep Renewal Pitch: Adam\'s Pizza', dueDate: '2025-11-28', completed: false },
              { id: 6, text: 'Design Ad Proof for Royco', dueDate: '2025-11-30', completed: false }
            ];
            saveTasks();
          }
        }
      } catch(e) {
        console.error('Error loading tasks:', e);
      }
      updateTasksDisplay();
    }

    async function saveTasks() {
      try {
        // Save to cloud and localStorage
        await saveToCloud('tasks', tasksState.tasks);
      } catch(e) {
        console.error('‚ùå Tasks save failed:', e);
        console.warn('Tasks saved to localStorage only (cloud sync failed):', e);
        // Show user-visible error
        toast('‚ö†Ô∏è Cloud sync failed - saved locally only', false);
      }
    }
    
    function updateTasksDisplay() {
      const container = document.getElementById('taskList');
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Filter: hide completed tasks that are overdue
      const visibleTasks = tasksState.tasks.filter(task => {
        if (task.completed) {
          const dueDate = new Date(task.dueDate);
          dueDate.setHours(0, 0, 0, 0);
          return dueDate >= today; // Only show completed if not overdue
        }
        return true;
      });
      
      if (visibleTasks.length === 0) {
        container.innerHTML = '<p class="text-sm text-gray-500 text-center py-4">All tasks complete!</p>';
        document.getElementById('overdueText').textContent = 'All tasks complete';
        document.getElementById('overdueText').className = 'text-sm text-green-600 mb-2';
        return;
      }
      
      container.innerHTML = visibleTasks.map(task => {
        const dueDate = new Date(task.dueDate);
        dueDate.setHours(0, 0, 0, 0);
        const overdueClass = dueDate < today && !task.completed ? 'overdue' : '';
        const completedClass = task.completed ? 'completed' : '';

        return `
          <div class="task-row ${completedClass}" draggable="true" data-task-id="${task.id}" data-due-date="${task.dueDate}">
            <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} onchange="toggleTaskComplete(this)" />
            <span class="task-text">${esc(task.text)}</span>
            <input type="date" class="task-date ${overdueClass}" value="${task.dueDate}" onchange="updateTaskDate(this)" />
            <div style="display: flex; gap: 0.5rem; margin-left: auto;">
              <button onclick="editTask(${task.id})" class="text-blue-600 hover:text-blue-800 text-xs" title="Edit task">
                ‚úé
              </button>
              <button onclick="deleteTask(${task.id})" class="text-red-600 hover:text-red-800 text-xs" title="Delete task">
                üóë
              </button>
            </div>
          </div>
        `;
      }).join('');
      
      // Update overdue count
      const incompleteTasks = visibleTasks.filter(t => !t.completed);
      const overdueCount = incompleteTasks.filter(t => {
        const dueDate = new Date(t.dueDate);
        dueDate.setHours(0, 0, 0, 0);
        return dueDate < today;
      }).length;
      
      const overdueText = document.getElementById('overdueText');
      if (overdueCount > 0) {
        overdueText.textContent = `${overdueCount} Task${overdueCount > 1 ? 's' : ''} Overdue`;
        overdueText.className = 'text-sm text-red-500 mb-2 font-bold';
      } else if (incompleteTasks.length > 0) {
        overdueText.textContent = `${incompleteTasks.length} Task${incompleteTasks.length > 1 ? 's' : ''} Pending`;
        overdueText.className = 'text-sm text-blue-600 mb-2';
      } else {
        overdueText.textContent = 'All tasks complete';
        overdueText.className = 'text-sm text-green-600 mb-2';
      }
      
      setupTaskDrag();
    }
    
    function setupTaskDrag() {
      const taskList = document.getElementById('taskList');
      
      taskList.querySelectorAll('.task-row').forEach(row => {
        row.addEventListener('dragstart', e => {
          draggedTask = row;
          row.classList.add('dragging');
        });
        
        row.addEventListener('dragend', e => {
          row.classList.remove('dragging');
          draggedTask = null;
        });
      });
      
      taskList.addEventListener('dragover', e => {
        e.preventDefault();
      });
      
      taskList.addEventListener('drop', e => {
        e.preventDefault();
        if (draggedTask) {
          const afterElement = getDragAfterElement(taskList, e.clientY);
          if (afterElement == null) {
            taskList.appendChild(draggedTask);
          } else {
            taskList.insertBefore(draggedTask, afterElement);
          }

          // Persist the new order
          const newOrder = Array.from(taskList.querySelectorAll('.task-row')).map(row => {
            const taskId = parseInt(row.dataset.taskId);
            return tasksState.tasks.find(t => t.id === taskId);
          }).filter(t => t != null);

          tasksState.tasks = newOrder;
          saveTasks();
          toast('Task order saved', true);
        }
      });
      
      function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.task-row:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
          } else {
            return closest;
          }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
      }
    }

    /* ========= SALES ACTIVITY TOGGLE ========= */
    function toggleSalesActivity() {
      const kanbanColumns = document.getElementById('salesActivityKanbanColumns');
      const icon = document.getElementById('salesActivityToggleIcon');

      if (kanbanColumns.style.maxHeight && kanbanColumns.style.maxHeight !== '0px') {
        // Collapse
        kanbanColumns.style.maxHeight = '0px';
        kanbanColumns.style.marginTop = '0px';
        icon.style.transform = 'rotate(-90deg)';
        safeSetItem('salesActivityCollapsed', 'true');
      } else {
        // Expand
        kanbanColumns.style.maxHeight = kanbanColumns.scrollHeight + 'px';
        kanbanColumns.style.marginTop = '';
        icon.style.transform = 'rotate(0deg)';
        safeSetItem('salesActivityCollapsed', 'false');

        // Remove max-height after transition so content can grow dynamically
        setTimeout(() => {
          if (kanbanColumns.style.maxHeight !== '0px') {
            kanbanColumns.style.maxHeight = 'none';
          }
        }, 300);
      }
    }

    // Initialize sales activity state on page load
    function initSalesActivityState() {
      const kanbanColumns = document.getElementById('salesActivityKanbanColumns');
      const icon = document.getElementById('salesActivityToggleIcon');
      const isCollapsed = safeGetItem('salesActivityCollapsed') === 'true';

      if (isCollapsed) {
        kanbanColumns.style.maxHeight = '0px';
        kanbanColumns.style.marginTop = '0px';
        icon.style.transform = 'rotate(-90deg)';
      } else {
        kanbanColumns.style.maxHeight = 'none';
      }
    }

    /* ========= TASK MANAGEMENT CRUD ========= */
    function openTaskModal(taskId = null) {
      const modal = document.getElementById("taskModal");
      const title = document.getElementById("taskModalTitle");
      const textInput = document.getElementById("taskText");
      const dateInput = document.getElementById("taskDueDate");
      const idInput = document.getElementById("taskId");

      if (taskId) {
        // Edit existing task
        const task = tasksState.tasks.find(t => t.id === taskId);
        if (task) {
          title.textContent = "Edit Task";
          textInput.value = task.text;
          dateInput.value = task.dueDate;
          idInput.value = task.id;
        }
      } else {
        // New task
        title.textContent = "Add New Task";
        textInput.value = "";
        // Set default date to today
        const today = new Date().toISOString().split('T')[0];
        dateInput.value = today;
        idInput.value = "";
      }

      lastFocusedElementBeforeModal = document.activeElement;
      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
      textInput.focus();
    }

    function closeTaskModal() {
      const modal = document.getElementById("taskModal");
      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
      if (lastFocusedElementBeforeModal) {
        lastFocusedElementBeforeModal.focus();
        lastFocusedElementBeforeModal = null;
      }
    }

    function saveTaskModal() {
      const textInput = document.getElementById("taskText");
      const dateInput = document.getElementById("taskDueDate");
      const idInput = document.getElementById("taskId");

      const text = textInput.value.trim();
      const dueDate = dateInput.value;

      if (!text) {
        toast("Please enter a task description", false);
        return;
      }

      if (!dueDate) {
        toast("Please select a due date", false);
        return;
      }

      // Warn if date is in the past (but still allow it)
      const today = new Date().toISOString().split('T')[0];
      if (dueDate < today) {
        if (!confirm(`‚ö†Ô∏è Warning: This date is in the past (${dueDate}).\n\nDo you want to continue?`)) {
          return;
        }
      }

      const taskId = idInput.value;

      if (taskId) {
        // Edit existing task
        const task = tasksState.tasks.find(t => t.id == taskId);
        if (task) {
          task.text = text;
          task.dueDate = dueDate;
          toast("Task updated successfully");
        }
      } else {
        // Create new task
        const newTask = {
          id: Date.now(),
          text: text,
          dueDate: dueDate,
          completed: false
        };
        tasksState.tasks.push(newTask);
        toast("Task added successfully");
      }

      saveTasks();
      updateTasksDisplay();
      closeTaskModal();
    }

    function editTask(taskId) {
      openTaskModal(taskId);
    }

    function deleteTask(taskId) {
      const index = tasksState.tasks.findIndex(t => t.id === taskId);

      if (index === -1) {
        toast("Task not found", false);
        return;
      }

      const task = tasksState.tasks[index];
      const taskText = task.text || 'Unnamed task';

      if (!confirm(`Are you sure you want to delete this task?\n\n"${taskText}"\n\nThis action cannot be undone.`)) {
        return;
      }

      tasksState.tasks.splice(index, 1);
      saveTasks();
      updateTasksDisplay();
      toast("Task deleted successfully");
    }

    /* ========= LEAD/PROSPECT MANAGEMENT CRUD ========= */
    // Render activity log
    function renderActivityLog(activityLog = []) {
      const container = document.getElementById('leadActivityLog');
      if (!activityLog || activityLog.length === 0) {
        container.innerHTML = '<div class="text-gray-400 italic">No activity yet</div>';
        return;
      }

      container.innerHTML = activityLog.map(activity => {
        const date = new Date(activity.timestamp);
        const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        return `
          <div class="text-gray-700">
            <span class="text-gray-500">${dateStr}:</span> ${esc(activity.note)}
          </div>
        `;
      }).join('');
    }

    // Add activity note to current lead
    function addActivityNote() {
      const noteInput = document.getElementById('leadNewActivity');
      const note = noteInput.value.trim();

      if (!note) {
        toast('Please enter a note', false);
        return;
      }

      const leadId = document.getElementById("leadId").value;
      const column = document.getElementById("leadColumn").value;

      if (!leadId) {
        toast('Please save the lead first before adding notes', false);
        return;
      }

      // Find the lead
      const items = kanbanState.columns[column] || [];
      const lead = items.find(item => typeof item === 'object' && item.id === parseFloat(leadId));

      if (!lead) {
        toast('Lead not found', false);
        return;
      }

      // Add note to activity log
      if (!lead.activityLog) {
        lead.activityLog = [];
      }

      lead.activityLog.push({
        timestamp: new Date().toISOString(),
        note: note
      });

      // Re-render activity log
      renderActivityLog(lead.activityLog);

      // Clear input
      noteInput.value = '';

      // Save changes
      saveKanban();

      toast('Note added', true);
    }

    // Expose functions globally
    window.addActivityNote = addActivityNote;

    /* ========= CONTACT LATER MODAL ========= */
    function openContactLaterModal(leadId, event) {
      if (event) {
        event.stopPropagation();
        event.preventDefault();
      }

      const prospectingColumn = 'prospect-list';
      const items = kanbanState.columns[prospectingColumn] || [];

      // Convert leadId to number for comparison
      const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;

      const lead = items.find(item => {
        if (typeof item !== 'object' || !item) return false;
        const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
        return itemId === numericLeadId;
      });

      if (!lead) {
        console.error('Lead not found. Looking for ID:', numericLeadId, 'in items:', items);
        toast('Prospect not found', false);
        return;
      }

      // Set modal data
      document.getElementById('contactLaterBusinessName').textContent = lead.businessName;
      document.getElementById('contactLaterLeadId').value = numericLeadId;

      // Set default date to tomorrow
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      document.getElementById('contactLaterDate').value = tomorrow.toISOString().split('T')[0];

      document.getElementById('contactLaterNote').value = '';

      // Show modal
      const modal = document.getElementById('contactLaterModal');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      document.getElementById('contactLaterDate').focus();
    }

    function closeContactLaterModal() {
      const modal = document.getElementById('contactLaterModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }

    function saveContactLater() {
      const leadId = parseFloat(document.getElementById('contactLaterLeadId').value);
      const followUpDate = document.getElementById('contactLaterDate').value;
      const note = document.getElementById('contactLaterNote').value.trim();

      if (!followUpDate) {
        toast('Please select a follow-up date', false);
        return;
      }

      const prospectingColumn = 'prospect-list';
      const items = kanbanState.columns[prospectingColumn] || [];
      const leadIndex = items.findIndex(item => typeof item === 'object' && item.id === leadId);

      if (leadIndex === -1) {
        toast('Prospect not found', false);
        return;
      }

      const lead = items[leadIndex];

      // Set follow-up date
      lead.followUpDate = followUpDate;

      // Add activity note if provided
      if (note) {
        if (!lead.activityLog) {
          lead.activityLog = [];
        }
        lead.activityLog.push({
          timestamp: new Date().toISOString(),
          note: `üìÖ Set follow-up for ${followUpDate}: ${note}`
        });
      } else {
        if (!lead.activityLog) {
          lead.activityLog = [];
        }
        lead.activityLog.push({
          timestamp: new Date().toISOString(),
          note: `üìÖ Set follow-up for ${followUpDate}`
        });
      }

      // Move to pool
      prospectPoolState.manualProspects.push({
        ...lead,
        movedToPoolDate: new Date().toISOString()
      });

      // Remove from prospecting
      kanbanState.columns[prospectingColumn].splice(leadIndex, 1);

      saveManualProspects();
      saveKanban();
      renderKanban();
      closeContactLaterModal();

      toast(`üìÖ "${lead.businessName}" moved to pool. Follow up on ${followUpDate}`, true);
    }

    // Expose functions globally
    window.openContactLaterModal = openContactLaterModal;
    window.closeContactLaterModal = closeContactLaterModal;
    window.saveContactLater = saveContactLater;

    function openLeadModal(column = null, leadId = null) {
      const modal = document.getElementById("leadModal");
      const title = document.getElementById("leadModalTitle");
      const columnInput = document.getElementById("leadColumn");
      const idInput = document.getElementById("leadId");

      if (leadId !== null && column) {
        // Edit existing lead
        const items = kanbanState.columns[column] || [];
        const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;
        const lead = items.find(item => {
          if (typeof item !== 'object') return false;
          const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
          return itemId === numericLeadId;
        });

        if (lead) {
          title.textContent = "Edit Lead";
          document.getElementById("leadBusinessName").value = lead.businessName || '';
          document.getElementById("leadContactName").value = lead.contactName || '';
          document.getElementById("leadPhone").value = lead.phone || '';
          document.getElementById("leadEmail").value = lead.email || '';
          document.getElementById("leadWebsite").value = lead.website || '';
          document.getElementById("leadFacebook").value = lead.facebook || '';
          document.getElementById("leadInstagram").value = lead.instagram || '';
          document.getElementById("leadValue").value = lead.value || '';
          document.getElementById("leadNotes").value = lead.notes || '';
          document.getElementById("leadFollowUpDate").value = lead.followUpDate || '';

          // Render activity log
          renderActivityLog(lead.activityLog || []);

          columnInput.value = column;
          idInput.value = leadId;
        }
      } else {
        // New lead
        title.textContent = "Add New Lead";
        document.getElementById("leadBusinessName").value = '';
        document.getElementById("leadContactName").value = '';
        document.getElementById("leadPhone").value = '';
        document.getElementById("leadEmail").value = '';
        document.getElementById("leadWebsite").value = '';
        document.getElementById("leadFacebook").value = '';
        document.getElementById("leadInstagram").value = '';
        document.getElementById("leadValue").value = '';
        document.getElementById("leadNotes").value = '';
        document.getElementById("leadFollowUpDate").value = '';

        // Clear activity log
        renderActivityLog([]);

        columnInput.value = column || 'prospect-list';
        idInput.value = '';
      }

      lastFocusedElementBeforeModal = document.activeElement;
      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
      document.getElementById("leadBusinessName").focus();
    }

    function closeLeadModal() {
      const modal = document.getElementById("leadModal");
      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
      if (lastFocusedElementBeforeModal) {
        lastFocusedElementBeforeModal.focus();
        lastFocusedElementBeforeModal = null;
      }
    }

    function saveLeadModal() {
      const businessName = document.getElementById("leadBusinessName").value.trim();
      const contactName = document.getElementById("leadContactName").value.trim();
      const phone = document.getElementById("leadPhone").value.trim();
      const email = document.getElementById("leadEmail").value.trim();
      const website = document.getElementById("leadWebsite").value.trim();
      const facebook = document.getElementById("leadFacebook").value.trim();
      const instagram = document.getElementById("leadInstagram").value.trim();
      const value = document.getElementById("leadValue").value.trim();
      const notes = document.getElementById("leadNotes").value.trim();
      const followUpDate = document.getElementById("leadFollowUpDate").value;
      const column = document.getElementById("leadColumn").value;
      const leadId = document.getElementById("leadId").value;

      if (!businessName) {
        toast("Please enter a business name", false);
        return;
      }

      // Get existing activity log if editing
      let activityLog = [];
      if (leadId) {
        const items = kanbanState.columns[column] || [];
        const existingLead = items.find(item => typeof item === 'object' && item.id === parseFloat(leadId));
        if (existingLead && existingLead.activityLog) {
          activityLog = existingLead.activityLog;
        }
      }

      const leadData = {
        id: leadId ? parseFloat(leadId) : Date.now() + Math.random(),
        businessName: businessName,
        contactName: contactName,
        phone: phone,
        email: email,
        website: website,
        facebook: facebook,
        instagram: instagram,
        value: value ? parseFloat(value) : 0,
        notes: notes,
        followUpDate: followUpDate,
        activityLog: activityLog,
        createdDate: new Date().toISOString()
      };

      if (leadId) {
        // Edit existing lead
        const items = kanbanState.columns[column] || [];
        const index = items.findIndex(item => typeof item === 'object' && item.id === parseFloat(leadId));
        if (index !== -1) {
          items[index] = leadData;
          toast("Lead updated successfully");
        }
      } else {
        // Add new lead
        if (!kanbanState.columns[column]) {
          kanbanState.columns[column] = [];
        }
        kanbanState.columns[column].push(leadData);
        toast("Lead added successfully");
      }

      saveKanban();
      renderKanban();
      closeLeadModal();
    }

    function editLead(column, leadId, event) {
      // Stop event propagation to prevent drag behavior
      if (event) {
        event.stopPropagation();
        event.preventDefault();
      }
      // Normalize ID type (handle both string and number)
      const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;
      openLeadModal(column, numericLeadId);
    }

    function deleteLead(column, leadId, event) {
      // Stop event propagation
      if (event) {
        event.stopPropagation();
        event.preventDefault();
      }

      // Normalize ID type (handle both string and number)
      const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;

      const items = kanbanState.columns[column] || [];
      const index = items.findIndex(item => {
        if (typeof item === 'string') return false;
        const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
        return itemId === numericLeadId;
      });

      if (index === -1) {
        toast("Lead not found", false);
        return;
      }

      const lead = items[index];
      const leadName = typeof lead === 'string' ? lead : (lead.businessName || 'Unnamed Lead');

      if (!confirm(`Are you sure you want to delete "${leadName}"?\n\nThis action cannot be undone.`)) {
        return;
      }

      if (index !== -1) {
        items.splice(index, 1);

        // Clear this prospect from selection if it was selected
        prospectingSelectionState.selectedIds.delete(leadId);

        saveKanban();
        renderKanban();
        toast("Lead deleted successfully");
      }
    }

    /* ========= DAILY GOAL TRACKING FUNCTIONS ========= */

    // Increment daily outreach count (called when: button clicks, manual moves)
    function incrementDailyGoal(businessName = '') {
      checkAndResetDailyGoal(); // Always check for date change first
      dailyGoalState.todayCount++;

      // Add to today's history
      const today = new Date().toDateString();
      let todayRecord = dailyGoalState.history.find(h => h.date === today);
      if (!todayRecord) {
        todayRecord = { date: today, goal: dailyGoalState.dailyGoal, actual: 0, businesses: [] };
        dailyGoalState.history.push(todayRecord);
      }
      todayRecord.actual = dailyGoalState.todayCount;
      if (businessName) {
        todayRecord.businesses.push({ name: businessName, timestamp: new Date().toISOString() });
      }

      saveDailyGoalState();
      // NOTE: Don't call renderKanban() here - let the calling function handle it
      // This prevents double-render issues and race conditions
    }

    // Decrement daily outreach count (called when moving back TO "To Contact")
    function decrementDailyGoal(businessName = '') {
      checkAndResetDailyGoal(); // Always check for date change first

      // Don't go below 0
      if (dailyGoalState.todayCount > 0) {
        dailyGoalState.todayCount--;
      }

      // Update today's history
      const today = new Date().toDateString();
      let todayRecord = dailyGoalState.history.find(h => h.date === today);
      if (todayRecord) {
        todayRecord.actual = dailyGoalState.todayCount;
        // Remove last business entry if it exists
        if (businessName && todayRecord.businesses.length > 0) {
          todayRecord.businesses.pop();
        }
      }

      saveDailyGoalState();
    }

    // Check if it's a new day and reset if needed
    function checkAndResetDailyGoal() {
      const today = new Date().toDateString();
      if (dailyGoalState.lastResetDate !== today) {
        // New day! Save yesterday's final count to history (if not already saved)
        if (dailyGoalState.todayCount > 0) {
          const yesterdayRecord = dailyGoalState.history.find(h => h.date === dailyGoalState.lastResetDate);
          if (yesterdayRecord) {
            yesterdayRecord.actual = dailyGoalState.todayCount;
          }
        }

        // Reset for new day
        dailyGoalState.todayCount = 0;
        dailyGoalState.lastResetDate = today;
        saveDailyGoalState();
        console.log('Daily goal reset for new day:', today);
      }
    }

    // Save daily goal state to localStorage
    function saveDailyGoalState() {
      try {
        localStorage.setItem('dailyGoalState', JSON.stringify(dailyGoalState));
      } catch (e) {
        console.error('Failed to save daily goal state:', e);
      }
    }

    // Load daily goal state from localStorage
    function loadDailyGoalState() {
      try {
        const saved = localStorage.getItem('dailyGoalState');
        if (saved) {
          const loaded = JSON.parse(saved);
          dailyGoalState.dailyGoal = loaded.dailyGoal || 10;
          dailyGoalState.todayCount = loaded.todayCount || 0;
          dailyGoalState.lastResetDate = loaded.lastResetDate || new Date().toDateString();
          dailyGoalState.history = loaded.history || [];
        }
        checkAndResetDailyGoal(); // Check if we need to reset for new day
      } catch (e) {
        console.error('Failed to load daily goal state:', e);
      }
    }

    // Handle "Communicating" button click
    function handleCommunicating(leadId, event) {
      if (event) {
        event.stopPropagation();
        event.preventDefault();
      }

      // Find lead in to-contact column
      const items = kanbanState.columns['to-contact'] || [];
      const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;
      const index = items.findIndex(item => {
        if (typeof item === 'string') return false;
        const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
        return itemId === numericLeadId;
      });

      if (index === -1) {
        toast("Lead not found", false);
        return;
      }

      // Move to in-progress column
      const lead = items[index];
      items.splice(index, 1);
      kanbanState.columns['in-progress'] = kanbanState.columns['in-progress'] || [];
      kanbanState.columns['in-progress'].push(lead);

      // Increment daily goal
      const businessName = typeof lead === 'string' ? lead : (lead.businessName || 'Unnamed Lead');
      incrementDailyGoal(businessName);

      saveKanban();
      renderKanban();
      toast(`${businessName} moved to In Progress`);
    }

    // Handle "Not Interested" button click
    function handleNotInterested(leadId, event) {
      if (event) {
        event.stopPropagation();
        event.preventDefault();
      }

      // Find lead in to-contact column
      const items = kanbanState.columns['to-contact'] || [];
      const numericLeadId = typeof leadId === 'string' ? parseFloat(leadId) : leadId;
      const index = items.findIndex(item => {
        if (typeof item === 'string') return false;
        const itemId = typeof item.id === 'string' ? parseFloat(item.id) : item.id;
        return itemId === numericLeadId;
      });

      if (index === -1) {
        toast("Lead not found", false);
        return;
      }

      const lead = items[index];
      const businessName = typeof lead === 'string' ? lead : (lead.businessName || 'Unnamed Lead');

      if (!confirm(`Mark "${businessName}" as Not Interested?\n\nThis will remove them from your pipeline.`)) {
        return;
      }

      // Remove from kanban
      items.splice(index, 1);

      // Add to not interested list (if it's an object with placeId)
      if (typeof lead === 'object' && lead.placeId) {
        addToNotInterestedList(lead);
      }

      // Increment daily goal
      incrementDailyGoal(businessName);

      saveKanban();
      renderKanban();
      toast(`${businessName} marked as not interested`);
    }

    // Reset daily goal count to 0
    function resetDailyGoal() {
      if (!confirm('Reset today\'s outreach count to 0?\n\nThis will clear your progress for today but keep your goal and history.')) {
        return;
      }

      dailyGoalState.todayCount = 0;

      // Update today's history record if it exists
      const today = new Date().toDateString();
      let todayRecord = dailyGoalState.history.find(h => h.date === today);
      if (todayRecord) {
        todayRecord.actual = 0;
        todayRecord.businesses = [];
      }

      saveDailyGoalState();
      renderKanban();
      toast('Daily count reset to 0');
    }

    // Open daily goal settings modal
    function openDailyGoalSettings() {
      const modal = document.getElementById('dailyGoalSettingsModal');
      if (!modal) return;

      // Pre-fill current goal
      const input = document.getElementById('dailyGoalInput');
      if (input) {
        input.value = dailyGoalState.dailyGoal;
      }

      lastFocusedElementBeforeModal = document.activeElement;
      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);

      // Focus on input
      if (input) input.focus();
    }

    function closeDailyGoalSettings() {
      const modal = document.getElementById('dailyGoalSettingsModal');
      if (!modal) return;

      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus();

      if (lastFocusedElementBeforeModal) {
        lastFocusedElementBeforeModal.focus();
      }
    }

    function saveDailyGoalFromModal() {
      const input = document.getElementById('dailyGoalInput');
      if (!input) return;

      const goalNumber = parseInt(input.value);
      if (isNaN(goalNumber) || goalNumber < 1) {
        toast("Please enter a valid number (minimum 1)", false);
        return;
      }

      dailyGoalState.dailyGoal = goalNumber;
      saveDailyGoalState();
      renderKanban();
      closeDailyGoalSettings();
      toast(`Daily goal updated to ${goalNumber} contacts`, true);
    }

    function resetDailyGoalFromModal() {
      if (!confirm("Are you sure you want to reset today's count to 0?")) {
        return;
      }

      dailyGoalState.todayCount = 0;
      dailyGoalState.todayDate = new Date().toISOString().split('T')[0];
      saveDailyGoalState();
      renderKanban();
      toast('Daily count reset to 0', true);
      // Don't close modal - user might want to adjust goal too
    }

    /* ========= NEW POSTCARD CREATION WORKFLOW ========= */
    function openNewPostcardModal() {
      const modal = document.getElementById("newPostcardModal");

      // Populate town dropdown with unique towns from existing postcards
      const towns = [...new Set(state.mailers.map(m => m.Town))].sort();
      const townSelect = document.getElementById("newPostcardTownSelect");
      townSelect.innerHTML = '<option value="">‚Äî Select existing town ‚Äî</option>' +
        towns.map(town => `<option value="${esc(town)}">${esc(town)}</option>`).join('');

      // Populate year dropdown (current year and next 2 years)
      const currentYear = new Date().getFullYear();
      const yearSelect = document.getElementById("newPostcardYear");
      yearSelect.innerHTML = [currentYear, currentYear + 1, currentYear + 2]
        .map(year => `<option value="${year}">${year}</option>`).join('');

      // Set default month to next month
      const nextMonth = new Date();
      nextMonth.setMonth(nextMonth.getMonth() + 1);
      document.getElementById("newPostcardMonth").value = String(nextMonth.getMonth() + 1).padStart(2, '0');

      // Populate copy source dropdown
      const copySelect = document.getElementById("copySourcePostcard");
      copySelect.innerHTML = '<option value="">‚Äî Select postcard ‚Äî</option>' +
        state.mailers.map((m, i) => `<option value="${i}">${esc(m.Town)} ‚Äî ${esc(m.Mail_Date)}</option>`).join('');

      // Reset form
      document.querySelector('input[name="townOption"][value="existing"]').checked = true;
      document.getElementById("newPostcardTownInput").disabled = true;
      document.getElementById("copyFromPrevious").checked = false;
      document.getElementById("copyOptions").classList.add('hidden');
      document.getElementById("advertiserChecklistContainer").classList.add('hidden');

      lastFocusedElementBeforeModal = document.activeElement;
      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
    }

    function closeNewPostcardModal() {
      const modal = document.getElementById("newPostcardModal");
      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
      if (lastFocusedElementBeforeModal) {
        lastFocusedElementBeforeModal.focus();
        lastFocusedElementBeforeModal = null;
      }
    }

    /* ========= DUPLICATE POSTCARD MODAL ========= */
    function openDuplicatePostcardModal() {
      const modal = document.getElementById("duplicatePostcardModal");

      // Populate source postcard dropdown
      const sourceSelect = document.getElementById("duplicateSourcePostcard");
      sourceSelect.innerHTML = '<option value="">‚Äî Select postcard ‚Äî</option>' +
        state.mailers.map((m, i) => {
          let displayDate = m.Mail_Date || "";
          if (/^\d{4}-\d{2}-\d{2}/.test(displayDate)) {
            const [year, month] = displayDate.split('-');
            const monthNames = ["", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            displayDate = `${monthNames[parseInt(month)]} ${year}`;
          }
          const sizeLabel = m.Postcard_Size ? ` (${m.Postcard_Size})` : '';
          return `<option value="${i}">${esc(m.Town)} ‚Äî ${esc(displayDate)}${sizeLabel}</option>`;
        }).join('');

      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
    }

    function closeDuplicatePostcardModal() {
      const modal = document.getElementById("duplicatePostcardModal");
      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
    }

    async function createDuplicatePostcard() {
      const sourceIndex = document.getElementById("duplicateSourcePostcard").value;
      if (!sourceIndex) {
        toast("Please select a postcard to duplicate", false);
        return;
      }

      const sourcePostcard = state.mailers[parseInt(sourceIndex)];
      const newTown = document.getElementById("duplicateTown").value.trim();
      const newMonth = document.getElementById("duplicateMonth").value;
      const newYear = document.getElementById("duplicateYear").value;
      const newSize = document.getElementById("duplicateSize").value;

      // Must change at least one thing
      const isSameTown = !newTown || newTown === sourcePostcard.Town;
      const isSameMonth = !newMonth || !newYear;
      const isSameSize = !newSize || newSize === sourcePostcard.Postcard_Size;

      if (isSameTown && isSameMonth && isSameSize) {
        toast("You must change at least one: town, month/year, or size", false);
        return;
      }

      const btn = document.getElementById('btnCreateDuplicate');
      const originalText = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Duplicating...';

      try {
        // Determine new values
        const finalTown = newTown || sourcePostcard.Town;
        const sourceDate = new Date(sourcePostcard.Mail_Date);
        const finalMonth = newMonth ? newMonth.padStart(2, '0') : String(sourceDate.getMonth() + 1).padStart(2, '0');
        const finalYear = newYear || sourceDate.getFullYear();
        const finalSize = newSize || sourcePostcard.Postcard_Size || '9x12';

        const mailDate = `${finalYear}-${finalMonth}-01`;
        const mailerId = `${finalTown.replace(/\s+/g, '-')}-${finalMonth}-${finalYear}`;

        // Check for duplicates
        const duplicate = state.mailers.find(m => m.Mailer_ID === mailerId);
        if (duplicate) {
          toast("A postcard with this combination already exists!", false);
          btn.disabled = false;
          btn.innerHTML = originalText;
          return;
        }

        // Create new postcard object
        const newPostcard = {
          Mailer_ID: mailerId,
          Town: finalTown,
          Mail_Date: mailDate,
          In_Homes_Date: sourcePostcard.In_Homes_Date, // Can be edited later
          Payment_Status: "Active",
          Postcard_Size: finalSize,
          availability: {},
          Postcard_BG: document.getElementById("duplicateCopyColors").checked ? sourcePostcard.Postcard_BG : "#000000",
          Banner_BG: document.getElementById("duplicateCopyColors").checked ? sourcePostcard.Banner_BG : "#000000"
        };

        // Initialize all spots as available
        for (let i = 1; i <= 18; i++) {
          newPostcard.availability[`Spot_${i}`] = "Available";
        }

        // Copy advertisers if checked
        if (document.getElementById("duplicateCopyAdvertisers").checked) {
          for (let i = 1; i <= 18; i++) {
            const spotKey = `Spot_${i}`;
            // Check both availability object and direct spot properties (Supabase format)
            const raw = (sourcePostcard.availability && sourcePostcard.availability[spotKey]) || sourcePostcard[spotKey] || "Available";
            if (!/^available$/i.test(raw)) {
              // Has an advertiser - copy as Reserved
              const match = String(raw).match(/^(.+?)\s*:\s*(.*)$/);
              if (match) {
                const name = match[2].trim();
                if (name) {
                  newPostcard.availability[spotKey] = `Reserved: ${name}`;
                }
              }
            }
          }
        }

        // Copy expenses if checked
        if (document.getElementById("duplicateCopyExpenses").checked && productionState.expenses[sourcePostcard.Mailer_ID]) {
          const sourceExpenses = productionState.expenses[sourcePostcard.Mailer_ID];
          productionState.expenses[mailerId] = {
            printing: sourceExpenses.printing || 0,
            postage: sourceExpenses.postage || 0,
            design: sourceExpenses.design || 0,
            misc: sourceExpenses.misc || 0
          };
          await saveExpenses();
        }

        // Copy pricing if checked
        if (document.getElementById("duplicateCopyPricing").checked && productionState.pricing[sourcePostcard.Mailer_ID]) {
          const sourcePricing = productionState.pricing[sourcePostcard.Mailer_ID];
          productionState.pricing[mailerId] = {
            singleAd: sourcePricing.singleAd || 0,
            doubleAd: sourcePricing.doubleAd || 0,
            bannerAd: sourcePricing.bannerAd || 0
          };
          await savePricing();
        }

        // Add to state
        state.mailers.push(newPostcard);

        // Sort mailers
        state.mailers = state.mailers.sort((a, b) => {
          const dateA = a.Mail_Date || '';
          const dateB = b.Mail_Date || '';
          if (dateA !== dateB) {
            return dateB.localeCompare(dateA);
          }
          const townA = (a.Town || '').toLowerCase();
          const townB = (b.Town || '').toLowerCase();
          return townA.localeCompare(townB);
        });

        // Repopulate selectors
        populateTownAndMonthSelectors();

        // Select new postcard
        const newIndex = state.mailers.findIndex(m => m.Mailer_ID === mailerId);
        selectPostcard(newIndex);
        switchTab('manager');

        // Save to Supabase
        try {
          const { error } = await supabaseClient
            .from('postcards')
            .insert({
              user_email: ACTIVE_USER,
              mailer_id: newPostcard.Mailer_ID,
              town: newPostcard.Town,
              mail_date: newPostcard.Mail_Date,
              in_homes_date: newPostcard.In_Homes_Date,
              payment_status: newPostcard.Payment_Status,
              postcard_size: newPostcard.Postcard_Size || '9x12',
              postcard_bg: newPostcard.Postcard_BG,
              banner_bg: newPostcard.Banner_BG,
              spot_1: newPostcard.availability.Spot_1 || 'Available',
              spot_2: newPostcard.availability.Spot_2 || 'Available',
              spot_3: newPostcard.availability.Spot_3 || 'Available',
              spot_4: newPostcard.availability.Spot_4 || 'Available',
              spot_5: newPostcard.availability.Spot_5 || 'Available',
              spot_6: newPostcard.availability.Spot_6 || 'Available',
              spot_7: newPostcard.availability.Spot_7 || 'Available',
              spot_8: newPostcard.availability.Spot_8 || 'Available',
              spot_9: newPostcard.availability.Spot_9 || 'Available',
              spot_10: newPostcard.availability.Spot_10 || 'Available',
              spot_11: newPostcard.availability.Spot_11 || 'Available',
              spot_12: newPostcard.availability.Spot_12 || 'Available',
              spot_13: newPostcard.availability.Spot_13 || 'Available',
              spot_14: newPostcard.availability.Spot_14 || 'Available',
              spot_15: newPostcard.availability.Spot_15 || 'Available',
              spot_16: newPostcard.availability.Spot_16 || 'Available',
              spot_17: newPostcard.availability.Spot_17 || 'Available',
              spot_18: newPostcard.availability.Spot_18 || 'Available'
            });

          if (error) throw error;

        } catch (cloudErr) {
          console.error("Failed to save duplicated postcard to cloud:", cloudErr);
          toast("‚ö†Ô∏è Postcard duplicated locally. Will sync on next spot edit.", false);
        }

        closeDuplicatePostcardModal();
        toast(`‚úÖ Duplicated postcard: ${finalTown} ‚Äî ${finalMonth}/${finalYear}`);

      } catch (error) {
        console.error('Error duplicating postcard:', error);
        toast('Failed to duplicate postcard', false);
        btn.disabled = false;
        btn.innerHTML = originalText;
      }
    }

    /* ========= PRICING MODAL ========= */
    async function loadPricing() {
      try {
        const cloudData = await loadFromCloud('pricing');
        if (cloudData) {
          // Ensure all pricing values are numbers, not strings
          productionState.pricing = {};
          Object.keys(cloudData).forEach(mailerId => {
            const pricing = cloudData[mailerId];
            productionState.pricing[mailerId] = {
              singleAd: parseFloat(pricing.singleAd) || 0,
              doubleAd: parseFloat(pricing.doubleAd) || 0,
              bannerAd: parseFloat(pricing.bannerAd) || 0
            };
          });
        }
      } catch (e) {
        // Silently handle error - pricing table may not exist yet in Supabase
        // This is expected on first use before running migration
        console.log('Pricing not available yet (this is normal on first use)');
      }
    }

    async function savePricing() {
      try {
        await saveToCloud('pricing', productionState.pricing);
        await saveToCloud('revenueGoals', productionState.revenueGoals);
      } catch (e) {
        console.warn('Pricing saved locally only (cloud sync failed):', e);
      }
    }

    async function loadRevenueGoals() {
      try {
        const cloudData = await loadFromCloud('revenueGoals');
        if (cloudData) {
          productionState.revenueGoals = cloudData;
        }
      } catch (e) {
        console.log('Revenue goals not available');
      }
    }

    /* ========= SPOT PRICING (PER-SPOT CUSTOM PRICES) ========= */

    // Helper function to normalize pricing keys (ALL UPPERCASE for consistency)
    // This fixes case mismatch between old data and new data
    function normalizePriceKey(mailerId, spotNum = null) {
      const base = String(mailerId).toUpperCase();
      return spotNum ? `${base}-SPOT_${spotNum}`.toUpperCase() : base;
    }

    async function loadSpotPricing() {
      try {
        const cloudData = await loadFromCloud('spotPricing');
        console.log('üí∞ [LOAD SPOT PRICING] Cloud data received:', cloudData ? 'YES' : 'NO');
        if (cloudData) {
          const keys = Object.keys(cloudData);
          console.log('üí∞ [LOAD SPOT PRICING] Found', keys.length, 'entries in cloud data');
          console.log('üí∞ [LOAD SPOT PRICING] Sample keys (raw):', keys.slice(0, 3));

          // Clean and normalize: only load valid spot pricing (numeric values with SPOT_ in key)
          // This filters out any Set Pricing data that got mixed in
          productionState.spotPricing = {};
          let skippedCount = 0;

          Object.keys(cloudData).forEach(key => {
            const value = cloudData[key];
            const normalizedKey = key.toUpperCase();

            // Skip if value is an object (Set Pricing data) or not a valid number
            if (typeof value === 'object') {
              console.log('üí∞ [LOAD SPOT PRICING] ‚ö†Ô∏è Skipping invalid entry (object):', key);
              skippedCount++;
              return;
            }

            const numValue = parseFloat(value);
            if (isNaN(numValue)) {
              console.log('üí∞ [LOAD SPOT PRICING] ‚ö†Ô∏è Skipping invalid entry (not a number):', key, '=', value);
              skippedCount++;
              return;
            }

            // Only load entries that look like spot pricing (contain SPOT_) or are explicitly 0
            if (normalizedKey.includes('SPOT_') || numValue === 0) {
              productionState.spotPricing[normalizedKey] = numValue;
              if (normalizedKey !== key) {
                console.log('üí∞ [LOAD SPOT PRICING] Normalized key:', key, '‚Üí', normalizedKey);
              }
            } else {
              console.log('üí∞ [LOAD SPOT PRICING] ‚ö†Ô∏è Skipping non-spot entry:', key, '=', value);
              skippedCount++;
            }
          });

          console.log('üí∞ [LOAD SPOT PRICING] ‚úÖ Loaded', Object.keys(productionState.spotPricing).length, 'valid spot prices');
          if (skippedCount > 0) {
            console.log('üí∞ [LOAD SPOT PRICING] ‚ö†Ô∏è Skipped', skippedCount, 'invalid entries');
          }
          console.log('üí∞ [LOAD SPOT PRICING] Sample loaded keys:', Object.keys(productionState.spotPricing).slice(0, 5));
        } else {
          console.log('üí∞ [LOAD SPOT PRICING] No cloud data found, starting fresh');
        }
      } catch (e) {
        console.log('üí∞ [LOAD SPOT PRICING] Error:', e.message);
      }
    }

    async function saveSpotPricing() {
      try {
        // FILTER OUT campaign-level pricing objects before saving
        // Only save individual spot prices (numbers with SPOT_ in key)
        const cleanedSpotPricing = {};
        Object.keys(productionState.spotPricing).forEach(key => {
          const value = productionState.spotPricing[key];
          // Only save if value is a number AND key contains SPOT_
          if (typeof value === 'number' && !isNaN(value) && key.toUpperCase().includes('SPOT_')) {
            cleanedSpotPricing[key.toUpperCase()] = value;
          } else if (typeof value === 'object') {
            console.log('üíæ [SAVE SPOT PRICING] ‚ö†Ô∏è Filtering out campaign-level pricing:', key);
          }
        });

        const keys = Object.keys(cleanedSpotPricing);
        console.log('üíæ [SAVE SPOT PRICING] Saving', keys.length, 'spot prices to cloud');
        console.log('üíæ [SAVE SPOT PRICING] Sample keys:', keys.slice(0, 3));
        console.log('üíæ [SAVE SPOT PRICING] Sample values:', keys.slice(0, 3).map(k => `${k}: ${cleanedSpotPricing[k]}`));
        console.log('üíæ [SAVE SPOT PRICING] Full data being saved:', JSON.stringify(cleanedSpotPricing).substring(0, 200) + '...');

        await saveToCloud('spotPricing', cleanedSpotPricing);

        console.log('üíæ [SAVE SPOT PRICING] ‚úÖ Successfully saved to cloud');

        // Update productionState to match cleaned data
        productionState.spotPricing = cleanedSpotPricing;

        // Also save to localStorage as backup (cleaned version only)
        safeSetItem('mailslot-pricing', JSON.stringify(cleanedSpotPricing));
      } catch (e) {
        console.error('üíæ [SAVE SPOT PRICING] ‚ùå Failed to save:', e);
      }
    }

    // Sync top pricing inputs to bottom calculator price fields
    function syncPricingToCalculator() {
      const singlePrice = parseFloat(document.getElementById("pricingSingleAd").value) || 0;
      const doublePrice = parseFloat(document.getElementById("pricingDoubleAd").value) || 0;
      const bannerPrice = parseFloat(document.getElementById("pricingBannerAd").value) || 0;

      document.getElementById("goalSinglePrice").value = singlePrice;
      document.getElementById("goalDoublePrice").value = doublePrice;
      document.getElementById("goalBannerPrice").value = bannerPrice;

      updateRevenueGoalCalculator();
    }

    function updateRevenueGoalCalculator() {
      const singleCount = parseFloat(document.getElementById("goalSingleCount").value) || 0;
      const singlePrice = parseFloat(document.getElementById("goalSinglePrice").value) || 0;
      const doubleCount = parseFloat(document.getElementById("goalDoubleCount").value) || 0;
      const doublePrice = parseFloat(document.getElementById("goalDoublePrice").value) || 0;
      const bannerCount = parseFloat(document.getElementById("goalBannerCount").value) || 0;
      const bannerPrice = parseFloat(document.getElementById("goalBannerPrice").value) || 0;

      const singleTotal = singleCount * singlePrice;
      const doubleTotal = doubleCount * doublePrice;
      const bannerTotal = bannerCount * bannerPrice;
      const total = singleTotal + doubleTotal + bannerTotal;

      document.getElementById("goalSingleTotal").textContent = formatCurrency(singleTotal);
      document.getElementById("goalDoubleTotal").textContent = formatCurrency(doubleTotal);
      document.getElementById("goalBannerTotal").textContent = formatCurrency(bannerTotal);
      document.getElementById("goalTotalRevenue").textContent = formatCurrency(total);
    }

    function openPricingModal() {
      if (!state.current) {
        toast('Please select a postcard first', false);
        return;
      }

      const modal = document.getElementById("pricingModal");
      const mailerId = state.current.Mailer_ID;

      // Load existing pricing for this postcard
      const pricing = productionState.pricing[mailerId] || { singleAd: 0, doubleAd: 0, bannerAd: 0 };

      document.getElementById("pricingSingleAd").value = pricing.singleAd || '';
      document.getElementById("pricingDoubleAd").value = pricing.doubleAd || '';
      document.getElementById("pricingBannerAd").value = pricing.bannerAd || '';

      // Load existing revenue goal for this postcard
      const revenueGoal = productionState.revenueGoals[mailerId] || {
        singleCount: 0, singlePrice: pricing.singleAd || 0,
        doubleCount: 0, doublePrice: pricing.doubleAd || 0,
        bannerCount: 0, bannerPrice: pricing.bannerAd || 0
      };

      document.getElementById("goalSingleCount").value = revenueGoal.singleCount || '';
      document.getElementById("goalSinglePrice").value = revenueGoal.singlePrice || pricing.singleAd || '';
      document.getElementById("goalDoubleCount").value = revenueGoal.doubleCount || '';
      document.getElementById("goalDoublePrice").value = revenueGoal.doublePrice || pricing.doubleAd || '';
      document.getElementById("goalBannerCount").value = revenueGoal.bannerCount || '';
      document.getElementById("goalBannerPrice").value = revenueGoal.bannerPrice || pricing.bannerAd || '';

      updateRevenueGoalCalculator();

      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
    }

    function closePricingModal() {
      const modal = document.getElementById("pricingModal");
      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
    }

    async function savePricingModal() {
      if (!state.current) return;

      const mailerId = state.current.Mailer_ID;
      const singleAd = parseFloat(document.getElementById("pricingSingleAd").value) || 0;
      const doubleAd = parseFloat(document.getElementById("pricingDoubleAd").value) || 0;
      const bannerAd = parseFloat(document.getElementById("pricingBannerAd").value) || 0;

      productionState.pricing[mailerId] = { singleAd, doubleAd, bannerAd };

      // Save revenue goal
      const singleCount = parseFloat(document.getElementById("goalSingleCount").value) || 0;
      const singlePrice = parseFloat(document.getElementById("goalSinglePrice").value) || 0;
      const doubleCount = parseFloat(document.getElementById("goalDoubleCount").value) || 0;
      const doublePrice = parseFloat(document.getElementById("goalDoublePrice").value) || 0;
      const bannerCount = parseFloat(document.getElementById("goalBannerCount").value) || 0;
      const bannerPrice = parseFloat(document.getElementById("goalBannerPrice").value) || 0;

      const total = (singleCount * singlePrice) + (doubleCount * doublePrice) + (bannerCount * bannerPrice);

      productionState.revenueGoals[mailerId] = {
        singleCount, singlePrice,
        doubleCount, doublePrice,
        bannerCount, bannerPrice,
        total
      };

      await savePricing();

      closePricingModal();
      toast('Pricing and revenue goal saved');

      // Refresh financials display
      updateFinancialDashboard();
      renderCardsInProgress();
    }

    function openEditDetailsModal() {
      if (!state.current) {
        toast('Please select a postcard first', false);
        return;
      }

      const modal = document.getElementById("editDetailsModal");
      const inHomesDate = state.current.In_Homes_Date;

      if (inHomesDate) {
        // Parse date string without timezone conversion
        // If already in YYYY-MM-DD format, use it directly
        if (/^\d{4}-\d{2}-\d{2}/.test(inHomesDate)) {
          document.getElementById("editInHomesDate").value = inHomesDate.substring(0, 10);
        } else {
          // Fallback: parse as local date
          const dateObj = new Date(inHomesDate);
          const yyyy = dateObj.getFullYear();
          const mm = String(dateObj.getMonth() + 1).padStart(2, '0');
          const dd = String(dateObj.getDate()).padStart(2, '0');
          document.getElementById("editInHomesDate").value = `${yyyy}-${mm}-${dd}`;
        }
      } else {
        document.getElementById("editInHomesDate").value = '';
      }

      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
    }

    function closeEditDetailsModal() {
      const modal = document.getElementById("editDetailsModal");
      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
    }

    async function saveEditDetailsModal() {
      if (!state.current) return;

      const inHomesDateValue = document.getElementById("editInHomesDate").value;

      if (inHomesDateValue) {
        state.current.In_Homes_Date = inHomesDateValue;

        try {
          const { error } = await supabaseClient
            .from('postcards')
            .update({ in_homes_date: inHomesDateValue })
            .eq('user_email', ACTIVE_USER)
            .eq('mailer_id', state.current.Mailer_ID);

          if (error) throw error;

          toast('‚úÖ In homes date updated successfully');
          closeEditDetailsModal();
        } catch (err) {
          console.error('Error updating in homes date:', err);
          toast('‚ùå Failed to update in homes date', false);
        }
      }
    }

    function toggleTownInput() {
      const isNew = document.querySelector('input[name="townOption"][value="new"]').checked;
      document.getElementById("newPostcardTownSelect").disabled = isNew;
      document.getElementById("newPostcardTownInput").disabled = !isNew;
    }

    function toggleCopyOptions() {
      const checked = document.getElementById("copyFromPrevious").checked;
      document.getElementById("copyOptions").classList.toggle('hidden', !checked);
      if (!checked) {
        document.getElementById("advertiserChecklistContainer").classList.add('hidden');
      }
    }

    function loadAdvertisersForCopy() {
      const sourceIndex = document.getElementById("copySourcePostcard").value;
      if (!sourceIndex) {
        document.getElementById("advertiserChecklistContainer").classList.add('hidden');
        return;
      }

      const sourcePostcard = state.mailers[sourceIndex];
      if (!sourcePostcard) return;

      // Extract advertisers from the source postcard
      const advertisers = [];
      for (let i = 1; i <= 18; i++) {
        const spotKey = `Spot_${i}`;
        const raw = (sourcePostcard.availability || {})[spotKey] || "Available";
        if (!/^available$/i.test(raw)) {
          const match = String(raw).match(/^(.+?)\s*:\s*(.*)$/);
          if (match) {
            const status = match[1].trim();
            const name = match[2].trim();
            if (name) {
              // Check if this advertiser is already in the list (merged spots)
              const existing = advertisers.find(a => a.name.toLowerCase() === name.toLowerCase());
              if (existing) {
                existing.spots.push(i);
              } else {
                advertisers.push({ name, status, spots: [i] });
              }
            }
          }
        }
      }

      // Render checklist
      const checklist = document.getElementById("advertiserChecklist");
      if (advertisers.length === 0) {
        checklist.innerHTML = '<p class="text-sm text-gray-500">No advertisers found in this postcard.</p>';
        document.getElementById("advertiserChecklistContainer").classList.remove('hidden');
        return;
      }

      checklist.innerHTML = advertisers.map((adv, idx) => {
        const spotText = adv.spots.length > 1 ? `Spots ${adv.spots.join(', ')}` : `Spot ${adv.spots[0]}`;
        return `
          <label class="flex items-start gap-2 p-2 hover:bg-gray-50 rounded cursor-pointer">
            <input type="checkbox" value="${idx}" checked class="mt-0.5" />
            <div class="flex-1">
              <div class="font-medium text-sm">${esc(adv.name)}</div>
              <div class="text-xs text-gray-600">${spotText} ‚Ä¢ Status: ${esc(adv.status)}</div>
            </div>
          </label>
        `;
      }).join('');

      document.getElementById("advertiserChecklistContainer").classList.remove('hidden');
    }

    async function createNewPostcard() {
      // Get form values
      const isNewTown = document.querySelector('input[name="townOption"][value="new"]').checked;
      const town = isNewTown ?
        document.getElementById("newPostcardTownInput").value.trim() :
        document.getElementById("newPostcardTownSelect").value;

      const month = document.getElementById("newPostcardMonth").value;
      const year = document.getElementById("newPostcardYear").value;
      const inHomesDate = document.getElementById("newPostcardInHomesDate").value;
      const postcardSize = document.getElementById("newPostcardSize").value;

      // Validation
      if (!town) {
        toast("Please select or enter a town name", false);
        return;
      }

      if (!inHomesDate) {
        toast("Please select an in-homes date", false);
        return;
      }

      // Show loading state
      const btn = document.getElementById('btnCreatePostcard');
      const originalText = btn.innerHTML;
      btn.disabled = true;
      btn.innerHTML = '‚è≥ Creating...';

      try {

        // Build mail date - store in ISO format (YYYY-MM-DD) to avoid timezone issues
        const mailDate = `${year}-${month.padStart(2, '0')}-01`;  // e.g., "2025-12-01"

        // Build display name for duplicate check
        const monthNames = ["", "January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"];
        const displayDate = `${monthNames[parseInt(month)]} ${year}`;

        // Check for duplicates using town and month/year
        const duplicate = state.mailers.find(m => {
          const mDate = new Date(m.Mail_Date);
          return m.Town.toLowerCase() === town.toLowerCase() &&
                 mDate.getMonth() + 1 === parseInt(month) &&
                 mDate.getFullYear() === parseInt(year);
        });
        if (duplicate) {
          toast("A postcard for this town and date already exists!", false);
          btn.disabled = false;
          btn.innerHTML = originalText;
          return;
        }

        // Create new postcard object
        const newPostcard = {
          Mailer_ID: `${town.replace(/\s+/g, '-')}-${month.padStart(2, '0')}-${year}`,
          Town: town,
          Mail_Date: mailDate,  // Store as "12/1/2025" format
          In_Homes_Date: inHomesDate,
          Payment_Status: "Active",  // Set to Active by default
          Postcard_Size: postcardSize,  // Store size (9x12)
          availability: {},
          Postcard_BG: "#000000",
          Banner_BG: "#000000"  // Black background (will display white text via useLightTextOn)
        };

        // Initialize all spots as available
        for (let i = 1; i <= 18; i++) {
          newPostcard.availability[`Spot_${i}`] = "Available";
        }

        // Handle copy from previous
        if (document.getElementById("copyFromPrevious").checked) {
          const sourceIndex = document.getElementById("copySourcePostcard").value;
          if (sourceIndex) {
            const sourcePostcard = state.mailers[sourceIndex];
            const checklist = document.getElementById("advertiserChecklist");
            const checkedBoxes = checklist.querySelectorAll('input[type="checkbox"]:checked');

            // Collect selected advertisers
            const advertisers = [];
            for (let i = 1; i <= 18; i++) {
              const spotKey = `Spot_${i}`;
              const raw = (sourcePostcard.availability || {})[spotKey] || "Available";
              if (!/^available$/i.test(raw)) {
                const match = String(raw).match(/^(.+?)\s*:\s*(.*)$/);
                if (match) {
                  const name = match[2].trim();
                  if (name) {
                    const existing = advertisers.find(a => a.name.toLowerCase() === name.toLowerCase());
                    if (existing) {
                      existing.spots.push(i);
                    } else {
                      advertisers.push({ name, spots: [i] });
                    }
                  }
                }
              }
            }

            // Apply selected advertisers to new postcard with "Reserved" status
            checkedBoxes.forEach(checkbox => {
              const idx = parseInt(checkbox.value);
              const adv = advertisers[idx];
              if (adv) {
                adv.spots.forEach(spotNum => {
                  newPostcard.availability[`Spot_${spotNum}`] = `Reserved:${adv.name}`;
                });
              }
            });
          }
        }

        // Handle copy expenses from previous
        if (document.getElementById("copyExpensesFromPrevious").checked) {
          const sourceIndex = document.getElementById("copySourcePostcard").value;
          if (sourceIndex) {
            const sourcePostcard = state.mailers[sourceIndex];
            const sourceMailerId = sourcePostcard.Mailer_ID;

            // Check if source postcard has expenses
            if (productionState.expenses[sourceMailerId]) {
              const sourceExpenses = productionState.expenses[sourceMailerId];

              // Copy expenses to new postcard
              productionState.expenses[newPostcard.Mailer_ID] = {
                printing: sourceExpenses.printing || 0,
                postage: sourceExpenses.postage || 0,
                design: sourceExpenses.design || 0,
                misc: sourceExpenses.misc || 0
              };

              // Save expenses to cloud
              await saveExpenses();

              console.log(`‚úÖ Copied expenses from ${sourceMailerId} to ${newPostcard.Mailer_ID}`);
            }
          }
        }

        // Add the new postcard to state.mailers
        state.mailers.push(newPostcard);

        // Sort mailers by date (newest first), then by town (alphabetically)
        state.mailers = state.mailers.sort((a, b) => {
          const dateA = a.Mail_Date || '';
          const dateB = b.Mail_Date || '';
          if (dateA !== dateB) {
            return dateB.localeCompare(dateA); // Reverse order for descending
          }
          const townA = (a.Town || '').toLowerCase();
          const townB = (b.Town || '').toLowerCase();
          return townA.localeCompare(townB);
        });

        // Find the index of the newly created postcard after sorting
        const newIndex = state.mailers.findIndex(m => m.Mailer_ID === newPostcard.Mailer_ID);

        // Update the dropdown selectors
        const selManager = document.getElementById("postcardSelect");

        const selectHtml = '<option value="">‚Äî Select ‚Äî</option>' +
          state.mailers.map((m,i)=>{
            // Format date display
            let displayDate = m.Mail_Date || "";
            if (/^\d{4}-\d{2}-\d{2}/.test(displayDate)) {
              const [year, month] = displayDate.split('-');
              const monthNames = ["", "January", "February", "March", "April", "May", "June",
                                  "July", "August", "September", "October", "November", "December"];
              displayDate = `${monthNames[parseInt(month)]} ${year}`;
            }
            // Add size indicator to label
            const sizeLabel = m.Postcard_Size ? ` (${m.Postcard_Size})` : '';
            return `<option value="${i}">${esc(m.Town)} ‚Äî ${esc(displayDate)}${sizeLabel}</option>`;
          }).join("");

        if (selManager) {
          selManager.innerHTML = selectHtml;
          selManager.value = newIndex.toString();
        }

        // Repopulate town and month selectors and set to new postcard
        populateTownAndMonthSelectors();
        const townSelect = document.getElementById("headerTownSelect");
        const monthSelect = document.getElementById("headerMonthSelect");
        if (townSelect && newPostcard.Town) {
          townSelect.value = newPostcard.Town;
          onTownChanged(); // Populate month dropdown for this town
          if (monthSelect && newPostcard.Mail_Date) monthSelect.value = newPostcard.Mail_Date;
        }

        // Save to cloud immediately
        btn.innerHTML = '‚òÅÔ∏è Saving to cloud...';

        try {
          // Insert into Supabase with snake_case column names
          const { error } = await supabaseClient
            .from('postcards')
            .insert({
              user_email: ACTIVE_USER,
              mailer_id: newPostcard.Mailer_ID,
              town: newPostcard.Town,
              mail_date: newPostcard.Mail_Date,
              in_homes_date: newPostcard.In_Homes_Date,
              payment_status: newPostcard.Payment_Status,
              postcard_size: newPostcard.Postcard_Size || '9x12',
              postcard_bg: newPostcard.Postcard_BG,
              banner_bg: newPostcard.Banner_BG,
              spot_1: newPostcard.availability.Spot_1 || 'Available',
              spot_2: newPostcard.availability.Spot_2 || 'Available',
              spot_3: newPostcard.availability.Spot_3 || 'Available',
              spot_4: newPostcard.availability.Spot_4 || 'Available',
              spot_5: newPostcard.availability.Spot_5 || 'Available',
              spot_6: newPostcard.availability.Spot_6 || 'Available',
              spot_7: newPostcard.availability.Spot_7 || 'Available',
              spot_8: newPostcard.availability.Spot_8 || 'Available',
              spot_9: newPostcard.availability.Spot_9 || 'Available',
              spot_10: newPostcard.availability.Spot_10 || 'Available',
              spot_11: newPostcard.availability.Spot_11 || 'Available',
              spot_12: newPostcard.availability.Spot_12 || 'Available',
              spot_13: newPostcard.availability.Spot_13 || 'Available',
              spot_14: newPostcard.availability.Spot_14 || 'Available',
              spot_15: newPostcard.availability.Spot_15 || 'Available',
              spot_16: newPostcard.availability.Spot_16 || 'Available',
              spot_17: newPostcard.availability.Spot_17 || 'Available',
              spot_18: newPostcard.availability.Spot_18 || 'Available'
            });

          if (error) throw error;

          toast("‚úÖ Postcard created and saved to cloud!", true);

        } catch (cloudErr) {
          console.error("Failed to save to cloud:", cloudErr);
          toast("‚ö†Ô∏è Postcard created locally. Will sync on next spot edit.", false);
        }

        // Switch to the new postcard
        pickCampaign({ target: { value: newIndex.toString() } });

        // Reset button
        btn.disabled = false;
        btn.innerHTML = originalText;

        closeNewPostcardModal();

      } catch (err) {
        console.error("Failed to create postcard:", err);
        toast("‚ö†Ô∏è Error creating postcard: " + err.message, false);

        // Reset button
        btn.disabled = false;
        btn.innerHTML = originalText;
      }
    }

    /* ========= RENEWAL AUTOMATION ========= */

    function checkRenewals() {
      if (!state.current) return;
      
      const mailDate = new Date(state.current.Mail_Date);
      const today = new Date();
      const daysSinceDrop = Math.floor((today - mailDate) / (1000 * 60 * 60 * 24));
      
      const renewalContainer = document.getElementById('renewalList');
      if (!renewalContainer) return;
      
      if (daysSinceDrop >= 30) {
        const clients = Object.values(crmState.clients).filter(c => 
          c.history.some(h => h.campaign.includes(state.current.Town))
        );
        
        renewalContainer.innerHTML = clients.map(c => `
          <div class="p-3 border rounded-lg bg-white">
            <div class="font-semibold">${esc(c.businessName)}</div>
            <div class="text-sm text-gray-600">Ready for renewal outreach</div>
            <button onclick="openEmailRenewal('${c.id}')" class="mt-2 text-sm px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700">
              Send Renewal Email
            </button>
          </div>
        `).join('');
      } else {
        renewalContainer.innerHTML = `<p class="text-sm text-gray-500">No renewals due yet (${30 - daysSinceDrop} days remaining)</p>`;
      }
    }
    
    function openEmailRenewal(clientId) {
      const client = crmState.clients[clientId];
      if (!client) return;
      
      openEmailModal();
      document.getElementById('emailTemplate').value = 'renewal';
      loadEmailTemplate();
      document.getElementById('emailTo').value = client.contact.email;
      
      // Replace placeholders
      let subject = document.getElementById('emailSubject').value;
      let body = document.getElementById('emailBody').value;
      subject = subject.replace('{businessName}', client.businessName);
      body = body.replace('{contactName}', client.contact.name || 'there');
      body = body.replace('{campaign}', state.current ? `${state.current.Town} ${state.current.Mail_Date}` : 'our campaign');
      
      document.getElementById('emailSubject').value = subject;
      document.getElementById('emailBody').value = body;
    }

    // Delete the current postcard
    async function deleteCurrentPostcard() {
      if (!state.current) {
        toast('No postcard selected', false);
        return;
      }

      const postcard = state.current;
      const confirmMsg = `Are you sure you want to delete the postcard for ${postcard.Town} ‚Äî ${postcard.Mail_Date}?\n\nThis action cannot be undone.`;

      if (!confirm(confirmMsg)) return;

      try {
        // Delete from Supabase
        const { error } = await supabaseClient
          .from('postcards')
          .delete()
          .eq('user_email', ACTIVE_USER)
          .eq('mailer_id', postcard.Mailer_ID);

        if (error) throw error;

        // Remove from state
        const currentIndex = state.mailers.findIndex(m => m.Mailer_ID === postcard.Mailer_ID);
        if (currentIndex !== -1) {
          state.mailers.splice(currentIndex, 1);
        }

        // Clear current selection
        state.current = null;
        state.availability = {};
        state.initial = {};
        state.merged.clear();
        state.selected.clear();
        state.dirty = false;

        // Refresh dropdowns
        populateTownAndMonthSelectors();

        // Select first postcard if available
        if (state.mailers.length > 0) {
          pickCampaign({ target: { value: '0' } });
        } else {
          renderAll();
        }

        toast(`‚úÖ Postcard for ${postcard.Town} deleted successfully`, true);

      } catch (err) {
        console.error('Error deleting postcard:', err);
        toast('Failed to delete postcard', false);
      }
    }

    /* ========= PERSISTED COLORS ========= */
    const POSTCARD_BG_KEY = "mailslot-postcard-bg";
    const BANNER_BG_KEY = "mailslot-banner-bg";
    
    function loadPostcardBg() {
      try {
        const v = localStorage.getItem(POSTCARD_BG_KEY) || "#000000";
        return v;
      } catch (_) { return "#000000"; }
    }
    
    function loadBannerBg() {
      try {
        const v = localStorage.getItem(BANNER_BG_KEY) || "#000000";
        return v;
      } catch (_) { return "#000000"; }
    }
    
    function savePostcardBg(hex) {
      try { localStorage.setItem(POSTCARD_BG_KEY, hex); } catch(_) {}
    }
    
    function saveBannerBg(hex) {
      try { localStorage.setItem(BANNER_BG_KEY, hex); } catch(_) {}
    }
    
    function applyStagedColors() {
      document.querySelectorAll('.postcard').forEach(el => {
        el.style.backgroundColor = stagedColors.Postcard_BG;
        const border = shadeBlend(stagedColors.Postcard_BG, -0.15) || '#e5e7eb';
        el.style.borderColor = border;
      });
      document.querySelectorAll('.banner').forEach(b => {
        b.style.backgroundColor = stagedColors.Banner_BG;
        const border = shadeBlend(stagedColors.Banner_BG, -0.12) || '#e5e7eb';
        b.style.borderColor = border;
        b.style.color = useLightTextOn(stagedColors.Banner_BG) ? '#fff' : '#0f172a';
      });
      const previewPostcard = document.getElementById('previewPostcard');
      const previewBanner = document.getElementById('previewBanner');
      if (previewPostcard) previewPostcard.style.backgroundColor = stagedColors.Postcard_BG;
      if (previewBanner) {
        previewBanner.style.backgroundColor = stagedColors.Banner_BG;
        previewBanner.style.color = useLightTextOn(stagedColors.Banner_BG) ? '#fff' : '#0f172a';
      }
    }
    
    function shadeBlend(hex, percent) {
      try {
        const h = hex.replace('#','');
        const r = parseInt(h.substring(0,2),16), g = parseInt(h.substring(2,4),16), b = parseInt(h.substring(4,6),16);
        const t = percent < 0 ? 0 : 255;
        const p = Math.abs(percent);
        const R = Math.round((t - r) * p) + r;
        const G = Math.round((t - g) * p) + g;
        const B = Math.round((t - b) * p) + b;
        return '#' + [R,G,B].map(x => x.toString(16).padStart(2,'0')).join('');
      } catch (e) { return null; }
    }
    
    function linearize(v){ return v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4); }
    function useLightTextOn(hex){ try{ const h = hex.replace('#',''); const r=parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16); const L = 0.2126*linearize(r/255)+0.7152*linearize(g/255)+0.0722*linearize(b/255); return L < 0.45; }catch(e){ return true; } }
    
    /* ========= INIT ========= */
    document.addEventListener("DOMContentLoaded", () => {
      try {
        const saved = JSON.parse(safeGetItem("mailslot-sort") || "{}");
        sortOrder = saved.order || [...CANONICAL_STATUSES];
        visibleStatuses = saved.visible || [...CANONICAL_STATUSES];
      } catch(_) {}
      updateColorMappings();
      renderLegend();
      
      stagedColors.Postcard_BG = loadPostcardBg();
      stagedColors.Banner_BG = loadBannerBg();
      document.getElementById('pickerPostcard').value = stagedColors.Postcard_BG;
      document.getElementById('pickerBanner').value = stagedColors.Banner_BG;
      applyStagedColors();

      // Load daily goal state from localStorage
      loadDailyGoalState();

      // Load all state from cloud (with localStorage fallback)
      Promise.allSettled([
        loadExpenses(),
        loadPricing(),
        loadRevenueGoals(),
        loadSpotPricing(),
        loadClients(),
        loadKanban(),
        loadTasks(),
        loadNotInterestedList(),
        loadManualProspects(),
        loadBusinessCategories()
      ]).then(results => {
        const succeeded = results.filter(r => r.status === 'fulfilled').length;
        const failed = results.filter(r => r.status === 'rejected').length;

        if (failed > 0) {
          console.warn(`‚ö†Ô∏è ${succeeded} data types loaded, ${failed} failed (using localStorage cache)`);
          const failedTypes = results
            .map((r, i) => r.status === 'rejected' ? ['expenses', 'pricing', 'revenueGoals', 'spotPricing', 'clients', 'kanban', 'tasks', 'notInterested', 'manualProspects', 'businessCategories'][i] : null)
            .filter(t => t !== null);
          console.warn('Failed types:', failedTypes.join(', '));

          // Show user notification about partial cloud sync failure
          toast(`‚ö†Ô∏è ${failed} data type(s) loaded from local cache (cloud unavailable)`, false);
        }

        // Load campaigns AFTER expenses and pricing are loaded so financial dashboard shows correct data
        console.log('‚úÖ Pricing data loaded. Loading campaigns...');
        loadCampaigns();
      });

      // Load API quota (local only)
      loadApiQuota();

      // Load prospect cache from cloud with merge
      loadPlacesCache().then(() => {
        renderProspectPool(); // Re-render to show loaded prospects

        // Save to cloud to ensure computer's data is uploaded
        savePlacesCache();
      }).catch(e => {
        console.error('Failed to load prospect cache:', e);
      });

      // Load spot pricing from localStorage as fallback (cloud load happens earlier)
      // This will be used if cloud sync fails or for migration
      try {
        const savedPricing = safeGetItem('mailslot-pricing');
        if (savedPricing && Object.keys(productionState.spotPricing).length === 0) {
          const rawPricing = JSON.parse(savedPricing);

          // FILTER: Only load valid spot prices (numbers with SPOT_ in key)
          // Prevents corrupted campaign-level pricing from localStorage
          productionState.spotPricing = {};
          Object.keys(rawPricing).forEach(key => {
            const value = rawPricing[key];
            if (typeof value === 'number' && !isNaN(value) && key.toUpperCase().includes('SPOT_')) {
              productionState.spotPricing[key.toUpperCase()] = value;
            }
          });

          console.log('üí∞ [LOCALSTORAGE MIGRATION] Loaded', Object.keys(productionState.spotPricing).length, 'valid spot prices from localStorage');

          // Migrate cleaned data to cloud
          if (Object.keys(productionState.spotPricing).length > 0) {
            saveSpotPricing();
          }
        }
      } catch(e) {}
      updateAutoSaveStatus(); // Initialize auto-save status indicator
      updateQuickApiUsage(); // Initialize API usage display in prospecting section

      // Initialize sales activity collapse state
      initSalesActivityState();

      // Restore last active tab, or default to pipeline
      const lastTab = localStorage.getItem('9x12_active_tab') || 'pipeline';
      switchTab(lastTab);

      window.addEventListener('resize', () => renderLegend());
      bindUI();

      // Ensure critical functions are globally accessible
      window.openExpenseModal = openExpenseModal;
      window.openReportsModal = openReportsModal;
      window.openEmailModal = openEmailModal;
      window.manualSaveNow = manualSaveNow;
      window.pickCampaign = pickCampaign;
      window.toggleCustomCategory = toggleCustomCategory;
      window.toggleBulkCustomCategory = toggleBulkCustomCategory;
      window.importClientsCSV = importClientsCSV;
      window.openAutoPopulateModal = openAutoPopulateModal;
      window.runBulkAutoPopulate = runBulkAutoPopulate;
      window.openProspectsResultsModal = openProspectsResultsModal;
      window.closeProspectsResultsModal = closeProspectsResultsModal;
      window.toggleProspectSelection = toggleProspectSelection;
      window.markNotInterested = markNotInterested;
      window.addSelectedProspects = addSelectedProspects;
      window.editLead = editLead;
      window.deleteLead = deleteLead;
      window.openLeadModal = openLeadModal;
      window.saveLeadModal = saveLeadModal;
      window.toggleCloudSyncUI = toggleCloudSyncUI;
      window.toggleProspectForSync = toggleProspectForSync;
      window.saveSelectedProspectsToCloud = saveSelectedProspectsToCloud;
      window.closeLeadModal = closeLeadModal;
      window.togglePoolProspect = togglePoolProspect;
      window.selectCategoryProspects = selectCategoryProspects;
      window.addFromProspectPool = addFromProspectPool;
      window.clearProspectPool = clearProspectPool;
      window.renderProspectPool = renderProspectPool;
      window.switchTab = switchTab;
      window.deleteCurrentPostcard = deleteCurrentPostcard;
    });
    
    function bindUI(){
      const btn = (id, handler) => {
        const el = document.getElementById(id);
        if (el) el.onclick = handler;
      };

      btn("btnCancelEdit", closeEditModal);
      btn("btnApplyEdit", applyEditModal);
      btn("btnCancelPostcard", closePostcardModal);
      btn("btnApplyPostcard", applyPostcardModal);
      btn("btnAdjustPostcard", openPostcardModal);
      btn("btnCancelEditStatus", closeEditStatusModal);
      btn("btnSaveEditStatus", saveEditStatusModal);

      // Duplicate modal
      btn("btnCancelDuplicate", closeDuplicatePostcardModal);
      btn("btnCreateDuplicate", createDuplicatePostcard);

      // Pricing modal
      btn("btnCancelPricing", closePricingModal);
      btn("btnSavePricing", savePricingModal);

      // Sync top pricing inputs to bottom calculator
      ["pricingSingleAd", "pricingDoubleAd", "pricingBannerAd"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('input', syncPricingToCalculator);
      });

      // Expense modal
      btn("btnCancelExpense", closeExpenseModal);
      btn("btnSaveExpense", saveExpenseModal);
      ["expensePrinting", "expensePostage", "expenseDesign", "expenseMisc"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('input', updateExpenseTotal);
      });
      
      // Client modal
      document.getElementById('btnCancelClient').onclick = closeClientModal;
      document.getElementById('btnSaveClient').onclick = saveClientModal;
      document.getElementById('btnDeleteClient').onclick = deleteClientModal;
      
      // Email modal
      document.getElementById('btnCancelEmail').onclick = closeEmailModal;
      document.getElementById('btnSendEmail').onclick = sendEmail;
      
      // Reports modal
      document.getElementById('btnCloseReports').onclick = closeReportsModal;

      // Task modal
      document.getElementById('btnCancelTask').onclick = closeTaskModal;
      document.getElementById('btnSaveTask').onclick = saveTaskModal;

      // Lead modal
      document.getElementById('btnCancelLead').onclick = closeLeadModal;
      document.getElementById('btnSaveLead').onclick = saveLeadModal;

      // Contact Later modal
      document.getElementById('btnCancelContactLater').onclick = closeContactLaterModal;
      document.getElementById('btnSaveContactLater').onclick = saveContactLater;

      // Auto-populate modal
      document.getElementById('btnCancelAutoPopulate').onclick = closeAutoPopulateModal;
      document.getElementById('btnRunAutoPopulate').onclick = runAutoPopulate;

      // Financial transaction modals
      document.getElementById('btnCancelAddTransaction').onclick = closeAddTransactionModal;
      document.getElementById('btnSaveAddTransaction').onclick = saveAddTransaction;
      document.getElementById('btnCancelEditTransaction').onclick = closeEditTransactionModal;
      document.getElementById('btnSaveEditTransaction').onclick = saveEditTransaction;

      // New Postcard modal
      document.getElementById('btnCancelNewPostcard').onclick = closeNewPostcardModal;
      document.getElementById('btnCreatePostcard').onclick = createNewPostcard;
      
      document.getElementById("pickerPostcard").addEventListener('input', (e)=> { stagedColors.Postcard_BG = e.target.value; previewPostcardModal(); });
      document.getElementById("pickerBanner").addEventListener('input', (e)=> { stagedColors.Banner_BG = e.target.value; previewPostcardModal(); });
     
      const commitBtn = document.getElementById("btnSaveCommit");
      if (commitBtn) {
        commitBtn.onclick = function() {
          return saveToSheet();
        };
      } else {
        console.error('‚ùå btnSaveCommit not found!');
      }
     
      window.addEventListener('beforeunload', (e) => {
        if (state.dirty) {
          // Attempt to auto-save before leaving
          performAutoSave();

          // Still show warning in case save isn't complete
          e.preventDefault();
          e.returnValue = 'You have unsaved changes. We are attempting to save them now.';
        }
      });
      
      document.addEventListener('click', (e)=> {
        if (e.target.matches('.sort-up') || e.target.matches('.sort-down')) handleSortUpDown(e);
      });
      
      document.getElementById("navTabs").addEventListener('click', (e) => {
          const target = e.target.closest('.tab-btn');
          if (!target) return;
          const tabName = target.dataset.tab;
          switchTab(tabName);
      });

      // Don't call switchTab here - it's already restored at line 6730
    }
    
    function switchTab(tabName) {
        // Auto-save before switching tabs if there are unsaved changes
        if (state.dirty) {
            performAutoSave(); // Immediate save on tab switch
        }

        // Save current tab to remember it on refresh
        localStorage.setItem('9x12_active_tab', tabName);

        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        const activeBtn = document.querySelector(`.tab-btn[data-tab="${tabName}"]`);
        if (activeBtn) {
            activeBtn.classList.add('active');
        }

        document.querySelectorAll('.tab-pane').forEach(pane => {
            pane.classList.add('hidden');
            pane.classList.remove('active-pane');
        });
        const activePane = document.querySelector(`.tab-pane[data-content="${tabName}"]`);
        if (activePane) {
            activePane.classList.remove('hidden');
            activePane.classList.add('active-pane');
        }

        const legendArea = document.getElementById("legendArea");
        if (legendArea) show(legendArea, tabName === 'manager');

        // Show/hide postcard selector - only visible on Postcards & Activation tab
        const selectorContainer = document.getElementById("postcardSelectorContainer");
        if (selectorContainer) {
            if (tabName === 'manager') {
                selectorContainer.classList.remove('hidden');
            } else {
                selectorContainer.classList.add('hidden');
            }
        }

        if (tabName === 'manager') {
            renderAll();
        } else if (tabName === 'pipeline') {
            renderCardsInProgress();
        } else if (tabName === 'clients') {
            renderClientList();
        } else if (tabName === 'admin') {
            // Load financial data when Financials tab is opened
            if (!financialState.loaded) {
                loadFinancialData();
            } else {
                renderFinancialRegister();
            }
        } else if (tabName === 'prospects') {
            renderProspectPool();
        }
    }
    
    /* ========= LOAD CAMPAIGNS ========= */
    async function loadCampaigns(restoreMailerId = null) {
      try {
        console.log('üì• LOADING FROM SUPABASE for user:', ACTIVE_USER, 'restoreMailerId:', restoreMailerId);

        const { data, error } = await supabaseClient
          .from('postcards')
          .select('*')
          .eq('user_email', ACTIVE_USER)
          .order('mail_date', { ascending: false });

        if (error) throw error;

        console.log('üì• SUPABASE LOAD SUCCESS:', data?.length, 'postcards loaded');
        if (data && data.length > 0) {
          console.log('üì• First postcard sample:', data[0]);
        }

        // Transform Supabase column names to match app expectations
        const mailers = (data || []).map(postcard => ({
          Mailer_ID: postcard.mailer_id,
          Town: postcard.town,
          Mail_Date: postcard.mail_date,
          In_Homes_Date: postcard.in_homes_date,
          Payment_Status: postcard.payment_status,
          Postcard_Size: postcard.postcard_size || '9x12',
          Postcard_BG: postcard.postcard_bg,
          Banner_BG: postcard.banner_bg,
          Spot_1: postcard.spot_1,
          Spot_2: postcard.spot_2,
          Spot_3: postcard.spot_3,
          Spot_4: postcard.spot_4,
          Spot_5: postcard.spot_5,
          Spot_6: postcard.spot_6,
          Spot_7: postcard.spot_7,
          Spot_8: postcard.spot_8,
          Spot_9: postcard.spot_9,
          Spot_10: postcard.spot_10,
          Spot_11: postcard.spot_11,
          Spot_12: postcard.spot_12,
          Spot_13: postcard.spot_13,
          Spot_14: postcard.spot_14,
          Spot_15: postcard.spot_15,
          Spot_16: postcard.spot_16,
          Spot_17: postcard.spot_17,
          Spot_18: postcard.spot_18
        }));

        onCampaignsLoaded(mailers, restoreMailerId);
      } catch (err) {
        console.error('Failed to load campaigns from Supabase:', err);
        toast("‚ö†Ô∏è Failed to load campaigns. Please refresh.", false);
      }
    }
    
    function jsonpLoad(url, cb){
      const cbName = "cb_" + Math.random().toString(36).slice(2);
      window[cbName] = (data) => { try{ cb(data); } finally { delete window[cbName]; s.remove(); } };
      const s = document.createElement("script");
      s.src = url + (url.includes("?") ? "&" : "?") + "callback=" + cbName;
      s.async = true;
      s.onerror = () => toast("Load failed", false);
      document.head.appendChild(s);
    }
    
    function onCampaignsLoaded(res, restoreMailerId = null){
      // Backend returns array directly, not wrapped in {mailers: []}
      let mailers = Array.isArray(res) ? res : (res && res.mailers) ? res.mailers : [];

      // Sort by date (newest first), then by town (alphabetically)
      mailers = mailers.sort((a, b) => {
        // Compare dates in descending order (newest first)
        const dateA = a.Mail_Date || '';
        const dateB = b.Mail_Date || '';
        if (dateA !== dateB) {
          return dateB.localeCompare(dateA); // Reverse order for descending
        }
        // If dates are the same, sort by town alphabetically
        const townA = (a.Town || '').toLowerCase();
        const townB = (b.Town || '').toLowerCase();
        return townA.localeCompare(townB);
      });

      state.mailers = mailers;
      const selectHtml = '<option value="">‚Äî Select ‚Äî</option>' +
        mailers.map((m,i)=>{
          // Format date: handle both formatted strings and date objects
          let displayDate = m.Mail_Date || "";

          // Check if it's already in "Month Year" format (like "December 2025")
          const isMonthYearFormat = displayDate && /^[A-Za-z]+ \d{4}$/.test(displayDate);

          if (!isMonthYearFormat && displayDate) {
            // Parse and format the date (handle ISO format YYYY-MM-DD)
            try {
              // If it's ISO format (YYYY-MM-DD), parse it without timezone issues
              if (/^\d{4}-\d{2}-\d{2}/.test(displayDate)) {
                const [year, month] = displayDate.split('-');
                const monthNames = ["", "January", "February", "March", "April", "May", "June",
                                    "July", "August", "September", "October", "November", "December"];
                displayDate = `${monthNames[parseInt(month)]} ${year}`;
              } else {
                const date = new Date(displayDate);
                if (!isNaN(date.getTime())) {
                  displayDate = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                }
              }
            } catch (e) {
              // Keep original if parsing fails
            }
          }

          const sizeLabel = m.Postcard_Size ? ` (${m.Postcard_Size})` : '';
          return `<option value="${i}">${esc(m.Town)} ‚Äî ${displayDate}${sizeLabel}</option>`;
        }).join("");
      const selManager = document.getElementById("postcardSelect");

      if (selManager) {
        selManager.innerHTML = selectHtml;
        selManager.onchange = pickCampaign;
      }

      // Populate town and month dropdowns
      populateTownAndMonthSelectors();

      renderAll();

      // Determine which postcard to select
      let selectedIndex = -1;

      // If restoring a specific campaign, find it by Mailer_ID
      let mailerIdToRestore = restoreMailerId;

      // If no restoreMailerId provided, check localStorage (for page refresh)
      if (!mailerIdToRestore) {
        const savedMailerId = safeGetItem('mailslot-selectedMailerId');
        if (savedMailerId) {
          mailerIdToRestore = savedMailerId;
          console.log('üìÇ Found saved campaign in localStorage:', savedMailerId);
        }
      }

      if (mailerIdToRestore) {
        console.log('üîç Looking for mailer_id:', mailerIdToRestore, 'type:', typeof mailerIdToRestore);
        console.log('üîç Available mailer_ids:', mailers.map(m => ({id: m.Mailer_ID, type: typeof m.Mailer_ID, town: m.Town})));

        // Try both strict and loose comparison in case of type mismatch
        selectedIndex = mailers.findIndex(m => m.Mailer_ID === mailerIdToRestore || m.Mailer_ID == mailerIdToRestore);

        if (selectedIndex !== -1) {
          console.log('üìå Restoring campaign:', mailers[selectedIndex].Town, mailers[selectedIndex].Mail_Date);
        } else {
          console.warn('‚ö†Ô∏è Could not find campaign with mailer_id:', mailerIdToRestore);
        }
      }

      // If not found or no restore ID, auto-select the most recent postcard (last in array)
      if (selectedIndex === -1 && mailers.length > 0) {
        selectedIndex = mailers.length - 1;
      }

      if (selectedIndex !== -1) {
        if (selManager) selManager.value = selectedIndex.toString();

        // Set town and month selectors to match the selected postcard
        const selected = mailers[selectedIndex];
        const townSelect = document.getElementById("headerTownSelect");
        const monthSelect = document.getElementById("headerMonthSelect");
        if (townSelect && selected.Town) {
          townSelect.value = selected.Town;
          populateMonthsForTown(selected.Town); // Populate month dropdown without triggering events
          if (monthSelect && selected.Mail_Date) monthSelect.value = selected.Mail_Date;
        }

        pickCampaign({ target: { value: selectedIndex.toString() } });
      }

      // Render cards in progress on dashboard
      renderCardsInProgress();
    }

    // Populate town selector from available mailers
    function populateTownAndMonthSelectors() {
      const townSelect = document.getElementById("headerTownSelect");

      if (!townSelect) return;

      // Get unique towns (sorted alphabetically)
      const towns = [...new Set(state.mailers.map(m => m.Town))].sort();

      // Populate town dropdown
      townSelect.innerHTML = '<option value="">‚Äî Select Town ‚Äî</option>' +
        towns.map(town => `<option value="${esc(town)}">${esc(town)}</option>`).join('');

      // Month dropdown will be populated when town is selected
      const monthSelect = document.getElementById("headerMonthSelect");
      if (monthSelect) {
        monthSelect.innerHTML = '<option value="">‚Äî Select Town First ‚Äî</option>';
        monthSelect.disabled = true;
      }
    }

    // When town changes, populate month dropdown with only months for that town
    function onTownChanged() {
      // Prevent circular updates when syncing dropdowns programmatically
      if (state.updatingSelectors) return;

      const townSelect = document.getElementById("headerTownSelect");
      const monthSelect = document.getElementById("headerMonthSelect");

      if (!townSelect || !monthSelect) return;

      const selectedTown = townSelect.value;

      if (!selectedTown) {
        // No town selected, disable month dropdown
        monthSelect.innerHTML = '<option value="">‚Äî Select Town First ‚Äî</option>';
        monthSelect.disabled = true;
        return;
      }

      // Filter mailers for this town only
      const townMailers = state.mailers.filter(m => m.Town === selectedTown);

      if (townMailers.length === 0) {
        monthSelect.innerHTML = '<option value="">‚Äî No cards for this town ‚Äî</option>';
        monthSelect.disabled = true;
        return;
      }

      // Get months for this town (sorted by date descending - newest first)
      const monthDates = townMailers.map(m => m.Mail_Date).sort((a, b) => b.localeCompare(a));

      // Enable and populate month dropdown
      monthSelect.disabled = false;
      monthSelect.innerHTML = '<option value="">‚Äî Select Month ‚Äî</option>' +
        monthDates.map(date => {
          // Find the mailer for this date to get its size
          const mailer = townMailers.find(m => m.Mail_Date === date);
          let displayDate = date;
          if (/^\d{4}-\d{2}-\d{2}/.test(date)) {
            const [year, month] = date.split('-');
            const monthNames = ["", "January", "February", "March", "April", "May", "June",
                                "July", "August", "September", "October", "November", "December"];
            displayDate = `${monthNames[parseInt(month)]} ${year}`;
          }
          // Add size indicator to label
          const sizeLabel = mailer?.Postcard_Size ? ` (${mailer.Postcard_Size})` : '';
          return `<option value="${esc(date)}">${esc(displayDate)}${sizeLabel}</option>`;
        }).join('');

      // If there's only one month for this town, auto-select it
      if (monthDates.length === 1) {
        monthSelect.value = monthDates[0];
        updatePostcardFromSelectors();
      } else {
        // Town changed but no month auto-selected - refresh prospect pool to show prospects for this town
        renderProspectPool();
      }
    }

    // Update selected postcard when town or month selector changes
    function updatePostcardFromSelectors() {
      // Prevent circular updates when syncing dropdowns programmatically
      if (state.updatingSelectors) return;

      const townSelect = document.getElementById("headerTownSelect");
      const monthSelect = document.getElementById("headerMonthSelect");

      if (!townSelect || !monthSelect) return;

      const selectedTown = townSelect.value;
      const selectedMonth = monthSelect.value;

      // If either is not selected, don't do anything
      if (!selectedTown || !selectedMonth) {
        return;
      }

      // Find the postcard that matches both town and month
      const matchingIndex = state.mailers.findIndex(m =>
        m.Town === selectedTown && m.Mail_Date === selectedMonth
      );

      if (matchingIndex !== -1) {
        // Update the manager selector if it exists
        const selManager = document.getElementById("postcardSelect");
        if (selManager) selManager.value = matchingIndex.toString();

        // Select this postcard
        pickCampaign({ target: { value: matchingIndex.toString() } });
      } else {
        toast('No postcard found for this town and month combination', false);
      }
    }

    /* ========= LEGEND & SORT ========= */
    function renderLegend(){
      const grid = document.getElementById("legendGrid");
      if (!grid) return; // Legend moved to Edit Status modal
      grid.innerHTML = "";
      const visibleSorted = sortOrder.filter(st => visibleStatuses.includes(st));
      visibleSorted.forEach(st => {
        const item = document.createElement("div");
        item.className = "legend-item";
        const dot = document.createElement("span");
        dot.className = `legend-dot`;
        dot.style.backgroundColor = STATUS_HEX[st] || GRADIENT_HEX[0];
        const txt = document.createElement("span");
        txt.textContent = st;
        item.appendChild(dot);
        item.appendChild(txt);
        grid.appendChild(item);
      });
      requestAnimationFrame(() => {
        const children = Array.from(grid.children);
        let totalW = 0;
        children.forEach((c) => {
          const r = c.getBoundingClientRect();
          totalW += Math.ceil(r.width);
        });
        const gap = 8 * (children.length - 1);
        const needed = totalW + gap;
        const available = grid.clientWidth;
        if (needed <= available) {
          grid.style.flexWrap = 'nowrap';
        } else {
          grid.style.flexWrap = 'wrap';
        }
      });
    }
    
    /* ========= PICK CAMPAIGN ========= */
    function pickCampaign(e){
      const i = e.target.value;
      if (!state.mailers[i]) {
        state.current = null;
        state.availability = {};
        state.initial = {};
        state.merged.clear();
        state.selected.clear();
        state.dirty = false;
        renderAll();
        updateFinancialDashboard();
        // Clear localStorage selection
        safeRemoveItem('mailslot-selectedMailerId');
        return;
      }
      const m = state.mailers[i];
      state.current = m;

      // Save selected campaign to localStorage for page refresh persistence
      if (m.Mailer_ID) {
        safeSetItem('mailslot-selectedMailerId', m.Mailer_ID);
      }
      state.availability = {};
      state.initial = {};
      state.merged.clear();
      state.selected.clear();
      state.dirty = false;
      updateToolbar();

      console.log('üìã LOADING POSTCARD:', {
        Mailer_ID: m.Mailer_ID,
        Town: m.Town,
        Mail_Date: m.Mail_Date,
        spots_sample: {
          Spot_1: m.Spot_1,
          Spot_2: m.Spot_2,
          Spot_3: m.Spot_3
        }
      });

      for (let s=1; s<=18; s++){
        // Get spot data directly from mailer object (comes from sheet columns Spot_1, Spot_2, etc.)
        const raw = m[`Spot_${s}`] || "Available";
        if (/^available$/i.test(raw)) {
          state.availability[`Spot_${s}`] = { name:"", status:"Available" };
          state.initial[`Spot_${s}`] = "";
        } else {
          const m2 = String(raw).match(/^(.+?)\s*:\s*(.*)$/);
          let long = "Proof In Progress", name = "";
          if (m2) { long = m2[1].trim(); name = (m2[2]||"").trim(); }
          state.availability[`Spot_${s}`] = { name, status:long };
          state.initial[`Spot_${s}`] = `${long}:${name}`;
        }
      }
      
      // Load colors: use postcard data if available, otherwise fall back to localStorage
      if (m.Postcard_BG) {
        stagedColors.Postcard_BG = m.Postcard_BG;
        savePostcardBg(m.Postcard_BG);
      } else {
        // Fall back to localStorage
        stagedColors.Postcard_BG = loadPostcardBg();
        m.Postcard_BG = stagedColors.Postcard_BG; // Update postcard data with loaded color
      }
      document.getElementById('pickerPostcard').value = stagedColors.Postcard_BG;

      if (m.Banner_BG) {
        stagedColors.Banner_BG = m.Banner_BG;
        saveBannerBg(m.Banner_BG);
      } else {
        // Fall back to localStorage
        stagedColors.Banner_BG = loadBannerBg();
        m.Banner_BG = stagedColors.Banner_BG; // Update postcard data with loaded color
      }
      document.getElementById('pickerBanner').value = stagedColors.Banner_BG;

      applyStagedColors();
      
      PAIRS.forEach(([a,b])=>{
        const A = (state.availability[`Spot_${a}`].name||"").toLowerCase().trim().replace(/\s+/g,' ');
        const B = (state.availability[`Spot_${b}`].name||"").toLowerCase().trim().replace(/\s+/g,' ');
        if (A && A===B) state.merged.add(keyPair(a,b));
        else state.merged.delete(keyPair(a,b));
      });
      
      show(document.getElementById("legendArea"), true);
      renderAll();
      updateFinancialDashboard();
      checkRenewals();

      // Sync all dropdowns
      const selManager = document.getElementById("postcardSelect");
      const townSelect = document.getElementById("headerTownSelect");
      const monthSelect = document.getElementById("headerMonthSelect");

      if (selManager) selManager.value = i;

      // Update town and month selectors to match current postcard
      // Set flag to prevent circular updates/infinite recursion
      state.updatingSelectors = true;
      try {
        if (townSelect && m.Town) {
          townSelect.value = m.Town;
          // Manually populate month dropdown without triggering events
          populateMonthsForTown(m.Town);
          if (monthSelect && m.Mail_Date) monthSelect.value = m.Mail_Date;
        }
      } finally {
        // Always clear the flag, even if there's an error
        state.updatingSelectors = false;
      }
    }

    // Helper function to populate months without triggering onchange events
    function populateMonthsForTown(town) {
      const monthSelect = document.getElementById("headerMonthSelect");
      if (!monthSelect) return;

      const townMailers = state.mailers.filter(m => m.Town === town);

      if (townMailers.length === 0) {
        monthSelect.innerHTML = '<option value="">‚Äî No cards for this town ‚Äî</option>';
        monthSelect.disabled = true;
        return;
      }

      // Get months for this town (sorted by date descending - newest first)
      const monthDates = townMailers.map(m => m.Mail_Date).sort((a, b) => b.localeCompare(a));

      // Enable and populate month dropdown
      monthSelect.disabled = false;
      monthSelect.innerHTML = '<option value="">‚Äî Select Month ‚Äî</option>' +
        monthDates.map(date => {
          // Find the mailer for this date to get its size
          const mailer = townMailers.find(m => m.Mail_Date === date);
          let displayDate = date;
          if (/^\d{4}-\d{2}-\d{2}/.test(date)) {
            const [year, month] = date.split('-');
            const monthNames = ["", "January", "February", "March", "April", "May", "June",
                                "July", "August", "September", "October", "November", "December"];
            displayDate = `${monthNames[parseInt(month)]} ${year}`;
          }
          // Add size indicator to label
          const sizeLabel = mailer?.Postcard_Size ? ` (${mailer.Postcard_Size})` : '';
          return `<option value="${esc(date)}">${esc(displayDate)}${sizeLabel}</option>`;
        }).join('');
    }
    
    /* ========= RENDERING ========= */
    function renderAll(){
      renderFront();
      renderBack();
      updateToolbar();

      // Apply size-specific CSS class to postcard containers
      const frontPostcard = document.getElementById("frontPostcard");
      const backPostcard = document.getElementById("backPostcard");

      if (frontPostcard && backPostcard) {
        // Remove existing size classes
        frontPostcard.classList.remove('size-9x12', 'size-6x12');
        backPostcard.classList.remove('size-9x12', 'size-6x12');

        // Apply appropriate size class based on Postcard_Size
        const size = state.current?.Postcard_Size || '9x12';
        const sizeClass = size === '6.5x12' ? 'size-6x12' : 'size-9x12';

        frontPostcard.classList.add(sizeClass);
        backPostcard.classList.add(sizeClass);
      }
    }

    function renderCardsInProgress() {
      const container = document.getElementById('cardsInProgressSection');
      if (!container) {
        console.warn('cardsInProgressSection container not found');
        return;
      }

      console.log('Rendering cards in progress. Total mailers:', state.mailers.length);


      // Filter postcards that are "in progress" (not fully sold - includes 0 spots sold)
      const inProgressCards = state.mailers.filter(campaign => {
        const financials = calculateFinancials(campaign.Mailer_ID, campaign);
        if (!financials) {
          console.log('No financials for', campaign.Town, campaign.Mail_Date);
          return false;
        }
        const spotsSold = financials.metrics.spotsSold;
        const totalSpots = financials.metrics.effectiveTotalSpots;
        console.log(`${campaign.Town}: ${spotsSold}/${totalSpots} spots`);
        return spotsSold >= 0 && spotsSold < totalSpots;
      });

      console.log('Cards in progress:', inProgressCards.length);

      if (inProgressCards.length === 0) {
        container.innerHTML = '';
        return;
      }

      // Sort by date (soonest/earliest date first)
      inProgressCards.sort((a, b) => {
        const dateA = a.Mail_Date || '';
        const dateB = b.Mail_Date || '';
        return dateA.localeCompare(dateB); // Ascending order (earliest first)
      });

      // Build HTML
      let html = `
        <div class="mb-4">
          <h4 class="text-lg font-bold text-gray-800">You have ${inProgressCards.length} Card${inProgressCards.length !== 1 ? 's' : ''} in Progress</h4>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
      `;

      inProgressCards.forEach(campaign => {
        const financials = calculateFinancials(campaign.Mailer_ID, campaign);
        if (!financials) return;

        const spotsSold = financials.metrics.spotsSold;
        const totalSpots = financials.metrics.effectiveTotalSpots;
        const percent = Math.round(financials.metrics.progressPercent);

        // Extract month name from Mail_Date
        let monthName = campaign.Mail_Date;
        try {
          if (/^\d{4}-\d{2}-\d{2}/.test(campaign.Mail_Date)) {
            const month = parseInt(campaign.Mail_Date.split('-')[1]);
            const monthNames = ["", "January", "February", "March", "April", "May", "June",
                                "July", "August", "September", "October", "November", "December"];
            monthName = monthNames[month] || campaign.Mail_Date;
          }
        } catch (e) {
          // Keep original if parsing fails
        }

        html += `
          <div class="dashboard-widget cursor-pointer hover:shadow-xl hover:scale-105 transition-all duration-200 border-2 border-indigo-200"
               onclick="openPostcardCard('${campaign.Town.replace(/'/g, "\\'")}', '${campaign.Mail_Date}')">
            <div class="metric-label text-indigo-800 font-bold">${campaign.Town.toUpperCase()}</div>
            <div class="text-sm text-gray-600 mb-2">${monthName}</div>
            <div class="metric-value text-indigo-600 text-lg">${spotsSold}/${totalSpots}</div>
            <div class="text-sm text-gray-500">${percent}% complete</div>
            <div class="w-full h-2 bg-gray-200 rounded-full mt-2">
              <div class="h-2 bg-indigo-500 rounded-full transition-all duration-300" style="width: ${percent}%;"></div>
            </div>
          </div>
        `;
      });

      html += '</div>';
      container.innerHTML = html;
    }

    function openPostcardCard(town, mailDate) {
      // Set the selectors to the correct town and month
      const townSelect = document.getElementById("headerTownSelect");
      const monthSelect = document.getElementById("headerMonthSelect");

      if (townSelect && monthSelect) {
        townSelect.value = town;
        monthSelect.value = mailDate;
      }

      // Switch to the manager (Postcards & Activation) tab
      switchTab('manager');

      // Update the postcard view
      updatePostcardFromSelectors();
    }

    function renderFront(){
      const grid = document.getElementById("frontGrid");
      grid.innerHTML = "";
      if (!state.current) {
        renderPlaceholderFront(grid);
        return;
      }
      renderRow(grid,1,4);
      const banner = document.createElement("div");
      banner.className = "card col-span-4 banner";
      const town = state.current?.Town || "";
      const md = state.current?.Mail_Date || "";

      // Extract month name from mail date (e.g., "2025-12-01" -> "December")
      // Parse ISO format without timezone issues
      let monthName = "";
      if (md) {
        try {
          if (/^\d{4}-\d{2}-\d{2}/.test(md)) {
            // ISO format: extract month directly from string to avoid timezone issues
            const month = parseInt(md.split('-')[1]);
            const monthNames = ["", "January", "February", "March", "April", "May", "June",
                                "July", "August", "September", "October", "November", "December"];
            monthName = monthNames[month] || "";
          } else {
            const date = new Date(md);
            monthName = date.toLocaleString('en-US', { month: 'long' });
          }
        } catch (e) {
          monthName = "";
        }
      }

      // Show just town and month (e.g., "KENMORE ‚Äî December")
      const fullText = monthName ? `${town.toUpperCase()} ‚Äî ${monthName.toUpperCase()}` : town.toUpperCase();
      const span = document.createElement('span');
      span.className = 'banner-text';
      span.textContent = fullText;
      span.setAttribute('aria-label', fullText);
      span.setAttribute('title', fullText); // Tooltip for overflow text

      // Apply banner colors directly
      banner.style.backgroundColor = stagedColors.Banner_BG || '#000000';
      banner.style.color = useLightTextOn(stagedColors.Banner_BG || '#000000') ? '#ffffff' : '#0f172a';
      const border = shadeBlend(stagedColors.Banner_BG || '#000000', -0.12) || '#e5e7eb';
      banner.style.borderColor = border;

      banner.appendChild(span);
      grid.appendChild(banner);
      renderRow(grid,5,8);
    }
    
    function renderBack(){
      const grid = document.getElementById("backGrid");
      grid.innerHTML = "";
      if (!state.current) {
        renderPlaceholderBack(grid);
        return;
      }
      renderRow(grid,9,12);
      // Check if spots 13-14 are merged OR both selected
      const bothSelected = state.selected.has(13) && state.selected.has(14);
      if (state.merged.has(keyPair(13,14)) || bothSelected) {
        const A = state.availability["Spot_13"], B = state.availability["Spot_14"];
        const name = A.name || B.name || "Merged Banner";
        const st = A.name ? A.status : (B.name ? B.status : "Available");
        const mergedEl = cardButtonSafe({label:"Spots 13‚Äì14", name, status:st, span4:true, selected:isSel([13,14]), spots:[13,14]});
        mergedEl.addEventListener("click", ()=>toggle([13,14],"back"));
        grid.appendChild(mergedEl);
      } else {
        const sp13 = cardButtonSafe({label:"Spot 13", name:(state.availability["Spot_13"]?.name || "Available"), status: (state.availability["Spot_13"]?.status || "Available"), span2:true, selected: state.selected.has(13), spots:[13]});
        sp13.addEventListener("click", ()=>toggle([13],"back"));
        grid.appendChild(sp13);
        const sp14 = cardButtonSafe({label:"Spot 14", name:(state.availability["Spot_14"]?.name || "Available"), status: (state.availability["Spot_14"]?.status || "Available"), span2:true, selected: state.selected.has(14), spots:[14]});
        sp14.addEventListener("click", ()=>toggle([14],"back"));
        grid.appendChild(sp14);
      }
      renderRow(grid,15,18,"back");
    }
    
    function renderRow(grid, a, b, side="front"){
      for (let i=a; i<=b; i+=2){
        // Check if spots are merged OR both selected
        const bothSelected = state.selected.has(i) && state.selected.has(i+1);
        if (state.merged.has(keyPair(i,i+1)) || bothSelected){
          const A = state.availability[`Spot_${i}`], B = state.availability[`Spot_${i+1}`];
          const name = A.name || B.name || "Merged Ad";
          const st = A.name ? A.status : (B.name ? B.status : "Available");
          const btn = cardButtonSafe({label:`Spots ${i}-${i+1}`, name, status:st, span2:true, selected:isSel([i,i+1]), spots:[i,i+1]});
          btn.addEventListener("click", ()=>toggle([i,i+1], side));
          grid.appendChild(btn);
        } else {
          grid.appendChild(single(i,false,side));
          grid.appendChild(single(i+1,false,side));
        }
      }
    }
    
    function single(i, span2=false, side="front"){
      const s = state.availability[`Spot_${i}`] || { name:"", status:"Available" };
      const btn = cardButtonSafe({label:`Spot ${i}`, name:(s.name || "Available"), status:s.status, span2, selected:state.selected.has(i), spots:[i]});
      btn.addEventListener("click", ()=>toggle([i], side));
      return btn;
    }
    
    function createTextNodeTag(tagName, text, className) {
      const el = document.createElement(tagName);
      if (className) el.className = className;
      el.textContent = text;
      return el;
    }
    
    function cardButtonSafe({label,name,status,selected=false,span2=false,span4=false,spots=[]}){
      const el = document.createElement("button");
      el.type = "button";
      const span = span4 ? "col-span-4" : (span2 ? "col-span-2" : "");
      const longStatus = normalizeStatusLong(status);
      el.className = `card ${span} ${selected ? "selected" : ""}`;
      el.style.backgroundColor = STATUS_HEX[longStatus] || GRADIENT_HEX[0];
      el.style.borderColor = shadeBlend(STATUS_HEX[longStatus] || GRADIENT_HEX[0], -0.2) || '#f59e0b';
      el.style.color = useLightTextOn(STATUS_HEX[longStatus] || GRADIENT_HEX[0]) ? 'white' : '#0f172a';
      el.setAttribute("aria-pressed", selected ? "true" : "false");
      el.tabIndex = 0;
      const match = label.match(/\d+/);
      if (match) el.dataset.spot = match[0];
      
      const labelEl = createTextNodeTag('div', label, 'spot-label');
      const nameEl = createTextNodeTag('div', name);
      const badge = createTextNodeTag('div', longStatus, 'status-badge');
      badge.style.backgroundColor = shadeBlend(STATUS_HEX[longStatus] || GRADIENT_HEX[0], 0.1) || 'rgba(255,255,255,.96)';
      
      el.appendChild(labelEl);
      el.appendChild(nameEl);
      el.appendChild(badge);
      
      // Add price badge if spot is sold and has a price
      if (state.current && spots.length > 0 && longStatus !== "Available") {
        const spotNum = spots[0];
        const priceKey = normalizePriceKey(state.current.Mailer_ID, spotNum);
        const customSpotPrice = productionState.spotPricing[priceKey];
        const pricing = productionState.pricing[state.current.Mailer_ID];

        // Use same 3-step pricing logic as calculateFinancials
        let price;
        if (customSpotPrice !== undefined && customSpotPrice !== null && customSpotPrice > 0) {
          // 1. Custom spot price (manually set)
          price = parseFloat(customSpotPrice);
        } else if (pricing) {
          // 2. Set Pricing (singleAd/doubleAd/bannerAd)
          const isMerged = spots.length > 1;
          if (isMerged) {
            price = parseFloat(pricing.doubleAd) || DEFAULT_SPOT_PRICE;
          } else {
            price = parseFloat(pricing.singleAd) || DEFAULT_SPOT_PRICE;
          }
        } else {
          // 3. Fallback default
          price = DEFAULT_SPOT_PRICE;
        }

        const priceBadge = createTextNodeTag('div', formatCurrency(price), 'price-badge');
        el.appendChild(priceBadge);
      }
      
      // Add overlay edit button if selected
      // When multiple spots are selected, only show button on the first (lowest numbered) spot
      if (selected) {
        const showButton = state.selected.size === 1 ||
                          (spots.length > 0 && spots[0] === Math.min(...Array.from(state.selected)));

        if (showButton) {
          const overlay = document.createElement('div');
          overlay.className = 'card-edit-overlay';
          const editBtn = document.createElement('button');
          // Show "EDIT SPOT" (singular) when multiple spots selected, "Edit Spot" otherwise
          editBtn.textContent = state.selected.size > 1 ? '‚úé EDIT SPOT' : '‚úé Edit Spot';
          editBtn.onclick = (e) => {
            e.stopPropagation();
            openEditModal();
          };
          overlay.appendChild(editBtn);
          el.appendChild(overlay);
        }
      }
      
      el.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          el.click();
        }
      });
      return el;
    }
    
    function normalizeStatusLong(s) {
      if (!s) return "Available";
      const up = String(s).trim();
      const map = {
        "RESERVED": "Reserved",
        "INVOICE": "Invoice Sent",
        "DEPOSIT": "Deposit Paid",
        "PROOF": "Proof In Progress",
        "APPROVED": "Ad Approved",
        "PAID": "Paid in Full",
        "AVAIL": "Available"
      };
      if (map[up.toUpperCase()]) return map[up.toUpperCase()];
      for (const k of CANONICAL_STATUSES) {
        if (k.toLowerCase() === up.toLowerCase()) return k;
      }
      return up;
    }
    
    function renderPlaceholderFront(grid){
      for (let i=1;i<=4;i++){
        const el = createPlaceholderCard(`Spot ${i}`);
        grid.appendChild(el);
      }
      const banner = document.createElement("div");
      banner.className = "card col-span-4 banner placeholder";
      banner.innerHTML = '<div class="banner-text" aria-label="TOWN ‚Äî MONTH" title="TOWN ‚Äî MONTH">TOWN ‚Äî MONTH</div>';
      banner.style.backgroundColor = '#000000';
      banner.style.color = '#ffffff';
      banner.style.borderColor = '#000000';
      grid.appendChild(banner);
      for (let i=5;i<=8;i++){
        const el = createPlaceholderCard(`Spot ${i}`);
        grid.appendChild(el);
      }
    }
    
    function renderPlaceholderBack(grid){
      for (let i=9;i<=12;i++){
        const el = createPlaceholderCard(`Spot ${i}`);
        grid.appendChild(el);
      }
      const p13 = createPlaceholderCard('Spot 13');
      p13.classList.add('col-span-2');
      grid.appendChild(p13);
      const p14 = createPlaceholderCard('Spot 14');
      p14.classList.add('col-span-2');
      grid.appendChild(p14);
      for (let i=15;i<=18;i++){
        const el = createPlaceholderCard(`Spot ${i}`);
        grid.appendChild(el);
      }
    }
    
    function createPlaceholderCard(label, hidden=false, isSpan2=false){
      const el = document.createElement("div");
      el.className = "card placeholder";
      if (isSpan2) el.classList.add('col-span-2');
      el.style.justifyContent = "center";
      if (hidden){
        el.style.visibility = 'hidden';
      } else {
        const lbl = document.createElement("div");
        lbl.textContent = label;
        el.appendChild(lbl);
      }
      return el;
    }
    
    /* ========= SELECTION / TOOLBAR ========= */
    function toggle(spots, sideHint="front"){
      spots.forEach(n => { state.selected.has(n) ? state.selected.delete(n) : state.selected.add(n); });
      if (state.selected.size > 2){
        const last = spots[spots.length-1];
        const others = [...state.selected].filter(x => x !== last);
        const mate = others.find(o => isValidPair(o,last));
        state.selected.clear();
        if (mate){ state.selected.add(mate); state.selected.add(last); }
        else { state.selected.add(last); toast("Pick a valid pair", false); }
      }
      if (state.selected.size === 2){
        const [a,b] = [...state.selected].sort((x,y)=>x-y);
        if (!isValidPair(a,b)){
          const last = spots[spots.length-1];
          state.selected.clear();
          state.selected.add(last);
          toast("Pick a valid pair", false);
        }
      }
      renderAll();
    }
    
    function isSel(arr){ return arr.every(n => state.selected.has(n)); }
    
    function updateToolbar(){
      const saveBtn = document.getElementById("btnSaveCommit");
      if (saveBtn) {
        if (state.dirty){
          saveBtn.disabled = false;
          saveBtn.classList.remove("opacity-50","cursor-not-allowed");
        } else {
          saveBtn.disabled = true;
          saveBtn.classList.add("opacity-50","cursor-not-allowed");
        }
      }
    }
    
    /* ========= MODAL & APPLY ========= */
    function openEditModal(){
      if (!state.selected.size) return;
      const modal = document.getElementById("editModal");
      const nameEl = document.getElementById("editName");
      const statusEl = document.getElementById("editStatus");
      const priceEl = document.getElementById("editPrice");

      lastFocusedElementBeforeModal = document.activeElement;
      const sel = [...state.selected].sort((a,b)=>a-b);

      // Get pricing for this postcard (new system)
      const mailerId = state.current.Mailer_ID;
      const pricing = productionState.pricing[mailerId] || null;

      if (sel.length === 1){
        const s = state.availability[`Spot_${sel[0]}`] || {name:"", status:"Available"};
        nameEl.value = s.name || "";
        statusEl.value = toShortKey(s.status);

        // Use new pricing system or fall back to old spot pricing
        const priceKey = normalizePriceKey(mailerId, sel[0]);
        const oldPrice = productionState.spotPricing[priceKey];
        if (oldPrice) {
          priceEl.value = oldPrice;
        } else if (pricing && pricing.singleAd) {
          priceEl.value = pricing.singleAd;
        } else {
          priceEl.value = ""; // Empty instead of $500 default
        }
      } else {
        const [a,b] = sel;
        const A = state.availability[`Spot_${a}`] || {name:"", status:"Available"}, B = state.availability[`Spot_${b}`] || {name:"", status:"Available"};
        const nm = (A.name && B.name && A.name.toLowerCase()===B.name.toLowerCase()) ? A.name : (A.name || B.name || "");
        const st = nm ? (A.status!=="Available" ? A.status : (B.status!=="Available"?B.status:"Proof In Progress")) : "Available";
        nameEl.value = nm;
        statusEl.value = toShortKey(st);

        // Use new pricing system for double ad or fall back to old spot pricing
        const priceKey = normalizePriceKey(mailerId, a);
        const oldPrice = productionState.spotPricing[priceKey];
        if (oldPrice) {
          priceEl.value = oldPrice;
        } else if (pricing && pricing.doubleAd) {
          priceEl.value = pricing.doubleAd;
        } else {
          priceEl.value = ""; // Empty instead of $500 default
        }
      }

      populateClientDropdown();

      modal.style.display = "flex";
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);
      nameEl.focus();
    }
    
    function trapModalFocus(modalEl) {
      const dialog = modalEl.querySelector('.modal');
      if (!dialog) return;
      const focusable = dialog.querySelectorAll('a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])');
      if (focusable.length === 0) return;
      const first = focusable[0], last = focusable[focusable.length - 1];
      function onKey(e) {
        if (e.key === 'Escape') {
          if (modalEl.id === 'editModal') closeEditModal();
          else if (modalEl.id === 'postcardModal') closePostcardModal();
          else if (modalEl.id === 'sortModal') closeSortModal();
          else if (modalEl.id === 'expenseModal') closeExpenseModal();
          else if (modalEl.id === 'clientModal') closeClientModal();
          else if (modalEl.id === 'emailModal') closeEmailModal();
          else if (modalEl.id === 'reportsModal') closeReportsModal();
          return;
        }
        if (e.key === 'Tab') {
          if (e.shiftKey && document.activeElement === first) {
            e.preventDefault(); last.focus();
          } else if (!e.shiftKey && document.activeElement === last) {
            e.preventDefault(); first.focus();
          }
        }
      }
      modalEl.__trap = onKey;
      modalEl.addEventListener('keydown', onKey);
    }
    
    function releaseModalFocus(modalEl) {
      if (!modalEl) return;
      if (modalEl.__trap) {
        modalEl.removeEventListener('keydown', modalEl.__trap);
        delete modalEl.__trap;
      }
    }
    
    function closeEditModal(){
      const modal = document.getElementById("editModal");
      modal.style.display = "none";
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
      if (lastFocusedElementBeforeModal && typeof lastFocusedElementBeforeModal.focus === 'function') {
        lastFocusedElementBeforeModal.focus();
      }
    }
    
    async function applyEditModal(){
      const nameRaw = document.getElementById("editName").value;
      const name = String(nameRaw || "").replace(/\s+/g,' ').trim();
      const short = document.getElementById("editStatus").value;
      let long = toLongLabel(short);
      const price = parseFloat(document.getElementById("editPrice").value) || DEFAULT_SPOT_PRICE;
      const selectedClientId = document.getElementById('editClient').value;

      // Auto-change status from Available to Reserved when name is entered
      if (name && long === "Available") {
        long = "Reserved";
      }

      const sel = [...state.selected].sort((a,b)=>a-b);

      sel.forEach(spotNum => {
        const priceKey = normalizePriceKey(state.current.Mailer_ID, spotNum);
        productionState.spotPricing[priceKey] = price;
      });

      // Save spot pricing to cloud (also saves to localStorage as backup)
      await saveSpotPricing();
      
      if (sel.length === 2){
        const [a,b] = sel;
        if (name){
          state.merged.add(keyPair(a,b));
          state.availability[`Spot_${a}`] = { name, status: long };
          state.availability[`Spot_${b}`] = { name, status: long };
        } else {
          state.merged.delete(keyPair(a,b));
          state.availability[`Spot_${a}`] = { name:"", status:"Available" };
          state.availability[`Spot_${b}`] = { name:"", status:"Available" };
        }
      } else if (sel.length === 1){
        const a = sel[0];
        const m = mateOf(a);
        if (name){
          state.availability[`Spot_${a}`] = { name, status: long };
          if (m && state.merged.has(keyPair(a,m))){
            state.merged.delete(keyPair(a,m));
            state.availability[`Spot_${m}`] = { name:"", status:"Available" };
          }
        } else {
          state.availability[`Spot_${a}`] = { name:"", status:"Available" };
          if (m && state.merged.has(keyPair(a,m))){
            state.merged.delete(keyPair(a,m));
            state.availability[`Spot_${m}`] = { name:"", status:"Available" };
          }
        }
      }
      
      // Link client if selected and status is Paid in Full
      if (selectedClientId && state.current && name && long === "Paid in Full") {
        const spotNum = sel[0];
        linkClientToSpot(
          selectedClientId,
          spotNum,
          `${state.current.Town} ‚Äî ${state.current.Mail_Date}`,
          price,
          long
        );
        renderClientList();
      }
      
      state.dirty = true;
      toast("Saved locally");

      // Clear selection immediately after save
      state.selected.clear();

      closeEditModal();
      renderAll();
      updateFinancialDashboard();
      scheduleAutoSave(); // Trigger auto-save
    }
    
    function toShortKey(longLabel){
      switch(longLabel){
        case "Reserved": return "RESERVED";
        case "Invoice Sent": return "INVOICE";
        case "Deposit Paid": return "DEPOSIT";
        case "Proof In Progress": return "PROOF";
        case "Ad Approved": return "APPROVED";
        case "Paid in Full": return "PAID";
        case "Available": return "AVAIL";
      }
      return String(longLabel || "").toUpperCase();
    }
    
    function toLongLabel(shortKey){
      switch(shortKey){
        case "RESERVED": return "Reserved";
        case "INVOICE": return "Invoice Sent";
        case "DEPOSIT": return "Deposit Paid";
        case "PROOF": return "Proof In Progress";
        case "APPROVED": return "Ad Approved";
        case "PAID": return "Paid in Full";
        default: return "Available";
      }
    }
    
    /* ========= POSTCARD MODAL ========= */
    function openPostcardModal(){ 
      const modal = document.getElementById("postcardModal");
      modal.style.display='flex'; 
      modal.setAttribute('aria-hidden','false'); 
      trapModalFocus(modal); 
      previewPostcardModal(); 
    }
    
    function closePostcardModal(){ 
      const modal = document.getElementById("postcardModal");
      modal.style.display = 'none'; 
      modal.setAttribute('aria-hidden','true'); 
      releaseModalFocus(modal); 
    }
    
    function previewPostcardModal(){
      const previewPostcard = document.getElementById('previewPostcard');
      const previewBanner = document.getElementById('previewBanner');
      previewPostcard.style.backgroundColor = stagedColors.Postcard_BG || '#000';
      previewBanner.style.backgroundColor = stagedColors.Banner_BG || '#000000';
      previewBanner.style.color = useLightTextOn(stagedColors.Banner_BG || '#000000')? '#fff' : '#0f172a';
    }
    
    function applyPostcardModal(){
      stagedColors.Postcard_BG = document.getElementById('pickerPostcard').value;
      stagedColors.Banner_BG = document.getElementById('pickerBanner').value;
      savePostcardBg(stagedColors.Postcard_BG);
      saveBannerBg(stagedColors.Banner_BG);

      // Also save to current postcard data so colors persist when switching postcards
      if (state.current) {
        // Find the index of current postcard in mailers array
        const currentIndex = state.mailers.findIndex(m => m === state.current || m?.Mailer_ID === state.current?.Mailer_ID);
        if (currentIndex !== -1) {
          state.mailers[currentIndex].Postcard_BG = stagedColors.Postcard_BG;
          state.mailers[currentIndex].Banner_BG = stagedColors.Banner_BG;
        }
        // Also update the current object directly
        state.current.Postcard_BG = stagedColors.Postcard_BG;
        state.current.Banner_BG = stagedColors.Banner_BG;
      }

      applyStagedColors();
      closePostcardModal();
      toast('Postcard colors saved successfully!', true);
      state.dirty = true;
      updateToolbar();
      scheduleAutoSave(); // Trigger auto-save
    }
    
    /* ========= SORT MODAL ========= */
    function openEditStatusModal() {
      const modal = document.getElementById("editStatusModal");
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
      trapModalFocus(modal);

      // Populate legend in modal
      const legendGrid = document.getElementById("editStatusLegendGrid");
      legendGrid.innerHTML = "";
      const visibleSorted = sortOrder.filter(st => visibleStatuses.includes(st));
      visibleSorted.forEach(st => {
        const item = document.createElement("div");
        item.className = "flex items-center gap-2";
        const dot = document.createElement("span");
        dot.className = "w-3 h-3 rounded-full";
        dot.style.backgroundColor = STATUS_HEX[st] || GRADIENT_HEX[0];
        const txt = document.createElement("span");
        txt.textContent = st;
        item.appendChild(dot);
        item.appendChild(txt);
        legendGrid.appendChild(item);
      });

      // Build sort list
      buildSortList();
      updateSortPreview();
    }

    function closeEditStatusModal() {
      const modal = document.getElementById("editStatusModal");
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      releaseModalFocus(modal);
    }

    function saveEditStatusModal() {
      saveSortOrderFromModal();
      closeEditStatusModal();
    }

    function openSortModal(){
      const modal = document.getElementById("sortModal");
      modal.style.display='flex';
      modal.setAttribute('aria-hidden','false');
      trapModalFocus(modal);
      buildSortList();
      updateSortPreview();
    }

    function closeSortModal(){
      const modal = document.getElementById("sortModal");
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden','true');
      releaseModalFocus(modal);
      renderLegend();
    }
    
    function buildSortList(){
      const container = document.getElementById("sortListContainer"); 
      container.innerHTML = ''; 
      sortOrder.forEach((s, idx)=>{
        const row = document.createElement('div'); 
        row.className='sort-row'; 
        row.dataset.idx = idx;
        const left = document.createElement('div'); 
        left.style.display='flex'; 
        left.style.alignItems='center'; 
        left.style.gap='8px';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = visibleStatuses.includes(s);
        checkbox.dataset.status = s;
        checkbox.style.marginRight = '8px';
        const dot = document.createElement('span'); 
        dot.style.width='14px'; 
        dot.style.height='14px'; 
        dot.style.borderRadius='9999px'; 
        dot.style.background = STATUS_HEX[s] || '#ddd';
        const label = document.createElement('div'); 
        label.textContent = s; 
        label.style.fontWeight='700';
        left.appendChild(checkbox);
        left.appendChild(dot); 
        left.appendChild(label);
        const right = document.createElement('div'); 
        right.style.display='flex'; 
        right.style.gap='6px';
        const up = document.createElement('button'); 
        up.className='sort-up'; 
        up.textContent='‚ñ≤'; 
        up.dataset.idx = idx; 
        up.title='Move up';
        const down = document.createElement('button'); 
        down.className='sort-down'; 
        down.textContent='‚ñº'; 
        down.dataset.idx = idx; 
        down.title='Move down';
        right.appendChild(up); 
        right.appendChild(down);
        row.appendChild(left); 
        row.appendChild(right);
        row.draggable = true;
        row.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', idx); row.style.opacity='0.6'; });
        row.addEventListener('dragend', e => { row.style.opacity=''; });
        row.addEventListener('dragover', e => { e.preventDefault(); row.style.background = '#f3f4f6'; });
        row.addEventListener('dragleave', e => { row.style.background = '#fff'; });
        row.addEventListener('drop', e => {
          e.preventDefault(); 
          row.style.background = '#fff';
          const from = Number(e.dataTransfer.getData('text/plain')); 
          const to = Number(row.dataset.idx);
          if (from === to) return;
          const copy = sortOrder.slice(); 
          const [item] = copy.splice(from,1); 
          copy.splice(to,0,item); 
          sortOrder = copy; 
          buildSortList(); 
          updateSortPreview();
        });
        container.appendChild(row);
      });
    }
    
    function handleSortUpDown(e){
      const el = e.target; 
      const idx = Number(el.dataset.idx);
      if (isNaN(idx)) return;
      if (el.classList.contains('sort-up')){ 
        if (idx>0){ 
          [sortOrder[idx-1], sortOrder[idx]] = [sortOrder[idx], sortOrder[idx-1]]; 
          buildSortList(); 
          updateSortPreview(); 
        } 
      }
      else if (el.classList.contains('sort-down')){ 
        if (idx < sortOrder.length-1){ 
          [sortOrder[idx+1], sortOrder[idx]] = [sortOrder[idx], sortOrder[idx+1]]; 
          buildSortList(); 
          updateSortPreview(); 
        } 
      }
    }
    
    function updateSortPreview(){
      const colors = GRADIENT_HEX;
      const grad = colors.map((c,i)=> `${c} ${i/(colors.length-1)*100}%`).join(',');
      document.getElementById('sortPreview').style.background = `linear-gradient(90deg, ${grad})`;
    }
    
    function saveSortOrderFromModal(){
      const checkboxes = document.querySelectorAll('#sortListContainer input[type="checkbox"]');
      visibleStatuses = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.dataset.status);
      safeSetItem('mailslot-sort', JSON.stringify({order: sortOrder, visible: visibleStatuses}));
      updateColorMappings();
      toast('Legend order and visibility saved');
      closeSortModal();
      renderAll();
    }
    
    /* ========= SAVE ========= */
    function computeUpdates(){
      let n=0;
      for (let i=1;i<=18;i++){
        const key=`Spot_${i}`;
        const cur = state.availability[key] || {name:"", status:"Available"};
        const human = cur.name ? `${cur.status}:${cur.name}` : "";
        if ((state.initial[key]||"") !== human) n++;
      }
      return n;
    }
    
    function buildAvailabilityPayload(){
      const out = {};
      for (let i=1;i<=18;i++){
        const key=`Spot_${i}`;
        const cur=state.availability[key] || {name:"", status:"Available"};
        const human = cur.name ? `${cur.status}: ${cur.name}` : "Available";
        const initial = state.initial[key] || "";
        const humanCompare = cur.name ? `${cur.status}:${cur.name}` : "";
        if (initial !== humanCompare) {
          out[key] = cur.name ? `${cur.status}: ${cur.name}` : "Available";
        }
      }
      state.merged.forEach(pair => {
        const parts = pair.split("-").map(n => Number(n));
        if (parts.length !== 2) return;
        const a = parts[0], b = parts[1];
        const A = state.availability[`Spot_${a}`] || {name:"", status:"Available"};
        const B = state.availability[`Spot_${b}`] || {name:"", status:"Available"};
        const preferredName = (A.name || B.name || "").replace(/\s+/g,' ').trim();
        const preferredStatus = (A.name ? A.status : (B.name ? B.status : "Available"));
        const human = preferredName ? `${preferredStatus}: ${preferredName}` : "Available";
        out[`Spot_${a}`] = human;
        out[`Spot_${b}`] = human;
      });
      return out;
    }
    
    /* ========= AUTO-SAVE SYSTEM ========= */

    function updateAutoSaveStatus() {
      try {
        const statusDiv = document.getElementById('autoSaveStatus');
        const iconSpan = document.getElementById('autoSaveIcon');
        const textSpan = document.getElementById('autoSaveText');
        const saveBtn = document.getElementById('btnManualSave');

        if (!statusDiv) return;

      // Clear any hide timeout and show the status
      if (window.autoSaveHideTimeout) {
        clearTimeout(window.autoSaveHideTimeout);
      }
      statusDiv.style.display = 'flex';
      statusDiv.style.opacity = '1';

      // Determine status
      if (autoSaveState.saving) {
        // Currently saving
        statusDiv.className = 'flex items-center gap-1 px-2 py-1 rounded-md text-xs font-medium bg-blue-50 border border-blue-300 text-blue-700';
        iconSpan.textContent = '‚òÅÔ∏è';
        textSpan.textContent = 'Saving...';
        saveBtn.classList.add('hidden');
      } else if (state.dirty) {
        // Has unsaved changes - hide status, show manual save button
        statusDiv.style.display = 'none';
        saveBtn.classList.remove('hidden');
      } else {
        // All saved
        statusDiv.className = 'flex items-center gap-1 px-2 py-1 rounded-md text-xs font-medium bg-green-50 border border-green-300 text-green-700';
        iconSpan.textContent = '‚úì';

        if (autoSaveState.lastSaveTime) {
          const relativeTime = getRelativeTime(autoSaveState.lastSaveTime);
          textSpan.textContent = relativeTime;
        } else {
          textSpan.textContent = 'Saved';
        }

        saveBtn.classList.add('hidden');

        // Auto-hide after 10 seconds (increased from 4s for better visibility)
        if (window.autoSaveHideTimeout) {
          clearTimeout(window.autoSaveHideTimeout);
        }
        statusDiv.style.opacity = '1';
        statusDiv.style.transition = 'opacity 0.3s';

        window.autoSaveHideTimeout = setTimeout(() => {
          statusDiv.style.opacity = '0';
          setTimeout(() => {
            statusDiv.style.display = 'none';
          }, 300);
        }, 10000);
      }
      } catch(e) {
        console.error('Error in updateAutoSaveStatus:', e);
      }
    }

    function getRelativeTime(timestamp) {
      const now = Date.now();
      const diff = now - timestamp;
      const seconds = Math.floor(diff / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (seconds < 10) return 'just now';
      if (seconds < 60) return `${seconds} sec ago`;
      if (minutes === 1) return '1 min ago';
      if (minutes < 60) return `${minutes} min ago`;
      if (hours === 1) return '1 hour ago';
      if (hours < 24) return `${hours} hours ago`;
      if (days === 1) return '1 day ago';
      return `${days} days ago`;
    }

    function scheduleAutoSave() {
      try {
        // Clear existing timer
        if (autoSaveState.timer) {
          clearTimeout(autoSaveState.timer);
        }

        // Don't schedule if no changes
        if (!state.dirty) {
          updateAutoSaveStatus();
          return;
        }

        // Schedule auto-save for 15 seconds from now
        autoSaveState.timer = setTimeout(() => {
          performAutoSave();
        }, 15000); // 15 seconds

        updateAutoSaveStatus();
      } catch(e) {
        console.error('Error in scheduleAutoSave:', e);
      }
    }

    function performAutoSave() {
      try {
        console.log('üîÑ performAutoSave triggered');
        if (!state.dirty) {
          console.log('üîÑ performAutoSave: nothing to save');
          return;
        }

        // Call saveToSheet to save to Supabase
        console.log('üîÑ performAutoSave: calling saveToSheet');
        saveToSheet();

      } catch(e) {
        console.error('Error in performAutoSave:', e);
      }
    }

      /* OLD CODE BELOW - DISABLED
      if (autoSaveState.saving) {
        // Already saving - reschedule for after current save completes
        return;
      }
      if (!state.current) return;

      const availabilityDiffs = buildAvailabilityPayload();
      if (Object.keys(availabilityDiffs).length === 0) {
        state.dirty = false;
        updateAutoSaveStatus();
        return;
      }

      autoSaveState.saving = true;
      updateAutoSaveStatus();

      const payload = {
        user: ACTIVE_USER,
        Mailer_ID: state.current.Mailer_ID,
        availability: availabilityDiffs,
        Postcard_BG: stagedColors.Postcard_BG || null,
        Banner_BG: stagedColors.Banner_BG || null
      };

      // Use GET request instead of POST to avoid 403 errors
      const payloadJson = encodeURIComponent(JSON.stringify(payload));
      const url = `${GAS_URL}?action=saveSpots&data=${payloadJson}`;

      fetch(url)
        .then(response => response.json())
        .then(result => {
          if (result.error) {
            throw new Error(result.error);
          }

          autoSaveState.saving = false;
          autoSaveState.lastSaveTime = Date.now();
          state.dirty = false;
          updateToolbar();
          updateAutoSaveStatus();

          // Clear spot selection after successful save
          state.selected.clear();
          renderAll();

          // Start interval to update "saved X min ago" text
          if (!autoSaveState.updateInterval) {
            autoSaveState.updateInterval = setInterval(() => {
              if (!state.dirty && autoSaveState.lastSaveTime) {
                updateAutoSaveStatus();
              }
            }, 30000); // Update every 30 seconds
          }

          toast('‚úì Auto-saved to cloud', true);
        })
        .catch(err => {
          console.error('Auto-save failed:', err);
          autoSaveState.saving = false;
          toast('Auto-save failed - saved locally only', false);
        });
      } catch(e) {
        console.error('Error in performAutoSave:', e);
        autoSaveState.saving = false;
        toast('Auto-save failed', false);
      }
    }
    */

    function manualSaveNow() {
      if (!state.dirty) {
        toast('No changes to save', false);
        return;
      }

      // Cancel any pending auto-save
      if (autoSaveState.timer) {
        clearTimeout(autoSaveState.timer);
        autoSaveState.timer = null;
      }

      performAutoSave();
    }

    async function saveToSheet(){
      console.log('üöÄ saveToSheet() CALLED!', {
        hasCurrent: !!state.current,
        isDirty: state.dirty,
        currentMailerId: state.current?.Mailer_ID
      });

      if (!state.current) {
        console.log('‚ùå Exiting: No current postcard');
        return;
      }

      if (!state.dirty) {
        console.log('‚ùå Exiting: Not dirty');
        toast("No changes to save");
        return;
      }

      const availabilityDiffs = buildAvailabilityPayload();
      console.log('üìù Availability diffs:', availabilityDiffs, 'Count:', Object.keys(availabilityDiffs).length);

      if (Object.keys(availabilityDiffs).length === 0) {
        console.log('‚ùå Exiting: No availability diffs');
        toast("No changes to save");
        state.dirty = false;
        updateToolbar();
        return;
      }

      const updates = computeUpdates();
      console.log('üìä Computed updates count:', updates);

      // If no actual changes (updates = 0), don't save
      if (updates === 0) {
        console.log('‚ùå Exiting: No changes to save (spots haven\'t changed from initial values)');
        toast("No changes to save");
        state.dirty = false;
        updateToolbar();
        return;
      }

      const payload = {
        User: ACTIVE_USER,  // Use uppercase User to match backend
        Mailer_ID: state.current.Mailer_ID,
        Town: state.current.Town,
        Mail_Date: state.current.Mail_Date,
        In_Homes_Date: state.current.In_Homes_Date,
        availability: availabilityDiffs,
        Postcard_BG: stagedColors.Postcard_BG || state.current.Postcard_BG || '#000000',
        Banner_BG: stagedColors.Banner_BG || state.current.Banner_BG || '#000000'
      };

      try {
        toast(`‚òÅÔ∏è Saving ${updates} change${updates===1?"":"s"}...`, false);

        // Build Supabase update object with snake_case column names
        const updateData = {
          postcard_bg: stagedColors.Postcard_BG || state.current.Postcard_BG || '#000000',
          banner_bg: stagedColors.Banner_BG || state.current.Banner_BG || '#000000'
        };

        // Add spot updates
        Object.keys(availabilityDiffs).forEach(spotKey => {
          const spotNumber = spotKey.replace('Spot_', '');
          updateData[`spot_${spotNumber}`] = availabilityDiffs[spotKey];
        });

        const { error, data: resultData } = await supabaseClient
          .from('postcards')
          .update(updateData)
          .eq('mailer_id', state.current.Mailer_ID)
          .eq('user_email', ACTIVE_USER)
          .select();

        if (error) throw error;

        toast(`‚úÖ Saved ${updates} change${updates===1?"":"s"} to cloud!`, true);
        state.dirty = false;
        autoSaveState.lastSaveTime = Date.now();
        updateToolbar();
        updateAutoSaveStatus();

        // Reload campaigns to get fresh data, preserving current selection
        const currentMailerId = state.current?.Mailer_ID;
        console.log('üíæ Saving complete. Will restore mailer_id:', currentMailerId, 'type:', typeof currentMailerId);
        setTimeout(() => loadCampaigns(currentMailerId), 500);

      } catch (err) {
        console.error("Failed to save to cloud:", err);
        toast("‚ö†Ô∏è Failed to save to cloud. Please try again.", false);
      }
    }

    // ===================================================================
    // FINANCIALS SYSTEM
    // ===================================================================

    // Financial data state
    const financialState = {
      transactions: [], // Array of transaction objects
      loaded: false
    };

    // Category definitions for auto-categorization and reporting
    const FINANCIAL_CATEGORIES = {
      // Revenue
      'Card Payment': { type: 'revenue', category: 'Sales Revenue', subcategory: 'Card Payments' },
      'Sales': { type: 'revenue', category: 'Sales Revenue', subcategory: 'General Sales' },

      // Cost of Goods Sold (COGS)
      'USPS': { type: 'cogs', category: 'COGS', subcategory: 'Postage & Shipping' },
      'Postage': { type: 'cogs', category: 'COGS', subcategory: 'Postage & Shipping' },
      'Printing': { type: 'cogs', category: 'COGS', subcategory: 'Printing' },

      // Operating Expenses
      'Square': { type: 'operating', category: 'Operating Expenses', subcategory: 'Software & Services' },
      'Software': { type: 'operating', category: 'Operating Expenses', subcategory: 'Software & Services' },
      'Bank Fee': { type: 'operating', category: 'Operating Expenses', subcategory: 'Bank Fees' },
      'Fee': { type: 'operating', category: 'Operating Expenses', subcategory: 'Bank Fees' },

      // Owner Draw
      'Transfer': { type: 'owner_draw', category: 'Owner Draw', subcategory: 'Withdrawals' },
      'Withdrawal': { type: 'owner_draw', category: 'Owner Draw', subcategory: 'Withdrawals' }
    };

    // Auto-categorize a transaction based on description
    function autoCategorizeTransaction(description, activityType, amount) {
      const desc = description.toUpperCase();
      const isPositive = amount > 0;

      // Revenue - Sales activity
      if (activityType === 'Sales' && isPositive) {
        return { type: 'revenue', category: 'Sales Revenue', subcategory: 'Card Payments' };
      }

      // COGS - Postage & Shipping
      if (desc.includes('USPS') || desc.includes('POSTAGE') || desc.includes('EVERY DOOR')) {
        return { type: 'cogs', category: 'COGS', subcategory: 'Postage & Shipping' };
      }

      // COGS - Printing
      if (desc.includes('4 OVER') || desc.includes('PRINTING')) {
        return { type: 'cogs', category: 'COGS', subcategory: 'Printing' };
      }

      // Operating Expenses - Software & Services
      if (desc.includes('SQUARE') || desc.includes('HOSTINGER') || desc.includes('XERO') ||
          desc.includes('SITEGROUND') || desc.includes('OPENAI') || desc.includes('CHATGPT') ||
          desc.includes('XAI') || desc.includes('HEYGEN') || desc.includes('ZEROBOUNCE')) {
        return { type: 'operating', category: 'Operating Expenses', subcategory: 'Software & Services' };
      }

      // Operating Expenses - Marketing/Advertising
      if (desc.includes('STRUC MARKE') || desc.includes('MARKETING') || desc.includes('ADVERTISING')) {
        return { type: 'operating', category: 'Operating Expenses', subcategory: 'Marketing' };
      }

      // Operating Expenses - General
      if (desc.includes('AMAZON') || activityType === 'Card spend') {
        return { type: 'operating', category: 'Operating Expenses', subcategory: 'General Expenses' };
      }

      // Owner equity - Transfers in
      if (activityType === 'Transfer in') {
        return { type: 'revenue', category: 'Owner Contribution', subcategory: 'Capital Injection' };
      }

      // Default uncategorized
      return { type: 'uncategorized', category: 'Uncategorized', subcategory: '' };
    }

    // Load financial data from Supabase
    async function loadFinancialData() {
      try {
        const { data, error } = await supabaseClient
          .from('app_data')
          .select('data')
          .eq('user_email', ACTIVE_USER)
          .eq('data_type', 'financialTransactions')
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            // No data yet - this is fine
            financialState.transactions = [];
            financialState.loaded = true;
            return;
          }
          throw error;
        }

        financialState.transactions = data.data || [];
        financialState.loaded = true;

        // Render the register
        renderFinancialRegister();

      } catch (err) {
        console.error('Error loading financial data:', err);
        toast('‚ö†Ô∏è Failed to load financial data', false);
        financialState.transactions = [];
        financialState.loaded = true;
      }
    }

    // Save financial data to Supabase
    async function saveFinancialData() {
      try {
        // Upsert to app_data table
        const { error } = await supabaseClient
          .from('app_data')
          .upsert({
            user_email: ACTIVE_USER,
            data_type: 'financialTransactions',
            data: financialState.transactions
          }, {
            onConflict: 'user_email,data_type'
          });

        if (error) throw error;

      } catch (err) {
        console.error('Error saving financial data:', err);
        toast('‚ö†Ô∏è Failed to save financial data', false);
        throw err;
      }
    }

    // Calculate financial summaries
    function calculateFinancialSummaries(transactions) {
      let totalRevenue = 0;
      let totalExpenses = 0;
      let currentBalance = 0;

      let revenueCount = 0;
      let expenseCount = 0;

      transactions.forEach(trans => {
        const amount = parseFloat(trans.amount) || 0;

        if (trans.type === 'revenue') {
          totalRevenue += amount;
          revenueCount++;
        } else if (trans.type === 'cogs' || trans.type === 'operating' || trans.type === 'owner_draw') {
          totalExpenses += Math.abs(amount);
          expenseCount++;
        }

        // Track balance - we'll use the latest (most recent) transaction's balance
        const transBalance = parseFloat(trans.balance) || 0;
        if (!currentBalance || transBalance > 0) {
          currentBalance = transBalance;
        }
      });

      // Since transactions are sorted newest first, get the balance from the first transaction (most recent)
      if (transactions.length > 0) {
        currentBalance = parseFloat(transactions[0].balance) || 0;
      }

      const netIncome = totalRevenue - totalExpenses;

      return { totalRevenue, totalExpenses, netIncome, currentBalance };
    }

    // Filter transactions based on period and category
    function filterTransactions(transactions, periodFilter, categoryFilter) {
      let filtered = [...transactions];

      // Period filter
      if (periodFilter !== 'all') {
        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonth = now.getMonth();

        filtered = filtered.filter(trans => {
          const transDate = new Date(trans.date);
          const transYear = transDate.getFullYear();
          const transMonth = transDate.getMonth();

          if (periodFilter === 'current-year') {
            return transYear === currentYear;
          } else if (periodFilter === 'current-month') {
            return transYear === currentYear && transMonth === currentMonth;
          } else if (periodFilter === 'last-month') {
            const lastMonth = currentMonth === 0 ? 11 : currentMonth - 1;
            const lastMonthYear = currentMonth === 0 ? currentYear - 1 : currentYear;
            return transYear === lastMonthYear && transMonth === lastMonth;
          } else if (periodFilter === 'q1') {
            return transYear === currentYear && transMonth >= 0 && transMonth <= 2;
          } else if (periodFilter === 'q2') {
            return transYear === currentYear && transMonth >= 3 && transMonth <= 5;
          } else if (periodFilter === 'q3') {
            return transYear === currentYear && transMonth >= 6 && transMonth <= 8;
          } else if (periodFilter === 'q4') {
            return transYear === currentYear && transMonth >= 9 && transMonth <= 11;
          }

          return true;
        });
      }

      // Category filter
      if (categoryFilter !== 'all') {
        filtered = filtered.filter(trans => trans.type === categoryFilter);
      }

      return filtered;
    }

    // Render the financial register
    function renderFinancialRegister() {
      const tbody = document.getElementById('financialRegisterBody');
      if (!tbody) return;

      if (!financialState.loaded) {
        tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-gray-500">Loading transactions...</td></tr>';
        return;
      }

      // Get filter values
      const periodFilterEl = document.getElementById('financialPeriodFilter');
      const periodFilter = periodFilterEl?.value || 'current-year';
      const categoryFilter = document.getElementById('financialCategoryFilter')?.value || 'all';

      // Filter transactions
      const filteredTransactions = filterTransactions(financialState.transactions, periodFilter, categoryFilter);

      // Sort by date descending (newest first)
      const sortedTransactions = [...filteredTransactions].sort((a, b) => {
        return new Date(b.date) - new Date(a.date);
      });

      // Calculate summaries
      const summaries = calculateFinancialSummaries(sortedTransactions);

      // Update summary cards
      document.getElementById('totalRevenue').textContent = `$${summaries.totalRevenue.toFixed(2)}`;
      document.getElementById('totalExpenses').textContent = `$${summaries.totalExpenses.toFixed(2)}`;
      document.getElementById('netIncome').textContent = `$${summaries.netIncome.toFixed(2)}`;
      document.getElementById('currentBalance').textContent = `$${summaries.currentBalance.toFixed(2)}`;

      // Render transactions
      if (sortedTransactions.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-gray-500">No transactions found</td></tr>';
        return;
      }

      tbody.innerHTML = sortedTransactions.map(trans => {
        const amount = parseFloat(trans.amount) || 0;
        const amountClass = amount >= 0 ? 'text-green-600 font-semibold' : 'text-red-600 font-semibold';
        const amountDisplay = amount >= 0 ? `+$${amount.toFixed(2)}` : `-$${Math.abs(amount).toFixed(2)}`;

        return `
          <tr class="border-b hover:bg-gray-50">
            <td class="py-2 px-3 text-sm">${trans.date}</td>
            <td class="py-2 px-3 text-sm">${trans.description}</td>
            <td class="py-2 px-3 text-sm">
              <span class="px-2 py-1 rounded text-xs font-medium ${getCategoryBadgeClass(trans.type)}">
                ${trans.category}
              </span>
            </td>
            <td class="py-2 px-3 text-sm ${amountClass}">${amountDisplay}</td>
            <td class="py-2 px-3 text-sm font-medium">$${(parseFloat(trans.balance) || 0).toFixed(2)}</td>
            <td class="py-2 px-3 text-sm text-gray-600">${trans.notes || ''}</td>
            <td class="py-2 px-3 text-sm">
              <button onclick="editTransaction('${trans.id}')" class="text-blue-600 hover:underline text-xs mr-2">Edit</button>
              <button onclick="deleteTransaction('${trans.id}')" class="text-red-600 hover:underline text-xs">Delete</button>
            </td>
          </tr>
        `;
      }).join('');
    }

    // Get badge class for category type
    function getCategoryBadgeClass(type) {
      switch (type) {
        case 'revenue':
          return 'bg-green-100 text-green-800';
        case 'cogs':
          return 'bg-blue-100 text-blue-800';
        case 'operating':
          return 'bg-orange-100 text-orange-800';
        case 'owner_draw':
          return 'bg-purple-100 text-purple-800';
        default:
          return 'bg-gray-100 text-gray-800';
      }
    }

    // Show add transaction modal
    function showAddTransactionModal() {
      // Reset form
      document.getElementById('txnDate').value = new Date().toISOString().split('T')[0];
      document.getElementById('txnType').value = '';
      document.getElementById('txnDescription').value = '';
      document.getElementById('txnAmount').value = '';
      document.getElementById('txnCategory').value = '';
      document.getElementById('txnNotes').value = '';

      // Show modal
      const modal = document.getElementById('addTransactionModal');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
    }

    // Close add transaction modal
    function closeAddTransactionModal() {
      const modal = document.getElementById('addTransactionModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }

    // Save add transaction
    async function saveAddTransaction() {
      try {
        const date = document.getElementById('txnDate').value;
        const type = document.getElementById('txnType').value;
        const description = document.getElementById('txnDescription').value;
        const amount = parseFloat(document.getElementById('txnAmount').value);
        const notes = document.getElementById('txnNotes').value;

        // Validate
        if (!date || !type || !description || isNaN(amount)) {
          toast('‚ö†Ô∏è Please fill in all required fields', false);
          return;
        }

        // Adjust amount for expenses (make negative)
        const adjustedAmount = (type === 'revenue') ? Math.abs(amount) : -Math.abs(amount);

        // Convert type to activityType for categorization
        let activityType = 'Manual Entry';
        if (type === 'revenue') activityType = 'Sales';
        else if (type === 'cogs') activityType = 'Card spend';
        else if (type === 'operating') activityType = 'Card spend';
        else if (type === 'owner_draw') activityType = 'Transfer out';

        // Auto-categorize based on description, activityType, and amount
        const categorization = autoCategorizeTransaction(description, activityType, adjustedAmount);

        // Calculate new balance (last transaction balance + this amount)
        const lastBalance = financialState.transactions.length > 0
          ? parseFloat(financialState.transactions[0].balance) || 0
          : 0;
        const newBalance = lastBalance + adjustedAmount;

        // Create transaction
        const transaction = {
          id: `manual-${Date.now()}`,
          date: date,
          description: description,
          activityType: activityType,
          amount: adjustedAmount,
          balance: newBalance,
          type: categorization.type,
          category: categorization.category,
          subcategory: categorization.subcategory,
          notes: notes
        };

        // Add to array (at beginning since it's new)
        financialState.transactions.unshift(transaction);

        // Recalculate balances for all transactions
        recalculateBalances();

        // Save to cloud
        await saveFinancialData();

        // Re-render
        renderFinancialRegister();

        // Close modal
        closeAddTransactionModal();

        toast('‚úÖ Transaction added', true);
      } catch (err) {
        console.error('Error adding transaction:', err);
        toast('‚ö†Ô∏è Failed to add transaction', false);
      }
    }

    // Recalculate balances for all transactions
    function recalculateBalances() {
      // Sort transactions by date (oldest first)
      const sorted = [...financialState.transactions].sort((a, b) => {
        return new Date(a.date) - new Date(b.date);
      });

      // Calculate running balance
      let runningBalance = 0;
      sorted.forEach(trans => {
        runningBalance += parseFloat(trans.amount) || 0;
        trans.balance = runningBalance;
      });

      // Update financialState with sorted and balanced transactions
      financialState.transactions = sorted;
    }

    // Edit transaction
    function editTransaction(id) {
      const transaction = financialState.transactions.find(t => t.id === id);
      if (!transaction) {
        toast('‚ö†Ô∏è Transaction not found', false);
        return;
      }

      // Fill form with transaction data
      document.getElementById('editTxnDate').value = transaction.date;
      document.getElementById('editTxnType').value = transaction.type;
      document.getElementById('editTxnDescription').value = transaction.description;
      document.getElementById('editTxnAmount').value = Math.abs(parseFloat(transaction.amount));
      document.getElementById('editTxnCategory').value = transaction.category;
      document.getElementById('editTxnNotes').value = transaction.notes || '';
      document.getElementById('editTxnId').value = id;

      // Show modal
      const modal = document.getElementById('editTransactionModal');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
    }

    // Close edit transaction modal
    function closeEditTransactionModal() {
      const modal = document.getElementById('editTransactionModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }

    // Save edit transaction
    async function saveEditTransaction() {
      try {
        const id = document.getElementById('editTxnId').value;
        const date = document.getElementById('editTxnDate').value;
        const type = document.getElementById('editTxnType').value;
        const description = document.getElementById('editTxnDescription').value;
        const amount = parseFloat(document.getElementById('editTxnAmount').value);
        const notes = document.getElementById('editTxnNotes').value;

        // Validate
        if (!date || !type || !description || isNaN(amount)) {
          toast('‚ö†Ô∏è Please fill in all required fields', false);
          return;
        }

        // Find and update transaction
        const transaction = financialState.transactions.find(t => t.id === id);
        if (!transaction) {
          toast('‚ö†Ô∏è Transaction not found', false);
          return;
        }

        // Adjust amount for expenses (make negative)
        const adjustedAmount = (type === 'revenue') ? Math.abs(amount) : -Math.abs(amount);

        // Convert type to activityType for categorization
        let activityType = 'Manual Entry';
        if (type === 'revenue') activityType = 'Sales';
        else if (type === 'cogs') activityType = 'Card spend';
        else if (type === 'operating') activityType = 'Card spend';
        else if (type === 'owner_draw') activityType = 'Transfer out';

        // Auto-categorize based on description, activityType, and amount
        const categorization = autoCategorizeTransaction(description, activityType, adjustedAmount);

        // Update transaction
        transaction.date = date;
        transaction.description = description;
        transaction.activityType = activityType;
        transaction.type = categorization.type;
        transaction.amount = adjustedAmount;
        transaction.category = categorization.category;
        transaction.subcategory = categorization.subcategory;
        transaction.notes = notes;

        // Recalculate all balances
        recalculateBalances();

        // Save to cloud
        await saveFinancialData();

        // Re-render
        renderFinancialRegister();

        // Close modal
        closeEditTransactionModal();

        toast('‚úÖ Transaction updated', true);
      } catch (err) {
        console.error('Error updating transaction:', err);
        toast('‚ö†Ô∏è Failed to update transaction', false);
      }
    }

    // Delete transaction
    async function deleteTransaction(id) {
      if (!confirm('Are you sure you want to delete this transaction?')) {
        return;
      }

      try {
        // Remove from array
        financialState.transactions = financialState.transactions.filter(t => t.id !== id);

        // Save to cloud
        await saveFinancialData();

        // Re-render
        renderFinancialRegister();

        toast('‚úÖ Transaction deleted', true);
      } catch (err) {
        console.error('Error deleting transaction:', err);
        toast('‚ö†Ô∏è Failed to delete transaction', false);
      }
    }

    // Export financial data to CSV
    function exportFinancialCSV() {
      const periodFilter = document.getElementById('financialPeriodFilter')?.value || 'all';
      const categoryFilter = document.getElementById('financialCategoryFilter')?.value || 'all';

      const filteredTransactions = filterTransactions(financialState.transactions, periodFilter, categoryFilter);

      if (filteredTransactions.length === 0) {
        toast('‚ö†Ô∏è No transactions to export', false);
        return;
      }

      // Build CSV
      const headers = ['Date', 'Description', 'Category', 'Subcategory', 'Amount', 'Balance', 'Notes'];
      const rows = filteredTransactions.map(trans => [
        trans.date,
        trans.description,
        trans.category,
        trans.subcategory || '',
        trans.amount,
        trans.balance,
        trans.notes || ''
      ]);

      const csv = [headers, ...rows].map(row =>
        row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
      ).join('\n');

      // Download
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `9x12Pro_Financials_${new Date().toISOString().slice(0, 10)}.csv`;
      a.click();
      URL.revokeObjectURL(url);

      toast('‚úÖ Exported to CSV', true);
    }

    // Show Profit & Loss report
    function showProfitLossReport() {
      // Set default period
      document.getElementById('plReportPeriod').value = 'current-year';

      // Generate report
      generatePLReport();

      // Show modal
      const modal = document.getElementById('plReportModal');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden', 'false');
    }

    // Close P&L Report modal
    function closePLReportModal() {
      const modal = document.getElementById('plReportModal');
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }

    // Generate P&L Report
    function generatePLReport() {
      const periodFilter = document.getElementById('plReportPeriod')?.value || 'current-year';
      const filteredTransactions = filterTransactions(financialState.transactions, periodFilter, 'all');

      // Calculate totals by category
      let totalRevenue = 0;
      let totalCOGS = 0;
      let totalOperating = 0;
      let totalOwnerDraw = 0;

      const revenueItems = [];
      const cogsItems = [];
      const operatingItems = [];
      const ownerDrawItems = [];

      filteredTransactions.forEach(trans => {
        const amount = Math.abs(parseFloat(trans.amount) || 0);
        const item = {
          date: trans.date,
          description: trans.description,
          amount: amount
        };

        if (trans.type === 'revenue') {
          totalRevenue += amount;
          revenueItems.push(item);
        } else if (trans.type === 'cogs') {
          totalCOGS += amount;
          cogsItems.push(item);
        } else if (trans.type === 'operating') {
          totalOperating += amount;
          operatingItems.push(item);
        } else if (trans.type === 'owner_draw') {
          totalOwnerDraw += amount;
          ownerDrawItems.push(item);
        }
      });

      const grossProfit = totalRevenue - totalCOGS;
      const operatingIncome = grossProfit - totalOperating;
      const netIncome = operatingIncome - totalOwnerDraw;

      // Get period label
      const periodLabel = getPeriodLabel(periodFilter);

      // Build report HTML
      const reportHTML = `
        <div class="p-6">
          <div class="text-center mb-6">
            <h2 class="text-2xl font-bold">9x12 PRO</h2>
            <h3 class="text-lg font-semibold mt-2">Profit & Loss Statement</h3>
            <p class="text-sm text-gray-600 mt-1">${periodLabel}</p>
          </div>

          <!-- Revenue Section -->
          <div class="mb-6">
            <div class="bg-green-50 px-4 py-2 font-semibold text-green-900 border-b-2 border-green-600">
              REVENUE
            </div>
            <div class="pl-6 py-2">
              <div class="flex justify-between items-center">
                <span>Sales Revenue</span>
                <span class="font-mono">$${totalRevenue.toFixed(2)}</span>
              </div>
            </div>
            <div class="bg-green-100 px-4 py-2 flex justify-between font-semibold text-green-900">
              <span>Total Revenue</span>
              <span class="font-mono">$${totalRevenue.toFixed(2)}</span>
            </div>
          </div>

          <!-- Cost of Goods Sold Section -->
          <div class="mb-6">
            <div class="bg-blue-50 px-4 py-2 font-semibold text-blue-900 border-b-2 border-blue-600">
              COST OF GOODS SOLD
            </div>
            <div class="pl-6 py-2">
              <div class="flex justify-between items-center">
                <span>Direct Costs</span>
                <span class="font-mono">$${totalCOGS.toFixed(2)}</span>
              </div>
            </div>
            <div class="bg-blue-100 px-4 py-2 flex justify-between font-semibold text-blue-900">
              <span>Total COGS</span>
              <span class="font-mono">$${totalCOGS.toFixed(2)}</span>
            </div>
          </div>

          <!-- Gross Profit -->
          <div class="mb-6 bg-gray-100 px-4 py-3 flex justify-between font-bold text-lg">
            <span>GROSS PROFIT</span>
            <span class="font-mono ${grossProfit >= 0 ? 'text-green-600' : 'text-red-600'}">$${grossProfit.toFixed(2)}</span>
          </div>

          <!-- Operating Expenses Section -->
          <div class="mb-6">
            <div class="bg-orange-50 px-4 py-2 font-semibold text-orange-900 border-b-2 border-orange-600">
              OPERATING EXPENSES
            </div>
            <div class="pl-6 py-2">
              <div class="flex justify-between items-center">
                <span>General & Administrative</span>
                <span class="font-mono">$${totalOperating.toFixed(2)}</span>
              </div>
            </div>
            <div class="bg-orange-100 px-4 py-2 flex justify-between font-semibold text-orange-900">
              <span>Total Operating Expenses</span>
              <span class="font-mono">$${totalOperating.toFixed(2)}</span>
            </div>
          </div>

          <!-- Operating Income -->
          <div class="mb-6 bg-gray-100 px-4 py-3 flex justify-between font-bold text-lg">
            <span>OPERATING INCOME</span>
            <span class="font-mono ${operatingIncome >= 0 ? 'text-green-600' : 'text-red-600'}">$${operatingIncome.toFixed(2)}</span>
          </div>

          <!-- Owner Draws -->
          ${totalOwnerDraw > 0 ? `
          <div class="mb-6">
            <div class="bg-purple-50 px-4 py-2 font-semibold text-purple-900 border-b-2 border-purple-600">
              OWNER DISTRIBUTIONS
            </div>
            <div class="pl-6 py-2">
              <div class="flex justify-between items-center">
                <span>Owner Draws</span>
                <span class="font-mono">$${totalOwnerDraw.toFixed(2)}</span>
              </div>
            </div>
          </div>
          ` : ''}

          <!-- Net Income -->
          <div class="bg-gradient-to-r from-gray-700 to-gray-800 text-white px-4 py-4 flex justify-between font-bold text-xl rounded-lg">
            <span>NET INCOME</span>
            <span class="font-mono ${netIncome >= 0 ? 'text-green-300' : 'text-red-300'}">$${netIncome.toFixed(2)}</span>
          </div>

          <!-- Summary Stats -->
          <div class="mt-6 grid grid-cols-3 gap-4 text-center">
            <div class="bg-green-50 p-3 rounded-lg">
              <div class="text-xs text-gray-600">Gross Margin</div>
              <div class="text-lg font-bold text-green-600">${totalRevenue > 0 ? ((grossProfit / totalRevenue) * 100).toFixed(1) : '0.0'}%</div>
            </div>
            <div class="bg-blue-50 p-3 rounded-lg">
              <div class="text-xs text-gray-600">Operating Margin</div>
              <div class="text-lg font-bold text-blue-600">${totalRevenue > 0 ? ((operatingIncome / totalRevenue) * 100).toFixed(1) : '0.0'}%</div>
            </div>
            <div class="bg-purple-50 p-3 rounded-lg">
              <div class="text-xs text-gray-600">Net Margin</div>
              <div class="text-lg font-bold text-purple-600">${totalRevenue > 0 ? ((netIncome / totalRevenue) * 100).toFixed(1) : '0.0'}%</div>
            </div>
          </div>

          <div class="mt-6 text-xs text-gray-500 text-center">
            Generated on ${new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })} at ${new Date().toLocaleTimeString('en-US')}
          </div>
        </div>
      `;

      document.getElementById('plReportContent').innerHTML = reportHTML;
    }

    // Get period label for P&L report
    function getPeriodLabel(periodFilter) {
      const now = new Date();
      const year = now.getFullYear();

      switch (periodFilter) {
        case 'current-year':
          return `For the Year Ending December 31, ${year}`;
        case 'q1':
          return `Q1 ${year} (January - March)`;
        case 'q2':
          return `Q2 ${year} (April - June)`;
        case 'q3':
          return `Q3 ${year} (July - September)`;
        case 'q4':
          return `Q4 ${year} (October - December)`;
        case 'current-month':
          return `For ${now.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`;
        case 'last-month':
          const lastMonth = new Date(year, now.getMonth() - 1, 1);
          return `For ${lastMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`;
        case 'all':
          return 'All Time (Inception to Date)';
        default:
          return periodFilter;
      }
    }

    // Export P&L Report as PDF (placeholder - would need library)
    function exportPLReportPDF() {
      toast('üí° PDF export coming soon! For now, use Print (Ctrl+P) to save as PDF', false);
    }

    // Import Square statement data
    async function importSquareStatements() {
      // Confirm with user - this will replace ALL existing transactions
      if (!confirm('‚ö†Ô∏è This will REPLACE all existing financial data with 96 transactions from Square statements (April-October 2025).\n\nThis action cannot be undone.\n\nContinue?')) {
        return;
      }

      try {
        console.log('üì• Importing Square statement data...');
        toast('üì• Importing Square data...', true);

        // All transactions from April-October 2025
        const rawTransactions = [
          // April 2025
          { date: '2025-04-03', description: 'Card payment', activityType: 'Sales', amount: 242.45, balance: 242.45 },
          { date: '2025-04-04', description: '2 Activities', activityType: 'Sales', amount: 1358.80, balance: 1601.25 },
          { date: '2025-04-05', description: 'Hostinger Hostinger.c', activityType: 'Card spend', amount: -22.34, balance: 1578.91 },
          { date: '2025-04-08', description: 'Hostinger Hostinger.c', activityType: 'Card spend', amount: -52.07, balance: 1526.84 },
          { date: '2025-04-08', description: '2 Activities', activityType: 'Sales', amount: 727.65, balance: 2254.49 },
          { date: '2025-04-13', description: 'Amazon', activityType: 'Card spend', amount: -40.30, balance: 2214.19 },
          { date: '2025-04-17', description: 'Card payment', activityType: 'Sales', amount: 242.45, balance: 2456.64 },
          { date: '2025-04-21', description: 'Amazon', activityType: 'Card spend', amount: -68.04, balance: 2388.60 },
          { date: '2025-04-21', description: 'Card payment', activityType: 'Sales', amount: 242.45, balance: 2631.05 },
          { date: '2025-04-22', description: 'Xero Us Inv', activityType: 'Card spend', amount: -2.00, balance: 2629.05 },
          { date: '2025-04-22', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 3114.25 },
          { date: '2025-04-22', description: 'Struc Marke', activityType: 'Card spend', amount: -2030.68, balance: 1083.57 },
          { date: '2025-04-23', description: 'Card payment', activityType: 'Sales', amount: 442.72, balance: 1526.29 },
          { date: '2025-04-24', description: 'Card payment', activityType: 'Sales', amount: 291.00, balance: 1817.29 },
          { date: '2025-04-28', description: 'Card payment', activityType: 'Sales', amount: 970.70, balance: 2787.99 },
          { date: '2025-04-29', description: 'USPS', activityType: 'Card spend', amount: -3.43, balance: 2784.56 },

          // May 2025
          { date: '2025-05-01', description: 'Openai Chatgpt Subscr', activityType: 'Card spend', amount: -21.75, balance: 2762.81 },
          { date: '2025-05-03', description: 'Usps.com Every Door Dt', activityType: 'Card spend', amount: -1023.35, balance: 1739.46 },
          { date: '2025-05-04', description: 'USPS', activityType: 'Card spend', amount: -1098.50, balance: 640.96 },
          { date: '2025-05-05', description: 'Amazon', activityType: 'Card spend', amount: -74.98, balance: 565.98 },
          { date: '2025-05-07', description: 'Xai Llc', activityType: 'Card spend', amount: -30.00, balance: 535.98 },
          { date: '2025-05-14', description: 'Card payment', activityType: 'Sales', amount: 483.20, balance: 1019.18 },
          { date: '2025-05-15', description: '3 Activities', activityType: 'Sales', amount: 1237.12, balance: 2256.30 },
          { date: '2025-05-16', description: 'Square Paid Services', activityType: 'Card spend', amount: -11.93, balance: 2244.37 },
          { date: '2025-05-19', description: 'Xero Us Inv', activityType: 'Card spend', amount: -2.00, balance: 2242.37 },
          { date: '2025-05-20', description: '2 Activities', activityType: 'Sales', amount: 970.40, balance: 3212.77 },
          { date: '2025-05-22', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 3697.97 },
          { date: '2025-05-26', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 4377.37 },
          { date: '2025-05-29', description: '4 Over International', activityType: 'Card spend', amount: -1363.63, balance: 3013.74 },

          // June 2025
          { date: '2025-06-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 2991.99 },
          { date: '2025-06-04', description: 'Siteground Hosting', activityType: 'Card spend', amount: -35.88, balance: 2956.11 },
          { date: '2025-06-06', description: 'Usps.com Every Door Dt', activityType: 'Card spend', amount: -1098.50, balance: 1857.61 },
          { date: '2025-06-07', description: 'Xai Llc', activityType: 'Card spend', amount: -30.00, balance: 1827.61 },
          { date: '2025-06-07', description: 'USPS', activityType: 'Card spend', amount: -1023.35, balance: 804.26 },
          { date: '2025-06-11', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 1289.46 },
          { date: '2025-06-16', description: 'Card payment', activityType: 'Sales', amount: 388.10, balance: 1677.56 },
          { date: '2025-06-19', description: 'Xero Us Inv', activityType: 'Card spend', amount: -2.00, balance: 1675.56 },
          { date: '2025-06-20', description: 'Heygen Technology Inc.', activityType: 'Card spend', amount: -20.30, balance: 1655.26 },
          { date: '2025-06-25', description: 'Card payment', activityType: 'Sales', amount: 291.00, balance: 1946.26 },
          { date: '2025-06-26', description: '4 Over International', activityType: 'Card spend', amount: -1322.50, balance: 623.76 },
          { date: '2025-06-29', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 1108.96 },

          // July 2025
          { date: '2025-07-01', description: 'Usps.com Every Door Dt', activityType: 'Card spend', amount: -992.13, balance: 116.83 },
          { date: '2025-07-01', description: '2 Activities', activityType: 'Sales', amount: 1164.60, balance: 1281.43 },
          { date: '2025-07-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 1259.68 },
          { date: '2025-07-02', description: 'USPS', activityType: 'Card spend', amount: -983.43, balance: 276.25 },
          { date: '2025-07-07', description: 'Xai Llc', activityType: 'Card spend', amount: -30.00, balance: 246.25 },
          { date: '2025-07-09', description: 'Zerobounce.com', activityType: 'Card spend', amount: -16.20, balance: 230.05 },
          { date: '2025-07-14', description: 'Card payment', activityType: 'Sales', amount: 266.72, balance: 496.77 },
          { date: '2025-07-15', description: 'Card payment', activityType: 'Sales', amount: 192.93, balance: 689.70 },
          { date: '2025-07-16', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 1174.90 },
          { date: '2025-07-17', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 1854.30 },
          { date: '2025-07-18', description: 'USPS', activityType: 'Card spend', amount: -279.60, balance: 1574.70 },
          { date: '2025-07-18', description: 'Card payment', activityType: 'Sales', amount: 315.27, balance: 1889.97 },
          { date: '2025-07-19', description: 'Xero Us Inv', activityType: 'Card spend', amount: -15.48, balance: 1874.49 },
          { date: '2025-07-19', description: 'USPS', activityType: 'Card spend', amount: -297.39, balance: 1577.10 },
          { date: '2025-07-20', description: 'Heygen Technology Inc.', activityType: 'Card spend', amount: -29.00, balance: 1548.10 },
          { date: '2025-07-22', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 1984.75 },
          { date: '2025-07-29', description: '4 Over International', activityType: 'Card spend', amount: -1378.66, balance: 606.09 },

          // August 2025
          { date: '2025-08-01', description: 'Card payment', activityType: 'Sales', amount: 485.20, balance: 1091.29 },
          { date: '2025-08-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 1069.54 },
          { date: '2025-08-02', description: 'Card payment', activityType: 'Sales', amount: 339.55, balance: 1409.09 },
          { date: '2025-08-05', description: 'Transfer in', activityType: 'Transfer in', amount: 1000.00, balance: 2409.09 },
          { date: '2025-08-05', description: 'USPS', activityType: 'Card spend', amount: -1205.36, balance: 1203.73 },
          { date: '2025-08-06', description: 'USPS', activityType: 'Card spend', amount: -1125.09, balance: 78.64 },
          { date: '2025-08-07', description: 'Xai Llc', activityType: 'Card spend', amount: -30.00, balance: 48.64 },
          { date: '2025-08-07', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 728.04 },
          { date: '2025-08-09', description: 'Zerobounce.net Saas', activityType: 'Card spend', amount: -18.00, balance: 710.04 },
          { date: '2025-08-20', description: 'Heygen Technology Inc.', activityType: 'Card spend', amount: -29.00, balance: 681.04 },
          { date: '2025-08-21', description: 'Card payment', activityType: 'Sales', amount: 266.72, balance: 947.76 },
          { date: '2025-08-22', description: 'Card payment', activityType: 'Sales', amount: 873.60, balance: 1821.36 },
          { date: '2025-08-25', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 2258.01 },
          { date: '2025-08-27', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 2694.66 },
          { date: '2025-08-29', description: '4 Over International', activityType: 'Card spend', amount: -1378.01, balance: 1316.65 },

          // September 2025
          { date: '2025-09-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 1294.90 },
          { date: '2025-09-03', description: 'Card payment', activityType: 'Sales', amount: 1026.04, balance: 2320.94 },
          { date: '2025-09-08', description: 'Transfer in', activityType: 'Transfer in', amount: 200.00, balance: 2520.94 },
          { date: '2025-09-08', description: 'USPS', activityType: 'Card spend', amount: -1116.93, balance: 1404.01 },
          { date: '2025-09-09', description: 'Card payment', activityType: 'Sales', amount: 164.77, balance: 1568.78 },
          { date: '2025-09-09', description: 'USPS', activityType: 'Card spend', amount: -1233.02, balance: 335.76 },
          { date: '2025-09-13', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 1015.16 },
          { date: '2025-09-15', description: 'Card payment', activityType: 'Sales', amount: 659.98, balance: 1675.14 },
          { date: '2025-09-17', description: 'Card payment', activityType: 'Sales', amount: 450.00, balance: 2125.14 },
          { date: '2025-09-19', description: 'Card payment', activityType: 'Sales', amount: 315.27, balance: 2440.41 },
          { date: '2025-09-22', description: 'Card payment', activityType: 'Sales', amount: 339.55, balance: 2779.96 },
          { date: '2025-09-26', description: 'Card payment', activityType: 'Sales', amount: 873.60, balance: 3653.56 },
          { date: '2025-09-30', description: '4 Over International', activityType: 'Card spend', amount: -1378.66, balance: 2274.90 },
          { date: '2025-09-30', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 2711.55 },

          // October 2025
          { date: '2025-10-02', description: 'Square Paid Services', activityType: 'Card spend', amount: -21.75, balance: 2689.80 },
          { date: '2025-10-02', description: 'Card payment', activityType: 'Sales', amount: 242.45, balance: 2932.25 },
          { date: '2025-10-06', description: 'USPS', activityType: 'Card spend', amount: -1116.44, balance: 1815.81 },
          { date: '2025-10-07', description: 'USPS', activityType: 'Card spend', amount: -1233.77, balance: 582.04 },
          { date: '2025-10-21', description: 'Card payment', activityType: 'Sales', amount: 436.65, balance: 1018.69 },
          { date: '2025-10-22', description: 'Card payment', activityType: 'Sales', amount: 786.21, balance: 1804.90 },
          { date: '2025-10-24', description: 'Card payment', activityType: 'Sales', amount: 388.10, balance: 2193.00 },
          { date: '2025-10-27', description: 'Card payment', activityType: 'Sales', amount: 315.27, balance: 2508.27 },
          { date: '2025-10-30', description: 'Card payment', activityType: 'Sales', amount: 679.40, balance: 3187.67 }
        ];

        // Process and categorize each transaction
        const transactions = rawTransactions.map((trans, index) => {
          const cat = autoCategorizeTransaction(trans.description, trans.activityType, trans.amount);

          return {
            id: `sq-${Date.now()}-${index}`,
            date: trans.date,
            description: trans.description,
            amount: trans.amount,
            balance: trans.balance,
            type: cat.type,
            category: cat.category,
            subcategory: cat.subcategory,
            notes: `Imported from Square statement - ${trans.activityType}`,
            source: 'square_import'
          };
        });

        // Add to financial state
        financialState.transactions = transactions;
        financialState.loaded = true;

        // Save to Supabase
        await saveFinancialData();

        // Render
        renderFinancialRegister();

        console.log(`‚úÖ Imported ${transactions.length} transactions from Square statements`);
        toast(`‚úÖ Imported ${transactions.length} transactions!`, true);

      } catch (err) {
        console.error('Error importing Square statements:', err);
        toast('‚ö†Ô∏è Failed to import statements', false);
      }
    }

  </script>
  <script src="auth-root.js"></script>
</body>
</html><!-- Force refresh 1762829270 -->
